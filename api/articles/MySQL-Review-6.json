{"title":"MySQL Review-6","uid":"5248bd149e90c578d377990ba1015e7f","slug":"MySQL-Review-6","date":"2023-12-06T07:14:37.000Z","updated":"2023-12-06T09:51:51.198Z","comments":true,"path":"api/articles/MySQL-Review-6.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/MySQL-image.png","content":"<p>这一节来讲关系非常复杂的JOIN，有各种JOIN，一个一个看。</p>\n<h1 id=\"JOIN\"><a href=\"#JOIN\" class=\"headerlink\" title=\"JOIN\"></a>JOIN</h1><p>开始前放一个关系图，来自<code>runoob</code></p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2019/01/sql-join.png\"></p>\n<p>ok，这就是我们要学的各种复杂的关系。</p>\n<h2 id=\"INNER-JOIN\"><a href=\"#INNER-JOIN\" class=\"headerlink\" title=\"INNER JOIN\"></a><code>INNER JOIN</code></h2><p><code>INNER JOIN</code> 是 MySQL 中用于连接两个或多个表的一种常见的连接类型。它根据两个表之间的共同列的匹配行将这些表组合在一起。<code>INNER JOIN</code> 只返回匹配条件为真的行，排除了不匹配的行。</p>\n<p>基本的 <code>INNER JOIN</code> 语法如下：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT table1.column1, table1.column2, table2.column3, ...\nFROM table1\nINNER JOIN table2 ON table1.common_column = table2.common_column;</code></pre>\n\n<ul>\n<li><code>table1.column1, table1.column2, ...</code>: 要检索的列的名称，可以是一个或多个列，通常是来自第一个表。</li>\n<li><code>table2.column3, ...</code>: 同样是要检索的列的名称，通常是来自第二个表。</li>\n<li><code>table1</code> 和 <code>table2</code>: 要连接的两个表的名称。</li>\n<li><code>common_column</code>: 两个表之间共同的列，用于匹配行的条件。</li>\n</ul>\n<p>以下是一些 <code>INNER JOIN</code> 的使用示例：</p>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><h4 id=\"1-连接两个表的共同列：\"><a href=\"#1-连接两个表的共同列：\" class=\"headerlink\" title=\"1. 连接两个表的共同列：\"></a>1. 连接两个表的共同列：</h4><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT employees.employee_id, employees.first_name, employees.last_name, departments.department_name\nFROM employees\nINNER JOIN departments ON employees.department_id = departments.department_id;</code></pre>\n\n<p>上述查询将返回员工的信息以及他们所属的部门名称，通过连接 <code>employees</code> 表和 <code>departments</code> 表的 <code>department_id</code> 列。</p>\n<h4 id=\"2-连接多个表：\"><a href=\"#2-连接多个表：\" class=\"headerlink\" title=\"2. 连接多个表：\"></a>2. 连接多个表：</h4><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT orders.order_id, customers.customer_name, products.product_name\nFROM orders\nINNER JOIN customers ON orders.customer_id = customers.customer_id\nINNER JOIN order_details ON orders.order_id = order_details.order_id\nINNER JOIN products ON order_details.product_id = products.product_id;</code></pre>\n\n<p>上述查询连接了 <code>orders</code>、<code>customers</code>、<code>order_details</code> 和 <code>products</code> 四个表，返回了订单号、客户名称以及产品名称的信息。</p>\n<h4 id=\"3-连接表并添加条件：\"><a href=\"#3-连接表并添加条件：\" class=\"headerlink\" title=\"3. 连接表并添加条件：\"></a>3. 连接表并添加条件：</h4><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT employees.employee_id, employees.first_name, employees.last_name, departments.department_name\nFROM employees\nINNER JOIN departments ON employees.department_id = departments.department_id\nWHERE employees.salary &gt; 50000;</code></pre>\n\n<p>上述查询在连接 <code>employees</code> 表和 <code>departments</code> 表的基础上，添加了一个条件，只返回工资超过 50000 的员工信息。</p>\n<p>这样没有感觉，有电脑的可以直接来看这个例子。</p>\n<h3 id=\"实操\"><a href=\"#实操\" class=\"headerlink\" title=\"实操\"></a>实操</h3><p>假设我们有两个表：<code>employees</code> 和 <code>departments</code>。<code>employees</code> 表存储员工的信息，<code>departments</code> 表存储部门的信息。两个表通过 <code>department_id</code> 列关联。下面是创建这两个表的 SQL 建表语句：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 创建 employees 表\nCREATE TABLE employees (\n    employee_id INT PRIMARY KEY,\n    first_name VARCHAR(50),\n    last_name VARCHAR(50),\n    department_id INT,\n    salary INT\n);\n\n-- 插入一些示例数据\nINSERT INTO employees VALUES (1, 'John', 'Doe', 1, 60000);\nINSERT INTO employees VALUES (2, 'Jane', 'Smith', 2, 55000);\nINSERT INTO employees VALUES (3, 'Bob', 'Johnson', 1, 62000);\nINSERT INTO employees VALUES (4, 'Alice', 'Williams', 2, 58000);\n\n-- 创建 departments 表\nCREATE TABLE departments (\n    department_id INT PRIMARY KEY,\n    department_name VARCHAR(50)\n);\n\n-- 插入一些示例数据\nINSERT INTO departments VALUES (1, 'IT');\nINSERT INTO departments VALUES (2, 'HR');</code></pre>\n\n<p>现在，我们可以使用 <code>INNER JOIN</code> 来查询员工的信息以及他们所在部门的名称。以下是一个使用 <code>INNER JOIN</code> 的查询示例：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 使用 INNER JOIN 查询员工信息和部门名称\nSELECT employees.employee_id, employees.first_name, employees.last_name, employees.salary, departments.department_name\nFROM employees\nINNER JOIN departments ON employees.department_id = departments.department_id;</code></pre>\n\n<p>上述查询将返回以下结果：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">employee_id</th>\n<th align=\"center\">first_name</th>\n<th align=\"center\">last_name</th>\n<th align=\"center\">salary</th>\n<th align=\"center\">department_name</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">John</td>\n<td align=\"center\">Doe</td>\n<td align=\"center\">60000</td>\n<td align=\"center\">IT</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">Jane</td>\n<td align=\"center\">Smith</td>\n<td align=\"center\">55000</td>\n<td align=\"center\">HR</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">Bob</td>\n<td align=\"center\">Johnson</td>\n<td align=\"center\">62000</td>\n<td align=\"center\">IT</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">Alice</td>\n<td align=\"center\">Williams</td>\n<td align=\"center\">58000</td>\n<td align=\"center\">HR</td>\n</tr>\n</tbody></table>\n<h2 id=\"LEFT-JOIN\"><a href=\"#LEFT-JOIN\" class=\"headerlink\" title=\"LEFT JOIN\"></a><code>LEFT JOIN</code></h2><p><code>LEFT JOIN</code> 是 MySQL 中的一种连接类型，它返回左表中的所有行，并包括右表中匹配的行。如果右表中没有匹配的行，结果集中将包含 NULL 值。</p>\n<p>基本的 <code>LEFT JOIN</code> 语法如下：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT table1.column1, table1.column2, table2.column3, ...\nFROM table1\nLEFT JOIN table2 ON table1.common_column = table2.common_column;</code></pre>\n\n<ul>\n<li><code>table1.column1, table1.column2, ...</code>: 要检索的列的名称，通常是来自左表。</li>\n<li><code>table2.column3, ...</code>: 同样是要检索的列的名称，通常是来自右表。</li>\n<li><code>table1</code> 和 <code>table2</code>: 要连接的两个表的名称。</li>\n<li><code>common_column</code>: 两个表之间共同的列，用于匹配行的条件。</li>\n</ul>\n<p>以下是一些 <code>LEFT JOIN</code> 的使用示例：</p>\n<h3 id=\"用法-1\"><a href=\"#用法-1\" class=\"headerlink\" title=\"用法\"></a>用法</h3><h4 id=\"1-连接两个表的共同列：-1\"><a href=\"#1-连接两个表的共同列：-1\" class=\"headerlink\" title=\"1. 连接两个表的共同列：\"></a>1. 连接两个表的共同列：</h4><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT employees.employee_id, employees.first_name, employees.last_name, departments.department_name\nFROM employees\nLEFT JOIN departments ON employees.department_id = departments.department_id;</code></pre>\n\n<p>上述查询将返回所有员工的信息以及他们所在部门的名称，即使员工所在的部门在 <code>departments</code> 表中没有对应的记录。</p>\n<h4 id=\"2-连接多个表：-1\"><a href=\"#2-连接多个表：-1\" class=\"headerlink\" title=\"2. 连接多个表：\"></a>2. 连接多个表：</h4><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT orders.order_id, customers.customer_name, products.product_name\nFROM orders\nLEFT JOIN customers ON orders.customer_id = customers.customer_id\nLEFT JOIN order_details ON orders.order_id = order_details.order_id\nLEFT JOIN products ON order_details.product_id = products.product_id;</code></pre>\n\n<p>上述查询连接了 <code>orders</code>、<code>customers</code>、<code>order_details</code> 和 <code>products</code> 四个表，返回了订单号、客户名称以及产品名称的信息。如果某个订单没有关联的客户或产品，对应的字段将包含 NULL 值。</p>\n<h4 id=\"3-结合-LEFT-JOIN-和条件：\"><a href=\"#3-结合-LEFT-JOIN-和条件：\" class=\"headerlink\" title=\"3. 结合 LEFT JOIN 和条件：\"></a>3. 结合 <code>LEFT JOIN</code> 和条件：</h4><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT employees.employee_id, employees.first_name, employees.last_name, departments.department_name\nFROM employees\nLEFT JOIN departments ON employees.department_id = departments.department_id\nWHERE employees.salary &gt; 50000;</code></pre>\n\n<p>上述查询在连接 <code>employees</code> 表和 <code>departments</code> 表的基础上，添加了一个条件，只返回工资超过 50000 的员工信息。</p>\n<h3 id=\"实操-1\"><a href=\"#实操-1\" class=\"headerlink\" title=\"实操\"></a>实操</h3><p>假设我们有两个表：<code>students</code> 和 <code>courses</code>。<code>students</code> 表存储学生的信息，<code>courses</code> 表存储课程的信息。两个表通过 <code>student_id</code> 列关联。下面是创建这两个表的 SQL 建表语句：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 创建 students 表\nCREATE TABLE students (\n    student_id INT PRIMARY KEY,\n    first_name VARCHAR(50),\n    last_name VARCHAR(50),\n    age INT,\n    department VARCHAR(50)\n);\n\n-- 插入一些示例数据\nINSERT INTO students VALUES (1, 'John', 'Doe', 22, 'Computer Science');\nINSERT INTO students VALUES (2, 'Jane', 'Smith', 21, 'Mathematics');\nINSERT INTO students VALUES (3, 'Bob', 'Johnson', 23, 'Physics');\nINSERT INTO students VALUES (4, 'Alice', 'Williams', 22, 'Chemistry');\n\n-- 创建 courses 表\nCREATE TABLE courses (\n    course_id INT PRIMARY KEY,\n    course_name VARCHAR(50),\n    student_id INT,\n    FOREIGN KEY (student_id) REFERENCES students(student_id)\n);\n\n-- 插入一些示例数据\nINSERT INTO courses VALUES (101, 'Introduction to Computer Science', 1);\nINSERT INTO courses VALUES (102, 'Linear Algebra', 2);</code></pre>\n\n<p>现在，我们可以使用 <code>LEFT JOIN</code> 来查询所有学生以及他们选修的课程。以下是一个使用 <code>LEFT JOIN</code> 的查询示例：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 使用 LEFT JOIN 查询学生信息以及选修的课程\nSELECT students.student_id, students.first_name, students.last_name, students.age, students.department, courses.course_name\nFROM students\nLEFT JOIN courses ON students.student_id = courses.student_id;</code></pre>\n\n<p>上述查询将返回以下结果：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">student_id</th>\n<th align=\"center\">first_name</th>\n<th align=\"center\">last_name</th>\n<th align=\"center\">age</th>\n<th align=\"center\">department</th>\n<th align=\"center\">course_name</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">John</td>\n<td align=\"center\">Doe</td>\n<td align=\"center\">22</td>\n<td align=\"center\">Computer Science</td>\n<td align=\"center\">Introduction to CS</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">Jane</td>\n<td align=\"center\">Smith</td>\n<td align=\"center\">21</td>\n<td align=\"center\">Mathematics</td>\n<td align=\"center\">Linear Algebra</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">Bob</td>\n<td align=\"center\">Johnson</td>\n<td align=\"center\">23</td>\n<td align=\"center\">Physics</td>\n<td align=\"center\"><null></null></td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">Alice</td>\n<td align=\"center\">Williams</td>\n<td align=\"center\">22</td>\n<td align=\"center\">Chemistry</td>\n<td align=\"center\"><null></null></td>\n</tr>\n</tbody></table>\n<p>在这个例子中，<code>LEFT JOIN</code> 将 <code>students</code> 表和 <code>courses</code> 表连接在一起，通过它们的 <code>student_id</code> 列进行匹配。查询结果包含了所有学生的信息以及他们选修的课程，即使有的学生没有选修任何课程，对应的字段将包含 NULL 值。</p>\n<p>这里可以涉及一下<code>RIGHT JOIN</code>，其实<code>RIGHT JOIN</code>就相当于把<code>LEFT JOIN</code>反过来。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 使用 RIGHT JOIN 查询学生信息以及选修的课程\nSELECT students.student_id, students.first_name, students.last_name, students.age, students.department, courses.course_name\nFROM students\nRIGHT JOIN courses ON students.student_id = courses.student_id;</code></pre>\n\n<p>然后就会发现就返回了这两行，因为右外连接后，只会保留右表拥有的，而如果左表没有的则会用null值填充。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">student_id</th>\n<th align=\"center\">first_name</th>\n<th align=\"center\">last_name</th>\n<th align=\"center\">age</th>\n<th align=\"center\">department</th>\n<th align=\"center\">course_name</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">John</td>\n<td align=\"center\">Doe</td>\n<td align=\"center\">22</td>\n<td align=\"center\">Computer Science</td>\n<td align=\"center\">Introduction to CS</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">Jane</td>\n<td align=\"center\">3 1SELECT column1, column22FROM table13WHERE EXISTS (SELECT 1 FROM table2 WHERE condition);sql</td>\n<td align=\"center\">21</td>\n<td align=\"center\">Mathematics</td>\n<td align=\"center\">Linear Algebra</td>\n</tr>\n</tbody></table>\n<h2 id=\"NATURAL-JOIN\"><a href=\"#NATURAL-JOIN\" class=\"headerlink\" title=\"NATURAL JOIN\"></a><code>NATURAL JOIN</code></h2><p><code>NATURAL JOIN</code> 是一种在 MySQL 中进行表连接的方法，它基于两个表之间具有相同列名的原则，自动匹配这些相同列名的列进行连接。在 <code>NATURAL JOIN</code> 中，不需要显式指定连接条件，系统会自动根据相同列名进行匹配。</p>\n<p>基本的 <code>NATURAL JOIN</code> 语法如下：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT columns\nFROM table1\nNATURAL JOIN table2;</code></pre>\n\n<ul>\n<li><code>columns</code>: 要检索的列的名称。</li>\n<li><code>table1</code> 和 <code>table2</code>: 要连接的两个表的名称。</li>\n</ul>\n<p>以下是一些关于 <code>NATURAL JOIN</code> 的使用示例：</p>\n<h3 id=\"用法-2\"><a href=\"#用法-2\" class=\"headerlink\" title=\"用法\"></a>用法</h3><h4 id=\"1-连接两个表：\"><a href=\"#1-连接两个表：\" class=\"headerlink\" title=\"1. 连接两个表：\"></a>1. 连接两个表：</h4><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT employees.employee_id, employees.first_name, employees.last_name, employees.salary, departments.department_name\nFROM employees\nNATURAL JOIN departments;</code></pre>\n\n<p>上述查询将返回所有员工的信息以及他们所在部门的名称，通过自动匹配 <code>employees</code> 表和 <code>departments</code> 表中相同列名的列，即 <code>department_id</code>。</p>\n<h4 id=\"2-连接多个表：-2\"><a href=\"#2-连接多个表：-2\" class=\"headerlink\" title=\"2. 连接多个表：\"></a>2. 连接多个表：</h4><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT orders.order_id, customers.customer_name, products.product_name\nFROM orders\nNATURAL JOIN customers\nNATURAL JOIN order_details\nNATURAL JOIN products;</code></pre>\n\n<p>上述查询连接了 <code>orders</code>、<code>customers</code>、<code>order_details</code> 和 <code>products</code> 四个表，返回了订单号、客户名称以及产品名称的信息，通过自动匹配相同列名的列。</p>\n<h4 id=\"3-使用-WHERE-子句限定条件：\"><a href=\"#3-使用-WHERE-子句限定条件：\" class=\"headerlink\" title=\"3. 使用 WHERE 子句限定条件：\"></a>3. 使用 <code>WHERE</code> 子句限定条件：</h4><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT employees.employee_id, employees.first_name, employees.last_name, employees.salary, departments.department_name\nFROM employees\nNATURAL JOIN departments\nWHERE employees.salary &gt; 50000;</code></pre>\n\n<p>上述查询在连接 <code>employees</code> 表和 <code>departments</code> 表的基础上，添加了一个条件，只返回工资超过 50000 的员工信息。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>NATURAL JOIN</code> 简化了连接条件的书写，但也有一些潜在的问题和注意事项：</p>\n<ul>\n<li><strong>潜在的歧义：</strong> 如果两个表中有多个相同列名的列，<code>NATURAL JOIN</code> 可能导致歧义，因此在设计数据库时需要小心避免这种情况。</li>\n<li><strong>性能问题：</strong> <code>NATURAL JOIN</code> 的性能可能不如显式指定连接条件的 <code>INNER JOIN</code>，因为它需要在运行时自动匹配列。</li>\n<li><strong>不够灵活：</strong> 由于 <code>NATURAL JOIN</code> 自动匹配所有相同列名的列，可能会导致连接的列不受控制，降低了查询的灵活性。</li>\n</ul></blockquote>\n<h3 id=\"实操-2\"><a href=\"#实操-2\" class=\"headerlink\" title=\"实操\"></a>实操</h3><p>这个和INNER JOIN很像，建表语句也采用上面一样的。</p>\n<p>我们可以使用 <code>NATURAL JOIN</code> 来查询所有员工的信息以及他们所在部门的名称，通过自动匹配 <code>employees</code> 表和 <code>departments</code> 表中相同列名的列，即 <code>department_id</code>。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 使用 NATURAL JOIN 查询员工信息和部门名称\nSELECT employee_id, first_name, last_name, salary, department_name\nFROM employees\nNATURAL JOIN departments;</code></pre>\n\n<p>上述查询将返回以下结果：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">employee_id</th>\n<th align=\"center\">first_name</th>\n<th align=\"center\">last_name</th>\n<th align=\"center\">salary</th>\n<th align=\"center\">department_name</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">John</td>\n<td align=\"center\">Doe</td>\n<td align=\"center\">60000</td>\n<td align=\"center\">IT</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">Jane</td>\n<td align=\"center\">Smith</td>\n<td align=\"center\">55000</td>\n<td align=\"center\">HR</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">Bob</td>\n<td align=\"center\">Johnson</td>\n<td align=\"center\">62000</td>\n<td align=\"center\">IT</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">Alice</td>\n<td align=\"center\">Williams</td>\n<td align=\"center\">58000</td>\n<td align=\"center\">HR</td>\n</tr>\n</tbody></table>\n<p>在这个例子中，<code>NATURAL JOIN</code> 自动匹配了 <code>employees</code> 表和 <code>departments</code> 表中相同列名的列（即 <code>department_id</code>），并返回了所有员工的信息以及他们所在部门的名称。</p>\n<p>但是如果我们更改一下，如果出现了NULL值，NATURAL JOIN会发生什么？</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">UPDATE employees t SET t.department_id = null WHERE t.employee_id = 3</code></pre>\n\n<p>然后我们再执行相同的SQL语句，此时就会发现返回结果为：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">employee_id</th>\n<th align=\"center\">first_name</th>\n<th align=\"center\">last_name</th>\n<th align=\"center\">salary</th>\n<th align=\"center\">department_name</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">John</td>\n<td align=\"center\">Doe</td>\n<td align=\"center\">60000</td>\n<td align=\"center\">IT</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">Jane</td>\n<td align=\"center\">Smith</td>\n<td align=\"center\">55000</td>\n<td align=\"center\">HR</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">Alice</td>\n<td align=\"center\">Williams</td>\n<td align=\"center\">58000</td>\n<td align=\"center\">HR</td>\n</tr>\n</tbody></table>\n<p>这是因为<code>NATURAL JOIN</code> 在处理含有 NULL 值的列时可能引发一些问题，因为 NULL 值会被视为不相等。在自动匹配列名时，如果有 NULL 值，匹配的结果可能不符合预期。</p>\n<p>所以这玩意，不太好用。</p>\n<h2 id=\"OUTER-JOIN\"><a href=\"#OUTER-JOIN\" class=\"headerlink\" title=\"OUTER JOIN\"></a><code>OUTER JOIN</code></h2><p><code>OUTER JOIN</code> 是一种连接类型，它包括左外连接 (<code>LEFT OUTER JOIN</code> 或简称为 <code>LEFT JOIN</code>)、右外连接 (<code>RIGHT OUTER JOIN</code> 或简称为 <code>RIGHT JOIN</code>) 以及全外连接 (<code>FULL OUTER JOIN</code> 或简称为 <code>FULL JOIN</code>)。<code>OUTER JOIN</code> 用于连接两个表，并返回满足连接条件的行，同时保留没有匹配行的记录，用 NULL 值填充这些缺失的部分。</p>\n<h3 id=\"1-左外连接-LEFT-OUTER-JOIN-或-LEFT-JOIN\"><a href=\"#1-左外连接-LEFT-OUTER-JOIN-或-LEFT-JOIN\" class=\"headerlink\" title=\"1. 左外连接 (LEFT OUTER JOIN 或 LEFT JOIN)\"></a>1. 左外连接 (<code>LEFT OUTER JOIN</code> 或 <code>LEFT JOIN</code>)</h3><p>左外连接返回左表中的所有行，并包括右表中匹配的行。如果右表中没有匹配的行，则结果集中右表的列将包含 NULL 值。</p>\n<p>跟上面讲的一样，这里提一下</p>\n<p>基本的语法如下：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT columns\nFROM table1\nLEFT JOIN table2 ON table1.column_name = table2.column_name;</code></pre>\n\n<h3 id=\"2-右外连接-RIGHT-OUTER-JOIN-或-RIGHT-JOIN\"><a href=\"#2-右外连接-RIGHT-OUTER-JOIN-或-RIGHT-JOIN\" class=\"headerlink\" title=\"2. 右外连接 (RIGHT OUTER JOIN 或 RIGHT JOIN)\"></a>2. 右外连接 (<code>RIGHT OUTER JOIN</code> 或 <code>RIGHT JOIN</code>)</h3><p>右外连接返回右表中的所有行，并包括左表中匹配的行。如果左表中没有匹配的行，则结果集中左表的列将包含 NULL 值。</p>\n<p>基本的语法如下：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT columns\nFROM table1\nRIGHT JOIN table2 ON table1.column_name = table2.column_name;</code></pre>\n\n<h3 id=\"3-全外连接-FULL-OUTER-JOIN-或-FULL-JOIN\"><a href=\"#3-全外连接-FULL-OUTER-JOIN-或-FULL-JOIN\" class=\"headerlink\" title=\"3. 全外连接 (FULL OUTER JOIN 或 FULL JOIN)\"></a>3. 全外连接 (<code>FULL OUTER JOIN</code> 或 <code>FULL JOIN</code>)</h3><p>哈哈，MySQL中不支持这个连接，但可以使用 <code>LEFT JOIN</code> 和 <code>UNION</code> 或者 <code>RIGHT JOIN</code> 和 <code>UNION</code> 的组合来模拟实现全外连接的效果。</p>\n<p>来个例子：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 创建 students 表\nCREATE TABLE students (\n    student_id INT PRIMARY KEY,\n    first_name VARCHAR(50),\n    last_name VARCHAR(50)\n);\n\n-- 插入一些示例数据\nINSERT INTO students VALUES (1, 'John', 'Doe');\nINSERT INTO students VALUES (2, 'Jane', 'Smith');\nINSERT INTO students VALUES (3, 'Bob', 'Johnson');\n\n-- 创建 courses 表\nCREATE TABLE courses (\n    course_id INT PRIMARY KEY,\n    course_name VARCHAR(50)\n);\n\n-- 插入一些示例数据\nINSERT INTO courses VALUES (101, 'Math');\nINSERT INTO courses VALUES (102, 'English');\nINSERT INTO courses VALUES (103, 'History');</code></pre>\n\n<p>然后我们使用左右分别连接然后进行合集操作。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 左外连接\nSELECT students.student_id, students.first_name, students.last_name, courses.course_name\nFROM students\nLEFT JOIN courses ON students.student_id = courses.course_id\n\nUNION\n\n-- 右外连接\nSELECT students.student_id, students.first_name, students.last_name, courses.course_name\nFROM students\nRIGHT JOIN courses ON students.student_id = courses.course_id;</code></pre>\n\n<p>然后返回</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>first_name</th>\n<th>last_name</th>\n<th>course_name</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>John</td>\n<td>Doe</td>\n<td><null></null></td>\n</tr>\n<tr>\n<td>2</td>\n<td>Jane</td>\n<td>Smith</td>\n<td><null></null></td>\n</tr>\n<tr>\n<td>3</td>\n<td>Bob</td>\n<td>Johnson</td>\n<td><null></null></td>\n</tr>\n<tr>\n<td><null></null></td>\n<td><null></null></td>\n<td><null></null></td>\n<td>Math</td>\n</tr>\n<tr>\n<td><null></null></td>\n<td><null></null></td>\n<td><null></null></td>\n<td>English</td>\n</tr>\n<tr>\n<td><null></null></td>\n<td><null></null></td>\n<td><null></null></td>\n<td>History</td>\n</tr>\n</tbody></table>\n<p>这里先使用左外连接获取所有学生以及他们选修的课程，然后使用右外连接获取所有课程以及它们的学生。最后通过 <code>UNION</code> 合并这两个结果集，得到类似全外连接的效果。</p>\n<h1 id=\"ORDER-BY\"><a href=\"#ORDER-BY\" class=\"headerlink\" title=\"ORDER BY\"></a><code>ORDER BY</code></h1><p><code>ORDER BY</code> 是 MySQL 中用于对查询结果进行排序的子句。它允许你按照一个或多个列的升序（ASC）或降序（DESC）顺序对结果进行排序。<code>ORDER BY</code> 子句通常位于 SQL 查询的最后。</p>\n<p>基本的 <code>ORDER BY</code> 语法如下：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT column1, column2, ...\nFROM table\nORDER BY column1 [ASC|DESC], column2 [ASC|DESC], ...;</code></pre>\n\n<ul>\n<li><code>column1, column2, ...</code>: 要检索的列的名称。</li>\n<li><code>table</code>: 要查询的表的名称。</li>\n<li><code>ORDER BY column1 [ASC|DESC], column2 [ASC|DESC], ...</code>: 指定一个或多个列以及它们的排序顺序。默认是升序（ASC），如果要降序排序，则使用 <code>DESC</code>。</li>\n</ul>\n<p>以下是一些使用 <code>ORDER BY</code> 的示例：</p>\n<h2 id=\"用法-3\"><a href=\"#用法-3\" class=\"headerlink\" title=\"用法\"></a>用法</h2><h3 id=\"1-按单个列排序：\"><a href=\"#1-按单个列排序：\" class=\"headerlink\" title=\"1. 按单个列排序：\"></a>1. 按单个列排序：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 按工资降序排序员工信息\nSELECT employee_id, first_name, last_name, salary\nFROM employees\nORDER BY salary DESC;</code></pre>\n\n<h3 id=\"2-按多个列排序：\"><a href=\"#2-按多个列排序：\" class=\"headerlink\" title=\"2. 按多个列排序：\"></a>2. 按多个列排序：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 先按部门升序排序，再按工资降序排序员工信息\nSELECT employee_id, first_name, last_name, department_id, salary\nFROM employees\nORDER BY department_id ASC, salary DESC;</code></pre>\n\n<h3 id=\"3-对字符串列排序：\"><a href=\"#3-对字符串列排序：\" class=\"headerlink\" title=\"3. 对字符串列排序：\"></a>3. 对字符串列排序：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 按学生姓名升序排序学生信息\nSELECT student_id, first_name, last_name\nFROM students\nORDER BY first_name ASC;</code></pre>\n\n<h3 id=\"4-按计算列排序：\"><a href=\"#4-按计算列排序：\" class=\"headerlink\" title=\"4. 按计算列排序：\"></a>4. 按计算列排序：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 按工资和奖金之和降序排序员工信息\nSELECT employee_id, first_name, last_name, salary, bonus, (salary + bonus) AS total_compensation\nFROM employees\nORDER BY total_compensation DESC;</code></pre>\n\n<p><code>ORDER BY</code> 子句也可以与其他子句一起使用，例如 <code>WHERE</code>、<code>GROUP BY</code>、<code>HAVING</code> 等，以便更灵活地组织查询。</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p><strong>指定正确的列名：</strong> 确保在 <code>ORDER BY</code> 子句中指定的列名确实存在于查询结果中。否则，可能会导致语法错误或不符合预期的结果。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 错误的示例：指定了不存在的列名\nSELECT employee_id, first_name, last_name\nFROM employees\nORDER BY non_existent_column;</code></pre>\n\n<p><strong>处理 NULL 值：</strong> 在排序时，NULL 值的处理可能需要格外小心。默认情况下，对于升序排序，NULL 值会被排在最前面；而对于降序排序，NULL 值会被排在最后面。你可以使用 <code>ORDER BY column_name ASC NULLS FIRST</code> 或 <code>ORDER BY column_name DESC NULLS LAST</code> 来明确指定 NULL 值的位置。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 将 NULL 值排在最后面的示例\nSELECT employee_id, first_name, last_name\nFROM employees\nORDER BY last_name ASC NULLS LAST;</code></pre>\n\n<p><strong>处理文本排序：</strong> 当排序文本列时，可能会受到大小写敏感性和特定字符集的影响。确保在排序之前了解数据库的默认排序规则，并在必要时使用 <code>COLLATE</code> 子句指定排序规则。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 指定不区分大小写的排序规则\nSELECT student_id, first_name, last_name\nFROM students\nORDER BY last_name COLLATE utf8_general_ci;</code></pre>\n\n<p><strong>谨慎使用排序表达式：</strong> 如果在 <code>ORDER BY</code> 中使用了表达式，确保表达式的结果是可排序的。有些表达式可能会导致无法预测的排序结果。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 错误的示例：在 ORDER BY 中使用非可排序的表达式\nSELECT employee_id, first_name, last_name\nFROM employees\nORDER BY CONCAT(last_name, first_name);</code></pre>\n\n<p><strong>性能注意：</strong> 在大型数据集上进行排序可能会影响性能。确保只对需要排序的列进行排序，避免不必要的开销。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 错误的示例：对所有列进行排序\nSELECT *\nFROM employees\nORDER BY employee_id;</code></pre>\n\n<p><strong>使用 LIMIT 时排序的影响：</strong> 如果你在查询中使用了 <code>LIMIT</code> 子句，排序的效果可能会受到限制的影响。<code>ORDER BY</code> 通常是在应用 <code>LIMIT</code> 之前完成的，因此你可能会得到按照排序顺序的前几行，而不是按照整个结果集排序。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 在排序之前应用 LIMIT 的示例\nSELECT employee_id, first_name, last_name\nFROM employees\nORDER BY last_name ASC\nLIMIT 10;</code></pre>\n\n\n\n\n\n","feature":true,"text":"这一节来讲关系非常复杂的JOIN，有各种JOIN，一个一个看。 JOIN开始前放一个关系图，来自runoob ok，这就是我们要学的各种复杂的关系。 INNER JOININNER JOIN 是 MySQL 中用于连接两个或多个表的一种常见的连接类型。它根据两个表之间的共同列的匹...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":37,"path":"api/tags/笔记.json"},{"name":"MySQL复习","slug":"MySQL复习","count":7,"path":"api/tags/MySQL复习.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JOIN\"><span class=\"toc-text\">JOIN</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#INNER-JOIN\"><span class=\"toc-text\">INNER JOIN</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">用法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E8%BF%9E%E6%8E%A5%E4%B8%A4%E4%B8%AA%E8%A1%A8%E7%9A%84%E5%85%B1%E5%90%8C%E5%88%97%EF%BC%9A\"><span class=\"toc-text\">1. 连接两个表的共同列：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E8%BF%9E%E6%8E%A5%E5%A4%9A%E4%B8%AA%E8%A1%A8%EF%BC%9A\"><span class=\"toc-text\">2. 连接多个表：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E8%BF%9E%E6%8E%A5%E8%A1%A8%E5%B9%B6%E6%B7%BB%E5%8A%A0%E6%9D%A1%E4%BB%B6%EF%BC%9A\"><span class=\"toc-text\">3. 连接表并添加条件：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E6%93%8D\"><span class=\"toc-text\">实操</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LEFT-JOIN\"><span class=\"toc-text\">LEFT JOIN</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%B3%95-1\"><span class=\"toc-text\">用法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E8%BF%9E%E6%8E%A5%E4%B8%A4%E4%B8%AA%E8%A1%A8%E7%9A%84%E5%85%B1%E5%90%8C%E5%88%97%EF%BC%9A-1\"><span class=\"toc-text\">1. 连接两个表的共同列：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E8%BF%9E%E6%8E%A5%E5%A4%9A%E4%B8%AA%E8%A1%A8%EF%BC%9A-1\"><span class=\"toc-text\">2. 连接多个表：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E7%BB%93%E5%90%88-LEFT-JOIN-%E5%92%8C%E6%9D%A1%E4%BB%B6%EF%BC%9A\"><span class=\"toc-text\">3. 结合 LEFT JOIN 和条件：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E6%93%8D-1\"><span class=\"toc-text\">实操</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NATURAL-JOIN\"><span class=\"toc-text\">NATURAL JOIN</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%B3%95-2\"><span class=\"toc-text\">用法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E8%BF%9E%E6%8E%A5%E4%B8%A4%E4%B8%AA%E8%A1%A8%EF%BC%9A\"><span class=\"toc-text\">1. 连接两个表：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E8%BF%9E%E6%8E%A5%E5%A4%9A%E4%B8%AA%E8%A1%A8%EF%BC%9A-2\"><span class=\"toc-text\">2. 连接多个表：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E4%BD%BF%E7%94%A8-WHERE-%E5%AD%90%E5%8F%A5%E9%99%90%E5%AE%9A%E6%9D%A1%E4%BB%B6%EF%BC%9A\"><span class=\"toc-text\">3. 使用 WHERE 子句限定条件：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E6%93%8D-2\"><span class=\"toc-text\">实操</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#OUTER-JOIN\"><span class=\"toc-text\">OUTER JOIN</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5-LEFT-OUTER-JOIN-%E6%88%96-LEFT-JOIN\"><span class=\"toc-text\">1. 左外连接 (LEFT OUTER JOIN 或 LEFT JOIN)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%8F%B3%E5%A4%96%E8%BF%9E%E6%8E%A5-RIGHT-OUTER-JOIN-%E6%88%96-RIGHT-JOIN\"><span class=\"toc-text\">2. 右外连接 (RIGHT OUTER JOIN 或 RIGHT JOIN)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%85%A8%E5%A4%96%E8%BF%9E%E6%8E%A5-FULL-OUTER-JOIN-%E6%88%96-FULL-JOIN\"><span class=\"toc-text\">3. 全外连接 (FULL OUTER JOIN 或 FULL JOIN)</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ORDER-BY\"><span class=\"toc-text\">ORDER BY</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%B3%95-3\"><span class=\"toc-text\">用法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%8C%89%E5%8D%95%E4%B8%AA%E5%88%97%E6%8E%92%E5%BA%8F%EF%BC%9A\"><span class=\"toc-text\">1. 按单个列排序：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%8C%89%E5%A4%9A%E4%B8%AA%E5%88%97%E6%8E%92%E5%BA%8F%EF%BC%9A\"><span class=\"toc-text\">2. 按多个列排序：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%97%E6%8E%92%E5%BA%8F%EF%BC%9A\"><span class=\"toc-text\">3. 对字符串列排序：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%8C%89%E8%AE%A1%E7%AE%97%E5%88%97%E6%8E%92%E5%BA%8F%EF%BC%9A\"><span class=\"toc-text\">4. 按计算列排序：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">注意事项</span></a></li></ol></li></ol>","author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}},"mapped":true,"prev_post":{"title":"MySQL Review-7","uid":"dc1ef9ee097f4e4c28b3dcd1a91e91c5","slug":"MySQL-Review-7","date":"2023-12-06T08:42:20.000Z","updated":"2023-12-06T09:53:31.268Z","comments":true,"path":"api/articles/MySQL-Review-7.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/MySQL-image.png","text":"继续继续。。。 GROUP BYGROUP BY 是 MySQL 中用于对查询结果进行分组的子句。它通常与聚合函数（如 SUM、COUNT、AVG 等）一起使用，以便对每个组应用聚合操作。使用 GROUP BY 可以将结果集按照一个或多个列的值分成不同的组。 基本的 GROUP ...","link":"","photos":[],"count_time":{"symbolsCount":"7.5k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":37,"path":"api/tags/笔记.json"},{"name":"MySQL复习","slug":"MySQL复习","count":7,"path":"api/tags/MySQL复习.json"}],"author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}},"feature":true},"next_post":{"title":"MySQL Review-5","uid":"383417e51810f2ed41db351deff5d8e2","slug":"MySQL-Review-5","date":"2023-12-06T06:26:47.000Z","updated":"2023-12-06T09:50:39.289Z","comments":true,"path":"api/articles/MySQL-Review-5.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/MySQL-image.png","text":"继续继续，接着上一篇继续讲这个逻辑运算符。 逻辑运算符学过编程的应该都能看懂，与或非嘛。 AND（&amp;&amp;）： 逻辑与运算符，用于结合两个条件，只有当两个条件都为真时，整个条件才为真。 SELECT * FROM employees WHERE department ...","link":"","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":37,"path":"api/tags/笔记.json"},{"name":"MySQL复习","slug":"MySQL复习","count":7,"path":"api/tags/MySQL复习.json"}],"author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}},"feature":true}}