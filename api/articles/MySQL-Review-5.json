{"title":"MySQL Review-5","uid":"383417e51810f2ed41db351deff5d8e2","slug":"MySQL-Review-5","date":"2023-12-06T06:26:47.000Z","updated":"2023-12-06T09:50:39.289Z","comments":true,"path":"api/articles/MySQL-Review-5.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/MySQL-image.png","content":"<p>继续继续，接着上一篇继续讲这个逻辑运算符。</p>\n<h1 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h1><p>学过编程的应该都能看懂，与或非嘛。</p>\n<p><strong>AND（&amp;&amp;）：</strong> 逻辑与运算符，用于结合两个条件，只有当两个条件都为真时，整个条件才为真。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM employees\nWHERE department = 'IT' AND salary &gt; 50000;</code></pre>\n\n<p><strong>OR（||）：</strong> 逻辑或运算符，用于结合两个条件，只要其中一个条件为真，整个条件就为真。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM employees\nWHERE department = 'HR' OR department = 'Finance';</code></pre>\n\n<p><strong>NOT（!）：</strong> 逻辑非运算符，用于否定一个条件，如果条件为真，则返回假，如果条件为假，则返回真。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM employees\nWHERE NOT department = 'IT';</code></pre>\n\n<p>或者使用 <code>&lt;&gt;</code> 运算符：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM employees\nWHERE department &lt;&gt; 'IT';</code></pre>\n\n<p><strong>IN：</strong> 用于匹配一列中的任何值与指定的值列表之一。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM employees\nWHERE department IN ('IT', 'HR', 'Finance');</code></pre>\n\n<p><strong>BETWEEN AND：</strong> 用于匹配一个范围内的值。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM products\nWHERE price BETWEEN 50 AND 100;</code></pre>\n\n<p><strong>LIKE：</strong> 用于匹配模式，常与通配符一起使用。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM employees\nWHERE last_name LIKE 'S%';</code></pre>\n\n<p><strong>IS NULL 和 IS NOT NULL：</strong> 用于匹配空值和非空值。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM employees\nWHERE manager_id IS NULL;</code></pre>\n\n<p>这些逻辑运算符可以结合使用，以创建更复杂的条件，以满足特定的查询需求。在使用逻辑运算符时，注意运算符的优先级，可以使用括号来明确指定运算的顺序，以确保查询的逻辑正确性。例如：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM employees\nWHERE (department = 'IT' OR department = 'HR') AND salary &gt; 50000;</code></pre>\n\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p><strong>运算符的优先级：</strong> 不同的逻辑运算符具有不同的优先级。当多个逻辑运算符同时出现时，确保清楚了解它们的优先级，可以使用括号来明确指定运算的顺序。例如，<code>AND</code> 的优先级高于 <code>OR</code>。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM employees\nWHERE department = 'IT' OR department = 'HR' AND salary &gt; 50000;</code></pre>\n\n<p>上述查询中，<code>AND</code> 的优先级高于 <code>OR</code>，所以实际上是 <code>department = 'IT' OR (department = 'HR' AND salary &gt; 50000)</code>。</p>\n<p>为了消除歧义，最好使用括号明确指定优先级：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM employees\nWHERE (department = 'IT' OR department = 'HR') AND salary &gt; 50000;</code></pre>\n\n<p><strong>避免过度复杂的逻辑：</strong> 避免创建过于复杂的逻辑条件，以免导致难以理解和维护的查询。如果逻辑条件变得复杂，可能需要将其拆分为多个简单的条件，以提高可读性。</p>\n<p><strong>注意 NULL 的处理：</strong> 在涉及到 NULL 值的比较时，要小心使用 <code>IS NULL</code> 和 <code>IS NOT NULL</code>。<code>NULL</code> 的比较结果可能是未知的，因此要特别注意这些情况。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 错误的比较\nSELECT *\nFROM employees\nWHERE department = NULL;\n\n-- 正确的比较\nSELECT *\nFROM employees\nWHERE department IS NULL;</code></pre>\n\n<p><strong>使用合适的运算符：</strong> 选择适当的逻辑运算符取决于具体的查询需求。确保选择正确的运算符，如 <code>AND</code>、<code>OR</code>、<code>IN</code>、<code>BETWEEN</code> 等。</p>\n<p><strong>注意字符集和排序规则：</strong> 在进行字符串比较时，确保了解你的数据库使用的字符集和排序规则。不同的字符集和排序规则可能会导致不同的比较结果。</p>\n<p><strong>避免在索引列上使用函数：</strong> 在逻辑条件中，尽量避免在索引列上使用函数，因为这可能导致索引失效，从而降低查询性能。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 不推荐\nSELECT *\nFROM products\nWHERE YEAR(sale_date) = 2023;\n\n-- 推荐\nSELECT *\nFROM products\nWHERE sale_date &gt;= '2023-01-01' AND sale_date &lt; '2024-01-01';</code></pre>\n\n<h1 id=\"笛卡尔积\"><a href=\"#笛卡尔积\" class=\"headerlink\" title=\"笛卡尔积\"></a>笛卡尔积</h1><p>笛卡尔积（Cartesian Product）是指在没有任何条件的情况下，两个或多个表之间的所有可能的组合。当没有使用 <code>JOIN</code> 条件时，MySQL 将返回两个表之间的笛卡尔积。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 创建两个简单的表\nCREATE TABLE table1 (\n    id INT,\n    name VARCHAR(20)\n);\n\nCREATE TABLE table2 (\n    id INT,\n    value INT\n);\n\n-- 插入一些数据\nINSERT INTO table1 (id, name) VALUES (1, 'Alice'), (2, 'Bob');\nINSERT INTO table2 (id, value) VALUES (1, 100), (2, 200);\n\n-- 查询两个表的笛卡尔积\nSELECT *\nFROM table1, table2;</code></pre>\n\n<p>上述查询将返回一个包含所有可能组合的结果集，即 <code>table1</code> 中的每一行与 <code>table2</code> 中的每一行的组合：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>name</th>\n<th>id</th>\n<th>value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2</td>\n<td>Bob</td>\n<td>1</td>\n<td>100</td>\n</tr>\n<tr>\n<td>1</td>\n<td>Alice</td>\n<td>1</td>\n<td>100</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Bob</td>\n<td>2</td>\n<td>200</td>\n</tr>\n<tr>\n<td>1</td>\n<td>Alice</td>\n<td>2</td>\n<td>200</td>\n</tr>\n</tbody></table>\n<p>在实际使用中，很少需要获取两个表的笛卡尔积，因为这通常会导致结果集非常庞大。正常情况下，通过使用 <code>JOIN</code> 子句来根据某些条件连接两个表，以获取有意义的关联数据。例如：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 使用 JOIN 条件连接两个表\nSELECT *\nFROM table1\nJOIN table2 ON table1.id = table2.id;</code></pre>\n\n<p>在这个例子中，<code>table1.id = table2.id</code> 是连接条件，而不是返回笛卡尔积。笛卡尔积是在没有任何连接条件的情况下获取的，而正常的关联查询则通过指定连接条件来获取有关联性的结果。</p>\n<p>JOIN后面会讲，这里是为了笔记的完整。</p>\n<p>当然学校里讲了用WHERE然后通过各自表名来指定具有相同的列名</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 使用 WHERE 条件连接两个表\nSELECT *\nFROM table1, table2\nWHERE table1.id = table2.id;</code></pre>\n\n<p>这样其实两者和JOIN获得的结果是一样的，一些 SQL 查询可能使用 <code>WHERE</code> 子句来表示连接条件，尤其是在较早的 SQL 版本中。</p>\n<p>但是后面会讲到，我们几乎从来不会用WHERE来指定两个表之间的关系，等我们后面讲到JOIN的时候会着重讲。</p>\n<h2 id=\"注意事项-1\"><a href=\"#注意事项-1\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>这一部分的注意事项就是为了避免过大的笛卡尔积，而且牵扯到数据库的一些性能上的调优。</p>\n<p><strong>结果集的大小：</strong> 笛卡尔积会返回两个或多个表之间的所有可能组合，导致结果集的大小可能会非常庞大。在实际应用中，通常需要通过合适的条件（例如 <code>WHERE</code> 子句或 <code>JOIN</code> 条件）来限制结果集，以防止返回过大的数据量。</p>\n<p><strong>性能影响：</strong> 笛卡尔积的性能影响很大，尤其是在表的行数较大时。因为它需要计算和返回所有可能的组合，可能导致查询变得缓慢。在实际使用中，要特别小心避免无意义的笛卡尔积。</p>\n<p><strong>避免不必要的笛卡尔积：</strong> 在实际查询中，尽量避免无意义的笛卡尔积。确保查询中有适当的条件来限制结果集，以获得有意义和有效的数据。</p>\n<p><strong>使用连接条件：</strong> 在实际应用中，很少直接使用逗号（<code>,</code>）生成笛卡尔积，而是通过使用连接条件，例如使用 <code>JOIN</code> 子句，来获取有意义的关联数据。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM table1\nJOIN table2 ON table1.id = table2.id;</code></pre>\n\n<h1 id=\"IN\"><a href=\"#IN\" class=\"headerlink\" title=\"IN\"></a><code>IN</code></h1><p><code>IN</code> 关键字在 MySQL 中用于判断一个值是否在一个给定的值列表中。它通常用于替代多个 <code>OR</code> 条件的情况，使得查询更加简洁和可读。</p>\n<p>基本的语法结构如下：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT column1, column2, ...\nFROM table_name\nWHERE column_name IN (value1, value2, ...);</code></pre>\n\n<ul>\n<li><code>column1, column2, ...</code>: 要检索的列的名称，可以是一个或多个列。</li>\n<li><code>table_name</code>: 要检索数据的表的名称。</li>\n<li><code>column_name</code>: 要进行 <code>IN</code> 操作的列的名称。</li>\n<li><code>value1, value2, ...</code>: 用于比较的值列表。</li>\n</ul>\n<p>以下是一些 <code>IN</code> 关键字的使用示例：</p>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><h3 id=\"1-使用常量值列表：\"><a href=\"#1-使用常量值列表：\" class=\"headerlink\" title=\"1. 使用常量值列表：\"></a>1. 使用常量值列表：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM products\nWHERE category_id IN (1, 2, 3);</code></pre>\n\n<p>上述查询将返回 <code>category_id</code> 列中值为 1、2 或 3 的所有产品。</p>\n<h3 id=\"2-使用子查询：\"><a href=\"#2-使用子查询：\" class=\"headerlink\" title=\"2. 使用子查询：\"></a>2. 使用子查询：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM employees\nWHERE department_id IN (SELECT department_id FROM departments WHERE location = 'New York');</code></pre>\n\n<p>上述查询将返回在 ‘New York’ 地点的部门中工作的所有员工。</p>\n<p>子查询后面会讲到，妈的SQL的知识点怎么这么复杂。</p>\n<h3 id=\"3-使用字符串列表：\"><a href=\"#3-使用字符串列表：\" class=\"headerlink\" title=\"3. 使用字符串列表：\"></a>3. 使用字符串列表：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM customers\nWHERE country IN ('USA', 'Canada', 'Mexico');</code></pre>\n\n<p>上述查询将返回位于 ‘USA’、’Canada’ 或 ‘Mexico’ 的所有客户。</p>\n<h3 id=\"4-使用-NULL：\"><a href=\"#4-使用-NULL：\" class=\"headerlink\" title=\"4. 使用 NULL：\"></a>4. 使用 <code>NULL</code>：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM orders\nWHERE customer_id IN (1, 2, NULL);</code></pre>\n\n<p><code>IN</code> 运算符可以用于包含 <code>NULL</code> 值，但要注意 <code>IN</code> 运算符的行为与其他比较运算符可能不同。在 <code>IN</code> 中，<code>NULL</code> 被视为未知，因此与 <code>IN (1, 2, NULL)</code> 比较时，如果列的值为 <code>NULL</code>，它将被包括在结果中。</p>\n<h3 id=\"5-使用子查询限制值范围：\"><a href=\"#5-使用子查询限制值范围：\" class=\"headerlink\" title=\"5. 使用子查询限制值范围：\"></a>5. 使用子查询限制值范围：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM products\nWHERE price IN (SELECT MAX(price) FROM products);</code></pre>\n\n<p>上述查询将返回价格等于产品中最高价格的所有产品。</p>\n<h1 id=\"EXISTS\"><a href=\"#EXISTS\" class=\"headerlink\" title=\"EXISTS\"></a><code>EXISTS</code></h1><p><code>EXISTS</code> 关键字在 MySQL 中用于检查子查询是否返回任何行。如果子查询返回至少一行，则 <code>EXISTS</code> 条件为真；如果子查询没有返回任何行，则 <code>EXISTS</code> 条件为假。<code>EXISTS</code> 主要用于检查子查询是否为空，而不是返回具体的值。</p>\n<p>基本的语法结构如下：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT column1, column2, ...\nFROM table_name\nWHERE EXISTS (SELECT * FROM another_table WHERE condition);</code></pre>\n\n<ul>\n<li><code>column1, column2, ...</code>: 要检索的列的名称，可以是一个或多个列。</li>\n<li><code>table_name</code>: 要检索数据的表的名称。</li>\n<li><code>another_table</code>: 用于子查询的表的名称。</li>\n<li><code>condition</code>: 子查询中的条件，用于限制子查询返回的行。</li>\n</ul>\n<p>以下是一些 <code>EXISTS</code> 关键字的使用示例：</p>\n<h2 id=\"用法-1\"><a href=\"#用法-1\" class=\"headerlink\" title=\"用法\"></a>用法</h2><h3 id=\"1-使用-EXISTS-检查是否存在相关行：\"><a href=\"#1-使用-EXISTS-检查是否存在相关行：\" class=\"headerlink\" title=\"1. 使用 EXISTS 检查是否存在相关行：\"></a>1. 使用 <code>EXISTS</code> 检查是否存在相关行：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM employees e\nWHERE EXISTS (SELECT 1 FROM departments d WHERE d.department_id = e.department_id);</code></pre>\n\n<p>上述查询将返回至少在 <code>departments</code> 表中存在的 <code>employees</code> 表中的所有员工。</p>\n<h3 id=\"2-使用-NOT-EXISTS-检查是否不存在相关行：\"><a href=\"#2-使用-NOT-EXISTS-检查是否不存在相关行：\" class=\"headerlink\" title=\"2. 使用 NOT EXISTS 检查是否不存在相关行：\"></a>2. 使用 <code>NOT EXISTS</code> 检查是否不存在相关行：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM products p\nWHERE NOT EXISTS (SELECT 1 FROM orders o WHERE o.product_id = p.product_id);</code></pre>\n\n<p>上述查询将返回在 <code>orders</code> 表中没有对应订单的所有产品。</p>\n<h3 id=\"3-使用子查询限制条件：\"><a href=\"#3-使用子查询限制条件：\" class=\"headerlink\" title=\"3. 使用子查询限制条件：\"></a>3. 使用子查询限制条件：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM customers c\nWHERE EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id AND o.order_date &gt;= '2023-01-01');</code></pre>\n\n<p>上述查询将返回至少在 <code>orders</code> 表中存在，并且订单日期在 ‘2023-01-01’ 之后的所有客户。</p>\n<h3 id=\"4-使用-EXISTS-作为连接条件：\"><a href=\"#4-使用-EXISTS-作为连接条件：\" class=\"headerlink\" title=\"4. 使用 EXISTS 作为连接条件：\"></a>4. 使用 <code>EXISTS</code> 作为连接条件：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM employees e\nWHERE EXISTS (SELECT 1 FROM departments d WHERE d.department_id = e.department_id)\n  AND e.salary &gt; 50000;</code></pre>\n\n<p>上述查询将返回在 <code>departments</code> 表中存在并且薪水大于 50000 的所有员工。</p>\n<h1 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h1><p>好，终于到了这个byd子查询。</p>\n<p>在 MySQL 中，子查询是指嵌套在其他 SQL 查询语句中的查询。子查询可以出现在 <code>SELECT</code>、<code>FROM</code>、<code>WHERE</code> 或 <code>HAVING</code> 子句中，用于执行嵌套的、独立的查询，并将其结果用于外部查询。</p>\n<p>也就是说，在查询过程中，可以先通过子查询返回回来的结果作为条件的一部分，然后再进行查询。</p>\n<h2 id=\"用法-2\"><a href=\"#用法-2\" class=\"headerlink\" title=\"用法\"></a>用法</h2><h3 id=\"1-在-SELECT-子句中使用子查询：\"><a href=\"#1-在-SELECT-子句中使用子查询：\" class=\"headerlink\" title=\"1. 在 SELECT 子句中使用子查询：\"></a>1. 在 <code>SELECT</code> 子句中使用子查询：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT column1, (SELECT column2 FROM table2 WHERE condition) AS subquery_result\nFROM table1;</code></pre>\n\n<p>在这个例子中，子查询 <code>(SELECT column2 FROM table2 WHERE condition)</code> 返回一个单一的值，并将其命名为 <code>subquery_result</code>。</p>\n<h3 id=\"2-在-FROM-子句中使用子查询：\"><a href=\"#2-在-FROM-子句中使用子查询：\" class=\"headerlink\" title=\"2. 在 FROM 子句中使用子查询：\"></a>2. 在 <code>FROM</code> 子句中使用子查询：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT column1, column2\nFROM (SELECT column1, column2 FROM table1 WHERE condition) AS subquery_result;</code></pre>\n\n<p>在这个例子中，子查询 <code>(SELECT column1, column2 FROM table1 WHERE condition)</code> 返回一组结果，作为一个虚拟的表被用于外部查询的 <code>FROM</code> 子句。</p>\n<h3 id=\"3-在-WHERE-子句中使用子查询：\"><a href=\"#3-在-WHERE-子句中使用子查询：\" class=\"headerlink\" title=\"3. 在 WHERE 子句中使用子查询：\"></a>3. 在 <code>WHERE</code> 子句中使用子查询：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT column1, column2\nFROM table1\nWHERE column1 = (SELECT column1 FROM table2 WHERE condition);</code></pre>\n\n<p>在这个例子中，子查询 <code>(SELECT column1 FROM table2 WHERE condition)</code> 返回一个值，用于与外部查询的 <code>WHERE</code> 子句中的条件进行比较。</p>\n<h3 id=\"4-在-IN-子句中使用子查询：\"><a href=\"#4-在-IN-子句中使用子查询：\" class=\"headerlink\" title=\"4. 在 IN 子句中使用子查询：\"></a>4. 在 <code>IN</code> 子句中使用子查询：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT column1, column2\nFROM table1\nWHERE column1 IN (SELECT column1 FROM table2 WHERE condition);</code></pre>\n\n<p>在这个例子中，子查询 <code>(SELECT column1 FROM table2 WHERE condition)</code> 返回一组值，用于与外部查询的 <code>IN</code> 子句中的条件进行比较。</p>\n<h3 id=\"5-在-EXISTS-子句中使用子查询：\"><a href=\"#5-在-EXISTS-子句中使用子查询：\" class=\"headerlink\" title=\"5. 在 EXISTS 子句中使用子查询：\"></a>5. 在 <code>EXISTS</code> 子句中使用子查询：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT column1, column2\nFROM table1\nWHERE EXISTS (SELECT 1 FROM table2 WHERE condition);</code></pre>\n\n<p>在这个例子中，子查询 <code>(SELECT 1 FROM table2 WHERE condition)</code> 返回结果集的存在性，用于与外部查询的 <code>EXISTS</code> 子句中的条件进行比较。</p>\n<h2 id=\"注意事项-2\"><a href=\"#注意事项-2\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><ul>\n<li>子查询的性能可能受影响，特别是在处理大量数据时。在使用子查询时，要确保查询的效率，并考虑是否有更好的优化方法。</li>\n<li>使用适当的连接（JOIN）和索引，以提高子查询的性能。</li>\n<li>注意处理子查询返回的结果集的唯一性，确保子查询返回的值不会引起外部查询的错误。</li>\n<li>子查询可以嵌套多层，但过度嵌套可能会降低查询的可读性。在编写复杂的查询时，考虑使用表连接（JOIN）和其他联结方式。</li>\n</ul>\n","text":"继续继续，接着上一篇继续讲这个逻辑运算符。 逻辑运算符学过编程的应该都能看懂，与或非嘛。 AND（&amp;&amp;）： 逻辑与运算符，用于结合两个条件，只有当两个条件都为真时，整个条件才为真。 SELECT * FROM employees WHERE department ...","link":"","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":44,"path":"api/tags/笔记.json"},{"name":"MySQL复习","slug":"MySQL复习","count":10,"path":"api/tags/MySQL复习.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6\"><span class=\"toc-text\">逻辑运算符</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF\"><span class=\"toc-text\">笛卡尔积</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1\"><span class=\"toc-text\">注意事项</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#IN\"><span class=\"toc-text\">IN</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">用法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BD%BF%E7%94%A8%E5%B8%B8%E9%87%8F%E5%80%BC%E5%88%97%E8%A1%A8%EF%BC%9A\"><span class=\"toc-text\">1. 使用常量值列表：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2%EF%BC%9A\"><span class=\"toc-text\">2. 使用子查询：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%97%E8%A1%A8%EF%BC%9A\"><span class=\"toc-text\">3. 使用字符串列表：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%BD%BF%E7%94%A8-NULL%EF%BC%9A\"><span class=\"toc-text\">4. 使用 NULL：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2%E9%99%90%E5%88%B6%E5%80%BC%E8%8C%83%E5%9B%B4%EF%BC%9A\"><span class=\"toc-text\">5. 使用子查询限制值范围：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#EXISTS\"><span class=\"toc-text\">EXISTS</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%B3%95-1\"><span class=\"toc-text\">用法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BD%BF%E7%94%A8-EXISTS-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E7%9B%B8%E5%85%B3%E8%A1%8C%EF%BC%9A\"><span class=\"toc-text\">1. 使用 EXISTS 检查是否存在相关行：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BD%BF%E7%94%A8-NOT-EXISTS-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9B%B8%E5%85%B3%E8%A1%8C%EF%BC%9A\"><span class=\"toc-text\">2. 使用 NOT EXISTS 检查是否不存在相关行：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%EF%BC%9A\"><span class=\"toc-text\">3. 使用子查询限制条件：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%BD%BF%E7%94%A8-EXISTS-%E4%BD%9C%E4%B8%BA%E8%BF%9E%E6%8E%A5%E6%9D%A1%E4%BB%B6%EF%BC%9A\"><span class=\"toc-text\">4. 使用 EXISTS 作为连接条件：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AD%90%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">子查询</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%B3%95-2\"><span class=\"toc-text\">用法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%9C%A8-SELECT-%E5%AD%90%E5%8F%A5%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2%EF%BC%9A\"><span class=\"toc-text\">1. 在 SELECT 子句中使用子查询：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%9C%A8-FROM-%E5%AD%90%E5%8F%A5%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2%EF%BC%9A\"><span class=\"toc-text\">2. 在 FROM 子句中使用子查询：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%9C%A8-WHERE-%E5%AD%90%E5%8F%A5%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2%EF%BC%9A\"><span class=\"toc-text\">3. 在 WHERE 子句中使用子查询：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%9C%A8-IN-%E5%AD%90%E5%8F%A5%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2%EF%BC%9A\"><span class=\"toc-text\">4. 在 IN 子句中使用子查询：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%9C%A8-EXISTS-%E5%AD%90%E5%8F%A5%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2%EF%BC%9A\"><span class=\"toc-text\">5. 在 EXISTS 子句中使用子查询：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2\"><span class=\"toc-text\">注意事项</span></a></li></ol></li></ol>","author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}},"mapped":true,"prev_post":{"title":"MySQL Review-6","uid":"5248bd149e90c578d377990ba1015e7f","slug":"MySQL-Review-6","date":"2023-12-06T07:14:37.000Z","updated":"2023-12-06T09:51:51.198Z","comments":true,"path":"api/articles/MySQL-Review-6.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/MySQL-image.png","text":"这一节来讲关系非常复杂的JOIN，有各种JOIN，一个一个看。 JOIN开始前放一个关系图，来自runoob ok，这就是我们要学的各种复杂的关系。 INNER JOININNER JOIN 是 MySQL 中用于连接两个或多个表的一种常见的连接类型。它根据两个表之间的共同列的匹...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":44,"path":"api/tags/笔记.json"},{"name":"MySQL复习","slug":"MySQL复习","count":10,"path":"api/tags/MySQL复习.json"}],"author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}}},"next_post":{"title":"MySQL Review-4","uid":"3cf8efd46ba4d0ca921476f1afc68b5c","slug":"MySQL-Review-4","date":"2023-12-06T05:45:33.000Z","updated":"2023-12-06T09:49:39.696Z","comments":true,"path":"api/articles/MySQL-Review-4.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/MySQL-image.png","text":"今天来继续复习MySQL中的SELECT语句，也是以后基本上用的最多的查询操作。 SELECT一般形式SELECT主要用于从数据库当中检索数据，这是它的一般形式。 SELECT column1, column2, ... FROM table_name WHERE conditi...","link":"","photos":[],"count_time":{"symbolsCount":"7.4k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":44,"path":"api/tags/笔记.json"},{"name":"MySQL复习","slug":"MySQL复习","count":10,"path":"api/tags/MySQL复习.json"}],"author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}}}}