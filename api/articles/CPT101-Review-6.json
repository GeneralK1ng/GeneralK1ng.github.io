{"title":"CPT101 Review-6","uid":"19c587a1fa2f0478e7eecddf0c905e63","slug":"CPT101-Review-6","date":"2024-01-05T14:42:31.000Z","updated":"2024-01-05T14:42:19.858Z","comments":true,"path":"api/articles/CPT101-Review-6.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/CPT101-img.png","content":"<h1 id=\"操作系统（Operating-Systems）\"><a href=\"#操作系统（Operating-Systems）\" class=\"headerlink\" title=\"操作系统（Operating Systems）\"></a>操作系统（Operating Systems）</h1><h2 id=\"什么是操作系统？\"><a href=\"#什么是操作系统？\" class=\"headerlink\" title=\"什么是操作系统？\"></a>什么是操作系统？</h2><p>操作系统（Operating System，简称OS）是管理计算机硬件和软件资源的系统软件。它提供了一个用户和计算机硬件之间的接口，使得应用程序可以运行并与计算机硬件交互。</p>\n<h2 id=\"操作系统的发展流程\"><a href=\"#操作系统的发展流程\" class=\"headerlink\" title=\"操作系统的发展流程\"></a>操作系统的发展流程</h2><h3 id=\"发展流程\"><a href=\"#发展流程\" class=\"headerlink\" title=\"发展流程\"></a>发展流程</h3><ol>\n<li><strong>OS/360 for IBM System/360 (1960s):</strong><ul>\n<li>IBM System/360是IBM推出的一系列主机计算机。</li>\n<li>OS/360是为System/360设计的操作系统，标志着主机系统操作系统的发展。</li>\n</ul>\n</li>\n<li><strong>Unix (1970s):</strong><ul>\n<li>Unix是由贝尔实验室的Ken Thompson、Dennis Ritchie等人开发的多用户、多任务操作系统。</li>\n<li>Unix的设计理念影响了许多后来的操作系统。</li>\n</ul>\n</li>\n<li><strong>MS-DOS for IBM PC and Mac OS for Apple Macintosh (1980s):</strong><ul>\n<li>MS-DOS是微软为IBM个人计算机开发的操作系统。</li>\n<li>Mac OS是苹果Macintosh计算机的操作系统。</li>\n</ul>\n</li>\n<li><strong>Windows 95, 98, NT (1990s):</strong><ul>\n<li>Windows 95和98是微软推出的桌面操作系统，具有图形用户界面。</li>\n<li>Windows NT是微软推出的面向企业的操作系统，后来成为Microsoft桌面操作系统的基础。</li>\n</ul>\n</li>\n<li><strong>Mac OS X (2001):</strong><ul>\n<li>Apple于2001年发布的Mac OS X是基于Unix内核的重新构建的操作系统，融合了苹果的用户界面设计。</li>\n</ul>\n</li>\n<li><strong>Linux, BSD Unix:</strong><ul>\n<li>Linux是一个开源的Unix-like操作系统内核，广泛应用于服务器和嵌入式系统。</li>\n<li>BSD Unix是Berkeley Software Distribution的一系列Unix操作系统的衍生。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"窗口界面\"><a href=\"#窗口界面\" class=\"headerlink\" title=\"窗口界面\"></a>窗口界面</h3><p>操作系统经历了40多年的演进，“…但令人惊讶的是，在技术核心方面变化并不大，只有窗口界面的引入真正使其与过去不同。” </p>\n<ol>\n<li><strong>技术核心相对稳定：</strong><ul>\n<li>操作系统的技术核心，即内核，负责管理硬件和提供基本服务。这一部分确实相对稳定，因为它需要满足基本的计算和资源管理需求。</li>\n</ul>\n</li>\n<li><strong>窗口界面的引入：</strong><ul>\n<li>引入窗口界面是操作系统演进的一个显著变化。窗口界面使得用户可以更直观地与计算机交互，提高了用户友好性。</li>\n</ul>\n</li>\n<li><strong>持续的稳定性需求：</strong><ul>\n<li>计算机系统对稳定性和可靠性有着极高的要求。任何操作系统的更新和演进都需要在保持核心稳定性的同时引入新功能。</li>\n</ul>\n</li>\n<li><strong>软件兼容性：</strong><ul>\n<li>由于大量软件和应用程序依赖于操作系统，为了确保向后兼容性，操作系统的变化可能会受到限制，以保持对旧版软件的支持。</li>\n</ul>\n</li>\n<li><strong>工业标准的影响：</strong><ul>\n<li>某些操作系统可能成为特定领域或工业的标准，限制了其在技术方面的大规模变革，以避免对生态系统的不稳定影响。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"重要名词和英语单词\"><a href=\"#重要名词和英语单词\" class=\"headerlink\" title=\"重要名词和英语单词\"></a>重要名词和英语单词</h3><ul>\n<li><strong>Desktop Operating System:</strong> 桌面操作系统，用于个人计算机的操作系统。</li>\n<li><strong>Unix Core:</strong> Unix内核，操作系统的核心部分，提供基本的系统功能。</li>\n<li><strong>Graphical User Interface (GUI):</strong> 图形用户界面，通过图形元素（如图标、按钮）而不是命令行来与用户交互。</li>\n<li><strong>Open Source:</strong> 开源，指软件的源代码是公开可用的，用户可以查看、修改和分享。</li>\n</ul>\n<h2 id=\"操作系统的功能\"><a href=\"#操作系统的功能\" class=\"headerlink\" title=\"操作系统的功能\"></a>操作系统的功能</h2><p>操作系统有多个关键功能，其中之一是解释和执行由以下两类实体发出的命令：</p>\n<ol>\n<li><strong>用户：</strong><ul>\n<li>操作系统作为用户与计算机交互的接口，接收和执行用户发出的各种命令。这包括通过命令行、图形用户界面（GUI）或其他交互方式输入的指令。</li>\n</ul>\n</li>\n<li><strong>应用程序：</strong><ul>\n<li>操作系统负责解释和执行由正在运行的应用程序发出的命令。应用程序通过操作系统与硬件和其他系统资源进行交互，以完成特定的任务。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"用户命令的解释和执行\"><a href=\"#用户命令的解释和执行\" class=\"headerlink\" title=\"用户命令的解释和执行\"></a>用户命令的解释和执行</h3><ol>\n<li><strong>命令解释：</strong><ul>\n<li>操作系统负责解释用户发出的命令。这可能涉及到语法分析和命令解码，以确保操作系统正确理解用户的要求。</li>\n</ul>\n</li>\n<li><strong>命令执行：</strong><ul>\n<li>一旦命令被解释，操作系统会采取相应的行动。这可能包括分配资源、调度任务、管理文件系统、处理输入输出等。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"应用程序命令的解释和执行\"><a href=\"#应用程序命令的解释和执行\" class=\"headerlink\" title=\"应用程序命令的解释和执行\"></a>应用程序命令的解释和执行</h3><ol>\n<li><strong>应用程序接口（API）：</strong><ul>\n<li>操作系统提供应用程序接口，允许应用程序通过特定的接口与操作系统通信。这使得应用程序能够请求操作系统执行各种操作。</li>\n</ul>\n</li>\n<li><strong>资源管理：</strong><ul>\n<li>操作系统负责为应用程序分配和管理系统资源，例如内存、处理器时间、文件系统空间等。这确保了多个应用程序能够共享计算机资源。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"操作系统的目的\"><a href=\"#操作系统的目的\" class=\"headerlink\" title=\"操作系统的目的\"></a>操作系统的目的</h2><h3 id=\"基本目的\"><a href=\"#基本目的\" class=\"headerlink\" title=\"基本目的\"></a>基本目的</h3><p>操作系统有两个基本目的，分别是管理和提供功能：</p>\n<h4 id=\"管理\"><a href=\"#管理\" class=\"headerlink\" title=\"管理\"></a>管理</h4><ul>\n<li><strong>有效控制和操作硬件：</strong><ul>\n<li>操作系统通过管理硬件资源，如中央处理器、内存、硬盘等，以确保它们被有效地分配和使用。这有助于提高计算机的整体性能和效率。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"提供功能\"><a href=\"#提供功能\" class=\"headerlink\" title=\"提供功能\"></a>提供功能</h4><ul>\n<li><strong>为用户提供功能：</strong><ul>\n<li><strong>高效访问计算机设备：</strong><ul>\n<li>操作系统旨在提供用户对计算机设备的高效访问，无论是通过命令行还是图形用户界面。这确保了用户可以轻松地与计算机交互，执行各种任务。</li>\n</ul>\n</li>\n<li><strong>公平访问计算机设备：</strong><ul>\n<li>操作系统致力于确保所有用户对计算机设备的访问是公平的，避免某个用户或应用程序占用过多资源，导致其他用户受影响。</li>\n</ul>\n</li>\n<li><strong>受保护的访问计算机设备：</strong><ul>\n<li>操作系统提供了安全机制，以确保用户的访问是受保护的。这包括对文件和系统资源的权限管理，以防止未经授权的访问。</li>\n</ul>\n</li>\n<li><strong>与用户的交互：</strong><ul>\n<li>操作系统作为用户与计算机之间的接口，促使用户能够通过命令或图形界面与计算机进行交互。这包括提供反馈、错误提示等。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"洋葱环模型（Onion-Ring-Model）\"><a href=\"#洋葱环模型（Onion-Ring-Model）\" class=\"headerlink\" title=\"洋葱环模型（Onion Ring Model）\"></a>洋葱环模型（Onion Ring Model）</h3><h4 id=\"实现操作系统目的的洋葱环模型\"><a href=\"#实现操作系统目的的洋葱环模型\" class=\"headerlink\" title=\"实现操作系统目的的洋葱环模型\"></a>实现操作系统目的的洋葱环模型</h4><p>为了实现操作系统的目的，操作系统软件通常被组织成多个层次，这就是所谓的“洋葱环模型”。</p>\n<h4 id=\"为什么需要多个层次？\"><a href=\"#为什么需要多个层次？\" class=\"headerlink\" title=\"为什么需要多个层次？\"></a>为什么需要多个层次？</h4><ol>\n<li><strong>抽象与模块化：</strong><ul>\n<li>多层次结构允许将操作系统功能划分为各个抽象层次和模块，使得系统更容易理解和维护。每个层次提供特定的功能，同时隐藏底层细节。</li>\n</ul>\n</li>\n<li><strong>简化系统设计和维护：</strong><ul>\n<li>分层的结构使得系统的设计更加模块化，可以更容易地进行修改、更新或扩展某个特定层次，而无需影响整个系统。</li>\n</ul>\n</li>\n<li><strong>提高系统的可扩展性：</strong><ul>\n<li>多层次结构使得系统更易于扩展。新功能或改进可以被添加到适当的层次，而不会对整个系统产生过多的影响。</li>\n</ul>\n</li>\n<li><strong>实现清晰的接口：</strong><ul>\n<li>每个层次都定义了与其他层次的明确接口，通过这些接口，层次之间的通信和协作变得更加清晰和可管理。</li>\n</ul>\n</li>\n<li><strong>提高系统的可维护性：</strong><ul>\n<li>多层次结构降低了系统的复杂性，使得在不同层次上进行调试、测试和维护更加容易。每个层次可以独立地进行测试，而无需考虑整个系统的复杂性。</li>\n</ul>\n</li>\n<li><strong>支持分布式开发：</strong><ul>\n<li>不同的团队可以专注于开发和维护特定层次，而无需过多关注其他层次的细节。这种分布式开发模型有助于提高开发效率。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"洋葱环模型的层次结构\"><a href=\"#洋葱环模型的层次结构\" class=\"headerlink\" title=\"洋葱环模型的层次结构\"></a>洋葱环模型的层次结构</h4><p>典型的洋葱环模型包括多个层次，例如：</p>\n<ul>\n<li>用户接口层</li>\n<li>Shell层</li>\n<li>系统调用层</li>\n<li>进程管理层</li>\n<li>文件系统层</li>\n<li>硬件抽象层</li>\n</ul>\n<p>每个层次负责不同的功能，通过定义清晰的接口使得它们能够有效地协同工作，从而实现了操作系统的各种目的。</p>\n<h4 id=\"操作系统作为计算机的门卫（Gatekeeper）\"><a href=\"#操作系统作为计算机的门卫（Gatekeeper）\" class=\"headerlink\" title=\"操作系统作为计算机的门卫（Gatekeeper）\"></a>操作系统作为计算机的门卫（Gatekeeper）</h4><ul>\n<li><strong>计算机的使用者入口：</strong><ul>\n<li>操作系统充当计算机的门卫，用户通过它与计算机进行交互。用户通过命令行、图形用户界面或其他方式向操作系统发出命令，然后由操作系统翻译和执行这些命令。</li>\n</ul>\n</li>\n<li><strong>安全性与权限控制：</strong><ul>\n<li>操作系统负责确保计算机系统的安全性，通过实施权限控制和身份验证机制，防止未经授权的访问。这使得操作系统成为计算机系统的保护门卫。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"操作系统作为计算机的管家（Butler）\"><a href=\"#操作系统作为计算机的管家（Butler）\" class=\"headerlink\" title=\"操作系统作为计算机的管家（Butler）\"></a>操作系统作为计算机的管家（Butler）</h4><ul>\n<li><strong>整体效率的决定者：</strong><ul>\n<li>操作系统在很大程度上决定了计算机的整体效率。通过有效的硬件资源管理、任务调度和性能优化，操作系统确保计算机系统以最佳方式运行。</li>\n</ul>\n</li>\n<li><strong>资源的分配和协调：</strong><ul>\n<li>作为管家，操作系统负责资源的分配和协调。它决定哪个程序在什么时候运行，如何分配内存、处理器时间和其他关键资源，以保持系统的平衡。</li>\n</ul>\n</li>\n<li><strong>问题解决和服务提供：</strong><ul>\n<li>操作系统作为管家解决了许多与硬件和软件交互相关的问题。它提供了各种服务，包括文件管理、网络连接、设备驱动程序等，以便用户和应用程序能够无缝地使用计算机。</li>\n</ul>\n</li>\n<li><strong>用户体验的改善：</strong><ul>\n<li>通过提供友好的用户界面和有效的资源管理，操作系统有助于提高用户体验。这包括快速响应用户请求、最小化等待时间和提供直观的界面。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"操作系统的综合作用\"><a href=\"#操作系统的综合作用\" class=\"headerlink\" title=\"操作系统的综合作用\"></a>操作系统的综合作用</h4><p>通过充当门卫和管家，操作系统不仅提供了计算机系统的安全性和保护，还确保了计算机系统的整体效率和用户体验。这两个角色共同构成了操作系统在计算机生态系统中的核心位置，为用户和应用程序提供了可靠的计算环境。</p>\n<p>![Onion Ring Model](<a href=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/Onion\">https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/Onion</a> Ring Model.png)</p>\n<h4 id=\"操作系统核心：直接处理硬件\"><a href=\"#操作系统核心：直接处理硬件\" class=\"headerlink\" title=\"操作系统核心：直接处理硬件\"></a>操作系统核心：直接处理硬件</h4><ul>\n<li><strong>核心概念：</strong><ul>\n<li>操作系统的核心是直接与硬件交互的部分，通常被称为内核（Kernel）。</li>\n</ul>\n</li>\n<li><strong>内核功能：</strong><ul>\n<li>内核包含处理硬件的关键功能，例如设备驱动程序、内存分配器等。</li>\n</ul>\n</li>\n<li><strong>设备驱动程序：</strong><ul>\n<li>内核中的设备驱动程序允许操作系统与计算机硬件进行通信。这包括对处理器、存储设备、网络接口等的控制。</li>\n</ul>\n</li>\n<li><strong>内存分配器：</strong><ul>\n<li>内核负责有效地管理计算机的内存。它分配内存给运行的程序，并在程序结束时回收这些资源。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"命令行界面（CLI）：为用户提供系统可访问性\"><a href=\"#命令行界面（CLI）：为用户提供系统可访问性\" class=\"headerlink\" title=\"命令行界面（CLI）：为用户提供系统可访问性\"></a>命令行界面（CLI）：为用户提供系统可访问性</h4><ul>\n<li><strong>CLI概念：</strong><ul>\n<li>命令行界面是操作系统提供给用户的一种交互方式，用户通过在命令行中输入文本命令与系统进行通信。</li>\n</ul>\n</li>\n<li><strong>用户可访问性：</strong><ul>\n<li>CLI提供了一种灵活而强大的方式，使用户能够直接与操作系统交互。用户可以通过命令行执行各种任务，如文件管理、进程控制等。</li>\n</ul>\n</li>\n<li><strong>自动化和脚本：</strong><ul>\n<li>CLI允许用户编写脚本自动执行一系列命令，提高了效率和一致性。</li>\n</ul>\n</li>\n<li><strong>系统管理员工具：</strong><ul>\n<li>对于系统管理员和高级用户而言，CLI是管理系统的强大工具。它提供了对系统深层次设置和配置的直接访问。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"洋葱环模型的层次结构再思考\"><a href=\"#洋葱环模型的层次结构再思考\" class=\"headerlink\" title=\"洋葱环模型的层次结构再思考\"></a>洋葱环模型的层次结构再思考</h4><ul>\n<li><strong>内核和CLI的位置：</strong><ul>\n<li>操作系统的洋葱环模型中，内核通常位于最底层，直接与硬件交互。CLI位于用户接口层次，为用户提供了直接的系统访问。</li>\n</ul>\n</li>\n<li><strong>用户与硬件的中间层次：</strong><ul>\n<li>在内核和CLI之间，可能还存在其他层次，如系统调用、进程管理、文件系统等。这些层次共同形成了洋葱环的结构，每个层次都有其特定的功能和作用。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"现代操作系统\"><a href=\"#现代操作系统\" class=\"headerlink\" title=\"现代操作系统\"></a>现代操作系统</h2><h3 id=\"并行处理多个程序\"><a href=\"#并行处理多个程序\" class=\"headerlink\" title=\"并行处理多个程序\"></a>并行处理多个程序</h3><ul>\n<li><strong>DOS：</strong><ul>\n<li>DOS（磁盘操作系统）是早期个人计算机上使用的操作系统之一。在DOS中，一次只能运行一个程序，要运行第二个程序，必须等待当前程序完成。这样的单任务操作系统在效率上存在一些限制。</li>\n<li><strong>后台处理（Background Spooling）：</strong><ul>\n<li>DOS引入了后台处理，提供了最小程度的并发性。例如，可以在后台进行打印作业，而用户可以在此期间进行其他任务。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>Windows、Unix和Linux：</strong><ul>\n<li>在现代操作系统中，如Windows、Unix和Linux，实现了更高程度的并发性和多任务处理。</li>\n<li><strong>多任务处理（Multi-tasking）：</strong><ul>\n<li>现代操作系统支持多任务处理，允许多个程序同时运行。这使得用户可以在不同的应用程序之间切换，而不必等待一个程序完成。</li>\n</ul>\n</li>\n<li><strong>多用户支持（Multi-user）：</strong><ul>\n<li>现代操作系统还支持多用户，允许多个用户同时访问计算机系统。每个用户都有自己的用户环境和资源。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"并行和分时系统的效率对比\"><a href=\"#并行和分时系统的效率对比\" class=\"headerlink\" title=\"并行和分时系统的效率对比\"></a>并行和分时系统的效率对比</h3><ul>\n<li><strong>DOS的效率：</strong><ul>\n<li>DOS的单任务模型可能导致效率低下，因为用户必须等待一个程序完成才能执行下一个。</li>\n</ul>\n</li>\n<li><strong>现代操作系统的效率：</strong><ul>\n<li>Windows、Unix和Linux等现代操作系统通过多任务处理提高了效率。多个程序可以同时运行，允许用户更充分地利用计算机资源。</li>\n</ul>\n</li>\n<li><strong>多任务处理的好处：</strong><ul>\n<li>提高了系统的响应速度，允许用户同时运行多个应用程序，提高了计算机的整体效率。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"与操作系统的交互\"><a href=\"#与操作系统的交互\" class=\"headerlink\" title=\"与操作系统的交互\"></a>与操作系统的交互</h2><h3 id=\"命令行解释器（CLI）\"><a href=\"#命令行解释器（CLI）\" class=\"headerlink\" title=\"命令行解释器（CLI）\"></a>命令行解释器（CLI）</h3><ul>\n<li><strong>DOS：</strong><ul>\n<li>在DOS中，用户通过在命令行中键入命令与操作系统进行交互。例如，用户可以键入命令来运行程序、管理文件等。</li>\n</ul>\n</li>\n<li><strong>Unix/Linux：</strong><ul>\n<li>Unix和Linux系统使用Shell脚本，这是一系列指令的脚本文件。用户可以通过在终端中输入命令来执行这些脚本，实现各种系统和应用程序的操作。</li>\n</ul>\n</li>\n<li><strong>Windows/Mac OS X：</strong><ul>\n<li>在Windows和Mac OS X中，用户通常通过使用鼠标点击图标来与操作系统进行交互。这种图形用户界面（GUI）提供了直观的可视化方式，用户可以通过图形元素进行操作。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"用户程序内的函数调用（API）\"><a href=\"#用户程序内的函数调用（API）\" class=\"headerlink\" title=\"用户程序内的函数调用（API）\"></a>用户程序内的函数调用（API）</h3><ul>\n<li><p><strong>API（应用程序接口）：</strong></p>\n<ul>\n<li>用户程序可以通过API与操作系统进行交互。API是一组允许应用程序与操作系统进行通信的函数和工具。</li>\n</ul>\n</li>\n<li><p><strong>示例：C代码段：</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n...\nvoid main() {\n    printf(\"Hello world!\");\n}</code></pre>\n</li>\n<li><p>在这个例子中，<code>printf</code> 是C语言的一个标准库函数，它通过API调用操作系统的输出功能来显示 “Hello world!”。</p>\n</li>\n</ul>\n<h3 id=\"交互方式的选择\"><a href=\"#交互方式的选择\" class=\"headerlink\" title=\"交互方式的选择\"></a>交互方式的选择</h3><ul>\n<li><strong>命令行 vs. 图形界面：</strong><ul>\n<li>命令行提供了更灵活的方式，适用于对命令和脚本熟悉的用户，而图形界面提供了更直观和用户友好的交互方式，适用于不熟悉命令的用户。</li>\n</ul>\n</li>\n<li><strong>API调用：</strong><ul>\n<li>通过API调用，用户程序可以直接与操作系统交互，执行各种操作，如文件管理、内存分配等。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"用户与操作系统的交互示例\"><a href=\"#用户与操作系统的交互示例\" class=\"headerlink\" title=\"用户与操作系统的交互示例\"></a>用户与操作系统的交互示例</h3><ul>\n<li><strong>命令行交互：</strong><ul>\n<li>用户在终端中输入命令，例如 <code>ls</code>（在Unix/Linux中列出文件和目录）。</li>\n</ul>\n</li>\n<li><strong>图形界面交互：</strong><ul>\n<li>用户在文件管理器中使用鼠标点击图标，例如双击文件以打开它。</li>\n</ul>\n</li>\n<li><strong>API调用：</strong><ul>\n<li>用户程序通过API调用，如上述的C代码段，与操作系统进行通信，执行特定的功能。</li>\n</ul>\n</li>\n</ul>\n<p>这些不同的交互方式为用户提供了多样性的选择，以适应他们的技能水平和工作需求。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>考虑你正在进行Java练习的情境：</p>\n<p><strong>编写Java程序：</strong></p>\n<ul>\n<li>你编写了一个Java程序，假设文件名为 <code>MyProc.java</code>。</li>\n</ul>\n<p><strong>编译Java程序：</strong></p>\n<ul>\n<li>为了将Java源代码转换为可执行的字节码，你需要运行Java编译器（javac）。</li>\n</ul>\n<p><strong>在命令行中输入命令：</strong></p>\n<ul>\n<li><p>你在命令行中键入以下命令并按回车键：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">javac MyProc.java</code></pre></li>\n</ul>\n<p><strong>命令解释和执行：</strong></p>\n<ul>\n<li>操作系统的命令行解释器（或Shell）解释并执行你键入的命令。在这种情况下，它启动了Java编译器（javac）。</li>\n</ul>\n<p><strong>Java编译器执行：</strong></p>\n<ul>\n<li>Java编译器（javac）接收到你的命令并开始编译 <code>MyProc.java</code> 文件。它检查代码的语法和语义，生成对应的字节码文件（<code>.class</code> 文件）。</li>\n</ul>\n<p><strong>输出结果：</strong></p>\n<ul>\n<li>如果没有编译错误，你将在屏幕上看到一些编译过程的输出，告诉你编译是否成功。如果有错误，它将指示错误的位置和类型。</li>\n</ul>\n<p><strong>运行Java程序：</strong></p>\n<ul>\n<li><p>一旦成功编译，你可以运行Java程序。在命令行中键入以下命令并按回车键：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">java MyProc</code></pre>\n\n<p>这将启动Java虚拟机（JVM），执行编译后的字节码文件。</p>\n</li>\n</ul>\n<p><strong>结果：</strong></p>\n<ul>\n<li>如果程序执行无误，你将在屏幕上看到Java程序的输出结果。</li>\n</ul>\n<p><strong>观察：</strong></p>\n<ul>\n<li><code>javac</code> 是一个需要执行的程序。</li>\n<li>任何程序在执行之前都应该存在于主存（RAM）中。</li>\n<li>因此，<code>javac</code> 需要从磁盘加载到主存中，然后才能被执行。</li>\n</ul>\n<p><strong>问题：由谁或什么来完成这个任务？</strong></p>\n<ul>\n<li><strong>回答：操作系统。</strong></li>\n</ul>\n<p>在上述例子中，当你输入 <code>javac MyProc.java</code> 时，<code>javac</code> 这个程序的可执行文件（二进制文件）必须从硬盘加载到计算机的主内存中，然后由操作系统负责执行。</p>\n<p><strong>加载过程：</strong></p>\n<ol>\n<li><strong>加载到内存：</strong><ul>\n<li>操作系统负责将 <code>javac</code> 的二进制文件从硬盘加载到主存中，通常会将其放入可执行文件的部分。</li>\n</ul>\n</li>\n<li><strong>执行程序：</strong><ul>\n<li>一旦加载完成，操作系统将启动 <code>javac</code>，开始执行它。这涉及操作系统对程序计数器和其他寄存器的设置，以及为程序提供必要的资源。</li>\n</ul>\n</li>\n<li><strong>程序执行：</strong><ul>\n<li><code>javac</code> 开始执行，它会读取并处理 <code>MyProc.java</code> 文件，并执行编译操作。整个过程在主内存中进行。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"另一个Linux示例\"><a href=\"#另一个Linux示例\" class=\"headerlink\" title=\"另一个Linux示例\"></a>另一个Linux示例</h3><p>在Linux中，当你键入 <code>ls</code> 命令并按回车键时，该命令将列出当前目录中的文件，类似于DOS中的 <code>dir</code> 命令。</p>\n<p><strong>用户输入命令：</strong></p>\n<ul>\n<li><p>你在终端中键入以下命令并按回车键：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ls</code></pre></li>\n</ul>\n<p><strong>命令解释和执行：</strong></p>\n<ul>\n<li>操作系统的命令行解释器（Shell）解释并执行你键入的命令。在这种情况下，它启动了 <code>ls</code> 程序。</li>\n</ul>\n<p><strong>ls程序的运行：</strong></p>\n<ul>\n<li>当 <code>ls</code> 程序运行时，它需要获取当前目录中文件的信息以进行显示。</li>\n</ul>\n<p><strong>信息来源：</strong></p>\n<ul>\n<li>问题：是谁或什么提供了这些文件信息？</li>\n<li>回答：操作系统。<code>ls</code> 程序通过向适当的系统程序发出请求，从而获取文件信息。</li>\n</ul>\n<p><strong>操作过程：</strong></p>\n<ul>\n<li>当 <code>ls</code> 程序运行并需要列出当前目录中的文件时，它不会直接访问硬盘或文件系统。相反，它通过系统调用向操作系统请求有关文件的信息。</li>\n<li>操作系统的文件系统管理模块（File System Manager）负责处理这些请求。它提供了对文件系统的访问，并返回 <code>ls</code> 程序所需的文件信息。</li>\n</ul>\n<h2 id=\"操作系统操作的复杂性\"><a href=\"#操作系统操作的复杂性\" class=\"headerlink\" title=\"操作系统操作的复杂性\"></a>操作系统操作的复杂性</h2><p><strong>示例：接受用户命令的复杂操作</strong></p>\n<p>为了接受用户的命令，操作系统必须执行以下一系列复杂的操作：</p>\n<ol>\n<li><strong>接收键盘输入：</strong><ul>\n<li>从键盘接收输入的按键。</li>\n</ul>\n</li>\n<li><strong>解释输入命令：</strong><ul>\n<li>将输入的按键解释为一个有效的命令。</li>\n</ul>\n</li>\n<li><strong>确定程序文件的位置：</strong><ul>\n<li>确定与该命令相关的程序文件的位置。</li>\n</ul>\n</li>\n<li><strong>从存储设备中读取文件块：</strong><ul>\n<li>从辅助存储设备（如硬盘）中读取程序文件的适当块到主内存。</li>\n</ul>\n</li>\n<li><strong>为程序设置上下文：</strong><ul>\n<li>设置程序执行所需的上下文，包括程序的初始状态、环境等。</li>\n</ul>\n</li>\n<li><strong>转移控制给执行的程序：</strong><ul>\n<li>将控制传递给将要执行的程序。</li>\n</ul>\n</li>\n<li><strong>在程序完成后恢复控制：</strong><ul>\n<li>当程序执行完成后，恢复控制给操作系统。</li>\n</ul>\n</li>\n</ol>\n<p><strong>每个步骤的说明：</strong></p>\n<ol>\n<li><strong>接收键盘输入：</strong><ul>\n<li>操作系统需要检测和接收来自键盘的输入，这可能涉及到中断处理等机制。</li>\n</ul>\n</li>\n<li><strong>解释输入命令：</strong><ul>\n<li>操作系统需要识别并解释用户输入的命令，以便知道如何处理接下来的步骤。</li>\n</ul>\n</li>\n<li><strong>确定程序文件的位置：</strong><ul>\n<li>操作系统需要确定与用户输入的命令相关联的程序文件在存储设备上的位置。</li>\n</ul>\n</li>\n<li><strong>从存储设备中读取文件块：</strong><ul>\n<li>操作系统必须从硬盘等辅助存储设备中读取程序文件的相应块，将其加载到主内存中。</li>\n</ul>\n</li>\n<li><strong>为程序设置上下文：</strong><ul>\n<li>操作系统需要设置程序执行所需的初始状态和环境，以便程序正确运行。</li>\n</ul>\n</li>\n<li><strong>转移控制给执行的程序：</strong><ul>\n<li>操作系统将控制传递给将要执行的程序，使得程序可以开始运行。</li>\n</ul>\n</li>\n<li><strong>在程序完成后恢复控制：</strong><ul>\n<li>操作系统需要在程序执行完成后，恢复对系统的控制，可能包括释放资源、更新系统状态等。</li>\n</ul>\n</li>\n</ol>\n<p><strong>操作系统复杂性的原因：</strong></p>\n<ul>\n<li>操作系统执行许多涉及底层硬件和高层软件抽象的任务，这些任务需要有效地协调和管理系统资源，以便为用户和应用程序提供一致且可靠的计算环境。</li>\n</ul>\n<p>如果多个程序同时执行，操作系统必须包括以下内容：</p>\n<ol>\n<li><strong>分配内存和其他资源的程序（内存管理器）：</strong><ul>\n<li>为每个程序分配必要的内存和其他系统资源，确保它们之间不会发生冲突。</li>\n</ul>\n</li>\n<li><strong>为每个程序分配CPU时间的程序（调度器）：</strong><ul>\n<li>协调和分配CPU时间，确保每个程序都有机会执行，并避免系统资源的浪费。</li>\n</ul>\n</li>\n<li><strong>维护每个程序的完整性的程序（安全内核）：</strong><ul>\n<li>确保每个程序在执行过程中保持数据和系统的完整性，防止非法访问和破坏。</li>\n</ul>\n</li>\n<li><strong>其他任务：</strong><ul>\n<li>还有许多其他任务，例如文件管理、网络管理、设备驱动程序等，这些都是由操作系统协调和管理的。</li>\n</ul>\n</li>\n</ol>\n<p><strong>操作系统处理任务的复杂性：</strong></p>\n<ul>\n<li>以上只是操作系统执行的一小部分任务的示例。操作系统需要处理各种复杂的任务，以提供高效、可靠和安全的计算环境。</li>\n<li><strong>内存管理、进程调度、安全性等：</strong><ul>\n<li>操作系统需要有效地分配和管理内存，调度程序执行的进程，并保障系统的安全性。</li>\n</ul>\n</li>\n<li><strong>文件管理、网络管理等：</strong><ul>\n<li>同时，操作系统还负责文件系统的管理、网络连接的维护、设备驱动程序的加载等任务。</li>\n</ul>\n</li>\n<li><strong>多任务、多用户支持：</strong><ul>\n<li>如果操作系统支持多任务和多用户，它必须更加复杂，以便同时处理多个用户和程序的需求。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/OSExample.png\" alt=\"OS\"></p>\n<h1 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h1><h2 id=\"计算机网络的影响\"><a href=\"#计算机网络的影响\" class=\"headerlink\" title=\"计算机网络的影响\"></a>计算机网络的影响</h2><p><strong>或许是对冯·诺依曼原始蓝图产生最深远变革的领域。</strong></p>\n<ul>\n<li><strong>变革的内容：</strong><ul>\n<li>计算机网络引入了一系列对冯·诺依曼计算机原始蓝图的变革。</li>\n</ul>\n</li>\n<li><strong>操作系统与网络的关系：</strong><ul>\n<li>操作系统通常提供对网络设施的访问，通过网络API（例如套接字接口）使计算机可以连接到网络。</li>\n</ul>\n</li>\n<li><strong>计算机网络的定义：</strong><ul>\n<li>计算机网络是相互连接的、自治的计算机集合，旨在促进快速的信息交换。</li>\n</ul>\n</li>\n</ul>\n<p><strong>操作系统与计算机网络的关联：</strong></p>\n<ol>\n<li><strong>网络API的提供：</strong><ul>\n<li>操作系统通过提供网络API（Application Programming Interface）的方式，允许应用程序与网络进行交互。套接字接口是其中常见的一个例子。</li>\n</ul>\n</li>\n<li><strong>资源共享与通信：</strong><ul>\n<li>计算机网络提供了资源共享的机会，允许计算机之间进行通信和协作。操作系统在这个过程中起到协调和管理的作用。</li>\n</ul>\n</li>\n<li><strong>分布式计算：</strong><ul>\n<li>计算机网络使得分布式计算成为可能，多台计算机可以合作完成复杂的任务。操作系统需要处理分布式环境下的任务分配、通信、同步等问题。</li>\n</ul>\n</li>\n<li><strong>远程访问：</strong><ul>\n<li>通过计算机网络，用户可以远程访问其他计算机上的资源。操作系统需要提供远程访问的支持，并确保安全性和可靠性。</li>\n</ul>\n</li>\n</ol>\n<p><strong>网络的影响：</strong></p>\n<ul>\n<li>计算机网络的引入改变了计算机系统的性质，从单一孤立的系统转变为相互连接的系统集合。这种变革对操作系统的功能和设计产生了深远的影响，使其适应了分布式、协同工作的新环境。</li>\n</ul>\n<h2 id=\"为什么要使用计算机网络？\"><a href=\"#为什么要使用计算机网络？\" class=\"headerlink\" title=\"为什么要使用计算机网络？\"></a>为什么要使用计算机网络？</h2><p><strong>增加计算能力：</strong></p>\n<ul>\n<li>分布式计算项目：<ul>\n<li>通过计算机网络，可以将多个计算机连接在一起，形成分布式计算系统。分布式计算项目如SETI@home和Folding@home利用网络上的多台计算机协同工作，以增加计算能力来解决复杂的科学问题。</li>\n</ul>\n</li>\n</ul>\n<p><strong>共享宝贵资源：</strong></p>\n<ul>\n<li>打印机、大容量磁盘等资源的共享：<ul>\n<li>计算机网络允许多个计算机共享重要的资源，如打印机、大容量磁盘、程序和数据库等。例如，在XJTLU有一个中央打印系统和一个中央文件系统，为整个学校提供了共享服务。</li>\n</ul>\n</li>\n</ul>\n<p><strong>方便用户之间的交互：</strong></p>\n<ul>\n<li>方便用户在不同位置工作时的交互：<ul>\n<li>计算机网络为用户提供了方便的交互方式，使得用户可以在不同位置的个人计算机上协同工作。这在在线游戏等应用中尤其显著。</li>\n</ul>\n</li>\n</ul>\n<p><strong>信息触手可及：</strong></p>\n<ul>\n<li>信息随时可得：<ul>\n<li>计算机网络使得信息变得更加容易获得。用户可以通过网络随时随地获取所需的信息，这使得信息更加容易传播和分享。</li>\n</ul>\n</li>\n</ul>\n<p>通过计算机网络，我们不仅能够提高计算能力、共享宝贵资源，还能够方便地协同工作和获取信息。这为用户提供了更灵活和高效的计算环境。</p>\n<h2 id=\"客户端-服务端计算\"><a href=\"#客户端-服务端计算\" class=\"headerlink\" title=\"客户端-服务端计算\"></a>客户端-服务端计算</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p><strong>客户端：</strong> 发起请求的一方。</p>\n<p><strong>服务器：</strong> 提供服务的一方。</p>\n<p>在客户端-服务器计算中，通常有两个主要角色：客户端和服务器。</p>\n<p><strong>客户端：</strong></p>\n<ul>\n<li>客户端是发起请求的一方。它通常是用户使用的终端设备，例如个人电脑、智能手机或平板电脑。客户端负责发出请求并处理从服务器返回的响应。</li>\n</ul>\n<p><strong>服务器：</strong></p>\n<ul>\n<li>服务器是提供服务的一方。它是一台或多台计算机，运行着特定的服务或应用程序，以响应来自客户端的请求。服务器的目标是满足客户端的需求，提供所请求的服务或资源。</li>\n</ul>\n<p><strong>客户端-服务器模型的工作流程：</strong></p>\n<ol>\n<li><strong>客户端发起请求：</strong><ul>\n<li>客户端向服务器发出请求，请求特定的服务或资源。</li>\n</ul>\n</li>\n<li><strong>服务器处理请求：</strong><ul>\n<li>服务器接收到客户端的请求后，会执行相应的服务或检索所需的资源。</li>\n</ul>\n</li>\n<li><strong>服务器返回响应：</strong><ul>\n<li>服务器将处理结果或所请求的资源返回给客户端。</li>\n</ul>\n</li>\n<li><strong>客户端处理响应：</strong><ul>\n<li>客户端接收到服务器的响应后，进行相应的处理，可能是显示内容、执行操作，或者其他交互。</li>\n</ul>\n</li>\n</ol>\n<p><strong>客户端-服务器模型的优势：</strong></p>\n<ul>\n<li><strong>分布式计算：</strong><ul>\n<li>客户端和服务器可以分布在不同的地理位置，实现分布式计算。</li>\n</ul>\n</li>\n<li><strong>资源共享：</strong><ul>\n<li>通过客户端-服务器模型，可以实现资源的有效共享，客户端通过请求服务器来获取所需的服务或资源。</li>\n</ul>\n</li>\n<li><strong>可伸缩性：</strong><ul>\n<li>可以根据需要增加或减少服务器，以应对不同规模的请求。</li>\n</ul>\n</li>\n</ul>\n<p>客户端-服务器计算模型是一种广泛应用的架构，它在分布式系统、互联网和各种应用程序中发挥着关键作用。</p>\n<h3 id=\"客户端-服务器交互\"><a href=\"#客户端-服务器交互\" class=\"headerlink\" title=\"客户端-服务器交互\"></a>客户端-服务器交互</h3><p>在客户端-服务器模型中，交互通常遵循以下步骤：</p>\n<ol>\n<li><strong>客户端发起请求：</strong><ul>\n<li>客户端通过向服务器发送请求消息来开始交互。请求消息通常包含客户端需要的服务或资源的详细信息。</li>\n</ul>\n</li>\n<li><strong>服务器响应：</strong><ul>\n<li>服务器接收到客户端的请求后，会进行相应的处理，并向客户端发送响应消息。响应消息包含请求的结果、所请求的资源，或其他必要的信息。</li>\n</ul>\n</li>\n<li><strong>客户端处理响应：</strong><ul>\n<li>客户端接收到服务器的响应后，会根据响应中的信息进行相应的处理。这可能包括显示内容、执行操作，或者触发其他交互。</li>\n</ul>\n</li>\n</ol>\n<p><strong>Web浏览器中的示例：</strong></p>\n<ul>\n<li>当你从远程站点打开网页时，可以通过查看浏览器的状态栏了解客户端-服务器交互的情况。</li>\n</ul>\n<p><strong>状态栏显示：</strong></p>\n<ul>\n<li>在浏览器的状态栏中，你可以看到加载网页的过程，其中可能包括以下信息：<ul>\n<li><strong>连接建立：</strong> 浏览器与服务器建立连接的过程。</li>\n<li><strong>请求发送：</strong> 浏览器向服务器发送请求的阶段。</li>\n<li><strong>响应接收：</strong> 浏览器接收服务器的响应的阶段。</li>\n<li><strong>加载完成：</strong> 网页加载完成，可以查看或与之交互。</li>\n</ul>\n</li>\n</ul>\n<p>通过观察这些状态，你可以了解客户端与服务器之间的交互过程，以及网页加载的不同阶段。这种交互模型是许多网络应用程序背后的基础，例如Web浏览器、电子邮件客户端等。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/Client-Server.png\" alt=\"client server\"></p>\n<p>在这个示例中，我们模拟了一个完整的客户端-服务器交互过程，包括前端和后端的角色，以及与数据库的交互。下面是每个步骤的详细说明：</p>\n<ol>\n<li><strong>打开浏览器：</strong><ul>\n<li>客户端打开浏览器，访问网页。</li>\n</ul>\n</li>\n<li><strong>请求前端资源：</strong><ul>\n<li>浏览器向服务器请求前端资源，如<code>index.html</code>、<code>script.js</code>、<code>style.css</code>等。</li>\n</ul>\n</li>\n<li><strong>请求后端数据：</strong><ul>\n<li>前端在加载完成后，向后端发送请求，请求后端数据。这可能是通过AJAX请求或其他方式。</li>\n</ul>\n</li>\n<li><strong>查询数据库：</strong><ul>\n<li>后端接收到请求后，执行数据库查询操作，例如从数据库中选择所有数据。</li>\n</ul>\n</li>\n<li><strong>返回数据库数据：</strong><ul>\n<li>数据库返回查询结果给后端。</li>\n</ul>\n</li>\n<li><strong>返回后端数据：</strong><ul>\n<li>后端将从数据库获取的数据封装在响应中，返回给前端。</li>\n</ul>\n</li>\n<li><strong>返回前端资源和数据：</strong><ul>\n<li>前端收到后端响应后，同时也获取到了请求的前端资源和后端数据。</li>\n</ul>\n</li>\n<li><strong>渲染网页：</strong><ul>\n<li>浏览器使用获取到的前端资源和后端数据，渲染最终的网页。</li>\n</ul>\n</li>\n</ol>\n","text":"操作系统（Operating Systems）什么是操作系统？操作系统（Operating System，简称OS）是管理计算机硬件和软件资源的系统软件。它提供了一个用户和计算机硬件之间的接口，使得应用程序可以运行并与计算机硬件交互。 操作系统的发展流程发展流程 OS/360 f...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"CPT101复习","slug":"CPT101复习","count":7,"path":"api/tags/CPT101复习.json"},{"name":"笔记","slug":"笔记","count":35,"path":"api/tags/笔记.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88Operating-Systems%EF%BC%89\"><span class=\"toc-text\">操作系统（Operating Systems）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9F\"><span class=\"toc-text\">什么是操作系统？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">操作系统的发展流程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%91%E5%B1%95%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">发展流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AA%97%E5%8F%A3%E7%95%8C%E9%9D%A2\"><span class=\"toc-text\">窗口界面</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%A6%81%E5%90%8D%E8%AF%8D%E5%92%8C%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D\"><span class=\"toc-text\">重要名词和英语单词</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">操作系统的功能</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%88%B7%E5%91%BD%E4%BB%A4%E7%9A%84%E8%A7%A3%E9%87%8A%E5%92%8C%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">用户命令的解释和执行</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%91%BD%E4%BB%A4%E7%9A%84%E8%A7%A3%E9%87%8A%E5%92%8C%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">应用程序命令的解释和执行</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%9B%AE%E7%9A%84\"><span class=\"toc-text\">操作系统的目的</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E7%9B%AE%E7%9A%84\"><span class=\"toc-text\">基本目的</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">管理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8F%90%E4%BE%9B%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">提供功能</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B4%8B%E8%91%B1%E7%8E%AF%E6%A8%A1%E5%9E%8B%EF%BC%88Onion-Ring-Model%EF%BC%89\"><span class=\"toc-text\">洋葱环模型（Onion Ring Model）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%AE%E7%9A%84%E7%9A%84%E6%B4%8B%E8%91%B1%E7%8E%AF%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">实现操作系统目的的洋葱环模型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B8%AA%E5%B1%82%E6%AC%A1%EF%BC%9F\"><span class=\"toc-text\">为什么需要多个层次？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B4%8B%E8%91%B1%E7%8E%AF%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">洋葱环模型的层次结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E9%97%A8%E5%8D%AB%EF%BC%88Gatekeeper%EF%BC%89\"><span class=\"toc-text\">操作系统作为计算机的门卫（Gatekeeper）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%AE%A1%E5%AE%B6%EF%BC%88Butler%EF%BC%89\"><span class=\"toc-text\">操作系统作为计算机的管家（Butler）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%BC%E5%90%88%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">操作系统的综合作用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%EF%BC%9A%E7%9B%B4%E6%8E%A5%E5%A4%84%E7%90%86%E7%A1%AC%E4%BB%B6\"><span class=\"toc-text\">操作系统核心：直接处理硬件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2%EF%BC%88CLI%EF%BC%89%EF%BC%9A%E4%B8%BA%E7%94%A8%E6%88%B7%E6%8F%90%E4%BE%9B%E7%B3%BB%E7%BB%9F%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7\"><span class=\"toc-text\">命令行界面（CLI）：为用户提供系统可访问性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B4%8B%E8%91%B1%E7%8E%AF%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%86%8D%E6%80%9D%E8%80%83\"><span class=\"toc-text\">洋葱环模型的层次结构再思考</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">现代操作系统</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">并行处理多个程序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">并行和分时系统的效率对比</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BA%A4%E4%BA%92\"><span class=\"toc-text\">与操作系统的交互</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E9%87%8A%E5%99%A8%EF%BC%88CLI%EF%BC%89\"><span class=\"toc-text\">命令行解释器（CLI）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E5%86%85%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%EF%BC%88API%EF%BC%89\"><span class=\"toc-text\">用户程序内的函数调用（API）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F%E7%9A%84%E9%80%89%E6%8B%A9\"><span class=\"toc-text\">交互方式的选择</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%88%B7%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BA%A4%E4%BA%92%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">用户与操作系统的交互示例</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">示例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%A6%E4%B8%80%E4%B8%AALinux%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">另一个Linux示例</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7\"><span class=\"toc-text\">操作系统操作的复杂性</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C\"><span class=\"toc-text\">计算机网络</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%BD%B1%E5%93%8D\"><span class=\"toc-text\">计算机网络的影响</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9F\"><span class=\"toc-text\">为什么要使用计算机网络？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">客户端-服务端计算</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">介绍</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BA%A4%E4%BA%92\"><span class=\"toc-text\">客户端-服务器交互</span></a></li></ol></li></ol></li></ol>","author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}},"mapped":true,"prev_post":{"title":"CPT101 Review-7","uid":"9f40b949505ca9d69d0cd0fe93485a8a","slug":"CPT101-Review-7","date":"2024-01-07T06:15:23.000Z","updated":"2024-01-07T08:14:30.934Z","comments":true,"path":"api/articles/CPT101-Review-7.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/CPT101-img.png","text":"冯·诺依曼模型冯·诺依曼模型（Von Neumann architecture）是计算机体系结构的一种基本设计范式，由匈牙利数学家和计算机科学家约翰·冯·诺依曼（John von Neumann）于20世纪40年代提出。这个模型成为了现代计算机体系结构的基础，几乎所有的通用计算机...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"CPT101复习","slug":"CPT101复习","count":7,"path":"api/tags/CPT101复习.json"},{"name":"笔记","slug":"笔记","count":35,"path":"api/tags/笔记.json"}],"author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}},"feature":true},"next_post":{"title":"Crash Course For CPT107-3","uid":"a352c287ad7a743761ffe31d8c5cee8c","slug":"Crash-Course-For-CPT107-3","date":"2023-12-29T09:00:46.000Z","updated":"2023-12-29T11:30:38.806Z","comments":true,"path":"api/articles/Crash-Course-For-CPT107-3.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/CPT107-img.png","text":"高中都学过简单逻辑吧，这里跟那一套一模一样，然后多背一点东西，做题嘎嘎顺。 各种符号 逻辑连接词（Logical Connectives）： 合取（Conjunction）： ∧ 解释：表示逻辑与（AND），当且仅当所有连接的命题都为真时，合取命题为真。 析取（Disjuncti...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":35,"path":"api/tags/笔记.json"},{"name":"CPT107","slug":"CPT107","count":3,"path":"api/tags/CPT107.json"}],"author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}}}}