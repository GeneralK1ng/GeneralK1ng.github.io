{"title":"MySQL Review-7","uid":"dc1ef9ee097f4e4c28b3dcd1a91e91c5","slug":"MySQL-Review-7","date":"2023-12-06T08:42:20.000Z","updated":"2023-12-06T09:53:31.268Z","comments":true,"path":"api/articles/MySQL-Review-7.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/MySQL-image.png","content":"<p>继续继续。。。</p>\n<h1 id=\"GROUP-BY\"><a href=\"#GROUP-BY\" class=\"headerlink\" title=\"GROUP BY\"></a><code>GROUP BY</code></h1><p><code>GROUP BY</code> 是 MySQL 中用于对查询结果进行分组的子句。它通常与聚合函数（如 <code>SUM</code>、<code>COUNT</code>、<code>AVG</code> 等）一起使用，以便对每个组应用聚合操作。使用 <code>GROUP BY</code> 可以将结果集按照一个或多个列的值分成不同的组。</p>\n<p>基本的 <code>GROUP BY</code> 语法如下：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT column1, column2, ..., aggregate_function(column)\nFROM table\nWHERE condition\nGROUP BY column1, column2, ...;</code></pre>\n\n<ul>\n<li><code>column1, column2, ...</code>: 要检索的列的名称。</li>\n<li><code>aggregate_function(column)</code>: 对每个组应用的聚合函数，可以是 <code>SUM</code>、<code>COUNT</code>、<code>AVG</code> 等。</li>\n<li><code>table</code>: 要查询的表的名称。</li>\n<li><code>WHERE condition</code>: 可选的筛选条件。</li>\n<li><code>GROUP BY column1, column2, ...</code>: 指定按哪些列进行分组。</li>\n</ul>\n<p>以下是一些使用 <code>GROUP BY</code> 的示例：</p>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><h3 id=\"1-按单个列分组：\"><a href=\"#1-按单个列分组：\" class=\"headerlink\" title=\"1. 按单个列分组：\"></a>1. 按单个列分组：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 按部门分组，并计算每个部门的平均工资\nSELECT department_id, AVG(salary) AS avg_salary\nFROM employees\nGROUP BY department_id;</code></pre>\n\n<h3 id=\"2-按多个列分组：\"><a href=\"#2-按多个列分组：\" class=\"headerlink\" title=\"2. 按多个列分组：\"></a>2. 按多个列分组：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 按部门和性别分组，并计算每个组的员工数量\nSELECT department_id, gender, COUNT(*) AS employee_count\nFROM employees\nGROUP BY department_id, gender;</code></pre>\n\n<h3 id=\"3-使用聚合函数：\"><a href=\"#3-使用聚合函数：\" class=\"headerlink\" title=\"3. 使用聚合函数：\"></a>3. 使用聚合函数：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 按部门分组，并计算每个部门的员工数量和总工资\nSELECT department_id, COUNT(*) AS employee_count, SUM(salary) AS total_salary\nFROM employees\nGROUP BY department_id;</code></pre>\n\n<h3 id=\"4-结合-HAVING-子句：\"><a href=\"#4-结合-HAVING-子句：\" class=\"headerlink\" title=\"4. 结合 HAVING 子句：\"></a>4. 结合 <code>HAVING</code> 子句：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 按部门分组，并筛选出平均工资超过 50000 的部门\nSELECT department_id, AVG(salary) AS avg_salary\nFROM employees\nGROUP BY department_id\nHAVING avg_salary &gt; 50000;</code></pre>\n\n<h3 id=\"5-使用表达式进行分组：\"><a href=\"#5-使用表达式进行分组：\" class=\"headerlink\" title=\"5. 使用表达式进行分组：\"></a>5. 使用表达式进行分组：</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 按出生年份分组，并计算每个年份的员工数量\nSELECT YEAR(birthdate) AS birth_year, COUNT(*) AS employee_count\nFROM employees\nGROUP BY birth_year;</code></pre>\n\n<h2 id=\"Having\"><a href=\"#Having\" class=\"headerlink\" title=\"Having\"></a><code>Having</code></h2><p><code>HAVING</code> 关键字在 SQL 中用于过滤聚合函数的结果。它通常与 <code>GROUP BY</code> 子句一起使用，用于筛选分组后的结果。<code>HAVING</code> 在过滤分组数据时起到与 <code>WHERE</code> 类似的作用，但 <code>HAVING</code> 主要用于聚合函数的筛选。</p>\n<p>基本的语法结构如下：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT column1, column2, aggregate_function(column3)\nFROM table_name\nGROUP BY column1, column2\nHAVING condition;</code></pre>\n\n<ul>\n<li><code>column1, column2</code>: 要检索的列的名称，可以是一个或多个列。</li>\n<li><code>aggregate_function(column3)</code>: 对某一列进行聚合函数操作，例如 <code>SUM</code>、<code>COUNT</code>、<code>AVG</code> 等。</li>\n<li><code>table_name</code>: 要检索数据的表的名称。</li>\n<li><code>GROUP BY column1, column2</code>: 用于指定分组的列。</li>\n<li><code>condition</code>: 用于筛选分组数据的条件。</li>\n</ul>\n<p>以下是一些 <code>HAVING</code> 关键字的使用示例：</p>\n<h3 id=\"用法-1\"><a href=\"#用法-1\" class=\"headerlink\" title=\"用法\"></a>用法</h3><h4 id=\"1-使用-HAVING-过滤聚合结果：\"><a href=\"#1-使用-HAVING-过滤聚合结果：\" class=\"headerlink\" title=\"1. 使用 HAVING 过滤聚合结果：\"></a>1. 使用 <code>HAVING</code> 过滤聚合结果：</h4><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT department, AVG(salary) as avg_salary\nFROM employees\nGROUP BY department\nHAVING AVG(salary) &gt; 50000;</code></pre>\n\n<p>上述查询将返回每个部门的平均工资，但只包括那些平均工资超过 50000 的部门。</p>\n<h4 id=\"2-结合-COUNT-和-HAVING：\"><a href=\"#2-结合-COUNT-和-HAVING：\" class=\"headerlink\" title=\"2. 结合 COUNT 和 HAVING：\"></a>2. 结合 <code>COUNT</code> 和 <code>HAVING</code>：</h4><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT department, COUNT(employee_id) as employee_count\nFROM employees\nGROUP BY department\nHAVING COUNT(employee_id) &gt; 10;</code></pre>\n\n<p>上述查询将返回每个部门的员工数量，但只包括那些员工数量超过 10 人的部门。</p>\n<h4 id=\"3-使用-SUM-和-HAVING：\"><a href=\"#3-使用-SUM-和-HAVING：\" class=\"headerlink\" title=\"3. 使用 SUM 和 HAVING：\"></a>3. 使用 <code>SUM</code> 和 <code>HAVING</code>：</h4><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT product_id, SUM(quantity) as total_quantity\nFROM order_details\nGROUP BY product_id\nHAVING SUM(quantity) &gt; 1000;</code></pre>\n\n<p>上述查询将返回每个产品的总销售数量，但只包括那些总销售数量超过 1000 的产品。</p>\n<h4 id=\"4-结合-GROUP-BY-和-HAVING：\"><a href=\"#4-结合-GROUP-BY-和-HAVING：\" class=\"headerlink\" title=\"4. 结合 GROUP BY 和 HAVING：\"></a>4. 结合 <code>GROUP BY</code> 和 <code>HAVING</code>：</h4><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT department, AVG(salary) as avg_salary\nFROM employees\nWHERE hire_date &gt; '2022-01-01'\nGROUP BY department\nHAVING AVG(salary) &gt; 50000;</code></pre>\n\n<p>在这个例子中，<code>WHERE</code> 子句用于在分组之前过滤数据，而 <code>HAVING</code> 子句用于筛选符合条件的分组。</p>\n<h2 id=\"实操\"><a href=\"#实操\" class=\"headerlink\" title=\"实操\"></a>实操</h2><p>假设我们有一个 <code>orders</code> 表，其中包含订单的信息，如下：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 创建 orders 表\nCREATE TABLE orders (\n    order_id INT PRIMARY KEY,\n    customer_id INT,\n    order_date DATE,\n    total_amount DECIMAL(10, 2)\n);\n\n-- 插入一些示例数据\nINSERT INTO orders VALUES (1, 101, '2023-01-10', 150.00);\nINSERT INTO orders VALUES (2, 102, '2023-02-15', 200.50);\nINSERT INTO orders VALUES (3, 101, '2023-02-20', 120.00);\nINSERT INTO orders VALUES (4, 103, '2023-03-05', 350.75);\nINSERT INTO orders VALUES (5, 102, '2023-03-12', 180.25);</code></pre>\n\n<p>现在，我们希望按照 <code>customer_id</code> 分组，并计算每个客户的订单数量和总订单金额。以下是一个使用 <code>GROUP BY</code> 的查询：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 按照 customer_id 分组，并计算每个客户的订单数量和总订单金额\nSELECT customer_id, COUNT(*) AS order_count, SUM(total_amount) AS total_amount\nFROM orders\nGROUP BY customer_id;</code></pre>\n\n<p>在这个查询中，我们使用了 <code>GROUP BY customer_id</code> 将结果按照 <code>customer_id</code> 列分组。然后，我们使用 <code>COUNT(*)</code> 计算每个客户的订单数量，并使用 <code>SUM(total_amount)</code> 计算每个客户的总订单金额。</p>\n<p>结果应该如下所示：</p>\n<table>\n<thead>\n<tr>\n<th>customer_id</th>\n<th>order_count</th>\n<th>total_amount</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>101</td>\n<td>2</td>\n<td>270.00</td>\n</tr>\n<tr>\n<td>102</td>\n<td>2</td>\n<td>380.75</td>\n</tr>\n<tr>\n<td>103</td>\n<td>1</td>\n<td>350.75</td>\n</tr>\n</tbody></table>\n<p>可以清楚的看到，101的顾客下单数为2，并且总共消费了270.00，以此类推，这就是结果。</p>\n<p>然后我们还可以这样：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 按照 customer_id 分组，计算每个客户的订单数量和总订单金额，\n-- 并筛选出订单数量超过 1 个且总订单金额超过 300 的客户\nSELECT customer_id, COUNT(*) AS order_count, SUM(total_amount) AS total_amount\nFROM orders\nGROUP BY customer_id\nHAVING order_count &gt; 1 AND SUM(total_amount) &gt; 300;</code></pre>\n\n<p>就会得到订单数大于一切总消费大于300的顾客：</p>\n<table>\n<thead>\n<tr>\n<th>customer_id</th>\n<th>order_count</th>\n<th>total_amount</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>102</td>\n<td>2</td>\n<td>380.75</td>\n</tr>\n</tbody></table>\n<h1 id=\"聚合函数\"><a href=\"#聚合函数\" class=\"headerlink\" title=\"聚合函数\"></a>聚合函数</h1><p>终于到达这一部分，怎么说呢，这一部分都很简单，都封装好了，你直接调用就可以了。</p>\n<h3 id=\"1-COUNT\"><a href=\"#1-COUNT\" class=\"headerlink\" title=\"1. COUNT()\"></a>1. <strong>COUNT()</strong></h3><p>用于计算行的数量。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 计算 employees 表中的总行数\nSELECT COUNT(*) FROM employees;</code></pre>\n\n<h3 id=\"2-SUM\"><a href=\"#2-SUM\" class=\"headerlink\" title=\"2. SUM()\"></a>2. <strong>SUM()</strong></h3><p>用于计算数值列的总和。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 计算 employees 表中工资的总和\nSELECT SUM(salary) FROM employees;</code></pre>\n\n<h3 id=\"3-AVG\"><a href=\"#3-AVG\" class=\"headerlink\" title=\"3. AVG()\"></a>3. <strong>AVG()</strong></h3><p>用于计算数值列的平均值。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 计算 employees 表中工资的平均值\nSELECT AVG(salary) FROM employees;</code></pre>\n\n<h3 id=\"4-MIN\"><a href=\"#4-MIN\" class=\"headerlink\" title=\"4. MIN()\"></a>4. <strong>MIN()</strong></h3><p>用于找出数值列中的最小值。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 找出 employees 表中最低的工资\nSELECT MIN(salary) FROM employees;</code></pre>\n\n<h3 id=\"5-MAX\"><a href=\"#5-MAX\" class=\"headerlink\" title=\"5. MAX()\"></a>5. <strong>MAX()</strong></h3><p>用于找出数值列中的最大值。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 找出 employees 表中最高的工资\nSELECT MAX(salary) FROM employees;</code></pre>\n\n<h3 id=\"6-GROUP-CONCAT\"><a href=\"#6-GROUP-CONCAT\" class=\"headerlink\" title=\"6. GROUP_CONCAT()\"></a>6. <strong>GROUP_CONCAT()</strong></h3><p>用于将组内的值连接成一个字符串。通常与<code>GROUP BY</code>一起使用。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 将每个部门的员工姓名连接成字符串\nSELECT department_id, GROUP_CONCAT(first_name) AS employee_names\nFROM employees\nGROUP BY department_id;</code></pre>\n\n<h3 id=\"7-GROUP-CONCAT-with-ORDER-BY\"><a href=\"#7-GROUP-CONCAT-with-ORDER-BY\" class=\"headerlink\" title=\"7. GROUP_CONCAT() with ORDER BY\"></a>7. <strong>GROUP_CONCAT() with ORDER BY</strong></h3><p><code>GROUP_CONCAT()</code> 还可以结合 <code>ORDER BY</code> 子句，对连接的结果进行排序。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 将每个部门的员工姓名连接成按照姓名升序排序的字符串\nSELECT department_id, GROUP_CONCAT(first_name ORDER BY first_name ASC) AS employee_names\nFROM employees\nGROUP BY department_id;</code></pre>\n\n<h3 id=\"8-GROUP-CONCAT-with-DISTINCT\"><a href=\"#8-GROUP-CONCAT-with-DISTINCT\" class=\"headerlink\" title=\"8. GROUP_CONCAT() with DISTINCT\"></a>8. <strong>GROUP_CONCAT() with DISTINCT</strong></h3><p><code>GROUP_CONCAT()</code> 可以与 <code>DISTINCT</code> 一起使用，以确保连接的结果中不包含重复的值。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 将每个部门的不重复员工姓名连接成字符串\nSELECT department_id, GROUP_CONCAT(DISTINCT first_name) AS employee_names\nFROM employees\nGROUP BY department_id;</code></pre>\n\n<h3 id=\"9-IFNULL-COALESCE\"><a href=\"#9-IFNULL-COALESCE\" class=\"headerlink\" title=\"9. IFNULL() / COALESCE()\"></a>9. <strong>IFNULL() / COALESCE()</strong></h3><p>用于返回第一个非 NULL 的表达式。<code>IFNULL()</code> 是 MySQL 特有的，而 <code>COALESCE()</code> 是标准 SQL 的函数，两者在大多数情况下是等效的。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 返回工资列，如果为 NULL，则返回 0\nSELECT IFNULL(salary, 0) FROM employees;\n\n-- 或者使用 COALESCE\nSELECT COALESCE(salary, 0) FROM employees;</code></pre>\n\n<h3 id=\"10-CONCAT\"><a href=\"#10-CONCAT\" class=\"headerlink\" title=\"10. CONCAT()\"></a>10. <strong>CONCAT()</strong></h3><p>用于将两个或多个字符串连接在一起。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 连接 first_name 和 last_name 列\nSELECT CONCAT(first_name, ' ', last_name) AS full_name FROM employees;</code></pre>\n\n<h3 id=\"11-SUBSTRING\"><a href=\"#11-SUBSTRING\" class=\"headerlink\" title=\"11. SUBSTRING()\"></a>11. <strong>SUBSTRING()</strong></h3><p>用于提取字符串的子串。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 提取 first_name 列的前三个字符\nSELECT SUBSTRING(first_name, 1, 3) AS short_name FROM employees;</code></pre>\n\n<h3 id=\"12-DATE-FORMAT\"><a href=\"#12-DATE-FORMAT\" class=\"headerlink\" title=\"12. DATE_FORMAT()\"></a>12. <strong>DATE_FORMAT()</strong></h3><p>用于将日期格式化为指定的字符串。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 格式化 order_date 列为 '年-月-日' 形式\nSELECT DATE_FORMAT(order_date, '%Y-%m-%d') AS formatted_date FROM orders;</code></pre>\n\n<h3 id=\"13-RAND\"><a href=\"#13-RAND\" class=\"headerlink\" title=\"13. RAND()\"></a>13. <strong>RAND()</strong></h3><p>用于生成一个介于 0 和 1 之间的随机数。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 生成一个随机数\nSELECT RAND() AS random_number;</code></pre>\n\n<h3 id=\"14-ROUND\"><a href=\"#14-ROUND\" class=\"headerlink\" title=\"14. ROUND()\"></a>14. <strong>ROUND()</strong></h3><p>用于将数值四舍五入到指定的小数位数。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 将 salary 列四舍五入到两位小数\nSELECT ROUND(salary, 2) AS rounded_salary FROM employees;</code></pre>\n\n<h3 id=\"15-UPPER-LOWER\"><a href=\"#15-UPPER-LOWER\" class=\"headerlink\" title=\"15. UPPER() / LOWER()\"></a>15. <strong>UPPER() / LOWER()</strong></h3><p>用于将字符串转换为大写或小写。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 将 first_name 列转换为大写\nSELECT UPPER(first_name) AS upper_name FROM employees;\n\n-- 将 last_name 列转换为小写\nSELECT LOWER(last_name) AS lower_name FROM employees;</code></pre>\n\n<h3 id=\"16-TRIM\"><a href=\"#16-TRIM\" class=\"headerlink\" title=\"16. TRIM()\"></a>16. <strong>TRIM()</strong></h3><p>用于去除字符串两端的空格或指定字符。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 去除 description 列两端的空格\nSELECT TRIM(description) AS trimmed_description FROM products;</code></pre>\n\n<h3 id=\"17-LENGTH-CHAR-LENGTH\"><a href=\"#17-LENGTH-CHAR-LENGTH\" class=\"headerlink\" title=\"17. LENGTH() / CHAR_LENGTH()\"></a>17. <strong>LENGTH() / CHAR_LENGTH()</strong></h3><p>用于返回字符串的字符数或字节数。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 返回 first_name 列的字符数\nSELECT LENGTH(first_name) AS name_length FROM employees;\n\n-- 或者使用 CHAR_LENGTH\nSELECT CHAR_LENGTH(first_name) AS name_length FROM employees;</code></pre>\n\n<h3 id=\"18-DATEDIFF\"><a href=\"#18-DATEDIFF\" class=\"headerlink\" title=\"18. DATEDIFF()\"></a>18. <strong>DATEDIFF()</strong></h3><p>用于计算两个日期之间的天数差。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 计算订单的创建日期和现在之间的天数差\nSELECT DATEDIFF(NOW(), order_date) AS days_since_order FROM orders;</code></pre>\n\n<h3 id=\"19-IF-CASE-WHEN\"><a href=\"#19-IF-CASE-WHEN\" class=\"headerlink\" title=\"19. IF() / CASE WHEN\"></a>19. <strong>IF() / CASE WHEN</strong></h3><p>用于条件判断。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 如果 salary 大于 50000，则返回 'High'，否则返回 'Low'\nSELECT employee_id, first_name, last_name, \n       IF(salary &gt; 50000, 'High', 'Low') AS salary_status\nFROM employees;</code></pre>\n\n<p>或者使用 <code>CASE WHEN</code>：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT employee_id, first_name, last_name,\n       CASE WHEN salary &gt; 50000 THEN 'High' ELSE 'Low' END AS salary_status\nFROM employees;</code></pre>\n\n<h3 id=\"20-COUNT-DISTINCT-column\"><a href=\"#20-COUNT-DISTINCT-column\" class=\"headerlink\" title=\"20. COUNT(DISTINCT column)\"></a>20. <strong>COU</strong>NT(DISTINCT column)</h3><p>用于计算唯一值的数量。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 计算 employees 表中不同部门的数量\nSELECT COUNT(DISTINCT department_id) AS distinct_departments FROM employees;</code></pre>\n\n<h3 id=\"21-IN\"><a href=\"#21-IN\" class=\"headerlink\" title=\"21. IN()\"></a>21. <strong>IN()</strong></h3><p>用于判断某个值是否在一个集合中。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 查询订单中客户ID为101、102、103的订单\nSELECT * FROM orders WHERE customer_id IN (101, 102, 103);</code></pre>\n\n<h3 id=\"22-CONVERT-CAST\"><a href=\"#22-CONVERT-CAST\" class=\"headerlink\" title=\"22. CONVERT() / CAST()\"></a>22. <strong>CONVERT() / CAST()</strong></h3><p>用于将一个类型的值转换为另一个类型。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 将字符串 '123' 转换为整数类型\nSELECT CONVERT('123', SIGNED) AS converted_value;</code></pre>\n\n<p>或者使用 <code>CAST()</code>：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT CAST('123' AS SIGNED) AS casted_value;</code></pre>\n\n<h3 id=\"23-LOCATE\"><a href=\"#23-LOCATE\" class=\"headerlink\" title=\"23. LOCATE()\"></a>23. LOCATE()</h3><p>查找子字符串在给定字符串中的位置。它返回子字符串在字符串中的起始位置，如果找不到则返回 0。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 返回 'is' 在 'This is a sample string' 中的位置\nSELECT LOCATE('is', 'This is a sample string') AS position;\n\n-- 从第 6 个字符开始，在 'This is a sample string' 中查找 'is'\nSELECT LOCATE('is', 'This is a sample string', 6) AS position;\n\n-- 如果 'apple' 存在于 'This is an apple' 中，返回子字符串的位置，否则返回 0\nSELECT IF(LOCATE('apple', 'This is an apple'), LOCATE('apple', 'This is an apple'), 'Not found') AS position;</code></pre>\n\n\n\n\n\n\n\n\n\n\n\n","feature":true,"text":"继续继续。。。 GROUP BYGROUP BY 是 MySQL 中用于对查询结果进行分组的子句。它通常与聚合函数（如 SUM、COUNT、AVG 等）一起使用，以便对每个组应用聚合操作。使用 GROUP BY 可以将结果集按照一个或多个列的值分成不同的组。 基本的 GROUP ...","link":"","photos":[],"count_time":{"symbolsCount":"7.5k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":37,"path":"api/tags/笔记.json"},{"name":"MySQL复习","slug":"MySQL复习","count":7,"path":"api/tags/MySQL复习.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#GROUP-BY\"><span class=\"toc-text\">GROUP BY</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">用法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%8C%89%E5%8D%95%E4%B8%AA%E5%88%97%E5%88%86%E7%BB%84%EF%BC%9A\"><span class=\"toc-text\">1. 按单个列分组：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%8C%89%E5%A4%9A%E4%B8%AA%E5%88%97%E5%88%86%E7%BB%84%EF%BC%9A\"><span class=\"toc-text\">2. 按多个列分组：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BD%BF%E7%94%A8%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%EF%BC%9A\"><span class=\"toc-text\">3. 使用聚合函数：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E7%BB%93%E5%90%88-HAVING-%E5%AD%90%E5%8F%A5%EF%BC%9A\"><span class=\"toc-text\">4. 结合 HAVING 子句：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E4%BD%BF%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%88%86%E7%BB%84%EF%BC%9A\"><span class=\"toc-text\">5. 使用表达式进行分组：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Having\"><span class=\"toc-text\">Having</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%B3%95-1\"><span class=\"toc-text\">用法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%BD%BF%E7%94%A8-HAVING-%E8%BF%87%E6%BB%A4%E8%81%9A%E5%90%88%E7%BB%93%E6%9E%9C%EF%BC%9A\"><span class=\"toc-text\">1. 使用 HAVING 过滤聚合结果：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E7%BB%93%E5%90%88-COUNT-%E5%92%8C-HAVING%EF%BC%9A\"><span class=\"toc-text\">2. 结合 COUNT 和 HAVING：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E4%BD%BF%E7%94%A8-SUM-%E5%92%8C-HAVING%EF%BC%9A\"><span class=\"toc-text\">3. 使用 SUM 和 HAVING：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E7%BB%93%E5%90%88-GROUP-BY-%E5%92%8C-HAVING%EF%BC%9A\"><span class=\"toc-text\">4. 结合 GROUP BY 和 HAVING：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E6%93%8D\"><span class=\"toc-text\">实操</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">聚合函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-COUNT\"><span class=\"toc-text\">1. COUNT()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-SUM\"><span class=\"toc-text\">2. SUM()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-AVG\"><span class=\"toc-text\">3. AVG()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-MIN\"><span class=\"toc-text\">4. MIN()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-MAX\"><span class=\"toc-text\">5. MAX()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-GROUP-CONCAT\"><span class=\"toc-text\">6. GROUP_CONCAT()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-GROUP-CONCAT-with-ORDER-BY\"><span class=\"toc-text\">7. GROUP_CONCAT() with ORDER BY</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-GROUP-CONCAT-with-DISTINCT\"><span class=\"toc-text\">8. GROUP_CONCAT() with DISTINCT</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-IFNULL-COALESCE\"><span class=\"toc-text\">9. IFNULL() &#x2F; COALESCE()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-CONCAT\"><span class=\"toc-text\">10. CONCAT()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-SUBSTRING\"><span class=\"toc-text\">11. SUBSTRING()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#12-DATE-FORMAT\"><span class=\"toc-text\">12. DATE_FORMAT()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-RAND\"><span class=\"toc-text\">13. RAND()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-ROUND\"><span class=\"toc-text\">14. ROUND()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-UPPER-LOWER\"><span class=\"toc-text\">15. UPPER() &#x2F; LOWER()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-TRIM\"><span class=\"toc-text\">16. TRIM()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#17-LENGTH-CHAR-LENGTH\"><span class=\"toc-text\">17. LENGTH() &#x2F; CHAR_LENGTH()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#18-DATEDIFF\"><span class=\"toc-text\">18. DATEDIFF()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#19-IF-CASE-WHEN\"><span class=\"toc-text\">19. IF() &#x2F; CASE WHEN</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#20-COUNT-DISTINCT-column\"><span class=\"toc-text\">20. COUNT(DISTINCT column)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#21-IN\"><span class=\"toc-text\">21. IN()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#22-CONVERT-CAST\"><span class=\"toc-text\">22. CONVERT() &#x2F; CAST()</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#23-LOCATE\"><span class=\"toc-text\">23. LOCATE()</span></a></li></ol></li></ol></li></ol>","author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"MySQL Review-6","uid":"5248bd149e90c578d377990ba1015e7f","slug":"MySQL-Review-6","date":"2023-12-06T07:14:37.000Z","updated":"2023-12-06T09:51:51.198Z","comments":true,"path":"api/articles/MySQL-Review-6.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/MySQL-image.png","text":"这一节来讲关系非常复杂的JOIN，有各种JOIN，一个一个看。 JOIN开始前放一个关系图，来自runoob ok，这就是我们要学的各种复杂的关系。 INNER JOININNER JOIN 是 MySQL 中用于连接两个或多个表的一种常见的连接类型。它根据两个表之间的共同列的匹...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":37,"path":"api/tags/笔记.json"},{"name":"MySQL复习","slug":"MySQL复习","count":7,"path":"api/tags/MySQL复习.json"}],"author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}},"feature":true}}