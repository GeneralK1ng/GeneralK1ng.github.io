{"title":"CPT101 Review-3","uid":"6ab5e8bf78dcc1c37aef3c4bb9344969","slug":"CPT101-Review-3","date":"2023-12-10T10:39:50.000Z","updated":"2023-12-11T10:48:44.313Z","comments":true,"path":"api/articles/CPT101-Review-3.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/CPT101-img.png","content":"<p>继续复习下一章，总感觉每节课讲的东西相似性都好高。</p>\n<h1 id=\"机器指令和高级语言\"><a href=\"#机器指令和高级语言\" class=\"headerlink\" title=\"机器指令和高级语言\"></a>机器指令和高级语言</h1><p>不是，之前都讲过了为什么还有。</p>\n<ol>\n<li><strong>机器指令（Machine Instructions）</strong>：<ul>\n<li><strong>定义</strong>：机器指令是计算机硬件可以直接执行的基本操作。每一条机器指令对应于一个特定的操作，如加法、乘法、加载数据等。计算机的中央处理单元（CPU）能够理解和执行这些指令。</li>\n<li><strong>指令集体系结构（Instruction Set Architecture，ISA）</strong>：ISA 定义了计算机体系结构的底层接口，包括机器指令的种类、格式以及它们的操作码。ISA 是硬件和软件之间的桥梁，确保软件能够正确地与硬件交互。</li>\n<li><strong>机器指令的执行过程</strong>：计算机通过从内存中读取指令，解码指令，执行指令，然后更新状态来执行程序。机器指令直接操作计算机硬件，因此它们对应的是底层的硬件操作。</li>\n</ul>\n</li>\n<li><strong>高级语言（High-Level Language，HLL）</strong>：<ul>\n<li><strong>定义</strong>：高级语言是一种更接近人类语言的编程语言，例如C、Java、Python等。它们通过抽象化，提供了更高层次的抽象，使程序员能够更容易地表达算法和逻辑。</li>\n<li><strong>编译和解释</strong>：HLL 代码需要通过编译器或解释器转换为机器代码才能在计算机上执行。编译器将整个源代码文件转换为目标机器代码，而解释器逐行解释执行源代码。</li>\n<li><strong>优势</strong>：HLL 提高了程序员的生产力，使得编写和维护程序更加容易。程序员可以更专注于问题的逻辑结构，而不必过于关注底层的硬件细节。</li>\n<li><strong>劣势</strong>：相对于直接使用机器指令编写的程序，HLL 代码可能会在性能上有所损失。这是因为编译器或解释器引入了额外的开销，而且有时候难以充分利用底层硬件的特性。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"语义鸿沟\"><a href=\"#语义鸿沟\" class=\"headerlink\" title=\"语义鸿沟\"></a>语义鸿沟</h2><p>“Semantic gap”是一个计算机科学领域的术语，用于描述不同抽象层次之间的理解或表达上的差异。在计算机系统和编程语言中，语义差距通常涉及高级语言（High-Level Language，HLL）和机器指令之间的差异。</p>\n<ol>\n<li><strong>在高级语言和机器指令之间的语义差距</strong>：<ul>\n<li><strong>高级语言层次</strong>：高级语言（如C、Java、Python）提供了更抽象的编程概念，允许程序员使用更自然、更易读的语法来表达算法和逻辑。高级语言屏蔽了底层硬件细节，提供了更高层次的抽象。</li>\n<li><strong>机器指令层次</strong>：机器指令是计算机硬件能够直接执行的低级指令。它们通常包括对寄存器和内存的直接访问，以及基本的算术和逻辑操作。机器指令更接近计算机硬件的实际操作。</li>\n<li><strong>语义差距</strong>：语义差距体现在高级语言和机器指令之间的概念和操作的不同。高级语言的一个语句可能对应多条机器指令，而机器指令的执行可能需要多个高级语言语句。此外，一些高级语言特性（如对象、异常处理）在机器指令层面可能没有直接的对应。</li>\n</ul>\n</li>\n<li><strong>解决语义差距的方法</strong>：<ul>\n<li><strong>编译器和解释器</strong>：编译器负责将高级语言的代码翻译成机器指令，而解释器则逐行地执行高级语言代码。这两者都是为了解决高级语言和机器指令之间的语义差距。</li>\n<li><strong>优化技术</strong>：编译器通常会应用各种优化技术，以尽量减小高级语言和机器指令之间的性能差距。这包括指令调度、寄存器分配、循环展开等技术，以便生成更有效率的机器代码。</li>\n<li><strong>抽象层次的设计</strong>：计算机体系结构的设计需要考虑如何提供足够的抽象，使得高级语言可以方便地映射到底层硬件，同时不牺牲性能。指令集体系结构的设计就是为了在高级语言和机器指令之间提供适当的抽象。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"翻译\"><a href=\"#翻译\" class=\"headerlink\" title=\"翻译\"></a>翻译</h2><p>也就是说，人类说的，就算是这些高级语言直接给机器去看，机器也是看不懂的，那么就需要有一种可以翻译给机器看的工具。</p>\n<ol>\n<li><strong>编译器（Compilers）</strong>：<ul>\n<li><strong>定义</strong>：编译器是一种特殊程序，负责将高级语言（HLL）的源代码翻译成目标机器的机器代码。这个过程被称为编译，生成的目标代码可以在计算机上直接执行。</li>\n<li><strong>翻译过程</strong>：编译器分为多个阶段，包括词法分析、语法分析、语义分析、中间代码生成、优化和目标代码生成等。每个阶段都有特定的任务，最终目的是将高级语言的抽象表示翻译成等效的机器指令。</li>\n<li><strong>优势</strong>：编译的目标代码通常在运行时执行效率较高，因为编译器可以进行全局的优化，产生针对目标平台的高效代码。</li>\n</ul>\n</li>\n<li><strong>汇编器（Assemblers）</strong>：<ul>\n<li><strong>定义</strong>：汇编器是一种翻译程序，负责将汇编语言中的助记符（mnemonics）翻译成对应的二进制机器码。汇编语言是一种低级别的编程语言，更接近机器指令的表示形式。</li>\n<li><strong>翻译过程</strong>：汇编器的任务是将汇编语言源代码中的助记符和操作数转换为机器指令的二进制表示。例如，将<code>MOV</code>（移动数据）或<code>ADD</code>（加法）等指令转换为相应的二进制码。</li>\n<li><strong>优势</strong>：与编译器不同，汇编器生成的目标代码是针对特定的机器体系结构的，因此更加直接和底层。这使得程序员可以更好地控制生成的机器代码。</li>\n</ul>\n</li>\n<li><strong>解释器（Interpreters）</strong>：<ul>\n<li><strong>定义</strong>：解释器是一种程序，能够在运行时逐行解释高级语言代码并将其转换为机器指令。与编译器不同，解释器不生成目标代码文件，而是动态地执行源代码。</li>\n<li><strong>翻译过程</strong>：解释器逐行解释高级语言的源代码，将其翻译成机器指令并立即执行。这个过程是即时的，不需要事先生成目标代码文件。</li>\n<li><strong>优势</strong>：解释器使得程序的修改和调试更加灵活，因为程序员可以在运行时查看和修改代码。然而，由于解释的性质，解释执行通常比编译执行慢一些。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"几种ERROR\"><a href=\"#几种ERROR\" class=\"headerlink\" title=\"几种ERROR\"></a>几种ERROR</h2><ol>\n<li><strong>编译时错误</strong>：<ul>\n<li><strong>定义</strong>：编译时错误是在程序编译阶段发生的错误。这些错误阻止程序从源代码成功地转换为机器代码。</li>\n<li><strong>处理</strong>：当发生编译时错误时，编译器会生成错误消息，指示错误在源代码中的位置和性质。程序员需要查看并修复这些错误，然后才能成功编译程序。</li>\n</ul>\n</li>\n<li><strong>链接：解决外部引用</strong>：<ul>\n<li><strong>定义</strong>：链接是在编译后发生的过程，在这个过程中，链接器组合各个编译的代码模块并解决它们之间的外部引用，创建最终的可执行文件。</li>\n<li><strong>处理</strong>：在链接过程中，链接器解析当前模块中未定义但在其他模块中引用的符号和地址。如果存在未解决的外部引用，链接将失败。程序员需要确保所有必要的模块和库正确链接。</li>\n</ul>\n</li>\n<li><strong>链接时错误</strong>：<ul>\n<li><strong>定义</strong>：链接时错误发生在链接阶段，当链接器遇到未解决的符号或不兼容的模块时。</li>\n<li><strong>处理</strong>：如果发生链接时错误，程序员需要检查链接器提供的错误消息。这些消息通常指示引起问题的符号或引用。需要通过在链接过程中提供缺失或正确的模块或库来解决这些错误。</li>\n</ul>\n</li>\n<li><strong>装载时错误</strong>：<ul>\n<li><strong>定义</strong>：装载时错误发生在可执行文件被加载到内存执行时。这些错误可能包括缺失的动态库或不兼容的可执行文件格式。</li>\n<li><strong>处理</strong>：当发生装载时错误时，操作系统或加载程序会生成错误消息。程序员需要确保所有必需的库可用并且兼容。解决装载时错误可能涉及提供必要的依赖项或以正确的设置重新编译程序。</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/IntegratedSoftwareFlow.png\" alt=\"Integrated Software Flow\"></p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>链接（Linking）是计算机程序开发中的一个重要概念，涉及将由多个源代码文件或模块组成的大型程序的各部分整合在一起，形成可执行文件的过程。这一过程包括解析符号、地址映射和生成最终的可执行文件。以下是链接的主要概念和工作原理：</p>\n<ol>\n<li><strong>大型程序的模块化设计</strong>：<ul>\n<li><strong>原因</strong>：大型程序通常被分解为多个独立的模块或部分，这样做有多个好处。首先，模块化设计提高了代码的可维护性，每个模块可以独立开发和测试。其次，团队可以并行地开发不同的模块，提高了开发效率。最后，模块化设计使得代码更易于理解和重用。</li>\n</ul>\n</li>\n<li><strong>模块之间的引用</strong>：<ul>\n<li><strong>需求</strong>：在大型程序中，一个模块可能需要引用另一个模块中的数据或子程序。这种引用涉及到如何在编译时和链接时处理这些跨模块的引用。</li>\n</ul>\n</li>\n<li><strong>符号解析</strong>：<ul>\n<li><strong>定义</strong>：当一个模块引用另一个模块的数据或函数时，引用的标识符称为符号。在链接阶段，需要解析这些符号，确定它们的确切地址。</li>\n</ul>\n</li>\n<li><strong>地址映射</strong>：<ul>\n<li><strong>定义</strong>：链接器负责将各个模块的地址映射到最终的内存位置。这包括分配内存地址，解决相对地址，确保各个模块之间的地址空间不冲突。</li>\n</ul>\n</li>\n<li><strong>生成可执行文件</strong>：<ul>\n<li><strong>定义</strong>：最终链接的结果是生成一个可执行文件，该文件包含了所有模块的机器代码，并且这些代码已经被正确地组织和映射到内存中。这个可执行文件可以被加载到内存并执行。</li>\n</ul>\n</li>\n<li><strong>静态链接 vs. 动态链接</strong>：<ul>\n<li><strong>静态链接</strong>：在编译时将所有模块的代码和数据都合并到一个单独的可执行文件中。这个文件独立于外部的模块，因此可以在不同的环境中运行。</li>\n<li><strong>动态链接</strong>：在运行时，程序使用动态链接库（DLL）或共享对象文件来链接程序。这样，多个程序可以共享同一份库，减小了可执行文件的大小。</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/LinkingFlow.png\" alt=\"Linking Flow\"></p>\n<p>这个图表包括了编写代码、编译阶段、链接阶段、装载阶段、执行阶段和错误处理，详细展示了链接阶段的符号解析和地址映射过程。</p>\n<ul>\n<li><strong>编译器无法解决模块间引用</strong>：<ul>\n<li><strong>原因</strong>：编译器负责将源代码翻译成二进制代码，但在这个过程中，它无法解决对其他模块的引用。编译器只能将当前模块的源代码翻译成机器代码，对于其他模块的代码或数据的确切位置和内容，编译器是不了解的。</li>\n<li><strong>意义</strong>：这导致了在编译阶段，对其他模块的引用仍然是符号化的，也就是说，它们只是符号或标识符，并没有具体的内存地址或数据。</li>\n</ul>\n</li>\n<li><strong>链接器的作用</strong>：<ul>\n<li><strong>定义</strong>：链接器在整个程序构建过程中发挥了关键作用。它的任务是将编译器生成的各个模块的二进制代码组合在一起，同时解决模块间的外部引用。</li>\n<li><strong>解决外部引用</strong>：链接器通过将模块的符号与其具体的内存地址相连接，解决了这些外部引用。在这一过程中，符号解析将模块中使用的符号映射到其他模块中相应的符号。</li>\n<li><strong>生成可执行文件</strong>：链接器的最终目标是生成一个可以被加载和执行的可执行文件。这个文件包含了所有模块的代码和数据，它们都已经被正确地连接和映射。</li>\n</ul>\n</li>\n<li><strong>外部引用的符号化</strong>：<ul>\n<li><strong>状态</strong>：在链接之前，那些引用其他模块的地方仍然是符号，而不是具体的内存地址。这些外部引用是待解决的符号。</li>\n</ul>\n</li>\n<li><strong>链接器的错误处理</strong>：<ul>\n<li><strong>查找模块或代码</strong>：当链接器在连接过程中找不到被引用的模块或代码时，它将报告错误。这可能是由于模块未被正确编译、模块不存在，或者符号引用的代码或数据未在可用的模块中找到。</li>\n<li><strong>错误报告</strong>：链接器的错误报告通常指示出错的地方和原因，使得程序员能够定位和解决这些问题。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"库文件\"><a href=\"#库文件\" class=\"headerlink\" title=\"库文件\"></a>库文件</h1><p>Library files（库文件）是在计算机科学和软件开发中常见的一种文件类型，它们起到了组织和重用代码的重要作用。Library files 包含了预先编写好的代码、函数、类或数据结构，这些可以被其他程序或模块引用。以下是有关 Library files 的详细解释：</p>\n<p>用最简单的话来说，<strong>库文件就像是一本工具书</strong>。你可以在这本书里找到很多已经写好的方法和函数，比如计算两个数字相加的方法、判断条件的方法等等。这些方法就是工具书里的“章节”或“知识点”。</p>\n<p>有两种主要类型的库文件：</p>\n<ol>\n<li><strong>静态库</strong>：就像你把整本工具书都复印下来，放在你的书包里。这样，当你需要用到书里的方法时，它们就直接在你的程序里，方便使用。但是，这也让你的书包变得有点大。</li>\n<li><strong>动态库</strong>：这次，你只带了一份“使用说明书”（头文件），里面写着怎么使用工具书里的方法。而真正的工具书（库文件）在需要的时候才被拿出来，用完再放回去。这样，书包轻巧了很多，但是使用的时候需要一点点额外的工作。</li>\n</ol>\n<p>在写程序的时候，我们需要告诉计算机去哪里找这些库文件，就像告诉它在哪里找工具书一样。这个过程就是链接阶段，而链接器就像是我们的导航，帮我们把各个部分都连接在一起。</p>\n<p>在Unix系统中，这些库文件通常存放在 <code>/lib</code> 和 <code>/usr/lib</code> 这两个文件夹里，就像把字典放在图书馆一样。而在Windows系统中，这些库文件通常是DLL（动态链接库）文件，就好比把字典分成了几个部分，只在需要的时候拿出来用。</p>\n<p>所以，简单来说，这些库文件就是程序员提前写好的方法书，我们可以在程序中引用它们，但要想真正使用，就得在链接的时候把它们连接到我们的程序里。</p>\n<h1 id=\"解释器\"><a href=\"#解释器\" class=\"headerlink\" title=\"解释器\"></a>解释器</h1><p><img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/interpreterFlow.png\" alt=\"interpreter Flow\"></p>\n<ul>\n<li><strong>逐行解释</strong>：解释器按行读取高级语言代码。</li>\n<li><strong>翻译成低级语言</strong>：解释器将每一行翻译成计算机能执行的低级语言。</li>\n<li><strong>逐行执行</strong>：计算机逐行执行翻译后的低级语言。</li>\n<li><strong>输出结果</strong>：程序执行完毕，输出最终结果。</li>\n</ul>\n<p>在这个流程中，错误可能发生在两个地方：</p>\n<ol>\n<li><strong>语法错误</strong>：当解释器读取高级语言代码时，如果发现了语法错误，就会在翻译这一步骤报告错误。</li>\n<li><strong>运行时错误</strong>：当计算机执行翻译后的低级语言时，如果发现了运行时错误（比如除零错误），就会在执行这一步骤报告错误。</li>\n</ol>\n<h2 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h2><p>可以直接看上面的图，举个例子来说的话：</p>\n<ol>\n<li><strong>高级语言代码</strong>：程序员用高级语言（比如BASIC或Java）编写程序。</li>\n<li><strong>转换为中间形式</strong>：解释器首先将这些高级语言的指令转换成一种叫做中间形式的东西，它包含了很多小的单元，我们称之为“标记”（Tokens）。<ul>\n<li><strong>例子</strong>：在Java中，这些标记可以是诸如 <code>static</code>、<code>boolean</code>、<code>file</code>、<code>string</code>、<code>void</code>、<code>return</code>等。</li>\n</ul>\n</li>\n<li><strong>解码执行</strong>：然后，这些标记会被传递给解释器的解码器，它的工作就是根据这些标记选择合适的例行程序或方法进行执行。<ul>\n<li><strong>例子</strong>：如果解释器看到 <code>static</code> 这个标记，它会知道要处理静态方法；如果看到 <code>return</code>，它会知道要处理返回值的相关操作。</li>\n</ul>\n</li>\n<li><strong>执行</strong>：最后，解释器开始执行所选的例行程序或方法。</li>\n</ol>\n<p>这个过程就好像在翻译一本书一样：我们先将原文（高级语言代码）翻译成中间语言（标记），然后根据中间语言选择合适的翻译规则（解码执行），最后按照规则翻译成另一种语言（机器语言），以便计算机能够理解和执行。</p>\n<p><strong>在这个过程中可能发生的错误</strong>：</p>\n<ul>\n<li>如果高级语言代码有语法错误，解释器会在转换为中间形式的过程中报告错误。</li>\n<li>如果在执行的时候遇到了问题，比如尝试使用一个不存在的方法，解释器也会报告相应的运行时错误。</li>\n</ul>\n<h2 id=\"对比编译器\"><a href=\"#对比编译器\" class=\"headerlink\" title=\"对比编译器\"></a>对比编译器</h2><h3 id=\"编译器（Compilers）\"><a href=\"#编译器（Compilers）\" class=\"headerlink\" title=\"编译器（Compilers）\"></a>编译器（Compilers）</h3><p><strong>1. 整体翻译：</strong> 编译器就像是一本翻译专家。当你写好整个程序（比如用高级语言写的）时，编译器会把整个程序一次性地翻译成计算机能理解的机器代码。</p>\n<p><strong>2. 独立翻译和执行：</strong> 翻译和执行是分开的步骤。首先，整个程序被翻译成机器代码，然后这个机器代码可以被多次执行，就像你只需翻译一次一样。</p>\n<p><strong>3. 例子：</strong> 就好比你写一篇文章，翻译专家把整篇文章都翻译成另一种语言，然后其他人可以反复阅读这篇翻译好的文章。</p>\n<h3 id=\"解释器（Interpreters）\"><a href=\"#解释器（Interpreters）\" class=\"headerlink\" title=\"解释器（Interpreters）\"></a>解释器（Interpreters）</h3><p><strong>1. 逐行翻译：</strong> 解释器像是一个实时翻译的人。当你写好一行代码时，解释器会逐行地翻译并立即执行。</p>\n<p><strong>2. 翻译和执行交替进行：</strong> 翻译和执行是交替进行的。一行代码翻译一行，然后立即执行。这就像是你一边说一边由翻译人员实时翻译。</p>\n<p><strong>3. 例子：</strong> 想象你在旅行，每当你说一句话，导游都会立即翻译并告诉司机要去哪里。这就是解释器的工作方式。</p>\n<h3 id=\"对比：\"><a href=\"#对比：\" class=\"headerlink\" title=\"对比：\"></a>对比：</h3><ul>\n<li><strong>编译器是整体的翻译专家，而解释器是实时的翻译人员。</strong></li>\n<li><strong>编译器的翻译和执行是分开的，而解释器的翻译和执行是交替进行的。</strong></li>\n</ul>\n<h2 id=\"C语言的编译，链接和执行\"><a href=\"#C语言的编译，链接和执行\" class=\"headerlink\" title=\"C语言的编译，链接和执行\"></a>C语言的编译，链接和执行</h2><p><img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/C-ImplementationFlow.png\" alt=\"C-Implementation Flow\"></p>\n<h2 id=\"Java的编译，链接和执行\"><a href=\"#Java的编译，链接和执行\" class=\"headerlink\" title=\"Java的编译，链接和执行\"></a>Java的编译，链接和执行</h2><p><img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/Java-ImplementationFlow.png\" alt=\"Java-Implementation Flow\"></p>\n<h2 id=\"解释器和计算机硬件的相似性\"><a href=\"#解释器和计算机硬件的相似性\" class=\"headerlink\" title=\"解释器和计算机硬件的相似性\"></a>解释器和计算机硬件的相似性</h2><p>解释器在某种程度上类似于计算机硬件（中央处理器，CPU）。它们都是按照一条指令一次执行的原理工作。</p>\n<ol>\n<li><strong>逐条执行：</strong> 就像计算机硬件逐条执行机器指令一样，解释器逐条执行高级语言的指令。</li>\n<li><strong>虚拟机概念：</strong> 由于解释器一次执行一条指令，有时候我们将其称为虚拟机。它是一个在软件层面上模拟硬件行为的机器。</li>\n<li><strong>例子：</strong> 一个典型的例子是Java虚拟机（JVM）。JVM被称为Java虚拟机，因为它执行Java字节码，这是一种中间代码，而不是直接执行机器代码。JVM充当了一个虚拟的计算机，能够解释和执行Java程序。</li>\n</ol>\n<h2 id=\"Java虚拟机（JVM）\"><a href=\"#Java虚拟机（JVM）\" class=\"headerlink\" title=\"Java虚拟机（JVM）\"></a>Java虚拟机（JVM）</h2><p>Java虚拟机（JVM）是一种特殊的解释器，它执行Java程序。它有以下特点：</p>\n<ol>\n<li><strong>字节码执行：</strong> JVM不直接执行Java源代码，而是将Java源代码编译成字节码。字节码是一种中间形式，类似于汇编语言，但不是直接的机器代码。</li>\n<li><strong>平台独立性：</strong> 由于JVM执行字节码，Java程序可以在任何安装了Java虚拟机的计算机上运行，而不受底层硬件和操作系统的影响。这使得Java具有良好的跨平台性。</li>\n<li><strong>动态优化：</strong> JVM还具有一些优化机制，例如即时编译（Just-In-Time Compilation，JIT）。JIT编译器将字节码转换为本地机器代码，从而提高程序的执行效率。</li>\n<li><strong>垃圾回收：</strong> JVM还负责Java程序的内存管理，包括垃圾回收。这有助于释放不再使用的内存，提高程序的健壮性。</li>\n</ol>\n<h1 id=\"代码的共享与复用\"><a href=\"#代码的共享与复用\" class=\"headerlink\" title=\"代码的共享与复用\"></a>代码的共享与复用</h1><p>在软件开发中，代码共享和重用是一个重要的问题。当我们开发新系统时，如何有效地重用已有的经过验证的软件呢？有几种解决方案：</p>\n<h3 id=\"1-源代码级别的子程序和宏库（Source-level-Subroutines-and-Macro-Libraries）\"><a href=\"#1-源代码级别的子程序和宏库（Source-level-Subroutines-and-Macro-Libraries）\" class=\"headerlink\" title=\"1. 源代码级别的子程序和宏库（Source-level Subroutines and Macro Libraries）\"></a>1. <strong>源代码级别的子程序和宏库（Source-level Subroutines and Macro Libraries）</strong></h3><p>这是一种基本的重用方法。开发者可以编写通用的子程序（也称为函数或方法）和宏，然后将它们保存在库中。其他开发者可以在新的项目中引用这些库，并在其源代码中调用这些子程序或宏。</p>\n<p><strong>优势：</strong></p>\n<ul>\n<li>灵活性高，可以根据需要进行修改和定制。</li>\n<li>代码的可读性好，因为直接看到了源代码。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>每次使用都需要重新编译，可能导致额外的工作量和时间消耗。</li>\n<li>不够灵活，因为源代码一旦编译，就不再能够适应不同的环境或需求。</li>\n</ul>\n<h3 id=\"2-预转换的可重定位二进制库（Pre-translated-Re-locatable-Binary-Libraries）\"><a href=\"#2-预转换的可重定位二进制库（Pre-translated-Re-locatable-Binary-Libraries）\" class=\"headerlink\" title=\"2. 预转换的可重定位二进制库（Pre-translated Re-locatable Binary Libraries）\"></a>2. <strong>预转换的可重定位二进制库（Pre-translated Re-locatable Binary Libraries）</strong></h3><p>这种方法是在开发阶段将源代码编译成可重定位的二进制库，而不是在每次使用时都重新编译。其他开发者可以将这些预编译的库链接到他们的项目中。</p>\n<p><strong>优势：</strong></p>\n<ul>\n<li>节省了重新编译的时间，提高了效率。</li>\n<li>提供了一定程度的代码隐藏，因为其他开发者不直接看到源代码。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>编译时需要考虑目标平台，可能导致平台兼容性问题。</li>\n<li>不够灵活，因为库的功能和接口在编译时已经确定，无法在运行时进行修改。</li>\n</ul>\n<h3 id=\"3-动态库和动态链接（Dynamic-Libraries-and-Dynamic-Linking）\"><a href=\"#3-动态库和动态链接（Dynamic-Libraries-and-Dynamic-Linking）\" class=\"headerlink\" title=\"3. 动态库和动态链接（Dynamic Libraries and Dynamic Linking）\"></a>3. <strong>动态库和动态链接（Dynamic Libraries and Dynamic Linking）</strong></h3><p>这是一种更为灵活和动态的重用方法。在运行时，程序可以动态地加载和链接库，而不是在编译时。这种方式在现代软件开发中非常常见。</p>\n<p><strong>优势：</strong></p>\n<ul>\n<li>具有更高的灵活性，可以在运行时加载和卸载库。</li>\n<li>允许共享库的不同版本，避免了一些版本兼容性问题。</li>\n<li>节省了存储空间，因为库在运行时才被加载。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>运行时开销相对较高，因为需要进行动态链接。</li>\n<li>一些错误可能在运行时才被发现，而不是在编译时。</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/CodeShareFlow.png\" alt=\"Code Share Flow\"></p>\n<ol>\n<li><strong>源代码级别的子程序和宏库：</strong> <code>Main.c</code> 调用了 <code>Util.c</code> 中的功能。这是源代码级别的重用。</li>\n<li><strong>预转换的可重定位二进制库（静态库）：</strong> 当有新的 <code>Util_v2.c</code> 版本时，它被编写、编译，并形成静态库。<code>Main.c</code> 可以链接到这个静态库，形成可执行文件。</li>\n<li><strong>动态库和动态链接：</strong> 当有新的 <code>Util_v3.c</code> 版本时，它被编写、编译，并形成动态库。<code>Main.c</code> 可以链接到这个动态库，形成可执行文件。动态库在运行时加载，而不是在编译时链接。</li>\n</ol>\n<h1 id=\"源代码级别的子程序和宏库\"><a href=\"#源代码级别的子程序和宏库\" class=\"headerlink\" title=\"源代码级别的子程序和宏库\"></a>源代码级别的子程序和宏库</h1><h3 id=\"意图：\"><a href=\"#意图：\" class=\"headerlink\" title=\"意图：\"></a>意图：</h3><p>使用源代码级别的子程序和宏库的目的是在开发新系统时，通过以下步骤实现代码重用：</p>\n<ol>\n<li><strong>获取库例程的副本：</strong> 获取库中的例程的副本，通常是复制源代码或者从已有的库中提取。</li>\n<li><strong>将其编辑到新代码中：</strong> 将所选的例程编辑并整合到新的代码中，以满足新系统的需求。</li>\n<li><strong>一起进行整体翻译：</strong> 最终，将整个代码进行翻译，生成新系统的可执行文件。</li>\n</ol>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ol>\n<li><strong>代码归属问题：</strong> 由于对库中例程的编辑和整合，产生了一个问题，即这些修改后的例程的归属问题。谁拥有修改后的代码？是原始库的所有者还是进行了修改的开发者？</li>\n<li><strong>维护责任问题：</strong> 同样，由于进行了修改，存在一个维护责任的问题。谁应该负责维护这些修改后的代码？是原始库的维护者还是修改代码的开发者？</li>\n</ol>\n<h1 id=\"预转换的可重定位二进制库\"><a href=\"#预转换的可重定位二进制库\" class=\"headerlink\" title=\"预转换的可重定位二进制库\"></a>预转换的可重定位二进制库</h1><h3 id=\"意图：-1\"><a href=\"#意图：-1\" class=\"headerlink\" title=\"意图：\"></a>意图：</h3><p>预转换的可重定位二进制库的意图在于：</p>\n<ol>\n<li><strong>预先翻译为可重定位二进制代码：</strong> 库中的例程在开发之前被预先翻译为可重定位二进制代码。这表示这些库例程已经编译成机器代码，但其地址信息还没有最终确定。</li>\n<li><strong>可以链接到新代码中，但不能更改：</strong> 这些预转换的库可以被链接到新的代码中，但不能被修改。开发者可以使用这些例程，但不能编辑它们。</li>\n</ol>\n<h3 id=\"接受度：\"><a href=\"#接受度：\" class=\"headerlink\" title=\"接受度：\"></a>接受度：</h3><p>这种方式已经被广泛接受，并在当今所有的软件开发中仍然是必不可少的。它提供了一种有效的代码重用方式，同时降低了代码所有权和维护责任的不确定性。</p>\n<h3 id=\"缺点：-1\"><a href=\"#缺点：-1\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><p>然而，这种方式也有缺点：</p>\n<ol>\n<li><strong>每个程序拥有私有副本的缺点：</strong> 每个程序都需要拥有自己的私有副本库，这会浪费宝贵的内存空间，并在多任务系统中交换时浪费时间。</li>\n</ol>\n<h3 id=\"‘可重定位’的含义：\"><a href=\"#‘可重定位’的含义：\" class=\"headerlink\" title=\"‘可重定位’的含义：\"></a>‘可重定位’的含义：</h3><p>在这个上下文中，”可重定位” 意味着生成的二进制代码中包含了一些未定的地址信息。这些地址信息在加载时会被系统调整，以便适应新程序的地址空间。这种可重定位性使得库例程可以在不同的程序中使用，因为加载时可以动态调整地址，而不会导致冲突。</p>\n<h1 id=\"动态库和动态链接\"><a href=\"#动态库和动态链接\" class=\"headerlink\" title=\"动态库和动态链接\"></a>动态库和动态链接</h1><h3 id=\"意图：-2\"><a href=\"#意图：-2\" class=\"headerlink\" title=\"意图：\"></a>意图：</h3><p>动态库和动态链接的主要目标是：</p>\n<ol>\n<li><strong>加载使用已经加载到内存中的“公共”例程的程序：</strong> 允许程序加载已经在内存中的“公共”例程，而不是在每个程序中都拷贝一份。这样可以避免内存浪费，提高效率。</li>\n<li><strong>通过内存管理系统映射内存驻留的库：</strong> 内存中驻留的库被映射到程序的地址空间中，通过内存管理系统控制访问，避免多次拷贝代码。</li>\n<li><strong>映射到什么地方：</strong> 动态库在内存中被映射到特定的地址空间，以便程序可以调用其中的例程。</li>\n</ol>\n<h3 id=\"接受度：-1\"><a href=\"#接受度：-1\" class=\"headerlink\" title=\"接受度：\"></a>接受度：</h3><p>这种方式取得了成功，特别是通过微软的ActiveX标准。动态链接和动态库已经成为现代软件开发的重要组成部分。</p>\n<h3 id=\"优势：\"><a href=\"#优势：\" class=\"headerlink\" title=\"优势：\"></a>优势：</h3><ol>\n<li><strong>节省内存空间：</strong> 动态库的代码不需要每个程序都拷贝一份，因此节省了内存空间。</li>\n<li><strong>避免多个代码副本：</strong> 动态链接避免了多个程序之间存在相同代码的问题，因为它们共享动态库。</li>\n<li><strong>运行时加载：</strong> 动态库在运行时加载，而不是在编译时链接，这提高了灵活性和可维护性。</li>\n</ol>\n<h3 id=\"Microsoft’s-ActiveX：\"><a href=\"#Microsoft’s-ActiveX：\" class=\"headerlink\" title=\"Microsoft’s ActiveX：\"></a>Microsoft’s ActiveX：</h3><p>ActiveX 是由微软公司提出的一种技术标准，它使得在网络环境中能够运行各种不同类型的程序。ActiveX 控件是可以被嵌入到网页中的可执行程序，允许在网页上运行交互式应用程序。这个标准成功地推动了动态链接和动态库的应用，特别是在Windows平台上。</p>\n<h1 id=\"Q-A\"><a href=\"#Q-A\" class=\"headerlink\" title=\"Q&A\"></a>Q&amp;A</h1><p><strong>高级编程语言（HLL）的四个例子是：</strong></p>\n<ul>\n<li>C++</li>\n<li>Java</li>\n<li>Python</li>\n<li>Ruby</li>\n</ul>\n<p><strong>翻译填补计算机系统中的语义差距（True or False？）</strong></p>\n<ul>\n<li>True</li>\n</ul>\n<p><strong>翻译的三种不同方式及其关键作用：</strong></p>\n<ul>\n<li><strong>源代码翻译（Source-to-Source Translation）：</strong><ul>\n<li><strong>关键作用：</strong> 将源代码从一种高级语言翻译成另一种高级语言，便于跨平台开发和移植。</li>\n</ul>\n</li>\n<li><strong>编译器翻译（Compiler Translation）：</strong><ul>\n<li><strong>关键作用：</strong> 将高级语言源代码翻译成机器语言或中间代码，使计算机能够执行程序。</li>\n</ul>\n</li>\n<li><strong>解释器翻译（Interpreter Translation）：</strong><ul>\n<li><strong>关键作用：</strong> 逐行解释执行源代码，无需编译成机器代码，便于调试和交互式开发。</li>\n</ul>\n</li>\n</ul>\n<p><strong>当发生编译时错误时，我们应该做什么？</strong></p>\n<ul>\n<li>当编译时错误发生时，需要检查源代码中的错误，并逐一修复这些错误。这可能涉及到语法错误、类型错误或其他编译器无法处理的问题。修复错误后，重新进行编译。</li>\n</ul>\n<p><strong>链接的目的是什么？</strong></p>\n<ul>\n<li><p>目的：</p>\n<p> 链接是将多个目标文件合并成一个可执行文件的过程，其主要目的有三：</p>\n<ul>\n<li><strong>符号解析（Symbol Resolution）：</strong> 将程序中使用的符号与其实际地址关联起来，解决外部引用。</li>\n<li><strong>地址绑定（Address Binding）：</strong> 将程序中的变量和地址关联，使得程序在内存中正确加载。</li>\n<li><strong>库链接（Library Linking）：</strong> 将程序中使用的库函数的代码合并到可执行文件中，减少对外部库的依赖。</li>\n</ul>\n</li>\n</ul>\n<p><strong>‘Loading’在程序编译后的‘linking’之前执行。（True or False?）</strong></p>\n<ul>\n<li><strong>False</strong></li>\n<li><strong>解释：</strong> 在编译后，程序首先进行链接（linking），将多个模块组合成一个可执行文件。加载（loading）则发生在链接之后，将可执行文件加载到内存中供计算机执行。</li>\n</ul>\n<p><strong>程序模块可以分别进行编译。（True or False?）</strong></p>\n<ul>\n<li><strong>True</strong></li>\n<li><strong>解释：</strong> 是的，程序的不同模块可以分别进行编译，这种模块化的编译方式有助于提高代码的可维护性和灵活性。</li>\n</ul>\n<p><strong>编译器可以将一个模块翻译成二进制代码，但无法解决对其他模块的引用。这发生在什么时候？</strong></p>\n<ul>\n<li>当编译器无法解决对其他模块的引用时，这通常发生在链接阶段。编译器生成的目标文件中可能包含对其他模块或库的引用，而这些引用的解析和绑定发生在链接过程中。</li>\n</ul>\n<p><strong>库文件如果链接到程序代码中是可用的。（True or False?）</strong></p>\n<ul>\n<li><strong>True</strong></li>\n<li><strong>解释：</strong> 是的，将库文件链接到程序代码中是常见的做法。这样可以使程序访问库中定义的函数和功能，提供了代码重用和模块化开发的优势。</li>\n</ul>\n<p><strong>解释器通常将程序代码转换成什么？</strong></p>\n<ul>\n<li>解释器通常将程序代码转换成中间代码或直接执行代码，而不是生成独立的可执行文件。这中间代码可以由解释器逐行执行，或者通过虚拟机进行解释执行。</li>\n</ul>\n<p><strong>程序编译的输出是什么？</strong></p>\n<ul>\n<li>程序编译的输出是目标文件或可执行文件。目标文件包含了源代码翻译成的机器代码或中间代码，而可执行文件是链接了所有必要模块并准备好在计算机上运行的文件。</li>\n</ul>\n<p><strong>两种情况下解释器比编译器更有用的场景是：</strong></p>\n<ul>\n<li><strong>交互式开发（Interactive Development）：</strong> 在交互式开发中，解释器能够逐行执行代码，立即显示结果，方便程序员调试和测试。</li>\n<li><strong>动态语言支持（Dynamic Language Support）：</strong> 解释器对于动态语言的支持更为灵活，能够在运行时动态地处理类型和内存管理，而不需要预先编译生成可执行文件。</li>\n</ul>\n<p><strong>解释器有时被称为虚拟机，因为…？</strong></p>\n<ul>\n<li>解释器有时被称为虚拟机，因为它能够模拟计算机硬件的行为，通过逐行执行中间代码或直接执行源代码来实现程序的运行。</li>\n</ul>\n<p><strong>代码共享的三种方法包括：</strong></p>\n<ul>\n<li><strong>静态链接（Static Linking）：</strong> 在编译时将代码合并成一个可执行文件，形成独立的执行单元。</li>\n<li><strong>动态链接（Dynamic Linking）：</strong> 在运行时加载共享库文件，以便多个程序可以共享相同的库，减少内存占用。</li>\n<li><strong>代码复制（Code Duplication）：</strong> 直接将代码复制到多个地方，以实现共享，但可能导致代码冗余。</li>\n</ul>\n<p><strong>宏库的两个缺点（或问题）是：</strong></p>\n<ul>\n<li><strong>可读性和维护性差：</strong> 宏库中的宏通常是代码片段的文本替换，可能导致代码可读性差，难以维护和调试。</li>\n<li><strong>潜在的命名冲突：</strong> 使用宏库时，可能出现命名冲突的问题，因为宏在全局范围内进行文本替换，可能与其他部分的代码发生冲突。</li>\n</ul>\n<p><strong>库可以链接到程序代码中，但不能被修改。（True or False?）</strong></p>\n<ul>\n<li><strong>True</strong></li>\n<li><strong>解释：</strong> 是的，库文件通常被链接到程序代码中，但一旦链接完成，它们通常不能被修改。程序在运行时可以使用这些库提供的功能，但不能直接修改库中的代码。</li>\n</ul>\n<p><strong>使用预先翻译的程序库进行程序执行的缺点是什么？</strong></p>\n<ul>\n<li><strong>性能损失：</strong> 预先翻译的程序库可能不够灵活，无法优化以适应不同的执行环境，导致性能损失。</li>\n<li><strong>版本兼容性：</strong> 如果程序库和目标环境的版本不匹配，可能导致兼容性问题，需要额外的处理和管理。</li>\n</ul>\n<p><strong>存在一个动态库和动态链接的事实标准。（True or False?）</strong></p>\n<ul>\n<li><strong>True</strong></li>\n<li><strong>解释：</strong> 是的，存在一些事实上的标准，例如在许多Unix-like系统中广泛使用的ELF（Executable and Linkable Format）格式，以及在Windows系统中使用的DLL（Dynamic Link Library）格式。这些标准定义了动态库的结构和动态链接的规范，使得不同的软件和系统能够更好地协同工作。</li>\n</ul>\n","text":"继续复习下一章，总感觉每节课讲的东西相似性都好高。 机器指令和高级语言不是，之前都讲过了为什么还有。 机器指令（Machine Instructions）： 定义：机器指令是计算机硬件可以直接执行的基本操作。每一条机器指令对应于一个特定的操作，如加法、乘法、加载数据等。计算机的中...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"CPT101复习","slug":"CPT101复习","count":5,"path":"api/tags/CPT101复习.json"},{"name":"笔记","slug":"笔记","count":46,"path":"api/tags/笔记.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%92%8C%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80\"><span class=\"toc-text\">机器指令和高级语言</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E4%B9%89%E9%B8%BF%E6%B2%9F\"><span class=\"toc-text\">语义鸿沟</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BF%BB%E8%AF%91\"><span class=\"toc-text\">翻译</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%A0%E7%A7%8DERROR\"><span class=\"toc-text\">几种ERROR</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">链接</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BA%93%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">库文件</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E9%87%8A%E5%99%A8\"><span class=\"toc-text\">解释器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">工作流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%AF%94%E7%BC%96%E8%AF%91%E5%99%A8\"><span class=\"toc-text\">对比编译器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%88Compilers%EF%BC%89\"><span class=\"toc-text\">编译器（Compilers）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E9%87%8A%E5%99%A8%EF%BC%88Interpreters%EF%BC%89\"><span class=\"toc-text\">解释器（Interpreters）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%AF%94%EF%BC%9A\"><span class=\"toc-text\">对比：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E8%AF%91%EF%BC%8C%E9%93%BE%E6%8E%A5%E5%92%8C%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">C语言的编译，链接和执行</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java%E7%9A%84%E7%BC%96%E8%AF%91%EF%BC%8C%E9%93%BE%E6%8E%A5%E5%92%8C%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">Java的编译，链接和执行</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E9%87%8A%E5%99%A8%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%9A%84%E7%9B%B8%E4%BC%BC%E6%80%A7\"><span class=\"toc-text\">解释器和计算机硬件的相似性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88JVM%EF%BC%89\"><span class=\"toc-text\">Java虚拟机（JVM）</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E5%A4%8D%E7%94%A8\"><span class=\"toc-text\">代码的共享与复用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AD%90%E7%A8%8B%E5%BA%8F%E5%92%8C%E5%AE%8F%E5%BA%93%EF%BC%88Source-level-Subroutines-and-Macro-Libraries%EF%BC%89\"><span class=\"toc-text\">1. 源代码级别的子程序和宏库（Source-level Subroutines and Macro Libraries）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E9%A2%84%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BA%93%EF%BC%88Pre-translated-Re-locatable-Binary-Libraries%EF%BC%89\"><span class=\"toc-text\">2. 预转换的可重定位二进制库（Pre-translated Re-locatable Binary Libraries）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%88Dynamic-Libraries-and-Dynamic-Linking%EF%BC%89\"><span class=\"toc-text\">3. 动态库和动态链接（Dynamic Libraries and Dynamic Linking）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BA%A7%E5%88%AB%E7%9A%84%E5%AD%90%E7%A8%8B%E5%BA%8F%E5%92%8C%E5%AE%8F%E5%BA%93\"><span class=\"toc-text\">源代码级别的子程序和宏库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%84%8F%E5%9B%BE%EF%BC%9A\"><span class=\"toc-text\">意图：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%BA%E7%82%B9%EF%BC%9A\"><span class=\"toc-text\">缺点：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%A2%84%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BA%93\"><span class=\"toc-text\">预转换的可重定位二进制库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%84%8F%E5%9B%BE%EF%BC%9A-1\"><span class=\"toc-text\">意图：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%97%E5%BA%A6%EF%BC%9A\"><span class=\"toc-text\">接受度：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%BA%E7%82%B9%EF%BC%9A-1\"><span class=\"toc-text\">缺点：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E2%80%98%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%80%99%E7%9A%84%E5%90%AB%E4%B9%89%EF%BC%9A\"><span class=\"toc-text\">‘可重定位’的含义：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">动态库和动态链接</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%84%8F%E5%9B%BE%EF%BC%9A-2\"><span class=\"toc-text\">意图：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%97%E5%BA%A6%EF%BC%9A-1\"><span class=\"toc-text\">接受度：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8A%BF%EF%BC%9A\"><span class=\"toc-text\">优势：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Microsoft%E2%80%99s-ActiveX%EF%BC%9A\"><span class=\"toc-text\">Microsoft’s ActiveX：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Q-A\"><span class=\"toc-text\">Q&amp;A</span></a></li></ol>","author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}},"mapped":true,"prev_post":{"title":"CPT101 Review-4","uid":"6a06535b3bcdc549550c9f79e3c5e8f7","slug":"CPT101-Review-4","date":"2023-12-11T10:50:04.000Z","updated":"2023-12-11T12:06:21.588Z","comments":true,"path":"api/articles/CPT101-Review-4.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/CPT101-img.png","text":"继续复习下一节。 数据，信息，知识这三者是我们在对于信息处理时的三个不同的抽象阶段。 数据（Data）： 数据是原始的、未经加工的事实或细节。它是离散的、不加组织的符号或符号集合，通常是数字、文字、图像等的表示。 数据本身并没有给予任何含义，只有在一定的上下文中才能被理解。例如，...","link":"","photos":[],"count_time":{"symbolsCount":"6.7k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"CPT101复习","slug":"CPT101复习","count":5,"path":"api/tags/CPT101复习.json"},{"name":"笔记","slug":"笔记","count":46,"path":"api/tags/笔记.json"}],"author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}}},"next_post":{"title":"CPT101 Review-2","uid":"e585c831fab448b304cde81e18fc31a2","slug":"CPT101-Review-2","date":"2023-12-08T10:02:43.000Z","updated":"2023-12-09T07:55:07.506Z","comments":true,"path":"api/articles/CPT101-Review-2.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/CPT101-img.png","text":"期末考试，细算留一个月用来复习好像是真的有点紧了，甚至现在都不只一个月。 101就按部就班，下周需要复习107，101就跟着感觉走算了。 IPO模型Input-Process-Output (IPO) 模型是描述计算机功能和工作原理的基本概念。这个模型简要地阐述了计算机是如何接收...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"CPT101复习","slug":"CPT101复习","count":5,"path":"api/tags/CPT101复习.json"},{"name":"笔记","slug":"笔记","count":46,"path":"api/tags/笔记.json"}],"author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}}}}