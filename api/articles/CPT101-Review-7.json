{"title":"CPT101 Review-7","uid":"9f40b949505ca9d69d0cd0fe93485a8a","slug":"CPT101-Review-7","date":"2024-01-07T06:15:23.000Z","updated":"2024-01-07T08:14:30.934Z","comments":true,"path":"api/articles/CPT101-Review-7.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/CPT101-img.png","content":"<h1 id=\"冯·诺依曼模型\"><a href=\"#冯·诺依曼模型\" class=\"headerlink\" title=\"冯·诺依曼模型\"></a>冯·诺依曼模型</h1><p>冯·诺依曼模型（Von Neumann architecture）是计算机体系结构的一种基本设计范式，由匈牙利数学家和计算机科学家约翰·冯·诺依曼（John von Neumann）于20世纪40年代提出。这个模型成为了现代计算机体系结构的基础，几乎所有的通用计算机都采用了冯·诺依曼模型。</p>\n<p>冯·诺依曼模型的关键特征包括以下几点：</p>\n<ol>\n<li><strong>存储程序：</strong> 冯·诺依曼模型使用存储程序的概念，即指令和数据都存储在同一存储器中。这与之前的一些计算机体系结构不同，这些计算机在执行程序之前需要将程序加载到计算机中。在冯·诺依曼模型中，程序被存储在内存中，可以被计算机按照顺序读取和执行。</li>\n<li><strong>二进制表示：</strong> 冯·诺依曼模型使用二进制来表示指令和数据。计算机中的所有信息，包括指令、数据和地址，都以二进制形式存储和处理。</li>\n<li><strong>中央处理单元（CPU）：</strong> CPU是冯·诺依曼计算机的核心部分，负责执行存储在内存中的指令。CPU包括运算器（Arithmetic Logic Unit，ALU）和控制器（Control Unit，CU）。运算器执行算术和逻辑运算，而控制器负责解释指令、控制数据流和执行程序。</li>\n<li><strong>存储器：</strong> 存储器用于存储指令和数据。在冯·诺依曼模型中，存储器被划分为指令存储器和数据存储器，但它们通常是统一的内存空间。</li>\n<li><strong>输入/输出设备：</strong> 冯·诺依曼计算机通过输入/输出设备与外部世界进行通信。这些设备可以是键盘、鼠标、显示器、磁盘驱动器等。</li>\n<li><strong>顺序执行：</strong> 指令按照顺序一条一条地执行，每条指令都由控制器解释和执行。这种顺序执行的方式使得计算机能够灵活地执行各种任务。</li>\n</ol>\n<p>冯·诺依曼模型的优点在于其简洁性和通用性。这个模型为计算机的发展奠定了基础，使得计算机可以执行各种不同的任务，而不需要物理上重新设计硬件。冯·诺依曼模型的基本概念成为现代计算机体系结构的基础，直到今天仍然广泛应用。</p>\n<h1 id=\"计算机的主要组成部分\"><a href=\"#计算机的主要组成部分\" class=\"headerlink\" title=\"计算机的主要组成部分\"></a>计算机的主要组成部分</h1><h2 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h2><p>计算机的中央处理器（CPU）是系统的核心，负责执行计算机程序中的指令。CPU包含多个部分，每个部分都有特定的功能，共同协作以实现计算和控制。以下是CPU的主要功能和组成部分：</p>\n<ol>\n<li><strong>控制单元（Control Unit，CU）：</strong><ul>\n<li><strong>功能：</strong> 控制数据在计算机内部的流动，协调和管理指令的执行。</li>\n</ul>\n</li>\n<li><strong>算术逻辑单元（Arithmetic Logic Unit，ALU）：</strong><ul>\n<li><strong>功能：</strong> 执行算术和逻辑运算，包括加法、减法、乘法、除法等数学运算，以及比较和逻辑判断。</li>\n</ul>\n</li>\n<li><strong>寄存器（Registers）：</strong><ul>\n<li><strong>功能：</strong> 临时存储CPU需要快速访问的数据和指令。</li>\n<li>包括累加器、程序计数器、指令寄存器等。</li>\n</ul>\n</li>\n<li><strong>缓存（Cache）：</strong><ul>\n<li><strong>功能：</strong> 存储临时数据，以便更快地访问经常使用的数据。</li>\n<li>分为多级缓存，如L1缓存和L2缓存。</li>\n</ul>\n</li>\n<li><strong>时钟（Clock）：</strong><ul>\n<li><strong>功能：</strong> 提供计时信号，同步CPU内部各个部分的工作。</li>\n<li>按时钟周期执行指令，划分为时钟周期和时钟频率。</li>\n</ul>\n</li>\n<li><strong>指令寄存器（Instruction Register，IR）：</strong><ul>\n<li><strong>功能：</strong> 存储当前执行的指令，从内存中取出的指令会存储在指令寄存器中，以供执行。</li>\n</ul>\n</li>\n<li><strong>程序计数器（Program Counter，PC）：</strong><ul>\n<li><strong>功能：</strong> 存储下一条要执行的指令的地址。</li>\n<li>在每次指令执行后自动递增，以指向下一条指令。</li>\n</ul>\n</li>\n<li><strong>状态寄存器（Flag Register）：</strong><ul>\n<li><strong>功能：</strong> 存储标志位，用于指示CPU的状态和执行结果，如零标志、进位标志等。</li>\n</ul>\n</li>\n<li><strong>总线接口（Bus Interface）：</strong><ul>\n<li><strong>功能：</strong> 通过内部和外部总线与其他系统组件（如内存、输入输出设备）进行数据交换。</li>\n</ul>\n</li>\n</ol>\n<p>这些部分共同协作，使CPU能够高效地执行各种计算任务。控制单元指导指令的执行流程，ALU执行实际的计算，寄存器和缓存提供临时存储，时钟同步各个部分的操作，而总线接口使CPU能够与其他硬件组件通信。这种协同作用使得计算机能够迅速、准确地执行各种计算任务。</p>\n<p>考虑一个简单的加法操作，我们使用一个包含 ALU、寄存器和时钟的基本 CPU。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/CPUExample.png\" alt=\"CPU\"></p>\n<h2 id=\"主储存器（Main-Memory）\"><a href=\"#主储存器（Main-Memory）\" class=\"headerlink\" title=\"主储存器（Main Memory）\"></a>主储存器（Main Memory）</h2><p>主存储器（Main Memory），也称为随机存取存储器（RAM），是计算机系统中用于存储正在运行的程序和数据的关键组件。主存储器在计算机启动时被操作系统加载，它的内容是易失性的，即在断电时会丢失。下面是主存储器的一些重要方面：</p>\n<ol>\n<li><strong>内存单元（Memory Cells）：</strong><ul>\n<li><strong>功能：</strong> 主存储器被划分为许多小的存储单元，每个单元存储一个数据位。每个单元都有一个唯一的地址。</li>\n</ul>\n</li>\n<li><strong>地址总线（Address Bus）：</strong><ul>\n<li><strong>功能：</strong> 用于指定内存中的特定单元。地址总线的位数决定了内存的寻址能力，即能够寻址的最大存储单元数。</li>\n</ul>\n</li>\n<li><strong>数据总线（Data Bus）：</strong><ul>\n<li><strong>功能：</strong> 传输CPU和主存储器之间的数据。数据总线的宽度决定了每次数据传输的位数，通常与CPU的数据总线宽度相匹配。</li>\n</ul>\n</li>\n<li><strong>存储单元的大小和字长（Word Size）：</strong><ul>\n<li><strong>功能：</strong> 描述每个存储单元能够容纳的位数。字长与计算机的体系结构和处理器有关，通常是8位、16位、32位或64位。</li>\n</ul>\n</li>\n<li><strong>主存储器的种类：</strong><ul>\n<li><strong>RAM（随机存取存储器）：</strong> 包括动态随机存储器（DRAM）和静态随机存储器（SRAM）。DRAM需要定期刷新以保持数据，而SRAM是静态的，不需要刷新，但成本较高。</li>\n<li><strong>ROM（只读存储器）：</strong> 存储固定的程序和数据，不易修改。包括EPROM、EEPROM和闪存等。</li>\n</ul>\n</li>\n<li><strong>内存层次结构：</strong><ul>\n<li><strong>功能：</strong> 包括多级缓存和主存储器，以提高数据访问速度。高速缓存用于存储CPU经常访问的数据，而主存储器用于存储更大量的数据。</li>\n</ul>\n</li>\n<li><strong>内存访问时间和带宽：</strong><ul>\n<li><strong>功能：</strong> 内存访问时间是CPU从请求数据到实际获取数据所需的时间。带宽指的是在单位时间内传输到或从内存的数据量。快速的内存访问和高带宽对于提高计算机性能至关重要。</li>\n</ul>\n</li>\n<li><strong>内存管理单元（Memory Management Unit，MMU）：</strong><ul>\n<li><strong>功能：</strong> 负责将逻辑地址（由程序生成的地址）映射为物理地址（在实际硬件上的地址），并处理虚拟内存等内存管理任务。</li>\n</ul>\n</li>\n</ol>\n<p>主存储器在计算机系统中起到了承载程序和数据的关键作用。它的大小、速度和类型对计算机性能有重要影响。存储层次结构的设计和内存管理单元的工作都是为了提高数据的访问效率和整体系统的性能。</p>\n<p>然后在此基础上就是这样来表示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/CPUExample2.png\"></p>\n<h2 id=\"输入输出单元（I-O-Units）\"><a href=\"#输入输出单元（I-O-Units）\" class=\"headerlink\" title=\"输入输出单元（I/O Units）\"></a>输入输出单元（I/O Units）</h2><p>输入输出单元（I/O Units）是计算机系统中负责处理与外部设备通信的组件。这些单元允许计算机与各种外部设备进行数据交换，包括键盘、鼠标、打印机、硬盘驱动器、网络适配器等。输入输出单元通常包括以下几个重要的组成部分：</p>\n<ol>\n<li><strong>输入输出控制器（I/O Controller）：</strong><ul>\n<li><strong>功能：</strong> 管理和协调计算机与外部设备之间的数据传输。</li>\n<li>负责将数据从内存传输到外部设备或将外部设备的数据传输到内存。</li>\n</ul>\n</li>\n<li><strong>设备驱动程序（Device Drivers）：</strong><ul>\n<li><strong>功能：</strong> 是操作系统中的软件模块，用于与特定硬件设备通信。</li>\n<li>提供了一个标准的接口，使操作系统能够控制和与各种设备进行交互。</li>\n</ul>\n</li>\n<li><strong>端口（Ports）：</strong><ul>\n<li><strong>功能：</strong> 提供物理或逻辑接口，允许外部设备与计算机连接。</li>\n<li>可以是串口、并口、USB端口、HDMI端口等，每种端口对应不同类型的设备连接。</li>\n</ul>\n</li>\n<li><strong>中断控制器（Interrupt Controller）：</strong><ul>\n<li><strong>功能：</strong> 处理硬件中断，通知CPU有外部事件需要处理。</li>\n<li>使计算机能够响应外部设备的请求，而不需要不断地轮询检查。</li>\n</ul>\n</li>\n<li><strong>缓冲区（Buffer）：</strong><ul>\n<li><strong>功能：</strong> 用于临时存储输入输出数据，协调不同速度的设备之间的数据传输。</li>\n<li>避免了设备之间的速度不匹配导致的数据丢失或延迟。</li>\n</ul>\n</li>\n<li><strong>通信接口（Communication Interface）：</strong><ul>\n<li><strong>功能：</strong> 提供计算机与网络通信的能力，例如网络适配器。</li>\n<li>负责处理网络数据包的发送和接收。</li>\n</ul>\n</li>\n<li><strong>DMA控制器（Direct Memory Access Controller）：</strong><ul>\n<li><strong>功能：</strong> 允许外部设备直接访问计算机内存，减轻CPU负担。</li>\n<li>提高数据传输效率，特别是在大量数据需要快速传输时。</li>\n</ul>\n</li>\n<li><strong>I/O端口地址空间（I/O Port Address Space）：</strong><ul>\n<li><strong>功能：</strong> 提供给CPU访问I/O设备的地址空间，通过这些地址可以与外部设备进行通信。</li>\n</ul>\n</li>\n</ol>\n<p>输入输出单元的主要任务是协调和管理计算机系统与外部设备之间的数据传输，以确保数据能够有效地在计算机系统和外部设备之间流动。这样，计算机系统就能够与用户交互，并与各种外部设备协同工作，实现各种功能。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/CPUExample3.png\"></p>\n<h1 id=\"主板（Mother-Board）\"><a href=\"#主板（Mother-Board）\" class=\"headerlink\" title=\"主板（Mother Board）\"></a>主板（Mother Board）</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>计算机主板是计算机系统中的核心组件，连接并协调各个硬件设备，确保它们能够正常工作。主板上有许多组成部分，每个部分都有其独特的功能。以下是计算机主板的主要组成部分及其功能：</p>\n<ol>\n<li><strong>中央处理器插槽（Central Processing Unit Socket）</strong>：<ul>\n<li><strong>功能：</strong> 放置中央处理器（CPU），负责执行计算机的指令。</li>\n</ul>\n</li>\n<li><strong>内存插槽（Memory Slots）</strong>：<ul>\n<li><strong>功能：</strong> 安装内存模块，存储正在执行的程序和数据，提供快速访问速度。</li>\n</ul>\n</li>\n<li><strong>芯片组（Chipset）</strong>：<ul>\n<li><strong>功能：</strong> 控制和协调数据流动，管理系统中的各种硬件组件。</li>\n</ul>\n</li>\n<li><strong>扩展插槽（Expansion Slots）</strong>：<ul>\n<li><strong>功能：</strong> 提供安装扩展卡的位置，如图形卡、声卡、网络适配器等，以扩展计算机的功能。</li>\n</ul>\n</li>\n<li><strong>输入/输出接口（I/O Ports）</strong>：<ul>\n<li><strong>功能：</strong> 提供连接外部设备的接口，如USB端口、HDMI端口、音频接口等。</li>\n</ul>\n</li>\n<li><strong>BIOS/UEFI芯片（BIOS/UEFI Chip）</strong>：<ul>\n<li><strong>功能：</strong> 存储计算机的基本输入/输出系统（BIOS）或统一可扩展固件接口（UEFI），启动和初始化系统硬件。</li>\n</ul>\n</li>\n<li><strong>电源连接口（Power Connectors）</strong>：<ul>\n<li><strong>功能：</strong> 提供电源连接，将电能传递给主板及其组件。</li>\n</ul>\n</li>\n<li><strong>CMOS电池（CMOS Battery）</strong>：<ul>\n<li><strong>功能：</strong> 供电给CMOS芯片，保存计算机的基本配置信息，如日期、时间和硬件设置。</li>\n</ul>\n</li>\n<li><strong>南桥（Southbridge）</strong>：<ul>\n<li><strong>功能：</strong> 管理次要的系统组件，如硬盘驱动器、USB控制器和音频控制器。</li>\n</ul>\n</li>\n<li><strong>北桥（Northbridge）</strong>：<ul>\n<li><strong>功能：</strong> 管理主要的系统组件，如内存、图形接口和PCI Express控制器。</li>\n</ul>\n</li>\n<li><strong>SATA接口（SATA Ports）</strong>：<ul>\n<li><strong>功能：</strong> 提供连接硬盘驱动器和光盘驱动器的接口。</li>\n</ul>\n</li>\n<li><strong>PCI Express插槽（PCI Express Slots）</strong>：<ul>\n<li><strong>功能：</strong> 提供高带宽的扩展插槽，用于连接图形卡、网络适配器等高性能设备。</li>\n</ul>\n</li>\n<li><strong>USB控制器（USB Controller）</strong>：<ul>\n<li><strong>功能：</strong> 管理USB接口，支持连接各种外部设备。</li>\n</ul>\n</li>\n<li><strong>音频芯片（Audio Chip）</strong>：<ul>\n<li><strong>功能：</strong> 控制计算机的音频输入和输出。</li>\n</ul>\n</li>\n<li><strong>网络接口控制器（Network Interface Controller，NIC）</strong>：<ul>\n<li><strong>功能：</strong> 管理网络连接，控制计算机与局域网或互联网的通信。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"主要组成\"><a href=\"#主要组成\" class=\"headerlink\" title=\"主要组成\"></a>主要组成</h2><h3 id=\"三个主要子系统\"><a href=\"#三个主要子系统\" class=\"headerlink\" title=\"三个主要子系统\"></a>三个主要子系统</h3><ul>\n<li><strong>中央处理器（CPU）</strong></li>\n<li><strong>主存储器</strong></li>\n<li><strong>输入输出单元（I/O Units）</strong></li>\n</ul>\n<h3 id=\"交换数据\"><a href=\"#交换数据\" class=\"headerlink\" title=\"交换数据\"></a>交换数据</h3><ul>\n<li><strong>中央处理器（CPU）：</strong><ul>\n<li>由算术逻辑单元（ALU）、控制单元和寄存器组成。</li>\n<li>ALU执行计算和逻辑操作。</li>\n<li>控制单元协调和控制指令的执行。</li>\n<li>寄存器存储临时数据和指令。</li>\n</ul>\n</li>\n<li><strong>主存储器：</strong><ul>\n<li>包括随机存取存储器（RAM）和只读存储器（ROM）。</li>\n<li>RAM用于存储正在运行的程序和数据。</li>\n<li>ROM包含系统启动所需的固定程序。</li>\n</ul>\n</li>\n<li><strong>输入输出单元：</strong><ul>\n<li>包括连接计算机与外部设备的各种接口。</li>\n<li>数据通过输入输出控制器传递，通过各种接口（如USB、HDMI、网络端口）与外部设备通信。</li>\n</ul>\n</li>\n</ul>\n<p>他们三者之间通过总线（bus）进行数据交换</p>\n<ul>\n<li><strong>总线（Bus）：</strong> 一组电子线路，允许数据在各个子系统之间传输。</li>\n<li>数据通过地址总线和数据总线传递，控制信号通过控制总线传递。</li>\n<li>CPU通过地址总线选择要访问的内存位置，通过数据总线进行读取或写入操作。</li>\n</ul>\n<p>• 数据流动的基本过程：</p>\n<ol>\n<li><strong>CPU向内存发出请求。</strong></li>\n<li><strong>内存通过总线将数据传递给CPU。</strong></li>\n<li><strong>CPU对数据进行处理，可能会写回内存。</strong></li>\n<li><strong>输入输出单元通过总线与外部设备进行通信。</strong></li>\n</ol>\n<h2 id=\"示意图\"><a href=\"#示意图\" class=\"headerlink\" title=\"示意图\"></a>示意图</h2><p>以下是一个简单的图来表示数据的传递：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/DataExchangeInComputer.png\"></p>\n<p>如果复杂一点，就是这样：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/Data-Exchange-in-Computer.png\"></p>\n<p>如果看不懂，那就举一个例子，比方说我们现在需要对一个图像进行处理</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/DiagramProcessing.png\"></p>\n<h1 id=\"协处理器（Coprocessor）\"><a href=\"#协处理器（Coprocessor）\" class=\"headerlink\" title=\"协处理器（Coprocessor）\"></a>协处理器（Coprocessor）</h1><h2 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>协处理器是计算机体系结构中的一种特殊处理器，其设计用于执行特定类型的计算任务，以协助主处理器（Central Processing Unit，CPU）完成特定的运算。</p>\n<ol>\n<li><strong>协处理器（Coprocessor）</strong>：一种辅助处理器，用于处理特定类型的运算，以提高计算机的性能和功能。</li>\n<li><strong>浮点运算单元（Floating-Point Unit，FPU）</strong>：一种协处理器，专门用于执行浮点数运算，包括浮点加法、减法、乘法和除法等。</li>\n<li><strong>图形处理器（Graphics Processing Unit，GPU）</strong>：一种广泛用于图形和并行计算的协处理器，主要用于处理图形和图像相关任务。</li>\n<li><strong>向量处理器（Vector Processor）</strong>：一种协处理器，专门用于执行向量运算，例如同时对一组数据进行加法或乘法。</li>\n<li><strong>数字信号处理器（Digital Signal Processor，DSP）</strong>：一种专门设计用于执行数字信号处理任务的协处理器，常用于音频和图像处理。</li>\n<li><strong>协同处理器（Coprocessor）</strong>：一般指与主处理器协同工作的任何辅助处理器，可以包括浮点运算单元、向量处理器等。</li>\n<li><strong>并行处理（Parallel Processing）</strong>：使用多个处理器或协处理器同时执行任务，以提高整体性能。</li>\n<li><strong>SIMD（Single Instruction, Multiple Data）</strong>：一种并行处理的架构，其中一条指令同时作用于多个数据元素，通常由向量处理器实现。</li>\n<li><strong>MIMD（Multiple Instruction, Multiple Data）</strong>：一种并行处理的架构，其中多个处理器独立执行不同的指令，通常用于多核处理器系统。</li>\n</ol>\n<p>协处理器的使用可以显著提高计算机系统的性能，特别是在需要大量浮点运算、图形处理或并行计算的应用中。不同类型的协处理器针对不同的应用领域和任务设计，以满足多样化的计算需求。</p>\n<h2 id=\"主要类别\"><a href=\"#主要类别\" class=\"headerlink\" title=\"主要类别\"></a>主要类别</h2><p>当涉及到计算机的协处理器时，我们通常指的是一类微处理器，它们执行一些特定的功能，这些功能主处理器（CPU）要么无法执行，要么执行效率不如协处理器高。以下是两个主要类别的协处理器以及它们的专业功能：</p>\n<ol>\n<li><strong>数学协处理器（Math Coprocessor）</strong>：<ul>\n<li><strong>功能（Function）</strong>：执行数学运算，特别是涉及浮点数的复杂计算。</li>\n<li><strong>CPU不能执行的任务</strong>：浮点运算、科学计算和其他需要高精度数学处理的任务。</li>\n<li><strong>例子（Example）</strong>：浮点运算单元（FPU）是一种常见的数学协处理器，负责加速浮点数运算。</li>\n</ul>\n</li>\n<li><strong>图形协处理器（Graphics Coprocessor）</strong>：<ul>\n<li><strong>功能（Function）</strong>：处理图形和图像相关的任务，包括渲染和加速图形处理。</li>\n<li><strong>CPU不能执行的任务</strong>：3D图形渲染、视频解码和其他图形密集型工作。</li>\n<li><strong>例子（Example）</strong>：图形处理器（GPU）是一种广泛应用的图形协处理器，用于加速图形相关计算。</li>\n</ul>\n</li>\n</ol>\n<p>这些协处理器的存在使得计算机系统能够更高效地执行特定任务，因为它们专门设计用于处理与这些任务相关的计算。协处理器和主处理器之间通过协同工作，共同提高了整体系统的性能，特别是在需要大量数学计算或图形处理的应用中。</p>\n<h1 id=\"总线\"><a href=\"#总线\" class=\"headerlink\" title=\"总线\"></a>总线</h1><p>总线（Bus）在计算机中是一种用于数据传输的通信系统，它连接了计算机内部的各个组件，如中央处理器（CPU）、内存、输入输出设备等。总线起着数据传输和信息交换的桥梁作用，使得计算机内部各个部分能够协同工作。以下是对计算机总线的详细解释：</p>\n<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><ol>\n<li><strong>数据传输：</strong> 总线用于在计算机内各个组件之间传输数据，包括指令、数据和控制信息。</li>\n<li><strong>信息交换：</strong> 通过总线，不同的硬件组件可以彼此通信，共享信息。这使得中央处理器能够与内存、输入输出设备等进行有效的沟通。</li>\n<li><strong>系统协调：</strong> 总线有助于协调系统中不同部分的工作，确保数据的正确流动和处理。</li>\n</ol>\n<h2 id=\"组成\"><a href=\"#组成\" class=\"headerlink\" title=\"组成\"></a>组成</h2><p>总线通常被分为三个主要部分：</p>\n<ol>\n<li><strong>数据总线（Data Bus）：</strong> 用于传输数据，包括指令和信息。数据总线的宽度决定了每次可以传输的数据位数。</li>\n<li><strong>地址总线（Address Bus）：</strong> 用于指定数据的存储位置，即内存地址。地址总线的宽度决定了系统能够寻址的内存空间大小。</li>\n<li><strong>控制总线（Control Bus）：</strong> 用于传输控制信号，包括读/写、时钟、中断等控制信息，以及其他与数据传输相关的控制信号。</li>\n</ol>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><ol>\n<li><strong>初始化：</strong> 在计算机启动时，总线的初始状态被设定。这包括总线的宽度、时钟频率等。</li>\n<li><strong>通信协议：</strong> 计算机系统内的各个组件必须遵循一定的通信协议，以确保正确的数据传输和处理。</li>\n<li><strong>地址识别：</strong> 当中央处理器需要读取或写入数据时，它通过地址总线发送目标内存地址。其他组件通过监测地址总线的状态来确定是否是自己的地址。</li>\n<li><strong>数据传输：</strong> 中央处理器通过数据总线向内存或其他设备发送数据，或者从中读取数据。控制总线用于传输控制信号，指导数据的读写操作。</li>\n<li><strong>同步和时序：</strong> 总线操作需要保持同步，以确保不同组件的操作在正确的时序下进行。时钟信号通常用于同步整个系统。</li>\n</ol>\n<h2 id=\"为什么选择总线？\"><a href=\"#为什么选择总线？\" class=\"headerlink\" title=\"为什么选择总线？\"></a>为什么选择总线？</h2><p>每个硬件单元都连接到这些总线上。这是构建复杂系统的简单方式，其中每个单元都能够与其他单元进行通信。这种设计使得插入新单元和替换故障单元时的干扰很小。</p>\n<ul>\n<li><strong>通信：</strong> 总线的存在使得各个硬件单元之间能够轻松地进行通信。通过总线，中央处理器可以向内存发送指令，图形处理器可以向显示器发送图像数据，输入设备可以将用户的指令传递给中央处理器，等等。这种通信是系统正常运作的关键。</li>\n<li><strong>系统扩展：</strong> 新的硬件单元可以相对容易地添加到系统中，而不会对现有的系统结构产生太大的干扰。这种可扩展性使得计算机系统能够适应不断变化的需求，同时提供更强大的计算能力。</li>\n<li><strong>故障处理：</strong> 当硬件单元发生故障时，可以相对容易地将其从总线上断开，并替换为一个正常的单元，而不会对整个系统产生重大的影响。这种模块化的设计有助于系统的可维护性和可靠性。</li>\n</ul>\n<p>总的来说，总线的存在提供了一种灵活、可扩展且容错的系统架构，使得计算机能够更有效地处理各种任务，并且更容易适应硬件的变化和故障的修复。这种设计理念在计算机系统的发展中一直是至关重要的。</p>\n<h2 id=\"总线和点对点连接\"><a href=\"#总线和点对点连接\" class=\"headerlink\" title=\"总线和点对点连接\"></a>总线和点对点连接</h2><h3 id=\"总线的连接方式\"><a href=\"#总线的连接方式\" class=\"headerlink\" title=\"总线的连接方式\"></a>总线的连接方式</h3><ul>\n<li><strong>集中连接：</strong> 在总线连接中，所有组件都通过一组共享的导线（总线）连接在一起。这样的设计允许所有组件共享相同的通信通道，简化了连接结构。</li>\n<li><strong>简化通信：</strong> 总线允许多个组件通过相同的通信通道传输数据，使得各个组件之间的通信变得简单。但在同一时刻，只有一个组件能够使用总线进行数据传输。</li>\n<li><strong>易于扩展：</strong> 添加新组件相对容易，因为它们只需连接到总线上即可。总线连接适用于中小规模系统，例如个人计算机。</li>\n</ul>\n<h3 id=\"点对点的连接方式\"><a href=\"#点对点的连接方式\" class=\"headerlink\" title=\"点对点的连接方式\"></a>点对点的连接方式</h3><ul>\n<li><strong>分散连接：</strong> 在点对点连接中，每个组件之间都有专门的连接线，即点对点连接。每对组件之间需要一条独立的通信路径。</li>\n<li><strong>复杂的连接结构：</strong> 随着系统中组件数量的增加，点对点连接的路径数量呈 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.781ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"6.204ex\" height=\"3.15ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -1047.1 2742.3 1392.1\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mfrac\"><g data-mml-node=\"mrow\" transform=\"translate(220,516.8) scale(0.707)\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(600,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(989,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(1589,0)\"><path data-c=\"2212\" d=\"M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(2367,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(2867,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g><g data-mml-node=\"mn\" transform=\"translate(1194.4,-345) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g><rect width=\"2502.3\" height=\"60\" x=\"120\" y=\"220\"></rect></g></g></g></svg></mjx-container> 的增长，其中 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.025ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.357ex\" height=\"1.025ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -442 600 453\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g></g></g></svg></mjx-container> 为组件的数量。这导致了复杂的连接结构。</li>\n<li><strong>数据高速公路：</strong> 每个点对点连接可能需要一条全宽度的数据高速公路，使得所需的导线数量急剧增加。例如，32位数据线和6条控制线可能会导致大量的导线。</li>\n</ul>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><ul>\n<li><strong>导线数量增多：</strong> 点对点连接的主要问题之一是需要大量的导线。这样的复杂连接结构使得系统设计更为困难，而且可能导致电磁干扰等问题。</li>\n<li><strong>系统复杂度提高：</strong> 点对点连接方式对系统的管理和维护提出了更高的要求，因为每次添加新组件都需要建立新的连接。</li>\n</ul>\n<h3 id=\"总线连接的优势\"><a href=\"#总线连接的优势\" class=\"headerlink\" title=\"总线连接的优势\"></a>总线连接的优势</h3><ul>\n<li><strong>导线数量较少：</strong> 总线连接所需的导线数量远远小于点对点连接。这样的设计降低了系统的复杂性，使得连接更为简单。</li>\n<li><strong>单一数据传输通道：</strong> 总线一次只能传输一个数据项，类似于一条铁路线。这样的设计在简单系统中可以工作良好，但对于一些大规模的高性能系统，可能会出现总线瓶颈（Bus Bottleneck）的问题。</li>\n</ul>\n<h3 id=\"总线瓶颈（Bus-Bottleneck）的问题\"><a href=\"#总线瓶颈（Bus-Bottleneck）的问题\" class=\"headerlink\" title=\"总线瓶颈（Bus Bottleneck）的问题\"></a>总线瓶颈（Bus Bottleneck）的问题</h3><ul>\n<li><strong>性能限制：</strong> 由于总线一次只能传输有限的数据量，即使提高处理器的速度也不能充分发挥其性能。这被称为总线瓶颈，是总线连接方式的一个局限。</li>\n<li><strong>难以解决：</strong> 增加处理器的速度并不能解决总线瓶颈的问题，因为总线仍然是数据传输的瓶颈。为了提高整个系统的性能，可能需要采用其他更先进的互连技术。</li>\n</ul>\n<h3 id=\"点对点连接的劣势\"><a href=\"#点对点连接的劣势\" class=\"headerlink\" title=\"点对点连接的劣势\"></a>点对点连接的劣势</h3><ul>\n<li><strong>导线数量增多：</strong> 点对点连接需要大量的导线，这使得系统的物理布局和维护变得更加复杂。这也可能导致电磁干扰等问题。</li>\n<li><strong>系统复杂性提高：</strong> 点对点连接对系统的管理和维护提出了更高的要求，因为每次添加新组件都需要建立新的连接。</li>\n</ul>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><ul>\n<li><strong>互连技术：</strong> 针对总线瓶颈问题，一些先进的互连技术被引入，例如高速总线、点对点互连网络（如光纤通信），以提高系统的整体性能。</li>\n<li><strong>并行计算：</strong> 通过引入并行计算，允许多个处理器同时执行任务，从而缓解了总线瓶颈的问题。</li>\n<li><strong>系统设计优化：</strong> 在设计系统时，工程师需要权衡总线连接和点对点连接之间的优缺点，选择适当的互连方案，以满足特定的性能和可扩展性需求。</li>\n</ul>\n<h1 id=\"寄存器\"><a href=\"#寄存器\" class=\"headerlink\" title=\"寄存器\"></a>寄存器</h1><p>当涉及到计算机的寄存器时，它们是CPU内部的小型、高速内存块，用于临时存储数据和地址变量。以下是一些常见的CPU寄存器以及它们的主要作用：</p>\n<ol>\n<li><strong>指令指针 (Instruction Pointer, IP) 或 程序计数器 (Program Counter, PC)：</strong><ul>\n<li>作用：存储下一条要执行的指令的地址。</li>\n<li>每当一条指令被执行，指令指针会自动增加，指向下一条指令的地址，以便顺序执行程序。</li>\n</ul>\n</li>\n<li><strong>累加器 (Accumulator) - AX, EAX（在Pentium中）：</strong><ul>\n<li>作用：通用数据寄存器，用于存储运算的中间结果或操作数。</li>\n<li>在一些体系结构中，累加器常用于算术运算和逻辑运算。</li>\n</ul>\n</li>\n<li><strong>指令寄存器 (Instruction Register, IR)：</strong><ul>\n<li>作用：存储当前正在执行的指令。</li>\n<li>指令寄存器中保存了当前被取出并正在执行的指令，CPU根据其中的指令码执行相应的操作。</li>\n</ul>\n</li>\n<li><strong>内存地址寄存器 (Memory Address Register, MAR)：</strong><ul>\n<li>作用：在总线传输期间，临时存储内存地址。</li>\n<li>当CPU需要读取或写入内存时，内存地址寄存器暂时保存目标内存地址，确保数据被正确地加载到或写入内存中。</li>\n</ul>\n</li>\n<li><strong>内存缓冲寄存器 (Memory Buffer Register, MBR)：</strong><ul>\n<li>作用：在总线传输期间，临时存储数据。</li>\n<li>MBR保存从内存中读取的数据或将要写入内存的数据，通过总线与内存进行数据传输。</li>\n</ul>\n</li>\n</ol>\n<p>这些寄存器在指令的执行过程中相互配合，协同工作。指令指针指向下一条要执行的指令，累加器存储运算的中间结果，指令寄存器保存当前执行的指令，而内存地址寄存器和内存缓冲寄存器则协助CPU与主内存进行数据交互。这种协同工作使得CPU能够高效地执行计算机程序。</p>\n<h1 id=\"指令集\"><a href=\"#指令集\" class=\"headerlink\" title=\"指令集\"></a>指令集</h1><p>计算机与处理器之间的交流是通过机器语言进行的。机器语言是一种特定处理器能够理解的指令集合，这些指令被设计成能够在计算机上直接执行，而无需翻译。机器语言指令集合也被称为指令集体系结构（Instruction Set Architecture, ISA）。</p>\n<h2 id=\"要点\"><a href=\"#要点\" class=\"headerlink\" title=\"要点\"></a>要点</h2><ol>\n<li><strong>机器语言指令集：</strong><ul>\n<li>机器语言指令集是一组特定处理器能够理解和执行的指令。</li>\n<li>指令集决定了处理器能够执行的基本操作，例如加法（ADD）、减法（SUB）、递增（INC）、递减（DEC）等。</li>\n</ul>\n</li>\n<li><strong>机器语言指令：</strong><ul>\n<li>机器语言指令是针对特定CPU设计的二进制代码，表示一条计算机程序中的基本操作。</li>\n<li>这些指令是直接由CPU执行的，无需进一步翻译。</li>\n</ul>\n</li>\n<li><strong>不同CPU的指令集：</strong><ul>\n<li>不同的处理器架构具有不同的指令集，因此特定的机器语言指令只能在与之兼容的处理器上执行。</li>\n<li>例如，x86架构的指令集与ARM架构的指令集是不同的，因此同一份源代码需要根据目标处理器进行适当的编译。</li>\n</ul>\n</li>\n<li><strong>机器码和汇编语言：</strong><ul>\n<li>机器语言也被称为机器码，是计算机能够直接执行的二进制形式的指令。</li>\n<li>汇编语言是一种人类可读的低级编程语言，它使用助记符（mnemonics）来表示机器语言指令，提供更容易理解和编写的界面。</li>\n</ul>\n</li>\n<li><strong>基本操作：</strong><ul>\n<li>机器语言指令集包括各种基本操作，如算术运算（ADD、SUB）、逻辑运算、数据传输、分支跳转等，这些指令充分利用了CPU内部的寄存器和运算单元。</li>\n</ul>\n</li>\n</ol>\n<p>机器语言为计算机提供了最底层的操作指令，允许程序直接与硬件进行交互。程序员可以使用汇编语言将高级语言编写的程序翻译成对应的机器语言，以便在特定的处理器上执行。机器语言的直接执行使得计算机能够高效地执行各种任务。</p>\n<h2 id=\"取指令-执行循环（Fetch-Execute-Cycle）\"><a href=\"#取指令-执行循环（Fetch-Execute-Cycle）\" class=\"headerlink\" title=\"取指令-执行循环（Fetch-Execute Cycle）\"></a>取指令-执行循环（Fetch-Execute Cycle）</h2><h3 id=\"基本介绍\"><a href=\"#基本介绍\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h3><p>指令是如何执行的基本过程被称为取指令-执行循环（Fetch-Execute Cycle）或机器周期。这是一个循环过程，其中程序中的每一条指令都被执行。该循环包括以下步骤：</p>\n<ol>\n<li><strong>取指令（Fetch）：</strong><ul>\n<li>在这一阶段，计算机从存储器（通常是主内存）中读取下一条指令。</li>\n<li>指令指针（或程序计数器）存储了当前要执行的指令的地址，该地址被用于访问内存。</li>\n</ul>\n</li>\n<li><strong>解码（Decode）：</strong><ul>\n<li>一旦指令被取出，CPU会解码它。解码的过程涉及将二进制指令翻译成CPU能够理解和执行的控制信号。</li>\n<li>解码阶段确定了指令的操作类型、操作数的位置以及执行其他与指令相关的必要操作。</li>\n</ul>\n</li>\n<li><strong>执行（Execute）：</strong><ul>\n<li>在执行阶段，CPU执行指令所指定的操作。这可能包括算术运算、逻辑运算、数据传输等。</li>\n<li>执行阶段还可能影响标志寄存器的状态，例如设置零标志或进位标志，以便在后续的条件分支中使用。</li>\n</ul>\n</li>\n<li><strong>回写（Write Back）：</strong><ul>\n<li>在某些情况下，执行阶段可能会导致对寄存器或内存的写入操作。这些写入操作在回写阶段完成，将结果存储回寄存器或内存中。</li>\n</ul>\n</li>\n<li><strong>重复：</strong><ul>\n<li>一旦一条指令的执行完成，指令指针会自动增加，指向下一条要执行的指令的地址。整个过程随后重复，执行下一条指令。</li>\n</ul>\n</li>\n</ol>\n<p>这个取指令-执行循环是计算机的基本操作方式，它允许计算机按照程序的顺序逐条执行指令。这个循环的速度非常快，以至于在极短的时间内，计算机能够执行数百万条指令。这种高效率是计算机在处理各种任务时的基础。</p>\n<h3 id=\"具体讲解\"><a href=\"#具体讲解\" class=\"headerlink\" title=\"具体讲解\"></a>具体讲解</h3><p>机器周期（Machine Cycle）是计算机执行指令的基本周期性过程，通常由取指令周期（Fetch Cycle）和执行周期（Execute Cycle）组成。下面详细解释机器周期的两个主要阶段：</p>\n<ol>\n<li><strong>取指令周期（Fetch Cycle）：</strong><ul>\n<li><strong>取指令阶段（Fetch Instruction）：</strong> CPU从存储器（通常是主内存）中读取下一条指令。指令的地址由指令指针（或程序计数器）提供。</li>\n<li><strong>指令译码阶段（Decode Instruction）：</strong> 取出的指令被解码成CPU能够理解的控制信号。这个阶段确定指令的操作类型、操作数的位置等。</li>\n<li><strong>更新指令指针阶段：</strong> 当取指令阶段完成后，指令指针被更新，指向下一条要执行的指令的地址。</li>\n</ul>\n</li>\n<li><strong>执行周期（Execute Cycle）：</strong><ul>\n<li><strong>执行阶段（Execute Instruction）：</strong> CPU执行指令所指定的操作，包括算术运算、逻辑运算、数据传输等。</li>\n<li><strong>访存阶段（Memory Access）：</strong> 在某些指令中，可能需要访问内存，这个阶段用于读取或写入内存中的数据。</li>\n<li><strong>写回阶段（Write Back）：</strong> 如果执行阶段导致对寄存器或内存的写入操作，结果将在这个阶段写回寄存器或内存。</li>\n</ul>\n</li>\n</ol>\n<p>整个机器周期包含取指令周期和执行周期，这两个阶段交替进行。一条指令的执行完成后，CPU将自动开始下一条指令的取指令周期，这种循环不断重复，直到程序执行完毕。</p>\n<p>这里是一个简单的机器周期的示意图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/MachineCycle.png\"></p>\n<p>比方说，如果我要循环计算1到100的和，这个指令的机器周期是如何执行的呢？</p>\n<p>我们先考虑这个循环怎么写，用伪代码先写一下：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">sum = 0\nfor i = 1 to 100\n    sum = sum + i</code></pre>\n\n<p>这个循环的周期示意图如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/PlusLoop.png\"></p>\n<h4 id=\"取指令周期\"><a href=\"#取指令周期\" class=\"headerlink\" title=\"取指令周期\"></a>取指令周期</h4><p>在机器周期的“取指令阶段”中，具体步骤可以进一步细化如下：</p>\n<ol>\n<li><strong>将指令指针（IP）寄存器中的地址复制到地址总线：</strong><ul>\n<li>在“取指令阶段”开始时，计算机将指令指针（IP）寄存器中存储的地址复制到地址总线上。地址总线是连接CPU和内存的通道，它传递指向下一条指令的地址。</li>\n</ul>\n</li>\n<li><strong>将地址传递到内存地址寄存器（MAR）：</strong><ul>\n<li>通过地址总线，将指令指针（IP）中的地址传递到内存地址寄存器（MAR）。MAR保存了即将被访问的内存地址。</li>\n</ul>\n</li>\n<li><strong>递增指令指针（IP）：</strong><ul>\n<li>在指令执行完成后，指令指针（IP）被递增，为下一轮机器周期做好准备。这确保了程序的下一条指令将在内存中的正确位置。</li>\n</ul>\n</li>\n<li><strong>内存选择并将内容复制到数据总线：</strong><ul>\n<li>根据MAR中的地址，内存选择相应的位置，并将该位置的内容复制到数据总线上。数据总线是CPU与内存之间传递数据的通道。</li>\n</ul>\n</li>\n<li><strong>CPU将指令代码从数据总线复制到指令寄存器（IR）：</strong><ul>\n<li>在数据总线上的内容包含下一条指令的二进制代码。CPU将这些代码复制到指令寄存器（IR）中，以便进一步的解码和执行。</li>\n</ul>\n</li>\n<li><strong>开始指令的解码：</strong><ul>\n<li>解码阶段开始。指令寄存器（IR）中的二进制代码被解释成CPU能够理解的控制信号。解码确定了指令的操作类型、操作数的位置等，为执行阶段提供了必要的信息。</li>\n</ul>\n</li>\n</ol>\n<p>在这个过程中，计算机系统通过地址总线和数据总线进行信息的传递，确保指令能够被正确地提取、解码和执行。这个取指令阶段是机器周期的起始点，为计算机执行程序提供了基本的指导。</p>\n<h4 id=\"执行周期\"><a href=\"#执行周期\" class=\"headerlink\" title=\"执行周期\"></a>执行周期</h4><p>在机器周期的“执行阶段”，实际的执行操作取决于指令的类型。让我们以一条MOV（Move）指令的执行为例，具体包括以下步骤：</p>\n<ol>\n<li><strong>IP被复制到地址总线并锁存到内存：</strong><ul>\n<li>首先，指令指针（IP）的内容被复制到地址总线上，并通过地址总线传递到内存。这个过程将确保CPU与正确的内存地址通信。</li>\n</ul>\n</li>\n<li><strong>IP被递增：</strong><ul>\n<li>在这一步骤中，指令指针（IP）被递增，以指向下一条指令的地址。这保证了程序的正常流程，CPU将执行程序中的下一条指令。</li>\n</ul>\n</li>\n<li><strong>从内存中选取的值被复制到数据总线：</strong><ul>\n<li>根据经过递增后的IP的地址，内存选择相应的位置，将该位置的内容复制到数据总线上。数据总线是CPU与内存之间传递数据的通道。</li>\n</ul>\n</li>\n<li><strong>CPU将数据总线上的值复制到AX寄存器：</strong><ul>\n<li>在这个阶段，CPU将数据总线上的内容复制到AX寄存器中。在这个例子中，指令是MOV AX, 256，所以从内存中读取的值（256）将被加载到AX寄存器中。</li>\n</ul>\n</li>\n</ol>\n<p>总体而言，执行阶段的步骤取决于具体的指令。不同的指令会涉及不同的操作，可能包括内存读写、寄存器操作、算术运算等。这里的例子是MOV指令，它主要用于将一个值从一个地方移动到另一个地方。在执行阶段，CPU根据指令的需求从内存中读取数据，并将其传输到寄存器中。</p>\n<h1 id=\"CISC-RISC\"><a href=\"#CISC-RISC\" class=\"headerlink\" title=\"CISC & RISC\"></a>CISC &amp; RISC</h1><p>CISC（Complex Instruction Set Computing）和RISC（Reduced Instruction Set Computing）是两种不同的计算机体系结构设计理念，它们在指令集的设计和执行方式上有着显著的区别。</p>\n<h2 id=\"介绍-2\"><a href=\"#介绍-2\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><h3 id=\"CISC\"><a href=\"#CISC\" class=\"headerlink\" title=\"CISC\"></a>CISC</h3><p><strong>CISC（复杂指令集计算）:</strong></p>\n<ul>\n<li><strong>特点：</strong> CISC架构的特点是指令集非常丰富且复杂，一条指令可以执行多个低级操作，甚至包括复杂的内存访问模式。指令长度通常变化，有些指令可能需要多个时钟周期才能执行完成。</li>\n<li><strong>应用：</strong> CISC架构主要应用在大型主机和个人计算机（PC）等系统上，如x86架构。</li>\n<li><strong>优点：</strong> 单条指令可以执行多个操作，有助于提高程序的紧凑性。</li>\n<li><strong>缺点：</strong> 复杂的指令集会导致硬件更复杂，难以达到高性能。指令的复杂性可能导致较长的时钟周期。</li>\n</ul>\n<h3 id=\"RISC\"><a href=\"#RISC\" class=\"headerlink\" title=\"RISC\"></a>RISC</h3><p><strong>RISC（精简指令集计算）:</strong></p>\n<ul>\n<li><strong>特点：</strong> RISC架构的特点是指令集相对简单，每条指令只执行一个基本的操作，指令长度通常是固定的，而且执行速度相对较快。</li>\n<li><strong>应用：</strong> RISC架构主要应用在嵌入式系统和一些高性能计算机上，如ARM和MIPS架构。</li>\n<li><strong>优点：</strong> 简化的指令集有助于简化处理器的硬件设计，提高执行效率，使处理器更容易实现流水线和乱序执行等技术。</li>\n<li><strong>缺点：</strong> 由于每个指令执行的操作较为简单，某些情况下可能需要更多的指令来完成复杂的任务。</li>\n</ul>\n<h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><ul>\n<li><strong>CISC vs. RISC：</strong> CISC处理器通常有更多的指令，每条指令执行的工作更复杂，而RISC处理器则倾向于简化指令集，每条指令执行的工作更单一。</li>\n<li><strong>性能：</strong> 在相同的时钟频率下，RISC处理器通常能够提供更高的性能，因为简化的指令集有助于更好地利用流水线和其他硬件优化。</li>\n<li><strong>成本：</strong> RISC处理器的硬件相对较简单，制造成本可能更低，但CISC处理器的广泛应用使得它们在市场上仍然存在。</li>\n</ul>\n<h2 id=\"组织方式\"><a href=\"#组织方式\" class=\"headerlink\" title=\"组织方式\"></a>组织方式</h2><h3 id=\"RISC（精简指令集计算）\"><a href=\"#RISC（精简指令集计算）\" class=\"headerlink\" title=\"RISC（精简指令集计算）\"></a>RISC（精简指令集计算）</h3><ul>\n<li>在RISC架构中，一条指令通常由一个字（word）表示，字的长度是固定的。这种设计使得指令的解析和执行相对简单，因为每条指令的长度都是已知的，不需要额外的解析步骤。</li>\n<li>RISC指令通常相对简单，执行一个基本操作，如加载寄存器、执行算术运算等。因此，每条指令的长度都趋向于保持一致，这有助于设计更加流水线化和高效的执行单元。</li>\n</ul>\n<h3 id=\"CISC（复杂指令集计算）\"><a href=\"#CISC（复杂指令集计算）\" class=\"headerlink\" title=\"CISC（复杂指令集计算）\"></a>CISC（复杂指令集计算）</h3><ul>\n<li>在CISC架构中，一条指令可能由多个字组成，长度可能是可变的。CISC指令可能包含多个操作，甚至可能包括复杂的内存寻址模式。这种多字节的指令需要多次取指令操作才能完全获取，并且在解析和执行上可能更加复杂。</li>\n<li>CISC指令的长度和复杂性可以使得在处理器中解析和执行指令变得更为复杂，因为指令的长度和格式可能是不确定的。</li>\n</ul>\n<h3 id=\"比较-1\"><a href=\"#比较-1\" class=\"headerlink\" title=\"比较\"></a>比较</h3><ul>\n<li>在RISC中，指令的固定长度和简单性使得指令的解析和执行相对更加高效和直接。</li>\n<li>在CISC中，由于指令的复杂性和可变长度，可能需要更多的时钟周期来解析和执行指令，因为一条指令的多个字可能需要多个时钟周期才能完全获取。</li>\n</ul>\n<p>总体而言，这个差异体现了RISC的设计原则，即保持指令简单和固定长度，以便在执行过程中更好地利用流水线和其他硬件优化。而CISC则追求提供更丰富和功能强大的指令集，以便用更少的指令完成更多的工作，但这可能会引入一些复杂性。选择CISC或RISC架构通常取决于特定应用的需求以及对性能和成本的权衡。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>RISC（精简指令集计算）被认为更快的原因主要有以下几点：</p>\n<ol>\n<li><strong>空出的芯片区域用于加速常用指令的性能：</strong></li>\n</ol>\n<ul>\n<li>在RISC架构中，由于指令较为简单，每条指令的长度相对较短，因此在芯片上会留下一些空闲的区域。这些空闲区域可以被用来集中优化对性能影响较大的常用指令。例如，这些区域可以用于增加缓存大小，提高指令和数据的访问速度，或者用于实现更高级的流水线技术，以加速指令的执行。</li>\n</ul>\n<ol start=\"2\">\n<li><strong>更容易优化设计：</strong></li>\n</ol>\n<ul>\n<li>RISC架构的指令集相对简单，这使得处理器的硬件设计更容易进行优化。设计人员可以专注于提高执行单元的效率、增加流水线阶段、实现更高级的超标量或乱序执行等技术，而无需过多考虑复杂指令集所带来的复杂性。</li>\n</ul>\n<ol start=\"3\">\n<li><strong>更容易从高级语言翻译成小型指令集：</strong></li>\n</ol>\n<ul>\n<li>RISC架构的指令集通常更接近高级编程语言的结构，这使得从高级语言翻译成硬件可执行的指令更为简单。简化的指令集有助于编译器生成更高效、更紧凑的机器代码，减少了编译器的复杂性。这样的优势在编译过程中能够更有效地使用硬件资源，生成更优化的程序。</li>\n</ul></blockquote>\n","feature":true,"text":"冯·诺依曼模型冯·诺依曼模型（Von Neumann architecture）是计算机体系结构的一种基本设计范式，由匈牙利数学家和计算机科学家约翰·冯·诺依曼（John von Neumann）于20世纪40年代提出。这个模型成为了现代计算机体系结构的基础，几乎所有的通用计算机...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"CPT101复习","slug":"CPT101复习","count":7,"path":"api/tags/CPT101复习.json"},{"name":"笔记","slug":"笔记","count":51,"path":"api/tags/笔记.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%AF%C2%B7%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">冯·诺依曼模型</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86\"><span class=\"toc-text\">计算机的主要组成部分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CPU\"><span class=\"toc-text\">CPU</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E5%82%A8%E5%AD%98%E5%99%A8%EF%BC%88Main-Memory%EF%BC%89\"><span class=\"toc-text\">主储存器（Main Memory）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%8D%95%E5%85%83%EF%BC%88I-O-Units%EF%BC%89\"><span class=\"toc-text\">输入输出单元（I&#x2F;O Units）</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E6%9D%BF%EF%BC%88Mother-Board%EF%BC%89\"><span class=\"toc-text\">主板（Mother Board）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90\"><span class=\"toc-text\">主要组成</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E4%B8%AA%E4%B8%BB%E8%A6%81%E5%AD%90%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">三个主要子系统</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">交换数据</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E6%84%8F%E5%9B%BE\"><span class=\"toc-text\">示意图</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%88Coprocessor%EF%BC%89\"><span class=\"toc-text\">协处理器（Coprocessor）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%8B%E7%BB%8D-1\"><span class=\"toc-text\">介绍</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E8%A6%81%E7%B1%BB%E5%88%AB\"><span class=\"toc-text\">主要类别</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BA%BF\"><span class=\"toc-text\">总线</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%84%E6%88%90\"><span class=\"toc-text\">组成</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">工作原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E6%80%BB%E7%BA%BF%EF%BC%9F\"><span class=\"toc-text\">为什么选择总线？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BA%BF%E5%92%8C%E7%82%B9%E5%AF%B9%E7%82%B9%E8%BF%9E%E6%8E%A5\"><span class=\"toc-text\">总线和点对点连接</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BA%BF%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">总线的连接方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%82%B9%E5%AF%B9%E7%82%B9%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">点对点的连接方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BA%BF%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">总线连接的优势</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BA%BF%E7%93%B6%E9%A2%88%EF%BC%88Bus-Bottleneck%EF%BC%89%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">总线瓶颈（Bus Bottleneck）的问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%82%B9%E5%AF%B9%E7%82%B9%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8A%A3%E5%8A%BF\"><span class=\"toc-text\">点对点连接的劣势</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">解决方案</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">寄存器</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%8C%87%E4%BB%A4%E9%9B%86\"><span class=\"toc-text\">指令集</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A6%81%E7%82%B9\"><span class=\"toc-text\">要点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%96%E6%8C%87%E4%BB%A4-%E6%89%A7%E8%A1%8C%E5%BE%AA%E7%8E%AF%EF%BC%88Fetch-Execute-Cycle%EF%BC%89\"><span class=\"toc-text\">取指令-执行循环（Fetch-Execute Cycle）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">基本介绍</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B7%E4%BD%93%E8%AE%B2%E8%A7%A3\"><span class=\"toc-text\">具体讲解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%96%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">取指令周期</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%A7%E8%A1%8C%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">执行周期</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#CISC-RISC\"><span class=\"toc-text\">CISC &amp; RISC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%8B%E7%BB%8D-2\"><span class=\"toc-text\">介绍</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CISC\"><span class=\"toc-text\">CISC</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RISC\"><span class=\"toc-text\">RISC</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">比较</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">组织方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RISC%EF%BC%88%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E9%9B%86%E8%AE%A1%E7%AE%97%EF%BC%89\"><span class=\"toc-text\">RISC（精简指令集计算）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CISC%EF%BC%88%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4%E9%9B%86%E8%AE%A1%E7%AE%97%EF%BC%89\"><span class=\"toc-text\">CISC（复杂指令集计算）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AF%94%E8%BE%83-1\"><span class=\"toc-text\">比较</span></a></li></ol></li></ol></li></ol>","author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}},"mapped":true,"prev_post":{"title":"CPT104 Learning Week1","uid":"103cf105d957389e86194541d8104f98","slug":"CPT104-Learning-Week1","date":"2024-02-26T09:46:35.000Z","updated":"2024-03-07T11:08:51.319Z","comments":true,"path":"api/articles/CPT104-Learning-Week1.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/CPT104-img.png","text":"开学第一课，操作系统原理。 进程什么是进程？进程就是程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位。 简单来说，进程就是程序的一次执行过程，程序是静态的，在计算机系统（CPT101）里面都学了，在冯诺依曼结构中，程序静态地存储在硬盘中。当需要执行时，...","link":"","photos":[],"count_time":{"symbolsCount":"9.7k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":51,"path":"api/tags/笔记.json"},{"name":"CPT104","slug":"CPT104","count":2,"path":"api/tags/CPT104.json"}],"author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}},"feature":true},"next_post":{"title":"CPT101 Review-6","uid":"19c587a1fa2f0478e7eecddf0c905e63","slug":"CPT101-Review-6","date":"2024-01-05T14:42:31.000Z","updated":"2024-01-05T14:42:19.858Z","comments":true,"path":"api/articles/CPT101-Review-6.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/CPT101-img.png","text":"操作系统（Operating Systems）什么是操作系统？操作系统（Operating System，简称OS）是管理计算机硬件和软件资源的系统软件。它提供了一个用户和计算机硬件之间的接口，使得应用程序可以运行并与计算机硬件交互。 操作系统的发展流程发展流程 OS/360 f...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"CPT101复习","slug":"CPT101复习","count":7,"path":"api/tags/CPT101复习.json"},{"name":"笔记","slug":"笔记","count":51,"path":"api/tags/笔记.json"}],"author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}}}}