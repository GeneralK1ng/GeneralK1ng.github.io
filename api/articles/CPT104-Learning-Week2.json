{"title":"CPT104 Learning Week2","uid":"92c1c7c7f1c0da34a8e6904f96b9e4c0","slug":"CPT104-Learning-Week2","date":"2024-03-07T08:30:23.000Z","updated":"2024-03-07T09:42:26.942Z","comments":true,"path":"api/articles/CPT104-Learning-Week2.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/CPT104-img.png","content":"<p>在此之前我要先晒卡，以表达我写本篇文章时喜悦的心情。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/ela.jpg\" alt=\"ELA\"></p>\n<p>好，言归正传，操作系统，我在想要不要再写一个Linux的笔记？正好最近在看相关的东西？</p>\n<p>无所谓，先看课件。</p>\n<h1 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h1><h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h2><p>在此之前，我们先做一个类比。</p>\n<p>首先，我想说明线程和进程是如何工作的。我能想到的最佳方法（除了深入研究实时系统的设计）就是想象我们的线程和进程处于某种情况下。</p>\n<h3 id=\"一个进程就像一个房子\"><a href=\"#一个进程就像一个房子\" class=\"headerlink\" title=\"一个进程就像一个房子\"></a>一个进程就像一个房子</h3><p>让我们用一个普通的日常物品–房子–来类比进程和线程。</p>\n<p>房子其实就是一个容器，具有一定的属性（如建筑面积、卧室数量等）。</p>\n<p>从这个角度看，房子本身并不会主动做任何事情，它只是一个被动对象(<strong>passive object</strong>)。这实际上就是一个进程。我们很快就会探讨这个问题。</p>\n<h3 id=\"线程就是居住者\"><a href=\"#线程就是居住者\" class=\"headerlink\" title=\"线程就是居住者\"></a>线程就是居住者</h3><p>住在房子里的人是活动对象(<strong>active objects</strong>)–他们使用各个房间、看电视、做饭、洗澡等等。我们很快就会看到线程的行为方式。</p>\n<h4 id=\"单线程\"><a href=\"#单线程\" class=\"headerlink\" title=\"单线程\"></a>单线程</h4><p>如果你也感受过一个人在家的时光，你肯定能知道这是一种什么样的美事，你可以随时在家里做任何你想做的事情，因为家里没有其他人，你可以短暂的抛弃公共伦理纲常已经道德约束，包括***，总之就是很爽。</p>\n<h4 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h4><p>但是如果此刻家里多了一个人，或者想想你现在的苦逼宿舍生活，情况就会发生很大的变化。</p>\n<p>幻想一下如果你结婚了，对不起，只是幻想。</p>\n<p>这时，你就不能随便去上厕所了，你必须在此之前检查一下你伴侣是否在里面，无论ta是在洗澡或者是如厕，总之洗手间你是进不去的，特殊情况除外。</p>\n<p>如果房子里住着两个负责任的成年人，一般来说，你可以对 “安全 “放宽要求–你知道另一个成年人会尊重你的空间，不会（故意）点燃厨房等等。</p>\n<p>现在，如果再加上几个孩子，事情就突然变得有趣多了。</p>\n<h3 id=\"返回进程和线程\"><a href=\"#返回进程和线程\" class=\"headerlink\" title=\"返回进程和线程\"></a>返回进程和线程</h3><p>就像一座房子占用了一块土地一样，一个进程也占用了内存。就像房子里的住户可以随意进入任何房间一样，进程的所有线程都可以共同访问内存。如果某个线程分配了某个东西（妈妈出去买了个游戏），其他所有线程都能立即访问它（因为它存在于公共地址空间中，就在房子里）。同样，如果进程分配了内存，那么所有线程也都可以使用这个新内存。这里的诀窍在于识别内存是否应该提供给进程中的所有线程。如果是，那么就需要让所有线程同步访问内存。如果不是，那么我们就假设它是某个特定线程的专用内存。在这种情况下，由于只有该线程可以访问它，所以我们可以认为不需要同步–该线程不会自己绊倒自己！</p>\n<p>从日常生活中我们可以看出，事情并没有那么简单。既然我们已经了解了基本特征（总结：一切都是共享的），下面让我们看看事情变得更有趣的地方和原因。</p>\n<p>所以我们首先就有一句话：<strong>进程是线程的容器</strong></p>\n<h3 id=\"Mutual-exclusion（互斥锁）\"><a href=\"#Mutual-exclusion（互斥锁）\" class=\"headerlink\" title=\"Mutual exclusion（互斥锁）\"></a>Mutual exclusion（互斥锁）</h3><p>回想你苦逼的宿舍生活，如果你半夜突发奇想想要去浴室洗澡，但好巧不巧你的唐氏舍友起夜正在上厕所，怎么办？你就得等，类比到线程当中，线程应该怎么办？</p>\n<p>这就是所谓的“互斥”。意思很简单，就是字面意思，当涉及到某个特定资源时，多个线程之间是互斥的。</p>\n<p>而带入你的唐氏舍友的视角，如果你想在宁静的深夜独占厕所来一场深度灵魂思考的话，那么你一定会走入厕所然后反锁门。以防其他人想要使用厕所，任何想要使用厕所的人都会被锁挡住，直到你的思考结果伴随着水流冲入下水道，其他人才能进去。</p>\n<p>线程就是这么做的，线程使用了一个叫做“Mutex （Mutual Exclusion）”的对象，这个对象就像厕所哥深夜门上的锁，一旦这个线程锁定了互斥锁，其他线程就无法获取这部分内存的资源，直到拥有它的线程将其释放（释放，字面意思），防止多个线程同时读写一块内存区域。</p>\n<p>互斥和门锁的另一个有趣的相似之处是，互斥实际上是一种 ”警告“ 锁。如果线程不遵守使用互斥的约定，那么保护就会失效。就好比你缘的劣质厕所门，专防好人。</p>\n<h3 id=\"优先排列\"><a href=\"#优先排列\" class=\"headerlink\" title=\"优先排列\"></a>优先排列</h3><p>好的，继续刚刚的情景。</p>\n<p>现在那个沉思者即将释放完毕，但是你的另外两个怨种室友突发奇想想要进去深入交流一下学术问题，于是本来只有你一个在床上伺机而动的情况就变了，现在是三个傻逼等待沉思者的释放蠢蠢欲动。</p>\n<p>如果沉思者还在沉思，那一切都好说，大家都会在外面等他，但是真正的问题是，一旦释放完毕，谁进去？</p>\n<p>你会想，显然，谁等的最久，谁就是下一个进去的人，这样才会显得“公平”。</p>\n<p>这个问题就非常的复杂了，你的诉求只是洗澡，而另外两个也许半夜交流的学术问题就能颠覆整个计算机界呢？你怎么敢耽误？</p>\n<p>我们的线程就比你三个怨种聪明，他们只考虑两个因素：<strong>优先级</strong>和<strong>等待时长</strong>。</p>\n<p>假设有两个人同时出现在（锁着的）浴室门口。其中一个人有紧迫的最后期限（他已经要泄洪了），而另一个人没有。让最后期限紧迫的那个人接着去不是很合理吗？当然有道理。唯一的问题是如何决定谁更 “重要”。这可以通过分配优先级来实现（比如让我们随便使用一个数字 ——1 是可用的最低优先级，255 是最高优先级）。房子里有紧迫期限的人会被赋予更高的优先级，而没有紧迫期限的人会被赋予更低的优先级。</p>\n<p>线程就是这样，线程从父线程继承调度算法，但也可以通过一些手段来改变调度策略和优先级。</p>\n<p>如果有多个线程在等待并且互斥，我们会把互斥锁定的交给优先级最高的等待线程。但假设两个人优先级相同该怎么办呢？</p>\n<p>在这种情况下，次要公平的做法就是让等待时间最长的那个人成为下一个。</p>\n<h3 id=\"Semaphores（信号量）\"><a href=\"#Semaphores（信号量）\" class=\"headerlink\" title=\"Semaphores（信号量）\"></a>Semaphores（信号量）</h3><p>好，再用你们的怨种宿舍来举例，为了提高你们宿舍深夜的厕所运作效率，你花费重金买了一个浴帘，于是格局大改，在你洗澡的时刻沉思者依旧可以思考，两不误。但是，从我们刚刚得到的解决方案来看，线程遇到这种情况就束手无策，或者说浪费资源了。</p>\n<p>比方说如果按照互斥锁的逻辑，现在撤硕就有且仅有两种情况：</p>\n<ul>\n<li>门没锁，没人</li>\n<li>门锁了，里面一个沉思者</li>\n</ul>\n<p>不可能有其他的情况，因为厕所如果没人，门就无法上锁，反过来说，一旦一个怨种进去，门就锁上了，那么浴帘就没有什么必要性了。</p>\n<p>这里的关键（恕我直言）在于我们如何描述锁的特性。在典型的浴室锁中，你只能从内部上锁或解锁，没有外部可访问的钥匙。实际上，这意味着对互斥体的所有权是一个原子操作–当你在获取互斥体的过程中，其他线程不可能获取它，从而导致你们同时拥有互斥体。在我们的房屋类比中，这一点就不那么明显了，因为人类比 1 和 0 要聪明得多。</p>\n<p>你们宿舍需要的是另一种“锁”。</p>\n<p>聪明的沉思者思考出来一种方法，在门口装上了传统的钥匙锁，这种锁的原理就很简单，如果你有钥匙，就可以开门进去。但是这个锁使用有一个约定，就是当有怨种拿着钥匙进门后就必须反锁，换言之，外面的人要进去总是需要一把钥匙才可以。哦，并且在没人的时候门也是锁起来的。</p>\n<p>聪明的沉思者灵机一动只配了两把钥匙挂在厕所门口，那么情况就了然了，当沉思者想要思考的时候，就会看看门口有没有挂着钥匙，如果有就拎着钥匙开始释放，如果没有，就老老实实排队。</p>\n<p>进入厕所的怨种必须随身带钥匙，所以可以通过门外挂的钥匙来控制允许进入厕所的人数！</p>\n<p>在线程中，这可以通过一个信号传递器来实现。一个 “普通 “标识符的工作原理就像一个互斥标识符——如果你拥有互斥标识符，这样你就可以访问资源；如果你不拥有互斥标识符，这样你就不能访问资源。我们刚才用厕所描述的标识符是一种计数标识符–它跟踪计数（线程可用键的数量）。</p>\n<p>不难看出，互斥锁 Mutex 是信号量 semaphore 的一种<strong>特殊情况</strong>（n = 1时）。也就是说，完全可以用后者替代前者。但是，因为 Mutex 较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</p>\n<p>好，我累了，先写到这里后面再正式开始什么是线程。</p>\n","feature":true,"text":"在此之前我要先晒卡，以表达我写本篇文章时喜悦的心情。 好，言归正传，操作系统，我在想要不要再写一个Linux的笔记？正好最近在看相关的东西？ 无所谓，先看课件。 线程引入在此之前，我们先做一个类比。 首先，我想说明线程和进程是如何工作的。我能想到的最佳方法（除了深入研究实时系统的...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":51,"path":"api/tags/笔记.json"},{"name":"CPT104","slug":"CPT104","count":2,"path":"api/tags/CPT104.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E5%85%A5\"><span class=\"toc-text\">引入</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%B0%B1%E5%83%8F%E4%B8%80%E4%B8%AA%E6%88%BF%E5%AD%90\"><span class=\"toc-text\">一个进程就像一个房子</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E5%B0%B1%E6%98%AF%E5%B1%85%E4%BD%8F%E8%80%85\"><span class=\"toc-text\">线程就是居住者</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%95%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">单线程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">多线程</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">返回进程和线程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Mutual-exclusion%EF%BC%88%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%89\"><span class=\"toc-text\">Mutual exclusion（互斥锁）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%85%88%E6%8E%92%E5%88%97\"><span class=\"toc-text\">优先排列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Semaphores%EF%BC%88%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%89\"><span class=\"toc-text\">Semaphores（信号量）</span></a></li></ol></li></ol></li></ol>","author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"CPT104 Learning Week1","uid":"103cf105d957389e86194541d8104f98","slug":"CPT104-Learning-Week1","date":"2024-02-26T09:46:35.000Z","updated":"2024-03-07T08:33:34.569Z","comments":true,"path":"api/articles/CPT104-Learning-Week1.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/CPT104-img.png","text":"开学第一课，操作系统原理。 进程什么是进程？进程就是程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位。 简单来说，进程就是程序的一次执行过程，程序是静态的，在计算机系统（CPT101）里面都学了，在冯诺依曼结构中，程序静态地存储在硬盘中。当需要执行时，...","link":"","photos":[],"count_time":{"symbolsCount":"9.7k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":51,"path":"api/tags/笔记.json"},{"name":"CPT104","slug":"CPT104","count":2,"path":"api/tags/CPT104.json"}],"author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}},"feature":true}}