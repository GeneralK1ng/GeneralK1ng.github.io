{"title":"CPT104 Learning Week2","uid":"92c1c7c7f1c0da34a8e6904f96b9e4c0","slug":"CPT104-Learning-Week2","date":"2024-03-07T08:30:23.000Z","updated":"2024-03-07T12:36:47.579Z","comments":true,"path":"api/articles/CPT104-Learning-Week2.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/CPT104-img.png","content":"<p>在此之前我要先晒卡，以表达我写本篇文章时喜悦的心情。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/ela.jpg\" alt=\"ELA\"></p>\n<p>好，言归正传，操作系统，我在想要不要再写一个Linux的笔记？正好最近在看相关的东西？</p>\n<p>无所谓，先看课件。</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在此之前，我们先做一个类比。</p>\n<p>首先，我想说明线程和进程是如何工作的。我能想到的最佳方法（除了深入研究实时系统的设计）就是想象我们的线程和进程处于某种情况下。</p>\n<h2 id=\"进程如同房子\"><a href=\"#进程如同房子\" class=\"headerlink\" title=\"进程如同房子\"></a>进程如同房子</h2><p>我们可以将进程比喻为一座房子，这座房子是一个容器，拥有各种属性，例如建筑面积和卧室数量。这个类比提供了一个直观的图像，让我们更容易理解进程的本质。就像房子本身并不会主动做任何事情一样，进程也是一种被动的对象。它存在于计算机系统中，提供了一定的资源和环境，但不会自发执行任务。</p>\n<p>这个类比揭示了进程的静态特性，但也为我们展开进一步讨论提供了契机。</p>\n<p>从这个角度看，房子本身并不会主动做任何事情，它只是一个被动对象(<strong>passive object</strong>)。这实际上就是一个进程。我们很快就会探讨这个问题。</p>\n<h2 id=\"线程就是居住者\"><a href=\"#线程就是居住者\" class=\"headerlink\" title=\"线程就是居住者\"></a>线程就是居住者</h2><p>现在，让我们把注意力转向线程。如果进程是一座房子，那么线程就是房子里正在发生的各种活动。想象一下，在这个房子中有多个房间，每个房间都发生着不同的活动，就像线程在进程内执行不同的任务。</p>\n<p>这个比喻强调了线程的活跃性和并发性，与进程的被动性形成鲜明对比。线程是进程内部的执行单元，使得程序能够同时执行多个任务。通过这种方式，整个计算过程变得更加灵活和高效。</p>\n<p>住在房子里的人是活动对象(<strong>active objects</strong>)——他们使用各个房间、看电视、做饭、洗澡等等。我们很快就会看到线程的行为方式。</p>\n<h3 id=\"单线程\"><a href=\"#单线程\" class=\"headerlink\" title=\"单线程\"></a>单线程</h3><p>在单线程的情境下，就如同独自一人在家的时光，享受着无拘无束的自由。这种状态下，你可以随心所欲地在家中进行各种活动，毫无担忧，因为没有其他人存在。这种自由让你能够暂时放下公共伦理和道德的约束，体验一种令人愉悦的状态，包括***在内，总之，是一种非常轻松的感觉。</p>\n<h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><p>然而，一旦家中多了一个人，或者你回忆起现在的宿舍生活，情景就会发生翻天覆地的变化。想象一下，如果你结婚了——抱歉，只是一种幻想。</p>\n<p>这时，你就不能再像之前那样随便去上厕所了。你需要在行动之前确认一下你的伴侣是否在里面，无论是在洗澡还是如厕，总之，洗手间变得不再是私人领地，而是需要共享的空间，特殊情况除外。</p>\n<p>如果房子里住着两个负责任的成年人，你可能会对“安全”放宽一些要求——你相信另一个成年人会尊重你的空间，不会（故意）制造困扰，比如点燃厨房等等。</p>\n<p>而当加入几个孩子后，情况就变得更加有趣。</p>\n<h2 id=\"返回进程和线程\"><a href=\"#返回进程和线程\" class=\"headerlink\" title=\"返回进程和线程\"></a>返回进程和线程</h2><p>就像一座房子占用了一块土地一样，一个进程也占用了内存。就像房子里的住户可以随意进入任何房间一样，进程的所有线程都可以共同访问内存。如果某个线程分配了某个东西（妈妈出去买了个游戏），其他所有线程都能立即访问它（因为它存在于公共地址空间中，就在房子里）。同样，如果进程分配了内存，那么所有线程也都可以使用这个新内存。这里的诀窍在于识别内存是否应该提供给进程中的所有线程。如果是，那么就需要让所有线程同步访问内存。如果不是，那么我们就假设它是某个特定线程的专用内存。在这种情况下，由于只有该线程可以访问它，所以我们可以认为不需要同步–该线程不会自己绊倒自己！</p>\n<p>从日常生活中我们可以看出，事情并没有那么简单。既然我们已经了解了基本特征（总结：一切都是共享的），下面让我们看看事情变得更有趣的地方和原因。</p>\n<p>所以我们首先就有一句话：<strong>进程是线程的容器</strong></p>\n<h2 id=\"Mutual-exclusion（互斥锁）\"><a href=\"#Mutual-exclusion（互斥锁）\" class=\"headerlink\" title=\"Mutual exclusion（互斥锁）\"></a>Mutual exclusion（互斥锁）</h2><p>回想你苦逼的宿舍生活，如果你半夜突发奇想想要去浴室洗澡，但好巧不巧你的唐氏舍友起夜正在上厕所，怎么办？你就得等，类比到线程当中，线程应该怎么办？</p>\n<p>这就是所谓的“互斥”。意思很简单，就是字面意思，当涉及到某个特定资源时，多个线程之间是互斥的。</p>\n<p>而带入你的唐氏舍友的视角，如果你想在宁静的深夜独占厕所来一场深度灵魂思考的话，那么你一定会走入厕所然后反锁门。以防其他人想要使用厕所，任何想要使用厕所的人都会被锁挡住，直到你的思考结果伴随着水流冲入下水道，其他人才能进去。</p>\n<p>线程就是这么做的，线程使用了一个叫做“Mutex （Mutual Exclusion）”的对象，这个对象就像厕所哥深夜门上的锁，一旦这个线程锁定了互斥锁，其他线程就无法获取这部分内存的资源，直到拥有它的线程将其释放（释放，字面意思），防止多个线程同时读写一块内存区域。</p>\n<p>互斥和门锁的另一个有趣的相似之处是，互斥实际上是一种 ”警告“ 锁。如果线程不遵守使用互斥的约定，那么保护就会失效。就好比你缘的劣质厕所门，专防好人。</p>\n<h2 id=\"优先排列\"><a href=\"#优先排列\" class=\"headerlink\" title=\"优先排列\"></a>优先排列</h2><p>好的，继续刚刚的情景。</p>\n<p>现在那个沉思者即将释放完毕，但是你的另外两个怨种室友突发奇想想要进去深入交流一下学术问题，于是本来只有你一个在床上伺机而动的情况就变了，现在是三个傻逼等待沉思者的释放蠢蠢欲动。</p>\n<p>如果沉思者还在沉思，那一切都好说，大家都会在外面等他，但是真正的问题是，一旦释放完毕，谁进去？</p>\n<p>你会想，显然，谁等的最久，谁就是下一个进去的人，这样才会显得“公平”。</p>\n<p>这个问题就非常的复杂了，你的诉求只是洗澡，而另外两个也许半夜交流的学术问题就能颠覆整个计算机界呢？你怎么敢耽误？</p>\n<p>我们的线程就比你三个怨种聪明，他们只考虑两个因素：<strong>优先级</strong>和<strong>等待时长</strong>。</p>\n<p>假设有两个人同时出现在（锁着的）浴室门口。其中一个人有紧迫的最后期限（他已经要泄洪了），而另一个人没有。让最后期限紧迫的那个人接着去不是很合理吗？当然有道理。唯一的问题是如何决定谁更 “重要”。这可以通过分配优先级来实现（比如让我们随便使用一个数字 ——1 是可用的最低优先级，255 是最高优先级）。房子里有紧迫期限的人会被赋予更高的优先级，而没有紧迫期限的人会被赋予更低的优先级。</p>\n<p>线程就是这样，线程从父线程继承调度算法，但也可以通过一些手段来改变调度策略和优先级。</p>\n<p>如果有多个线程在等待并且互斥，我们会把互斥锁定的交给优先级最高的等待线程。但假设两个人优先级相同该怎么办呢？</p>\n<p>在这种情况下，次要公平的做法就是让等待时间最长的那个人成为下一个。</p>\n<h2 id=\"Semaphores（信号量）\"><a href=\"#Semaphores（信号量）\" class=\"headerlink\" title=\"Semaphores（信号量）\"></a>Semaphores（信号量）</h2><p>好，再用你们的怨种宿舍来举例，为了提高你们宿舍深夜的厕所运作效率，你花费重金买了一个浴帘，于是格局大改，在你洗澡的时刻沉思者依旧可以思考，两不误。但是，从我们刚刚得到的解决方案来看，线程遇到这种情况就束手无策，或者说浪费资源了。</p>\n<p>比方说如果按照互斥锁的逻辑，现在撤硕就有且仅有两种情况：</p>\n<ul>\n<li>门没锁，没人</li>\n<li>门锁了，里面一个沉思者</li>\n</ul>\n<p>不可能有其他的情况，因为厕所如果没人，门就无法上锁，反过来说，一旦一个怨种进去，门就锁上了，那么浴帘就没有什么必要性了。</p>\n<p>这里的关键（恕我直言）在于我们如何描述锁的特性。在典型的浴室锁中，你只能从内部上锁或解锁，没有外部可访问的钥匙。实际上，这意味着对互斥体的所有权是一个原子操作–当你在获取互斥体的过程中，其他线程不可能获取它，从而导致你们同时拥有互斥体。在我们的房屋类比中，这一点就不那么明显了，因为人类比 1 和 0 要聪明得多。</p>\n<p>你们宿舍需要的是另一种“锁”。</p>\n<p>聪明的沉思者思考出来一种方法，在门口装上了传统的钥匙锁，这种锁的原理就很简单，如果你有钥匙，就可以开门进去。但是这个锁使用有一个约定，就是当有怨种拿着钥匙进门后就必须反锁，换言之，外面的人要进去总是需要一把钥匙才可以。哦，并且在没人的时候门也是锁起来的。</p>\n<p>聪明的沉思者灵机一动只配了两把钥匙挂在厕所门口，那么情况就了然了，当沉思者想要思考的时候，就会看看门口有没有挂着钥匙，如果有就拎着钥匙开始释放，如果没有，就老老实实排队。</p>\n<p>进入厕所的怨种必须随身带钥匙，所以可以通过门外挂的钥匙来控制允许进入厕所的人数！</p>\n<p>在线程中，这可以通过一个信号传递器来实现。一个 “普通 “标识符的工作原理就像一个互斥标识符——如果你拥有互斥标识符，这样你就可以访问资源；如果你不拥有互斥标识符，这样你就不能访问资源。我们刚才用厕所描述的标识符是一种计数标识符–它跟踪计数（线程可用键的数量）。</p>\n<p>不难看出，互斥锁 Mutex 是信号量 semaphore 的一种<strong>特殊情况</strong>（n = 1时）。也就是说，完全可以用后者替代前者。但是，因为 Mutex 较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>为了避免混淆，请注意互斥锁还具有其他属性，例如优先级继承，这是它与信号量的区别所在。</p></blockquote>\n<p>好，我累了，先写到这里后面再正式开始什么是线程。</p>\n<h1 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h1><h2 id=\"什么是线程？\"><a href=\"#什么是线程？\" class=\"headerlink\" title=\"什么是线程？\"></a>什么是线程？</h2><p>这一段我复制百度百科，单纯是我不想自己给定义。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>线程（thread）是操作系统能够进行运算调度的<strong>最小单位</strong>。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p></blockquote>\n<p>我还是喜欢类比来记忆，按照上面的说法，我们可以得出四个怨种就是线程，宿舍就是进程，然后一个进程当中可以有多个线程，线程之间通过各种关系共享一个进程当中的资源。</p>\n<p>好，对吧，这就是我给的一个简单的定义，并且方便记忆。</p>\n<p>好吧，其实你再仔细想，为啥这是线程，还是感觉很抽象，那接下来再看。</p>\n<h2 id=\"内核的作用\"><a href=\"#内核的作用\" class=\"headerlink\" title=\"内核的作用\"></a>内核的作用</h2><p>之前的宿舍比喻生动地诠释了同步（<strong>simultaneously</strong>）的概念，但在一个主要方面存在一些局限。在我们的宿舍中，有许多“线程”同时运行。然而，在真实的实时系统中，通常只有一个 CPU，因此一次只能运行一个 “东西”。</p>\n<h3 id=\"单CPU\"><a href=\"#单CPU\" class=\"headerlink\" title=\"单CPU\"></a>单CPU</h3><p>让我们看看在现实世界中会发生什么，特别是在系统中只有一个 CPU 的 “经济 “情况下。</p>\n<p>在这种情况下，由于只有一个 CPU，所以在任何给定时间点都只能运行一个<strong>线程</strong>。这意味着，即使有多个线程需要执行，它们也必须依次排队等待 CPU 的处理。内核的作用就是协调和调度这些线程，以确保它们在适当的时间获得执行权，实现看似同时运行的效果。</p>\n<h3 id=\"多-CPU（SMP）\"><a href=\"#多-CPU（SMP）\" class=\"headerlink\" title=\"多 CPU（SMP）\"></a>多 CPU（SMP）</h3><p>然而，如果你的系统有多个相同的 CPU，它们共享内存和设备，那么你就拥有了一个 SMP 系统（SMP 是对称多处理器的缩写，<strong>S</strong>ymmetrical <strong>M</strong>ulti <strong>P</strong>rocessor，”对称 “部分表示系统中的所有 CPU 都是相同的）。在这种情况下，可并发（同时）运行的线程数受到 CPU 数量的限制。每个处理器一次只能执行一个线程，但在多处理器情况下，可以同时执行多个线程。</p>\n<p>我们不妨先忽略 CPU 的数量——一个有用的抽象方法是将系统设计成多个线程同时运行的样子，即使实际情况并非如此。稍后，在 “使用 SMP 时应注意的事项 “部分，我们将看到 SMP 的一些非直观影响。这强调了内核的重要性，它在单CPU和多CPU情况下都扮演着关键的协调和调度角色，确保系统的正常运行。</p>\n<h3 id=\"内核作为仲裁者\"><a href=\"#内核作为仲裁者\" class=\"headerlink\" title=\"内核作为仲裁者\"></a>内核作为仲裁者</h3><p>那么，谁来决定哪个线程将在任意给定时间运行呢？这正是内核的工作。</p>\n<p>内核负责决定哪个线程应该在特定时刻使用 CPU，并将上下文切换到该线程。现在，让我们深入了解内核如何管理 CPU 的使用。</p>\n<p>CPU包含许多寄存器（具体数量取决于处理器系列，如 x86 和 MIPS，以及具体的系列成员，如 80486 和奔腾）。当线程运行时，这些寄存器中会存储信息，例如当前程序的位置等。</p>\n<p>当内核决定运行另一个线程时，它需要：</p>\n<ol>\n<li>保存当前运行线程的寄存器和其他上下文信息</li>\n<li>将新线程的寄存器和上下文载入 CPU</li>\n</ol>\n<p>但内核如何决定下一个运行的线程呢？内核会查看特定线程此时是否有能力使用 CPU。例如，在讨论互斥时，我们引入了<strong>阻塞状态</strong>。这种情况发生在一个线程拥有互斥锁，而另一个线程也想获得它的时候，第二个线程将被<strong>阻塞</strong>。</p>\n<p>因此，从内核的角度来看，有一个线程可以消耗 CPU，而另一个线程却不能，因为它被阻塞了，正在等待互斥。在这种情况下，内核会让能运行的线程消耗 CPU，并将另一个线程放入内部列表（这样内核就能跟踪它的互斥请求）。</p>\n<p>显然，这种情况并不有趣。假设有多个线程可以使用 CPU。还记得我们根据优先级和等待时长来分配对互斥的访问权限吗？内核也使用类似的方法来决定下一个运行的线程。有两个因素：优先级和调度算法，依次进行评估。</p>\n<p>内核充当了一个高效的仲裁者，通过权衡各个线程的状态、优先级和调度策略，以确保系统资源的合理利用和线程的公正执行。</p>\n<h4 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h4><p>考虑两个可以使用 CPU 的线程。在 Linux 中，如果这些线程有不同的优先级，那么答案其实很简单——内核会将 CPU 交给优先级最高的线程。Linux 的优先级范围是从 -20（最高优先级）到 19（最低优先级），正值表示实时线程的优先级，负值表示普通线程的优先级。</p>\n<p>如果另一个优先级更高的线程突然可以使用 CPU，内核会立即上下文切换到优先级更高的线程。这被称为抢占–优先级较高的线程抢占了优先级较低的线程。当优先级较高的线程运行完毕，内核上下文切换回之前运行的优先级较低的线程时，我们称之为<strong>恢复（resumption）</strong>–内核恢复运行之前的线程。</p>\n<p>现在，假设有两个线程可以使用 CPU，并且它们的优先级完全相同。在这种情况下，内核将采用一种公平的调度策略，确保这些线程在 CPU 上获得相近的执行时间，以避免某个线程长时间占用 CPU，导致其他线程无法获得执行的情况。这就是为什么在多线程环境中，即使优先级相同，线程也能够相对公平地分享 CPU 资源的原因。</p>\n<h4 id=\"调度算法\"><a href=\"#调度算法\" class=\"headerlink\" title=\"调度算法\"></a>调度算法</h4><p>让我们假设其中一个线程当前正在使用 CPU。我们将检查内核在这种情况下决定何时进行上下文切换的规则。（当然，这整个讨论实际上仅适用于相同优先级的线程——在高优先级线程准备好使用 CPU 的瞬间，它将获得 CPU；这是实时操作系统中设定优先级的主要目的。）</p>\n<p>在Linux内核中，有两个主要的调度算法（策略）：<strong>Round Robin</strong>（简称“RR”）和 <strong>FIFO</strong>（First-In, First-Out）。</p>\n<p>**Round Robin (RR)**：在这个策略中，每个线程都被分配一个固定的时间片，当时间片用尽时，内核将上下文切换到下一个线程。这确保了每个线程都有机会在 CPU 上运行，避免了某个线程长时间占用 CPU 的情况。</p>\n<p>**FIFO (First-In, First-Out)**：这个策略是按照线程加入队列的先后顺序进行调度的。先加入队列的线程会先获得 CPU 使用权，直到它主动释放或等待资源时发生上下文切换。FIFO 不考虑线程的优先级，只关注它们在队列中的排列顺序。</p>\n<p>在Linux系统中，这些调度算法的具体实现和配置可以在调度策略（sched_policy）和相关参数中找到。例如，使用命令<code>chrt</code>可以为进程设置实时调度策略。</p>\n<h4 id=\"单CPU调度规则\"><a href=\"#单CPU调度规则\" class=\"headerlink\" title=\"单CPU调度规则\"></a>单CPU调度规则</h4><ol>\n<li><strong>同一时刻只能有一个线程运行</strong>：在单CPU环境下，同一时刻只能有一个线程占用CPU，确保资源的独占性。</li>\n<li><strong>最高优先级的准备就绪线程将获得运行机会</strong>：线程的优先级是决定其运行顺序的关键因素，高优先级线程将优先获得CPU，以满足对响应性要求的高优先级任务。</li>\n<li><strong>线程运行直至阻塞或退出</strong>：一旦线程开始运行，它将一直执行，直至发生阻塞（等待资源或锁）或线程结束。这确保了CPU的高效利用。</li>\n<li><strong>Round Robin线程将运行其时间片，然后进行重新调度</strong>：对于采用Round Robin调度策略的线程，每个线程被分配一个固定的时间片，用于避免某个线程长时间占用CPU。当时间片用尽时，内核将重新调度线程，确保其他线程有机会执行。</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/SingleCPUSchedulingRule.png\"></p>\n<h2 id=\"线程的目的？\"><a href=\"#线程的目的？\" class=\"headerlink\" title=\"线程的目的？\"></a>线程的目的？</h2><p>上面这些弄完差不多对线程有那么一点点具象的认知了，那么是否考虑过为什么需要线程？或者换句话说，为什么需要在一个进程中引入多个线程？</p>\n<p>要搞清上面这个问题，其实是不是还得先思考一下操作系统为什么又需要多进程设计？</p>\n<h3 id=\"Why-Processes\"><a href=\"#Why-Processes\" class=\"headerlink\" title=\"Why Processes?\"></a>Why Processes?</h3><p>为什么不只使用一个进程，而是使用多个进程和线程呢？</p>\n<ol>\n<li><strong>解耦和模块化</strong></li>\n<li><strong>可维护性</strong></li>\n<li><strong>可靠性</strong></li>\n</ol>\n<p>假设我们有一个网络服务器应用，需要同时处理多个客户端请求。为了提高可维护性、可靠性和模块化，我们选择采用多进程的设计。</p>\n<ol>\n<li><p><strong>解耦和模块化</strong>：</p>\n<p>我们可以设计不同的进程来处理不同的任务，比如一个进程负责接受客户端连接，另一个进程负责处理请求，还有一个进程用于日志记录。每个进程都有特定的职责，彼此之间的关系通过明确定义的接口进行通信，实现了模块化设计。</p>\n</li>\n<li><p><strong>可维护性</strong>：</p>\n<p>如果我们需要修改或修复处理请求的进程，我们只需关注该进程的代码，而不必担心影响其他进程。这使得修改、测试和维护变得更为简便。</p>\n</li>\n<li><p><strong>可靠性</strong>：</p>\n<p>每个进程在自己的地址空间内运行，如果一个进程发生错误或崩溃，不会对其他进程产生负面影响。例如，如果处理请求的进程出现问题，不会导致接受客户端连接的进程受到影响。这种隔离性提高了系统的可靠性。</p>\n</li>\n</ol>\n<p>在Linux中，可以使用fork()系统调用创建新的进程。每个进程都有自己的地址空间和资源，相互之间独立运行。进程间通信（IPC）机制，如管道、消息队列和共享内存，可以用于实现进程之间的通信和协作。</p>\n<p>然后我们就可以思考，<strong>为什么需要线程？</strong></p>\n<h3 id=\"Why-Threads\"><a href=\"#Why-Threads\" class=\"headerlink\" title=\"Why Threads?\"></a>Why Threads?</h3><p>早期的操作系统将进程视为独立运行的基本单位，类似于物理学家研究物质时首先发现的分子。然而，随着计算机科学的发展，科学家们提出了更小的、能够独立运行的基本单位——线程，就如同在物质研究中分子之后的发现原子、原子核和电子。</p>\n<p>那么，为何要引入线程呢？这就好比在军事战争中，需要灵活机动的士兵来执行各种任务。进程就像是一支随时携带大量粮草和物资的士兵，虽然有充足的资源，但行动相对较慢。</p>\n<p><strong>为什么引入线程？</strong> 线程，<strong>又称为迷你进程，就好比轻装上阵的特种部队士兵，更容易创建和撤销</strong>。我们可以将其比喻为分配两个士兵执行同一个任务的思想：一个负责携带所需物资，另一个专注于执行任务。这样，轻装上阵的士兵即为线程。</p>\n<p>在这个比喻中，进程就像是一支庞大的军队，拥有完整的资源和指挥结构，而线程则类似于精锐小队，更灵活、更迅速地执行任务。引入线程使得计算机系统更适应多任务环境，提高了程序的执行效率。</p>\n<p>在操作系统中，创建或撤销进程涉及为其分配或回收资源，如内存空间和I/O设备，这引起了较大的时空开销，限制了并发性的提高。为了减少进程切换的开销，我们将进程的两个关键属性分开处理：资源分配和调度。</p>\n<p>在这一模型中，进程仍然是资源分配的基本单位，但不再是调度的基本单位。调度的职责被赋予了线程，这是一种更轻量级的执行单元。引入线程后，系统通过区分资源和调度的责任，提高了灵活性和效率。</p>\n<p>在这个框架下，引入线程之前，进程既是资源分配的基本单位，也是独立调度的基本单位。然而，引入线程后，进程仍然负责资源分配，而线程则成为独立调度的基本单位。这使得系统更容易适应多任务环境，线程的快速创建和撤销减小了调度的负担，提高了系统的并发性和响应性。</p>\n<p>简而言之，引入线程改善了系统的时空效率，通过将资源分配和调度分离，为系统提供了更好的灵活性和性能。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>所以记住一句话：引入线程前，进程是资源分配和独立调度的基本单位。引入线程后，<strong>进程是资源分配的基本单位，线程是独立调度的基本单位</strong>。</p></blockquote>\n<p>卧槽，写到这才发现和课件不一样，不急，起码上面的都是正确的，多学点总比少学了好。</p>\n<p>接下来，开始看课件。</p>\n","feature":true,"text":"在此之前我要先晒卡，以表达我写本篇文章时喜悦的心情。 好，言归正传，操作系统，我在想要不要再写一个Linux的笔记？正好最近在看相关的东西？ 无所谓，先看课件。 前言在此之前，我们先做一个类比。 首先，我想说明线程和进程是如何工作的。我能想到的最佳方法（除了深入研究实时系统的设计...","link":"","photos":[],"count_time":{"symbolsCount":"7.8k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":51,"path":"api/tags/笔记.json"},{"name":"CPT104","slug":"CPT104","count":2,"path":"api/tags/CPT104.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E5%A6%82%E5%90%8C%E6%88%BF%E5%AD%90\"><span class=\"toc-text\">进程如同房子</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E5%B0%B1%E6%98%AF%E5%B1%85%E4%BD%8F%E8%80%85\"><span class=\"toc-text\">线程就是居住者</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">单线程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">多线程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">返回进程和线程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Mutual-exclusion%EF%BC%88%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%89\"><span class=\"toc-text\">Mutual exclusion（互斥锁）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%85%88%E6%8E%92%E5%88%97\"><span class=\"toc-text\">优先排列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Semaphores%EF%BC%88%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%89\"><span class=\"toc-text\">Semaphores（信号量）</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%9F\"><span class=\"toc-text\">什么是线程？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E6%A0%B8%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">内核的作用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95CPU\"><span class=\"toc-text\">单CPU</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A-CPU%EF%BC%88SMP%EF%BC%89\"><span class=\"toc-text\">多 CPU（SMP）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E6%A0%B8%E4%BD%9C%E4%B8%BA%E4%BB%B2%E8%A3%81%E8%80%85\"><span class=\"toc-text\">内核作为仲裁者</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">优先级</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">调度算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%95CPU%E8%B0%83%E5%BA%A6%E8%A7%84%E5%88%99\"><span class=\"toc-text\">单CPU调度规则</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%9B%AE%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">线程的目的？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Why-Processes\"><span class=\"toc-text\">Why Processes?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Why-Threads\"><span class=\"toc-text\">Why Threads?</span></a></li></ol></li></ol></li></ol>","author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"CPT104 Learning Week1","uid":"103cf105d957389e86194541d8104f98","slug":"CPT104-Learning-Week1","date":"2024-02-26T09:46:35.000Z","updated":"2024-03-07T11:08:51.319Z","comments":true,"path":"api/articles/CPT104-Learning-Week1.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/CPT104-img.png","text":"开学第一课，操作系统原理。 进程什么是进程？进程就是程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位。 简单来说，进程就是程序的一次执行过程，程序是静态的，在计算机系统（CPT101）里面都学了，在冯诺依曼结构中，程序静态地存储在硬盘中。当需要执行时，...","link":"","photos":[],"count_time":{"symbolsCount":"9.7k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":51,"path":"api/tags/笔记.json"},{"name":"CPT104","slug":"CPT104","count":2,"path":"api/tags/CPT104.json"}],"author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}},"feature":true}}