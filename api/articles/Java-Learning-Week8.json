{"title":"Java_Learning(Week8)","uid":"0d78bd92a017cfff181854aa3e1bedda","slug":"Java-Learning-Week8","date":"2023-11-06T10:20:06.000Z","updated":"2023-11-06T12:33:31.073Z","comments":true,"path":"api/articles/Java-Learning-Week8.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/codeBackground.png","content":"<p>因为最近太忙了，所以直接空了三周的笔记没有写，后面看有没有时间再补上吧，这节课，我们直接开始Java编程当中的重头戏——面向对象。</p>\n<h1 id=\"面向对象（OOP）\"><a href=\"#面向对象（OOP）\" class=\"headerlink\" title=\"面向对象（OOP）\"></a>面向对象（OOP）</h1><h2 id=\"什么是对象？\"><a href=\"#什么是对象？\" class=\"headerlink\" title=\"什么是对象？\"></a>什么是对象？</h2><p>首先先明确一点，<strong>对象不是找男女朋友！</strong></p>\n<p>这里我想先引用我很喜欢的一本Java书（Java编程思想，非常好的工具书）当中面向对象导论中的第一句话</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>“我们之所以将自然界分解，组织成各种概念，并按其含义分类，主要是因为我们是整个口语交流社会共同遵守的协议的参与者，这个协定以语言的形式固定下来……除非赞成这个协定中规定的有关语言信息的组织和分类，否则我们根本无法交谈”</p>\n<p>——Benjamin Lee Whorf (1897 - 1941)</p></blockquote>\n<p>所以对于我们的Java这门完全面向对象的语言来说，<strong>对象就是对物体的抽象</strong>。</p>\n<p>当然不仅限于Java，任何支持面向对象变成的语言，我们都可以这么说，因为面向对象和语言的关系并不大，而是一种<strong>编程思想</strong>。</p>\n<p>现在我们来想想什么是对物体的抽象。</p>\n<p>比方说有一个人，我们就可以想想它具有什么特点？</p>\n<ul>\n<li>性别，是男是女？</li>\n<li>年龄，几岁了？</li>\n<li>姓名，我们怎么称呼？</li>\n<li>性格</li>\n<li>。。。</li>\n</ul>\n<p>这样我们就逐步将一个人进行了分解，这个分解的过程就是抽象的过程。</p>\n<p>而这些东西体现在代码上面就是我们要写的一个类（class），什么是类呢？</p>\n<h2 id=\"什么是类？\"><a href=\"#什么是类？\" class=\"headerlink\" title=\"什么是类？\"></a>什么是类？</h2><p>什么是类？也就是我们经常见到的<code>class</code>，我们每次写代码的时候都会见到它，我们必须把代码写到类里面，每次新建也都是要新建一个类，方法也必须用类包裹。</p>\n<p>所以，有具体想过什么是类吗？</p>\n<p>我用最简单的话来说，类就是一个模板，我们通过这个模板来构建对象。</p>\n<p>什么意思？我第一次接触也是晕头转向。但是没关系，</p>\n<p>比方说用上面那个例子，我们构建一个类，名字叫做<code>Person</code></p>\n<p>那么，我们就把一个人进行抽象然后写出一个类来</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Person {\n    String name;   //姓名\n    int age;\t   //年龄\n    String gender; //性别\n}</code></pre>\n\n<p>对吧，这就我们最基本的对这个人进行的抽象，他肯定有名字，年龄，性别。</p>\n<p>接下来最终要的一句话就是，<strong>对象要根据类来创建，类是构造对象的模板</strong>。</p>\n<p>比如说我是一个人，我叫<code>张三</code>，年龄是<code>20</code>，性别是<code>男</code>。对吧，那么此处的张三就是一个“人”对象，或者说是一个<code>Person</code>对象，但是Person这是一个类，他是张三的模板。</p>\n<p>或者再来一个人，姓名是<code>李四</code>，年龄<code>30</code>，性别是<code>女</code>，那么我们说李四也是一个<code>Person</code>对象。</p>\n<p>所以就能发现李四和张三都是人，都是Person，我们可以通过Person这个类去构造很多对象。</p>\n<h2 id=\"类和对象的关系\"><a href=\"#类和对象的关系\" class=\"headerlink\" title=\"类和对象的关系\"></a>类和对象的关系</h2><ul>\n<li>类定义了对象的结构，包括两个大部分，属性和方法，这两点我们后面说。</li>\n<li>对象是类的实例，对象们具体化了类的定义，拥有类的属性和方法。</li>\n<li>一个类可以创建多个对象，每个对象之间是相互独立的，它们之间可以有不同的属性值。</li>\n</ul>\n<p>所以记住我的这句话</p>\n<p><strong>类是对象的模板，对象是类的实例</strong></p>\n<p>目前为止，只需要知道这些应该就够了。</p>\n<h2 id=\"为什么需要面向对象？\"><a href=\"#为什么需要面向对象？\" class=\"headerlink\" title=\"为什么需要面向对象？\"></a>为什么需要面向对象？</h2><p>要搞懂这个问题我们就要讲到面向对象的对立面——<strong>面向过程</strong>。</p>\n<p>面向过程，顾名思义，就是面向过程，hhhhhh</p>\n<p>好吧，为了方便理解，我来举一个例子，比方说我们现在有一个飞机，让你用程序去控制它，我们怎么控制？</p>\n<h3 id=\"面向过程\"><a href=\"#面向过程\" class=\"headerlink\" title=\"面向过程\"></a>面向过程</h3><p>在面向过程编程中，我们会将问题分解为一系列的步骤，然后按照顺序执行这些步骤来模拟飞机的飞行。</p>\n<ol>\n<li>初始化飞机参数（速度、高度、燃料等）。</li>\n<li>启动引擎。</li>\n<li>增加速度。</li>\n<li>升高飞机。</li>\n<li>检查燃料。</li>\n<li>如果燃料足够，继续飞行；否则，降落。</li>\n<li>定期检查飞机的状态。</li>\n<li>如果到达目的地，降落。</li>\n</ol>\n<p>对吧，如果是面向过程，我们就必须依次写这些过程的函数，并且必须提前将运行的时序排列好。</p>\n<p>而且飞机还有很多的全局变量，我们该怎么保存和管理和操作呢？比方说高度？速度？燃料量？甚至这只能描述一架飞机，如果飞机更多该怎么办呢？</p>\n<p>所以发现了吗？</p>\n<p>这种方式将问题分解为一系列步骤，每个步骤都是一个函数或方法。这些函数按照顺序执行，但问题是，我们需要管理大量的全局变量来存储飞机的状态，以及一系列函数来操作这些状态。</p>\n<h3 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h3><p>那么面向对象，我们就先对飞机这个物体进行抽象，先来构建一个飞机的类，也就是飞机的class</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Airplane {\n    double speed;\n    double altitude;\n    double fuel;\n\n  \tvoid startEngine() {\n        // 启动引擎\n        // 实现细节\n    }\n\n    void increaseSpeed() {\n        // 增加速度\n        // 实现细节\n    }\n\n    void ascend() {\n        // 升高飞机\n        // 实现细节\n    }\n\n    void checkFuel() {\n        // 检查燃料\n        // 实现细节\n    }\n\n    // 更多方法...\n\n    void land() {\n        // 降落\n        // 实现细节\n    }\n}</code></pre>\n\n<p>这里我们就简单构造了一个飞机的类，这个类里面拥有一架飞机应该有的一些参数和一些方法，或者说属性和方法，这里方法指的就是飞机可以实现的一些方法，而且每个飞机都具有自己的状态，而且不需要全局变量。不同的飞机（对象）之间是可以独立操作的，当我需要操作的时候，只需要用不同的对象调用需要的方法就行了，而且代码更加的清晰和可维护。</p>\n<p>当然，面向过程肯定也不是就像这么说的这么差劲了，面向过程也有节省资源，对于小规模问题更有操作性这些优点。</p>\n<p>总之，OOP 适用于模拟复杂的现实世界问题，提供了更有组织的代码结构和更好的可维护性。但有时，对于简单问题或需要高度的资源效率的情况，面向过程编程可能更合适。在实际编程中，我们可以根据问题的复杂性和要求来选择适当的编程方法。有时候，甚至可以将两种方法结合使用，以获得最佳的结果。</p>\n<h2 id=\"封装思想\"><a href=\"#封装思想\" class=\"headerlink\" title=\"封装思想\"></a>封装思想</h2><p>继续上面飞机的例子，我们可以这个类里面有各种各样飞机所具备的方法，我们在需要用的时候只需要构建一个飞机对象，然后让这个对象去调用它的方法就行了，我们就不需要关心这个方法内部是怎么实现的，这让方法更具有复用性和方便别人来使用，并且更加的安全，我们不能随便去改变方法的内部，我们只能调用这个方法。</p>\n<p>或者再举个例子，我们目前学习的很多方法其实都是封装后的结果，比方说<code>Math</code>这个工具类当中的很多方法<code>max()</code>，<code>pow()</code>还记的吗？我们只需要去调用，或者传递参数，他就会返回一个结果，我们并不知道Java底层是怎么实现的，只知道我们把数字放进去，他就给我最大值，我把数字传进去，他就吐给我幂。</p>\n<p>所以和面向对象类似的，</p>\n<p><strong>封装</strong> 是一种面向对象编程的概念，它就像是一个飞机机舱一样，将飞机内部的复杂部分隐藏在外部看不见的地方。</p>\n<p>比方说飞机内部的电子设备和引擎。在飞机上，有许多复杂的机械和电子零部件，例如引擎、仪表板、油箱等等。这些零部件对于让飞机正常运行非常重要，但乘客通常不需要知道所有这些细节。所以，这些零部件被封装在飞机的外部之下，乘客只能看到和使用一些简单的控制界面，如按钮、手柄和屏幕。</p>\n<p>封装的好处就是：</p>\n<ul>\n<li><strong>隐藏细节</strong>：乘客不需要知道飞机内部的复杂性，他们只需要使用控制界面来与飞机交互。</li>\n<li><strong>安全性</strong>：乘客不能随意触摸飞机内部的复杂零部件，这可以防止不必要的干预和错误操作。</li>\n<li><strong>简化使用</strong>：乘客只需使用简单的控制界面，而不需要了解复杂的内部工作。</li>\n</ul>\n<p>所以，封装就像是将复杂性和细节隐藏在一个容器中，对外部提供了一个简化的界面，这使得事物更容易理解和使用，就像乘客使用飞机的控制面板一样。</p>\n<p>懂了吗？如懂，无所谓，看不懂多看几遍，或者问我。</p>\n<h1 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h1><p>构造方法是 Java 编程中的一个特殊方法，它有点像一个蓝图，用来<strong>创建对象</strong>。</p>\n<p>你可以把构造方法比作一家工厂，用来制造不同种类的产品，而这些产品就是<strong>对象</strong>。</p>\n<h2 id=\"为什么需要构造方法？\"><a href=\"#为什么需要构造方法？\" class=\"headerlink\" title=\"为什么需要构造方法？\"></a>为什么需要构造方法？</h2><p>你想想嘛，刚刚的类是什么？是对象的模板，对吧，就相当于一个蓝图，但是只有蓝图那不行的呀，我们怎么才能把这个对象构造出来呢？</p>\n<p>——构造方法。</p>\n<h2 id=\"构造方法的特点\"><a href=\"#构造方法的特点\" class=\"headerlink\" title=\"构造方法的特点\"></a>构造方法的特点</h2><ul>\n<li>构造方法与类名相同。</li>\n<li>构造方法<strong>没有</strong>返回类型（不像其他方法有int、String等返回类型）。</li>\n<li>构造方法可以有参数，这些参数可以帮助你设置对象的特性。</li>\n</ul>\n<p>我们来举一个例子，就用刚刚的飞机的例子，我们给它加上构造方法。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Airplane {\n    double speed;    // 飞机的速度\n    double altitude; // 飞机的高度\n    double fuel;     // 飞机的燃料量\n\n    // 空参构造方法，用于创建一个默认的飞机对象\n    public Airplane() {\n        this.speed = 0;\n        this.altitude = 0;\n        this.fuel = 0;\n    }\n\n    // 有参构造方法，用于创建具有特定特性的飞机对象\n    public Airplane(double speed, double altitude, double fuel) {\n        this.speed = speed;\n        this.altitude = altitude;\n        this.fuel = fuel;\n    }\n}</code></pre>\n\n<p>这里要讲的东西比较多哈，先从我们有点陌生的这个<code>this</code>关键字开始，这里的<code>this</code>是什么？有什么用呢？</p>\n<h3 id=\"this关键字\"><a href=\"#this关键字\" class=\"headerlink\" title=\"this关键字\"></a><code>this</code>关键字</h3><p>我一句话解决，为了区分类的属性变量和方法的参数。</p>\n<p>有时候需要在类的方法中区分类的实例变量（类的属性）和方法的参数，以避免混淆。这时候就可以使用关键字 <code>this</code>。</p>\n<p>想象一栋大楼（类），每层楼都有一扇窗户（属性），然后有人站在某一层的窗前，这个人需要知道他所在的楼层有多少窗户，也就是说，他需要引用自己所在楼层的窗户。这时，<code>this</code> 就像是告诉他，”这里是你所在的楼层的窗户”。</p>\n<p>具体来说，<code>this</code> 是一个特殊的关键字，它在类的方法中表示当前对象的引用。通过 <code>this</code>，你可以访问或修改当前对象的属性。这有助于区分属性和方法参数，因为它告诉编译器你想要访问的是对象的属性而不是方法参数。</p>\n<p>懂了吧，就是你在构建类之前的那些飞机的速度，高度，燃油量都是要靠<code>this</code>来区分滴</p>\n<h3 id=\"空参构造\"><a href=\"#空参构造\" class=\"headerlink\" title=\"空参构造\"></a>空参构造</h3><p>好，我们再来看一下空参构造的那个方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// 空参构造方法，用于创建一个默认的飞机对象\npublic Airplane() {\n    this.speed = 0;\n    this.altitude = 0;\n    this.fuel = 0;\n}</code></pre>\n\n<p>这就是我们那个模板的空参构造，那么在对象构建的时候所对应的那个语句长什么样子呢？</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// 使用空参构造方法创建默认飞机\n      Airplane defaultPlane = new Airplane();</code></pre>\n\n<p>熟悉吧，就长这个样子，可以看见我们在<code>new Airplane()</code>这个括号当中并没有传递任何参数，然后在构造方法当中我们也可以发现，我们为每个属性值都配上了默认的值，都是<code>0</code>。</p>\n<h3 id=\"有参构造\"><a href=\"#有参构造\" class=\"headerlink\" title=\"有参构造\"></a>有参构造</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// 有参构造方法，用于创建具有特定特性的飞机对象\npublic Airplane(double speed, double altitude, double fuel) {\n    this.speed = speed;\n    this.altitude = altitude;\n    this.fuel = fuel;\n}</code></pre>\n\n<p>这就是有参构造，可以发现这个构造方法需要接收三个参数才可以，然后就把这些参数传递给了用<code>this</code>声明的属性参数，那么我们在构造这个对象的时候就要这么写：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// 使用有参构造方法创建具有特定特性的飞机\nAirplane customPlane = new Airplane(600, 10000, 500);</code></pre>\n\n<p>可以发现我们向里面分别传递了三个参数，依次对应速度，高度，燃油量这几个属性，传递进去以后就创建了两个对象。</p>\n<p>然后我们就可以看一下这两个方法构造出来的飞机对象有什么区别吧。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) {\n\n        // 使用空参构造方法创建默认飞机\n        Airplane defaultPlane = new Airplane();\n\n        // 使用有参构造方法创建具有特定特性的飞机\n        Airplane customPlane = new Airplane(600, 10000, 500);\n\n        System.out.println(\"默认飞机的速度：\" + defaultPlane.speed);\n        System.out.println(\"默认飞机的高度：\" + defaultPlane.altitude);\n        System.out.println(\"默认飞机的燃料量：\" + defaultPlane.fuel);\n\n        System.out.println(\"定制飞机的速度：\" + customPlane.speed);\n        System.out.println(\"定制飞机的高度：\" + customPlane.altitude);\n        System.out.println(\"定制飞机的燃料量：\" + customPlane.fuel);\n    }</code></pre>\n\n<p>输出如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">默认飞机的速度：0.0\n默认飞机的高度：0.0\n默认飞机的燃料量：0.0\n定制飞机的速度：600.0\n定制飞机的高度：10000.0\n定制飞机的燃料量：500.0</code></pre>\n\n<p>空参构造出来的默认飞机各个属性都是<code>0</code>，没问题，因为我们什么都没传递。</p>\n<p>定制出来的飞机因为我们传递了参数，所以各个属性也就赋上了相应的值。</p>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><p>这里涉及继承只是简单的讲一下，因为后面需要讲到重写<code>toString()</code>方法，这里需要涉及一些继承的知识，只是简单过一下，方便我待会来讲重写方法。</p>\n<h2 id=\"什么是继承？\"><a href=\"#什么是继承？\" class=\"headerlink\" title=\"什么是继承？\"></a>什么是继承？</h2><p>当谈到继承时，我们可以将其想象成一种关系，就像家庭关系一样，其中有父母和子女。</p>\n<p>在Java中，继承是一种对象之间的关系，其中一个类可以继承另一个类的属性和行为。这就像家庭中的关系，父母把一些特征和技能传给他们的孩子。</p>\n<p>举个例子，假设有一个基本的类叫做”人”，这个类有一些属性和方法，比如”姓名”和”走路”。现在，我们想创建一个新的类，叫做”学生”，”学生”就可以继承”人”的属性和方法。</p>\n<p>这意味着”学生”类可以拥有”姓名”这个属性，而且可以调用”走路”这个方法，就像”人”类一样。但同时，”学生”类还可以有自己的属性和方法，比如”学习”和”考试”。</p>\n<p>通过继承，我们不需要重复定义”姓名”和”走路”，因为这些已经在”人”类中定义了。而”学生”类可以专注于定义与学生相关的属性和方法，如”学习”和”考试”。</p>\n<p>所以，继承允许我们建立一个类之间的父子关系，使子类可以继承父类的特性，同时可以添加自己的特性。这就像家庭中的关系一样，孩子可以继承父母的一些特点，但也可以拥有自己独特的特点。</p>\n<h2 id=\"谁是爹？\"><a href=\"#谁是爹？\" class=\"headerlink\" title=\"谁是爹？\"></a>谁是爹？</h2><p>所以继承你就会发现了一个问题——谁是爹？或者谁是谁的爷爷？</p>\n<p>爸爸的爸爸是爷爷，爷爷的爷爷是？</p>\n<p>是祖先，祖先的祖先是？</p>\n<p>发现了吗，就是终归要有个头对吧？</p>\n<p>所以，在Java当中就给我提供了一个类名叫做<code>Object</code>，我们把它称为超类，任何一个类都继承了这个类当中的方法和属性。</p>\n<p>你可以把<code>Object</code>类想象成所有类的祖先，就像一个超级爷爷或超级奶奶。这个超级爷爷或超级奶奶传下来了一些共同的特征和方法，而每个类都可以继承这些特征和方法。</p>\n<p>例如，<code>Object</code>类有一些通用的方法，比如<code>toString()</code>，<code>equals()</code>和<code>hashCode()</code>。这些方法可以在任何类中使用，因为每个类都继承了<code>Object</code>的这些方法。</p>\n<p>如果你的类没有显式地继承自其他类，它就会默认继承自<code>Object</code>类。所以，<code>Object</code>类就像是所有类的最远祖先，它为所有类提供了一些共同的功能。</p>\n<p>当你创建自己的类时，你可以使用<code>Object</code>类中的这些通用方法，或者你可以重写这些方法以适应你的类的需求。就像在家庭中，你可以继承一些祖先的特点，但也可以发展出自己的特点。</p>\n<h2 id=\"方法的重写\"><a href=\"#方法的重写\" class=\"headerlink\" title=\"方法的重写\"></a>方法的重写</h2><p>好了终于到这里了，什么是方法的重写？</p>\n<p>简单来说，是在面向对象当中的一种编程概念，它允许你在子类中重新创建一个已经存在的方法，但是你可以改变这个方法的行为，以适应子类的需求。</p>\n<p>让我们通过一个简单的例子来解释方法的重写。假设你有一个基类叫做”动物”，它有一个方法叫做”发出声音”，这个方法可以让动物发出不同的声音。然后，你有两个子类，一个是”狗”，另一个是”猫”。</p>\n<p>现在，你想让狗和猫分别发出它们自己的声音，而不是使用基类”动物”的声音（比如说“Siu~~”）。这就是方法的重写的地方。</p>\n<p>在子类中，你可以创建一个与基类中”发出声音”方法名称相同的方法，但是你可以给它不同的声音。例如，在”狗”类中，你可以创建一个”发出声音”的方法，让它返回”汪汪”声音。而在”猫”类中，你可以创建一个相同名称的方法，让它返回”喵喵”声音。</p>\n<p>这样，当你调用狗的”发出声音”方法时，它会返回”汪汪”声音，而调用猫的”发出声音”方法时，它会返回”喵喵”声音。</p>\n<p>这就是方法的重写的基本概念。你可以在子类中<strong>重新定义一个方法，以覆盖基类中的相同方法，以适应子类的需求。</strong></p>\n<h1 id=\"重写toString-方法\"><a href=\"#重写toString-方法\" class=\"headerlink\" title=\"重写toString()方法\"></a>重写<code>toString()</code>方法</h1><p>好了前面铺垫了这么多，就是为了让我可以来讲为什么我们需要在类当中重写<code>toString()</code>方法。</p>\n<p>我们先把那个飞机的例子拿下来：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Airplane {\n    double speed;    // 飞机的速度\n    double altitude; // 飞机的高度\n    double fuel;     // 飞机的燃料量\n\n    // 空参构造方法，用于创建一个默认的飞机对象\n    public Airplane() {\n        this.speed = 0;\n        this.altitude = 0;\n        this.fuel = 0;\n    }\n\n    // 有参构造方法，用于创建具有特定特性的飞机对象\n    public Airplane(double speed, double altitude, double fuel) {\n        this.speed = speed;\n        this.altitude = altitude;\n        this.fuel = fuel;\n    }\n}</code></pre>\n\n<p>这是那个飞机类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// 使用空参构造方法创建默认飞机\nAirplane defaultPlane = new Airplane();\n\n// 使用有参构造方法创建具有特定特性的飞机\nAirplane customPlane = new Airplane(600, 10000, 500);\n\nSystem.out.println(defaultPlane);\nSystem.out.println(customPlane);</code></pre>\n\n<p>刚刚我们是通过对象去调用其中的属性值来获得里面的这些速度啊，高度之类的，有些太麻烦了，我想直接通过打印这个对象的方式来实现打印我对应对象的属性值，可不可以？</p>\n<p>然后我们就会发现控制台输出了这一行：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">CPT111.week8.Airplane@7ef20235\nCPT111.week8.Airplane@27d6c5e0</code></pre>\n\n<p>你就会发现输出了这么个奇怪的东西，这是什么呢？</p>\n<p><code>CPT111.week8.</code>说明是这个类目前在这个包下面，也就是这个文件夹下面，这个类的名字叫<code>Airplane</code>，然后<code>@</code>后面跟上了一堆乱码。</p>\n<p>那这个其实就是这个对象的地址值，当我们有<code>new</code>关键字的时候，就会生成一个新的对象，然后就会产生相应的地址值，当然这一部分的数据结构我是不想讲的，要讲的话放到后面吧，这里讲不完。</p>\n<p>总之，这个地址值指向了内存当中的一个部分，那个部分就存放着我们的地址值，在我们执行输出语句的时候，其实JVM底层就调用我们这个对象的<code>toString()</code>方法，然后进行输出。</p>\n<p>那你就会问，我们的方法当中明明没有这个方法啊。</p>\n<p>那到这里应该就很显而易见了，在我们的超类<code>Object</code>当中就有一个<code>toString()</code>方法，我们可以去Java的源码当中看一下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">/**\n * Returns a string representation of the object.\n * @apiNote\n * In general, the\n * {@code toString} method returns a string that\n * \"textually represents\" this object. The result should\n * be a concise but informative representation that is easy for a\n * person to read.\n * It is recommended that all subclasses override this method.\n * The string output is not necessarily stable over time or across\n * JVM invocations.\n * @implSpec\n * The {@code toString} method for class {@code Object}\n * returns a string consisting of the name of the class of which the\n * object is an instance, the at-sign character `{@code @}', and\n * the unsigned hexadecimal representation of the hash code of the\n * object. In other words, this method returns a string equal to the\n * value of:\n * &lt;blockquote&gt;\n * &lt;pre&gt;\n * getClass().getName() + '@' + Integer.toHexString(hashCode())\n * &lt;/pre&gt;&lt;/blockquote&gt;\n *\n * @return  a string representation of the object.\n */\npublic String toString() {\n    return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n}</code></pre>\n\n<p>看见啦，上面那一大段读不懂无所谓，我们就看下面这个返回值，不要管这些方法内部是怎么实现的，我们都学了封装了，就直接看</p>\n<p>先通过<code>getClass()</code>获得这个类，然后再调用<code>getName() </code>方法获得这个类名字（对应<code>Airplane</code>），然后字符串拼接上一个<code>@</code>，最后通过<code>Integer</code>包装类下的一个方法将这个类的<code>hashCode</code>转换成了十六进制的整数，然后再返回。</p>\n<p>对吧，这就是封装的魅力，可能不懂，但是懂了。。。</p>\n<p>所以我们就知道了，那一串乱码不是随便打出来的，而是超父类<code>Object</code>中的一个方法，而我们的飞机类在底层默认继承了这个类罢了。</p>\n<p>所以我们就要重写这个方法，怎么重写，其实就跟新建方法一样，不过方法名要相同</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public String toString() {\n    return \"Airplane{speed = \" + speed + \", altitude = \" + altitude + \", fuel = \" + fuel + \"}\";\n}</code></pre>\n\n<p>这就重写完成了，其实按照规范我们还要加上一个<code>@Override</code>注解，告诉别的开发者和JVM这个方法是重写的，但是其实没有必要，底层JVM也都知道这个方法是重写的，在调用的时候，会调用这个重写后覆盖的方法。</p>\n<p>当然，我的习惯还是加上。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic String toString() {\n    return \"Airplane{speed = \" + speed + \", altitude = \" + altitude + \", fuel = \" + fuel + \"}\";\n}</code></pre>\n\n<p>OK，现在我们再来看看直接打印这个对象会有什么结果</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">Airplane{speed = 0.0, altitude = 0.0, fuel = 0.0}\nAirplane{speed = 600.0, altitude = 10000.0, fuel = 500.0}</code></pre>\n\n<p>结束！！！</p>\n<p>到这里后，应该就可以对着课件把老师上课搞得东西自己研究出来了，我就不对着搞了，太累了。</p>\n<p>最近事情还是蛮多的，不一定会定时更新。</p>\n<p>T T</p>\n","feature":true,"text":"因为最近太忙了，所以直接空了三周的笔记没有写，后面看有没有时间再补上吧，这节课，我们直接开始Java编程当中的重头戏——面向对象。 面向对象（OOP）什么是对象？首先先明确一点，对象不是找男女朋友！ 这里我想先引用我很喜欢的一本Java书（Java编程思想，非常好的工具书）当中面...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":29,"path":"api/tags/笔记.json"},{"name":"Java初学","slug":"Java初学","count":9,"path":"api/tags/Java初学.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88OOP%EF%BC%89\"><span class=\"toc-text\">面向对象（OOP）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%EF%BC%9F\"><span class=\"toc-text\">什么是对象？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%EF%BC%9F\"><span class=\"toc-text\">什么是类？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">类和对象的关系</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9F\"><span class=\"toc-text\">为什么需要面向对象？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">面向过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">面向对象</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%81%E8%A3%85%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">封装思想</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">构造方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9F\"><span class=\"toc-text\">为什么需要构造方法？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">构造方法的特点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#this%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">this关键字</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E5%8F%82%E6%9E%84%E9%80%A0\"><span class=\"toc-text\">空参构造</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0\"><span class=\"toc-text\">有参构造</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">继承</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF%EF%BC%9F\"><span class=\"toc-text\">什么是继承？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B0%81%E6%98%AF%E7%88%B9%EF%BC%9F\"><span class=\"toc-text\">谁是爹？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99\"><span class=\"toc-text\">方法的重写</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%87%8D%E5%86%99toString-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">重写toString()方法</span></a></li></ol>","author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2645370205"},"WeChat":{"icon":"/svg/wechat.svg","link":null}}}},"mapped":true,"prev_post":{"title":"Java_Learning(Week9)","uid":"7d4841571c0abc342271e318c113c7dc","slug":"Java-Learning-Week9","date":"2023-11-14T07:22:21.000Z","updated":"2023-11-14T09:07:16.675Z","comments":true,"path":"api/articles/Java-Learning-Week9.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/codeBackground.png","text":"说实话，我看了一下这一周的课件，我感觉学校还是没有讲东西，OOP的思想我上一周应该说的比较详细了，这周需要讲的一些东西应该就是多态和异常了，说实话这会儿讲异常没有什么必要我感觉，其他更重要的东西都还没讲，什么链表，哈希表这些的。 哦对了，顺便补一下之前拉下的一点东西，讲一下方法重...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":29,"path":"api/tags/笔记.json"},{"name":"Java初学","slug":"Java初学","count":9,"path":"api/tags/Java初学.json"}],"author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2645370205"},"WeChat":{"icon":"/svg/wechat.svg","link":null}}}},"feature":true},"next_post":{"title":"Java_Exercise(Week4)","uid":"19b17cf70fbf7b80415d6c3b17a3d380","slug":"Java-Exercise-Week4","date":"2023-10-14T04:44:30.000Z","updated":"2023-10-14T07:14:07.926Z","comments":true,"path":"api/articles/Java-Exercise-Week4.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/codeBackground.png","text":"说实话在我昨天晚上做玩这周的Exercise和CW之后，我对于这周是否要写这个笔记产生了很大的怀疑，难度确实有，但是不大，问题在于，想要把我昨天做题时候的思路讲清楚，呈现明白，是一个非常浪费时间和精力的事。。 想了想，还是写出来吧。 Exercise #4.1 Copy Even...","link":"","photos":[],"count_time":{"symbolsCount":"7.8k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":29,"path":"api/tags/笔记.json"},{"name":"Java初学","slug":"Java初学","count":9,"path":"api/tags/Java初学.json"}],"author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2645370205"},"WeChat":{"icon":"/svg/wechat.svg","link":null}}}}}}