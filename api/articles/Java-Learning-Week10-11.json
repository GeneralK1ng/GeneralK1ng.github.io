{"title":"Java_Learning(Week10&11)","uid":"39fbf399d55711348e77da1a1e71b32f","slug":"Java-Learning-Week10-11","date":"2023-11-30T08:33:11.000Z","updated":"2023-11-30T10:56:25.198Z","comments":true,"path":"api/articles/Java-Learning-Week10-11.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/codeBackground.png","content":"<p>哥们上周发烧了，就啥也没写，这周看能不能把两周的东西全写了。</p>\n<p>第十周这个<code>JavaFX</code>快被人喷烂了，我这里也不想写，我只写有必要学的。</p>\n<h1 id=\"Java-IO\"><a href=\"#Java-IO\" class=\"headerlink\" title=\"Java IO\"></a><code>Java IO</code></h1><p>首先，Java IO 指的是 Java Input/Output（输入/输出）的缩写。在编程中，输入/输出是指程序与外部世界之间的信息传递。</p>\n<p>就好比你在电脑上输入文字，或者程序输出一些结果。</p>\n<p>让我们以一个简单的例子来理解 Java IO。假设你有一个小程序，要求用户输入他们的名字，然后程序将打印出一个问候语。在这个例子中，用户输入和程序输出就是IO的一部分。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.util.Scanner;  // 导入一个用于输入的工具\n\npublic class GreetingProgram {\n    public static void main(String[] args) {\n        // 创建一个 Scanner 对象，用于接收用户的输入\n        Scanner scanner = new Scanner(System.in);\n\n        // 提示用户输入名字\n        System.out.print(\"请输入你的名字: \");\n\n        // 通过 Scanner 获取用户输入的名字\n        String userName = scanner.nextLine();\n\n        // 输出问候语\n        System.out.println(\"你好, \" + userName + \"! 欢迎使用这个程序。\");\n\n        // 关闭 Scanner 对象，释放资源\n        scanner.close();\n    }\n}\n</code></pre>\n\n<p>在这个例子中，<code>Scanner</code> 类帮助我们从控制台（<code>System.in</code>）获取用户的输入。这就是 Java 中的一种输入操作。而 <code>System.out.println</code> 则是一种输出操作，它将问候语打印到屏幕上。</p>\n<p>Java 的IO包含很多类，用于处理各种输入和输出。它们可以用于文件、网络、内存等不同的地方。就像你用不同的方式和不同的工具进行不同类型的交流一样，Java IO 也提供了不同的类来满足各种需求。</p>\n<h2 id=\"File类\"><a href=\"#File类\" class=\"headerlink\" title=\"File类\"></a><code>File</code>类</h2><p>在 Java 中，<code>File</code> 类是用来表示文件和目录路径的。就像你在电脑上有文件夹来存放文件一样，程序中也可以通过 <code>File</code> 类来处理文件和文件夹。</p>\n<p>举个例子，想象你有一个程序，需要读取或写入一些文本文件。这时候，<code>File</code> 类就可以帮助你指定文件的路径和名称。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.io.File;\n\npublic class FileExample {\n    public static void main(String[] args) {\n        // 创建一个 File 对象，表示一个文件\n        File myFile = new File(\"example.txt\");\n\n        // 判断文件是否存在\n        if (myFile.exists()) {\n            System.out.println(\"文件存在！\");\n        } else {\n            System.out.println(\"文件不存在！\");\n        }\n\n        // 获取文件名\n        String fileName = myFile.getName();\n        System.out.println(\"文件名：\" + fileName);\n\n        // 获取文件路径\n        String filePath = myFile.getAbsolutePath();\n        System.out.println(\"文件路径：\" + filePath);\n    }\n}\n</code></pre>\n\n<p>在这个例子中，我们创建了一个 <code>File</code> 对象，表示一个文件的路径。然后，我们检查文件是否存在，获取文件名和文件路径。</p>\n<p><code>File</code> 类的作用就像是一个文件的抽象描述，你可以使用它来检查文件是否存在、获取文件信息，甚至创建、删除文件。类似于你在电脑上通过文件夹来组织文件，程序中通过 <code>File</code> 类来处理文件和目录。</p>\n<h2 id=\"File类中的常用方法\"><a href=\"#File类中的常用方法\" class=\"headerlink\" title=\"File类中的常用方法\"></a><code>File</code>类中的常用方法</h2><p><strong><code>file.exists()</code>：</strong> 检查文件或目录是否存在。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">File myFile = new File(\"C:\\\\Users\\\\YourUsername\\\\Documents\\\\example.txt\");\n\nif (myFile.exists()) {\n    System.out.println(\"文件存在！\");\n} else {\n    System.out.println(\"文件不存在！\");\n}</code></pre>\n\n<p><strong><code>file.isFile()</code>：</strong> 判断给定路径是否表示一个文件。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">File myFile = new File(\"C:\\\\Users\\\\YourUsername\\\\Documents\\\\example.txt\");\n\nif (myFile.isFile()) {\n    System.out.println(\"这是一个文件！\");\n} else {\n    System.out.println(\"这不是一个文件！\");\n}</code></pre>\n\n<p><strong><code>file.isDirectory()</code>：</strong> 判断给定路径是否表示一个目录。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">File myDirectory = new File(\"C:\\\\Users\\\\YourUsername\\\\Documents\");\n\nif (myDirectory.isDirectory()) {\n    System.out.println(\"这是一个目录！\");\n} else {\n    System.out.println(\"这不是一个目录！\");\n}</code></pre>\n\n<p><strong><code>file.isHidden()</code>：</strong> 判断文件是否是隐藏文件。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">File myFile = new File(\"C:\\\\Users\\\\YourUsername\\\\Documents\\\\example.txt\");\n\nif (myFile.isHidden()) {\n    System.out.println(\"这是一个隐藏文件！\");\n} else {\n    System.out.println(\"这不是一个隐藏文件！\");\n}</code></pre>\n\n<p><strong><code>file.length()</code>：</strong> 获取文件的长度（以字节为单位）。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">File myFile = new File(\"C:\\\\Users\\\\YourUsername\\\\Documents\\\\example.txt\");\nlong fileSize = myFile.length();\n\nSystem.out.println(\"文件大小：\" + fileSize + \" 字节\");</code></pre>\n\n<p><strong><code>file.canRead()</code>：</strong> 判断文件是否可读。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">File myFile = new File(\"C:\\\\Users\\\\YourUsername\\\\Documents\\\\example.txt\");\n\nif (myFile.canRead()) {\n    System.out.println(\"文件可读！\");\n} else {\n    System.out.println(\"文件不可读！\");\n}</code></pre>\n\n<p><strong><code>file.canWrite()</code>：</strong> 判断文件是否可写。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">File myFile = new File(\"C:\\\\Users\\\\YourUsername\\\\Documents\\\\example.txt\");\n\nif (myFile.canWrite()) {\n    System.out.println(\"文件可写！\");\n} else {\n    System.out.println(\"文件不可写！\");\n}</code></pre>\n\n<p><strong><code>file.getAbsolutePath()</code>：</strong> 获取文件或目录的绝对路径。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">File myFile = new File(\"C:\\\\Users\\\\YourUsername\\\\Documents\\\\example.txt\");\nString absolutePath = myFile.getAbsolutePath();\n\nSystem.out.println(\"文件的绝对路径：\" + absolutePath);</code></pre>\n\n<h2 id=\"绝对路径与相对路径\"><a href=\"#绝对路径与相对路径\" class=\"headerlink\" title=\"绝对路径与相对路径\"></a>绝对路径与相对路径</h2><h3 id=\"绝对路径\"><a href=\"#绝对路径\" class=\"headerlink\" title=\"绝对路径\"></a>绝对路径</h3><p>想象一下你住在一个大城市中，有很多房子和街道。每个房子都有一个唯一的地址，这个地址就像文件在计算机中的绝对路径一样。绝对路径告诉计算机，文件在整个文件系统中的确切位置。</p>\n<p><strong>在计算机中：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">File myFile = new File(\"C:\\\\Users\\\\YourUsername\\\\Documents\\\\example.txt\");</code></pre>\n\n<p>这里的 <code>\"C:\\\\Users\\\\YourUsername\\\\Documents\\\\example.txt\"</code> 就是文件的绝对路径。就像你的家庭地址告诉你的朋友你住在哪个房子一样，计算机使用绝对路径告诉程序文件在哪里。</p>\n<h3 id=\"相对路径\"><a href=\"#相对路径\" class=\"headerlink\" title=\"相对路径\"></a>相对路径</h3><p>相对路径有点像给朋友一个指示方向的方式。想象你和朋友在一个大花园里，有很多树和小道。如果你告诉朋友：“在我们左侧的第三颗大树旁边有一个小花园”，这就是相对于你当前位置的路径描述。相对路径是相对于当前工作目录或当前文件所在的位置的路径。</p>\n<p><strong>在计算机中：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">File myFile = new File(\"Documents\\\\example.txt\");</code></pre>\n\n<p>这里的 <code>\"Documents\\\\example.txt\"</code> 就是文件的相对路径。程序会在当前工作目录或当前文件所在的位置中寻找这个文件。</p>\n<h2 id=\"PrintWriter类\"><a href=\"#PrintWriter类\" class=\"headerlink\" title=\"PrintWriter类\"></a><code>PrintWriter</code>类</h2><p>如果我们需要向文件当中写入一些内容，我们就可以用到<code>PrintWriter</code>类，就相当于我们用来写字的笔一样。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.io.FileWriter;\nimport java.io.PrintWriter;\nimport java.io.IOException;\n\npublic class LetterWriter {\n    public static void main(String[] args) {\n        try {\n            // 创建一个 PrintWriter 对象，用于写入文件\n            PrintWriter writer = new PrintWriter(new FileWriter(\"letter.txt\"));\n\n            // 写入信的内容\n            writer.println(\"亲爱的朋友,\");\n            writer.println(\"希望你过得很好！\");\n            writer.println(\"祝你一切顺利。\");\n\n            // 关闭 PrintWriter，确保写入完成\n            writer.close();\n            \n            System.out.println(\"信已写入文件！\");\n        } catch (IOException e) {\n            System.out.println(\"写信时出错：\" + e.getMessage());\n        }\n    }\n}\n</code></pre>\n\n<p>在这个例子中，我们创建了一个 <code>PrintWriter</code> 对象，用于写入文件。然后，我们使用 <code>println</code> 方法向文件写入每一行信的内容。最后，我们关闭 <code>PrintWriter</code>，确保信的内容已经写入文件。</p>\n<h2 id=\"BufferedWriter类\"><a href=\"#BufferedWriter类\" class=\"headerlink\" title=\"BufferedWriter类\"></a><code>BufferedWriter</code>类</h2><p>想象一下你在写一篇文章，你可以选择是逐字逐句写，还是先在脑海中构思好，然后再一次性写入。<code>BufferedWriter</code> 就像是帮你提前构思好的大脑，让你能够更高效地写入文件。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class ArticleWriter {\n    public static void main(String[] args) {\n        try {\n            // 创建一个 BufferedWriter 对象，用于写入文件\n            BufferedWriter writer = new BufferedWriter(new FileWriter(\"article.txt\"));\n\n            // 写入文章内容\n            writer.write(\"今天是个美好的一天。\\n\");\n            writer.write(\"阳光明媚，空气清新。\\n\");\n            writer.write(\"希望每个人都过得愉快！\");\n\n            // 关闭 BufferedWriter，确保写入完成\n            writer.close();\n            \n            System.out.println(\"文章已写入文件！\");\n        } catch (IOException e) {\n            System.out.println(\"写文章时出错：\" + e.getMessage());\n        }\n    }\n}\n</code></pre>\n\n<p>在这个例子中，我们创建了一个 <code>BufferedWriter</code> 对象，它负责将数据写入文件。然后，我们使用 <code>write</code> 方法逐行写入文章内容。最后，我们关闭 <code>BufferedWriter</code>，确保文章的内容已经写入文件。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>BufferedWriter</code> 和 <code>PrintWriter</code> 都是 Java 中用于写入文件的类，但它们有一些区别。</p>\n<p><strong>1. 数据类型:</strong></p>\n<ul>\n<li><code>BufferedWriter</code> 主要用于写入字符数据，而且通常搭配其他的 <code>Writer</code> 使用。</li>\n<li><code>PrintWriter</code> 则旨在向文本文件写入各种类型的数据，包括字符、数字等。它继承自 <code>Writer</code> 类，但提供了更高级别的写入操作。</li>\n</ul>\n<p><strong>2. 功能:</strong></p>\n<ul>\n<li><code>BufferedWriter</code> 主要关注的是提高写入性能，通过在内存中创建缓冲区，将数据一次性写入文件，而不是每次都直接写入文件。</li>\n<li><code>PrintWriter</code> 提供了方便的写入各种数据类型的方法，例如 <code>println</code> 可以用于写入一行文本，<code>print</code> 可以用于写入其他数据类型。</li>\n</ul>\n<p><strong>3. 用途:</strong></p>\n<ul>\n<li>如果你主要关心写入字符数据并提高写入性能，比如写入大量文本数据，那么 <code>BufferedWriter</code> 是个好选择。</li>\n<li>如果你需要更高级别的写入操作，比如写入不同类型的数据，而且希望写入更方便，那么 <code>PrintWriter</code> 可能更适合你。</li>\n</ul></blockquote>\n<h2 id=\"BufferedReader类\"><a href=\"#BufferedReader类\" class=\"headerlink\" title=\"BufferedReader类\"></a><code>BufferedReader</code>类</h2><p>如果你在阅读一本书，有时你可能会一次读一个字，但这样效率不高。<code>BufferedReader</code> 就像是一种阅读方式，它可以提高你读取文本的效率，一次读取一行文字。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class BookReader {\n    public static void main(String[] args) {\n        try {\n            // 创建一个 BufferedReader 对象，用于读取文件\n            BufferedReader reader = new BufferedReader(new FileReader(\"book.txt\"));\n\n            // 读取书的内容一行一行地输出\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n\n            // 关闭 BufferedReader\n            reader.close();\n            \n            System.out.println(\"书已读完！\");\n        } catch (IOException e) {\n            System.out.println(\"读书时出错：\" + e.getMessage());\n        }\n    }\n}</code></pre>\n\n<p>在这个例子中，我们创建了一个 <code>BufferedReader</code> 对象，它负责从文件中读取数据。然后，我们使用 <code>readLine</code> 方法一次读取一行书的内容，并输出到控制台。最后，我们关闭 <code>BufferedReader</code>，表示我们已经读完了这本书。</p>\n<p>以上就是学校教的了，但是！其实压根没讲全，没讲明白，所以下来我来补充。</p>\n<h2 id=\"什么是流？\"><a href=\"#什么是流？\" class=\"headerlink\" title=\"什么是流？\"></a>什么是流？</h2><p>想象一下水流，水从一个地方流向另一个地方，这是一个连续的过程。在计算机中，流也是一种数据的流动方式，数据可以从一个地方（比如文件、网络、键盘）流向另一个地方（比如文件、网络、屏幕）。</p>\n<p>在计算机中，流是一种用于处理输入和输出的概念。就像水流一样，数据可以流经不同的管道（流），从一个地方传送到另一个地方。</p>\n<ul>\n<li><strong>输入流（Input Stream）：</strong> 就像是水流进入计算机，可以是文件、键盘、网络等。我们可以从输入流中读取数据。</li>\n<li><strong>输出流（Output Stream）：</strong> 就像是水流离开计算机，可以是文件、屏幕、网络等。我们可以往输出流中写入数据。</li>\n</ul>\n<p>可以把流比作一个管道，通过这个管道可以传送数据。输入流就像是管道的一端，数据从外部流入计算机；输出流就像是管道的另一端，数据从计算机流向外部。这样，我们就可以通过这个管道实现数据的输入和输出。</p>\n<p>在Java中，流是一种用于在程序中读取和写入数据的机制。流可以用于处理各种输入和输出，如文件、网络连接、内存等。Java中的流按照数据类型分为字节流（Byte Stream）和字符流（Character Stream），以及按照功能分为输入流和输出流。</p>\n<h3 id=\"字节流（Byte-Stream）\"><a href=\"#字节流（Byte-Stream）\" class=\"headerlink\" title=\"字节流（Byte Stream）\"></a>字节流（Byte Stream）</h3><p>想象一下，你正在把一本书从图书馆搬到家里。这本书就像是你的数据，而搬运的过程就是数据在计算机中传输的过程。在Java中，字节流就好比是你用一个个小车把书本一页一页地搬运到家里的过程。</p>\n<p>字节流就是一种比较原始的搬运方式，就像是逐页逐页地把书本搬运到家里。Java中的字节流可以帮助我们在程序中传输和处理数据，就像你搬运书本一样。</p>\n<h3 id=\"字符流（Character-Stream）\"><a href=\"#字符流（Character-Stream）\" class=\"headerlink\" title=\"字符流（Character Stream）\"></a>字符流（Character Stream）</h3><p>字符流和字节流有些相似，但在处理文本数据时更方便。让我们用一个类似的比喻来解释字符流。</p>\n<p>想象你有一张写满字的便签，这些字就是你的文本数据。你想要把这张便签上的文字复制到电脑里。这时候，你会用一个专门读取文字的笔，而不是一个一页一页地搬运。</p>\n<p>在Java中，字符流就像这支专门读取文字的笔。它以字符为单位进行读写，而不是字节。这样做的好处是，在处理文本文件时，字符流可以更好地处理字符编码，确保我们正确地读取和写入文本数据。</p>\n<p>也就是说，字符流更加适合来处理字符，或者说是文本数据。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/JavaIO.svg\"></p>\n<p>这张图说明了输入流和输出流的类层次</p>\n<h2 id=\"FileInputStream\"><a href=\"#FileInputStream\" class=\"headerlink\" title=\"FileInputStream\"></a><code>FileInputStream</code></h2><p>想象一下你的电脑是一个大型文件柜，里面有很多文件夹和文件。有时候，你可能想要读取某个文件的内容，就像打开文件柜并查看文件一样。这时候，Java中的<code>FileInputStream</code>就像是一个专门用来帮你读取文件的小助手。</p>\n<p>首先，你需要告诉这个小助手你要读取哪个文件。就像告诉朋友：“嘿，我要看一下那个文件柜里的那个文件”，你需要给<code>FileInputStream</code>一个文件的路径，告诉它你要读取哪个文件。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// 创建一个FileInputStream，告诉它你要读取的文件是哪个\nFileInputStream fis = new FileInputStream(\"文件的路径\");</code></pre>\n\n<p>现在，它知道你要读取哪个文件了。接下来，你可以要求它帮你一个字一个字地读取文件的内容。就像你可以一个一个字母地读一封信一样。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// 创建一个变量来存储读取到的字节\nint byteRead = fis.read();</code></pre>\n\n<p>上面的代码告诉小助手：“嘿，帮我读取文件的第一个字节。”小助手会告诉你这个字节是什么，然后你可以决定做什么，比如显示在屏幕上或者做其他处理。</p>\n<p>读取完一个字节后，你可以继续读取下一个字节，直到整个文件都被读取完毕。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">while (byteRead != -1) {\n    // 处理读取到的字节，比如显示在屏幕上\n    System.out.print((char) byteRead);\n\n    // 继续读取下一个字节\n    byteRead = fis.read();\n}</code></pre>\n\n<p>最后记得释放资源：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// 关闭FileInputStream\nfis.close();</code></pre>\n\n<h2 id=\"FileOutputStream\"><a href=\"#FileOutputStream\" class=\"headerlink\" title=\"FileOutputStream\"></a><code>FileOutputStream</code></h2><p>当你想要往文件里写入内容时，就可以使用Java中的<code>FileOutputStream</code>。</p>\n<p>想象一下，你现在想在文件柜里新建一个文件，并开始写一些东西。Java中的<code>FileOutputStream</code>就像是一个小秘书，专门帮你把你想写的东西一个字一个字地写进文件里。</p>\n<p>首先，你需要告诉这个小秘书你要写入哪个文件。就像对朋友说：“我要在文件柜里的这个文件里写点东西”，你需要给<code>FileOutputStream</code>一个文件的路径，告诉它你要写入哪个文件。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// 创建一个FileOutputStream，告诉它你要写入的文件是哪个\nFileOutputStream fos = new FileOutputStream(\"文件的路径\");</code></pre>\n\n<p>现在，小秘书知道你要往哪个文件写入了。接下来，你可以告诉它你要写入的内容是什么。就像告诉小秘书：“嘿，帮我写下这一句话”，你需要把要写入的内容转换成字节数组，并传给<code>FileOutputStream</code>。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// 要写入的内容，这里用字符串举例\nString content = \"你好，文件！\";\n// 把字符串转换成字节数组\nbyte[] byteContent = content.getBytes();\n\n// 告诉小秘书把这个字节数组写入文件\nfos.write(byteContent);</code></pre>\n\n<p>上面的代码告诉小秘书：“好的，帮我把这个字节数组写入文件。”小秘书会帮你把内容一个字一个字地写进文件。</p>\n<p>最后一样，记得释放资源。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// 关闭FileOutputStream\nfos.close();</code></pre>\n\n<h1 id=\"集合框架（Collections-Framework）\"><a href=\"#集合框架（Collections-Framework）\" class=\"headerlink\" title=\"集合框架（Collections Framework）\"></a>集合框架（Collections Framework）</h1><p>这周讲了几个数据结构，但是没细讲，因为我们下学期好像有算法课，但是无所谓，讲了就先记着。</p>\n<p>首先，什么是集合框架呢？在Java中，集合框架是一组用于存储和操作数据的类和接口。就像你有一个盒子，可以把不同类型的东西放进去，Java的集合框架也提供了不同类型的容器，用于存储和处理数据。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/Collection.svg\"></p>\n<h2 id=\"集合框架的种类\"><a href=\"#集合框架的种类\" class=\"headerlink\" title=\"集合框架的种类\"></a>集合框架的种类</h2><ul>\n<li><strong>List（列表）：</strong> 就像一个有序的清单，你可以按照顺序放入和取出物品。比如，一个购物清单就是一个List。</li>\n<li><strong>Set（集合）：</strong> 就像一个没有重复物品的袋子，你可以往里放入各种东西，但相同的东西只会有一个。比如，一个装满不同颜色糖果的袋子就是一个Set。</li>\n<li><strong>Map（映射）：</strong> 就像一本字典，你可以查找特定的词语并找到对应的解释。在Java中，Map允许你用一个值（键）来查找另一个值（值）。</li>\n<li><strong>Queue（队列）：</strong> 就像排队等候的人一样，先来的先被处理。在Java中，Queue用于处理先进先出（FIFO）的数据结构。</li>\n</ul>\n<h2 id=\"具体的集合类\"><a href=\"#具体的集合类\" class=\"headerlink\" title=\"具体的集合类\"></a>具体的集合类</h2><p>这些集合框架中的每一个都有具体的实现类，就像箱子的每个分区都有不同的盒子。比如，<code>List</code>有<code>ArrayList</code>、<code>LinkedList</code>，<code>Set</code>有<code>HashSet</code>、<code>TreeSet</code>，<code>Map</code>有<code>HashMap</code>、<code>TreeMap</code>等。</p>\n<p>像<code>List</code>、<code>Set</code>这些都是接口，而<code>ArrayList</code>是它的实现类，这里只是说明一下，毕竟我们没学接口。</p>\n<ul>\n<li><strong><code>ArrayList</code>：</strong> 动态数组，可以动态增长和缩小。适合随机访问元素。</li>\n<li><strong><code>LinkedList</code>：</strong> 双向链表，对于频繁的插入和删除操作比<code>ArrayList</code>更高效。</li>\n<li><strong><code>HashSet</code>：</strong> 无序、不包含重复元素的集合。</li>\n<li><strong><code>LinkedHashSet</code>：</strong> 有序、不包含重复元素的集合，保留了元素的插入顺序。</li>\n<li><strong><code>TreeSet</code>：</strong> 有序、不包含重复元素的集合，按照元素的自然顺序或者指定的比较器进行排序。</li>\n<li><strong><code>HashMap</code>：</strong> 无序的键值对集合，使用哈希表实现。</li>\n<li><strong><code>LinkedHashMap</code>：</strong> 有序的键值对集合，保留了元素的插入顺序。</li>\n<li><strong><code>TreeMap</code>：</strong> 有序的键值对集合，按照键的自然顺序或者指定的比较器进行排序。</li>\n</ul>\n<h2 id=\"为什么要用这些？\"><a href=\"#为什么要用这些？\" class=\"headerlink\" title=\"为什么要用这些？\"></a>为什么要用这些？</h2><p>byd想要自己手搓链表？手搓数据结构？</p>\n<p>体验过一遍你就不会想要再来了，所以Java给你提供了，直接用就行，这也是封装的体现。</p>\n<h1 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h1><p>当我们谈到泛型时，可以将其比喻成一种“万能容器”，就像一个可以装任何类型的盒子一样。让我们通过一个简单的例子来理解泛型：</p>\n<h2 id=\"1-什么是泛型？\"><a href=\"#1-什么是泛型？\" class=\"headerlink\" title=\"1. 什么是泛型？\"></a>1. 什么是泛型？</h2><p>泛型是一种让你在编写代码时，不仅可以指定数据类型，还可以使代码更灵活、通用的特性。就像你可以用一个盒子来容纳各种各样的东西，泛型让你的代码可以容纳不同类型的数据。</p>\n<h2 id=\"2-为什么需要泛型？\"><a href=\"#2-为什么需要泛型？\" class=\"headerlink\" title=\"2. 为什么需要泛型？\"></a>2. 为什么需要泛型？</h2><p>假设你有一个盒子类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Box {\n    private Object content;\n\n    public void setContent(Object content) {\n        this.content = content;\n    }\n\n    public Object getContent() {\n        return content;\n    }\n}</code></pre>\n\n<p>这个盒子可以装任何东西，但有一个问题，当你想取出盒子里的东西时，你必须强制转换类型：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Box myBox = new Box();\nmyBox.setContent(\"Hello, World!\");\n\n// 需要强制转换类型\nString message = (String) myBox.getContent();</code></pre>\n\n<p>这样的代码看起来有些麻烦，而且容易出错。泛型的出现就是为了解决这个问题。</p>\n<h2 id=\"3-使用泛型的盒子：\"><a href=\"#3-使用泛型的盒子：\" class=\"headerlink\" title=\"3. 使用泛型的盒子：\"></a>3. 使用泛型的盒子：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class GenericBox&lt;T&gt; {\n    private T content;\n\n    public void setContent(T content) {\n        this.content = content;\n    }\n\n    public T getContent() {\n        return content;\n    }\n}</code></pre>\n\n<p>在这个泛型盒子中，<code>&lt;T&gt;</code>表示这是一个泛型类，<code>T</code>是类型的占位符，可以代表任何数据类型。现在，你可以创建一个可以装任何类型的盒子：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">GenericBox&lt;String&gt; myGenericBox = new GenericBox&lt;&gt;();\nmyGenericBox.setContent(\"Hello, World!\");\n\n// 不需要强制转换类型\nString message = myGenericBox.getContent();</code></pre>\n\n<h2 id=\"4-泛型的好处：\"><a href=\"#4-泛型的好处：\" class=\"headerlink\" title=\"4. 泛型的好处：\"></a>4. 泛型的好处：</h2><ul>\n<li><strong>类型安全：</strong> 泛型提供了类型检查，防止在编译时发生类型错误。</li>\n<li><strong>代码重用：</strong> 泛型可以使你编写更通用的代码，适用于多种数据类型。</li>\n</ul>\n<h2 id=\"5-示例：使用泛型的集合：\"><a href=\"#5-示例：使用泛型的集合：\" class=\"headerlink\" title=\"5. 示例：使用泛型的集合：\"></a>5. 示例：使用泛型的集合：</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;String&gt; myList = new ArrayList&lt;&gt;();\nmyList.add(\"苹果\");\nmyList.add(\"香蕉\");\n\n// 不需要强制转换类型\nString fruit = myList.get(0);</code></pre>\n\n<p>在这个例子中，<code>List&lt;String&gt;</code>表示这是一个字符串类型的列表，你可以放入和取出字符串，不需要担心类型转换问题。</p>\n<p>说白了，就是告诉你，这个数据结构里面装的是什么类型的东西，是装什么对象的。</p>\n<h1 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a><code>List</code></h1><p>记住List是一个接口，下面的两个都是它的实现类，在实现类当中必须实现接口中的所有方法，所以，只要是List中的方法，在下面的两个实现类当中都能用。</p>\n<p>当我们谈到<code>List</code>接口时，可以把它看作是一个有序的集合，就像你的播放列表一样，你可以按照特定的顺序存储和访问元素。<code>List</code>接口提供了一系列方法，让我们能够方便地操作列表中的元素。以下是一些常用的<code>List</code>接口方法：</p>\n<h2 id=\"常用的List接口方法：\"><a href=\"#常用的List接口方法：\" class=\"headerlink\" title=\"常用的List接口方法：\"></a>常用的<code>List</code>接口方法：</h2><h3 id=\"添加元素：\"><a href=\"#添加元素：\" class=\"headerlink\" title=\"添加元素：\"></a><strong>添加元素：</strong></h3><p><code>add(E element)</code>: 将元素添加到列表的末尾。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;String&gt; playlist = new ArrayList&lt;&gt;();\nplaylist.add(\"歌曲1\");\nplaylist.add(\"歌曲2\");</code></pre>\n\n<p><code>add(int index, E element)</code>: 在指定位置插入元素。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">playlist.add(1, \"歌曲3\");</code></pre>\n\n<h3 id=\"获取元素：\"><a href=\"#获取元素：\" class=\"headerlink\" title=\"获取元素：\"></a><strong>获取元素：</strong></h3><p><code>get(int index)</code>: 获取指定位置（索引）的元素。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String song = playlist.get(0);</code></pre>\n\n<h3 id=\"移除元素：\"><a href=\"#移除元素：\" class=\"headerlink\" title=\"移除元素：\"></a><strong>移除元素：</strong></h3><p><code>remove(int index)</code>: 移除指定位置的元素。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">playlist.remove(1);</code></pre>\n\n<p><code>remove(Object obj)</code>: 移除第一次出现的指定元素。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">playlist.remove(\"歌曲1\");</code></pre>\n\n<h3 id=\"判断元素是否存在：\"><a href=\"#判断元素是否存在：\" class=\"headerlink\" title=\"判断元素是否存在：\"></a><strong>判断元素是否存在：</strong></h3><p><code>contains(Object obj)</code>: 判断列表中是否包含指定元素。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">boolean hasSong = playlist.contains(\"歌曲2\");</code></pre>\n\n<h3 id=\"获取列表大小：\"><a href=\"#获取列表大小：\" class=\"headerlink\" title=\"获取列表大小：\"></a><strong>获取列表大小：</strong></h3><p><code>size()</code>: 获取列表中元素的数量。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int numberOfSongs = playlist.size();</code></pre>\n\n<h3 id=\"遍历列表：\"><a href=\"#遍历列表：\" class=\"headerlink\" title=\"遍历列表：\"></a><strong>遍历列表：</strong></h3><p>使用<code>for</code>循环或者迭代器<code>Iterator</code>来遍历列表中的元素。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">for (String song : playlist) {\n    System.out.println(song);\n}\n\n// 或者\n\nIterator&lt;String&gt; iterator = playlist.iterator();\nwhile (iterator.hasNext()) {\n    String song = iterator.next();\n    System.out.println(song);\n}\n</code></pre>\n\n<h3 id=\"替换元素：\"><a href=\"#替换元素：\" class=\"headerlink\" title=\"替换元素：\"></a><strong>替换元素：</strong></h3><p><code>set(int index, E element)</code>: 替换指定位置的元素。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">playlist.set(0, \"新歌曲\");</code></pre>\n\n<h2 id=\"增强For\"><a href=\"#增强For\" class=\"headerlink\" title=\"增强For\"></a>增强For</h2><p>就是一种For循环，你们肯定也会见过IDEA中用黄色波浪线画出来说你这个<code>for</code>循环可以替换为增强<code>for</code>。</p>\n<p>增强<code>for</code>循环也被称为<code>for-each</code>循环，它提供了一种简化遍历数组或集合的语法。语法格式如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">for (ElementType variable : collection) {\n    // 循环体，使用 variable 访问当前元素\n}</code></pre>\n\n<p>其中，<code>ElementType</code>是集合中元素的类型，<code>variable</code>是一个新的变量，用于存储当前循环迭代的元素，<code>collection</code>是被遍历的集合。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;String&gt; fruits = Arrays.asList(\"苹果\", \"香蕉\", \"橙子\");\n\n// 使用增强for循环遍历列表\nfor (String fruit : fruits) {\n    System.out.println(fruit);\n}</code></pre>\n\n<p>这段代码将会输出：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">苹果\n香蕉\n橙子</code></pre>\n\n<h2 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h2><p>迭代器是一种更传统的遍历集合的方式，它是<code>Iterator</code>接口的实现类。通过迭代器，你可以手动控制遍历的过程，并进行一些额外的操作。迭代器提供了三个基本方法：</p>\n<ul>\n<li><code>hasNext()</code>: 判断集合中是否还有下一个元素。</li>\n<li><code>next()</code>: 返回集合中的下一个元素，并将迭代器的位置移动到下一个元素。</li>\n<li><code>remove()</code>: 从集合中移除上一个返回的元素（可选操作）。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);\n\n// 使用迭代器遍历列表\nIterator&lt;Integer&gt; iterator = numbers.iterator();\nwhile (iterator.hasNext()) {\n    Integer number = iterator.next();\n    System.out.println(number);\n}</code></pre>\n\n<p>这段代码同样会输出：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">1\n2\n3\n4\n5</code></pre>\n\n<h3 id=\"选择使用哪种方式？\"><a href=\"#选择使用哪种方式？\" class=\"headerlink\" title=\"选择使用哪种方式？\"></a><strong>选择使用哪种方式？</strong></h3><ul>\n<li><strong>增强For循环：</strong> 适用于简单的遍历操作，语法简洁，易读。</li>\n<li><strong>迭代器：</strong> 提供了更多的控制权，可以在遍历的同时对集合进行操作，适用于需要更多控制的情况。</li>\n</ul>\n<p>实际上，肯定还是增强For用的多，但是不代表迭代器你就可以不学了。</p>\n<h2 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a><code>ArrayList</code></h2><p>当我们谈到<code>ArrayList</code>时，可以把它比作一个可伸缩的动态数组，就像你的书包可以随时放入更多的书一样。让我们通过简单的例子来理解<code>ArrayList</code>：</p>\n<h3 id=\"1-什么是ArrayList？\"><a href=\"#1-什么是ArrayList？\" class=\"headerlink\" title=\"1. 什么是ArrayList？\"></a>1. 什么是<code>ArrayList</code>？</h3><p><code>ArrayList</code>是Java中的一种数据结构，它允许我们以列表的形式存储一组元素。就像你的书包可以容纳许多书籍一样，<code>ArrayList</code>可以容纳很多数据。</p>\n<h3 id=\"2-如何使用ArrayList？\"><a href=\"#2-如何使用ArrayList？\" class=\"headerlink\" title=\"2. 如何使用ArrayList？\"></a>2. 如何使用<code>ArrayList</code>？</h3><p>假设我们有一个<code>ArrayList</code>用来存储水果：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建一个ArrayList来存储水果\n        ArrayList&lt;String&gt; fruits = new ArrayList&lt;&gt;();\n\n        // 添加水果\n        fruits.add(\"苹果\");\n        fruits.add(\"香蕉\");\n        fruits.add(\"橙子\");\n\n        // 打印水果\n        System.out.println(\"水果列表: \" + fruits);\n    }\n}</code></pre>\n\n<p>在这个例子中，我们首先创建了一个<code>ArrayList</code>，然后向其中添加了一些水果（”苹果”、”香蕉”、”橙子”）。最后，我们打印整个水果列表。</p>\n<h3 id=\"3-ArrayList的好处\"><a href=\"#3-ArrayList的好处\" class=\"headerlink\" title=\"3. ArrayList的好处\"></a>3. <code>ArrayList</code>的好处</h3><ul>\n<li><strong>动态大小：</strong> 与普通数组不同，<code>ArrayList</code>的大小是动态的，你可以根据需要添加或删除元素，而不用担心数组的固定大小。</li>\n<li><strong>方便操作：</strong> <code>ArrayList</code>提供了许多方便的方法，比如添加元素、删除元素、获取元素等，使得对数据的操作更加灵活。</li>\n</ul>\n<h3 id=\"4-操作ArrayList\"><a href=\"#4-操作ArrayList\" class=\"headerlink\" title=\"4. 操作ArrayList\"></a>4. 操作<code>ArrayList</code></h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// 获取特定位置的水果\nString firstFruit = fruits.get(0);\nSystem.out.println(\"第一个水果: \" + firstFruit);\n\n// 删除水果\nfruits.remove(\"香蕉\");\nSystem.out.println(\"删除香蕉后的列表: \" + fruits);</code></pre>\n\n<p>在这里，我们通过<code>get</code>方法获取第一个水果，然后使用<code>remove</code>方法删除了”香蕉”。</p>\n<p>对于我而言，这个玩意最好的地方在于动态，你可以回想一下自己用数组的时候的诸多不便，这里基本上都能解决了。</p>\n<h2 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a><code>LinkedList</code></h2><p>当我们谈到<code>LinkedList</code>时，可以将其比作一条可以在节点之间移动的链表，就像你的项链上的各种珠子可以一个接一个地连接一样。让我们通过简单的例子来理解<code>LinkedList</code>：</p>\n<h3 id=\"1-什么是LinkedList？\"><a href=\"#1-什么是LinkedList？\" class=\"headerlink\" title=\"1. 什么是LinkedList？\"></a>1. 什么是LinkedList？</h3><p><code>LinkedList</code>是Java中的一种数据结构，它使用节点（Node）的方式来存储元素，每个节点都包含一个元素和指向下一个节点的引用。就像项链上的珠子一个接一个地连接，<code>LinkedList</code>中的元素也是通过节点连接的。</p>\n<h3 id=\"2-如何使用LinkedList？\"><a href=\"#2-如何使用LinkedList？\" class=\"headerlink\" title=\"2. 如何使用LinkedList？\"></a>2. 如何使用LinkedList？</h3><p>假设我们有一个<code>LinkedList</code>用来存储颜色：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.util.LinkedList;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建一个LinkedList来存储颜色\n        LinkedList&lt;String&gt; colors = new LinkedList&lt;&gt;();\n\n        // 添加颜色\n        colors.add(\"红色\");\n        colors.add(\"绿色\");\n        colors.add(\"蓝色\");\n\n        // 打印颜色\n        System.out.println(\"颜色链表: \" + colors);\n    }\n}</code></pre>\n\n<p>在这个例子中，我们首先创建了一个<code>LinkedList</code>，然后向其中添加了一些颜色（”红色”、”绿色”、”蓝色”）。最后，我们打印整个颜色链表。</p>\n<h3 id=\"3-LinkedList的好处\"><a href=\"#3-LinkedList的好处\" class=\"headerlink\" title=\"3. LinkedList的好处\"></a>3. LinkedList的好处</h3><ul>\n<li><strong>动态操作：</strong> 与<code>ArrayList</code>不同，<code>LinkedList</code>对于频繁的插入和删除操作更为高效，因为它只需要调整节点的引用。</li>\n<li><strong>节点连接：</strong> <code>LinkedList</code>的元素通过节点相互连接，这意味着你可以在链表中方便地插入或删除元素。</li>\n</ul>\n<h3 id=\"4-操作LinkedList\"><a href=\"#4-操作LinkedList\" class=\"headerlink\" title=\"4. 操作LinkedList\"></a>4. 操作LinkedList</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// 获取第一个颜色\nString firstColor = colors.getFirst();\nSystem.out.println(\"第一个颜色: \" + firstColor);\n\n// 在指定位置插入颜色\ncolors.add(1, \"黄色\");\nSystem.out.println(\"插入黄色后的链表: \" + colors);</code></pre>\n\n<p>在这里，我们通过<code>getFirst</code>方法获取第一个颜色，然后使用<code>add</code>方法在指定位置插入了”黄色”。</p>\n<p>这个就是双向链表，具体的数据结构细节这里我就不说了，如果有时间的话以后再说，你只需要记得，频繁的删改，这个更加高效。</p>\n<h1 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a><code>Set</code></h1><p>跟<code>List</code>一样，<code>Set</code>也是一样的，也是接口。</p>\n<p>当我们谈到<code>Set</code>接口时，可以将其比作一个独特的盒子，这个盒子只能放不同的物品，不允许重复。<code>Set</code>是一种集合，它不保留元素的插入顺序，而且不允许包含重复元素。</p>\n<h2 id=\"常用的Set接口方法：\"><a href=\"#常用的Set接口方法：\" class=\"headerlink\" title=\"常用的Set接口方法：\"></a>常用的<code>Set</code>接口方法：</h2><h3 id=\"添加元素：-1\"><a href=\"#添加元素：-1\" class=\"headerlink\" title=\"添加元素：\"></a><strong>添加元素：</strong></h3><p><code>add(E element)</code>: 将元素添加到集合中。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Set&lt;String&gt; uniqueColors = new HashSet&lt;&gt;();\nuniqueColors.add(\"红色\");\nuniqueColors.add(\"绿色\");\nuniqueColors.add(\"蓝色\");</code></pre>\n\n<h3 id=\"移除元素：-1\"><a href=\"#移除元素：-1\" class=\"headerlink\" title=\"移除元素：\"></a><strong>移除元素：</strong></h3><p><code>remove(Object obj)</code>: 从集合中移除指定元素。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">uniqueColors.remove(\"绿色\");</code></pre>\n\n<h3 id=\"判断元素是否存在：-1\"><a href=\"#判断元素是否存在：-1\" class=\"headerlink\" title=\"判断元素是否存在：\"></a><strong>判断元素是否存在：</strong></h3><p><code>contains(Object obj)</code>: 判断集合中是否包含指定元素。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">boolean hasRed = uniqueColors.contains(\"红色\");</code></pre>\n\n<h3 id=\"获取集合大小：\"><a href=\"#获取集合大小：\" class=\"headerlink\" title=\"获取集合大小：\"></a><strong>获取集合大小：</strong></h3><p><code>size()</code>: 获取集合中元素的数量。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int numberOfColors = uniqueColors.size();</code></pre>\n\n<h3 id=\"清空集合：\"><a href=\"#清空集合：\" class=\"headerlink\" title=\"清空集合：\"></a><strong>清空集合：</strong></h3><p><code>clear()</code>: 移除集合中的所有元素。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">uniqueColors.clear();</code></pre>\n\n<h3 id=\"遍历集合：\"><a href=\"#遍历集合：\" class=\"headerlink\" title=\"遍历集合：\"></a><strong>遍历集合：</strong></h3><p>使用增强for循环或者迭代器<code>Iterator</code>遍历集合中的元素。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">for (String color : uniqueColors) {\n    System.out.println(color);\n}\n\n// 或者\n\nIterator&lt;String&gt; iterator = uniqueColors.iterator();\nwhile (iterator.hasNext()) {\n    String color = iterator.next();\n    System.out.println(color);\n}</code></pre>\n\n<h2 id=\"HashSet\"><a href=\"#HashSet\" class=\"headerlink\" title=\"HashSet\"></a><code>HashSet</code></h2><p><code>HashSet</code> 是 Java 中的一个集合类，实现了 <code>Set</code> 接口，它以哈希表的形式存储元素，确保不包含重复元素。现在，让我们通过一些简单的比喻和例子来理解 <code>HashSet</code>。</p>\n<p>特性就是这玩意放东西不会重复，懂吧，就是不会重复，但是问题就是不会保证元素的顺序，就是你添加的时候和最后往外拿的时候顺序可能不一样。</p>\n<h3 id=\"1-使用-HashSet\"><a href=\"#1-使用-HashSet\" class=\"headerlink\" title=\"1. 使用 HashSet\"></a>1. 使用 HashSet</h3><p>让我们通过一些例子来看看如何使用 <code>HashSet</code>：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.util.HashSet;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建一个 HashSet 来存储颜色\n        HashSet&lt;String&gt; uniqueColors = new HashSet&lt;&gt;();\n\n        // 添加颜色\n        uniqueColors.add(\"红色\");\n        uniqueColors.add(\"绿色\");\n        uniqueColors.add(\"蓝色\");\n        uniqueColors.add(\"红色\"); // 尝试添加重复的颜色，但实际上只有一个红色被保留\n\n        // 输出 HashSet 的大小\n        System.out.println(\"颜色集合大小：\" + uniqueColors.size());\n\n        // 遍历 HashSet\n        for (String color : uniqueColors) {\n            System.out.println(color);\n        }\n    }\n}</code></pre>\n\n<h3 id=\"2-HashSet-的特性\"><a href=\"#2-HashSet-的特性\" class=\"headerlink\" title=\"2. HashSet 的特性\"></a>2. HashSet 的特性</h3><ul>\n<li><strong>不允许重复元素：</strong>无论你尝试往里放多少个相同的东西，最终只会保留一个。</li>\n<li><strong>无序性：</strong> <code>HashSet</code> <strong>不保证元素的顺序</strong>，元素的存储顺序可能和你添加的顺序不一样。</li>\n</ul>\n<h3 id=\"3-HashSet-的用途\"><a href=\"#3-HashSet-的用途\" class=\"headerlink\" title=\"3. HashSet 的用途\"></a>3. HashSet 的用途</h3><p><code>HashSet</code> 常常用于需要快速查找和去重的场景。比如，你可以使用 <code>HashSet</code> 存储一组唯一的用户名，以快速检查新用户名是否已存在。</p>\n<p>学校就讲了这一个，其实也就这个用的最多，剩下的一个<code>LinkedHashSet</code>和<code>TreeSet</code>以后看有没有时间再写。</p>\n<h1 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a><code>Map</code></h1><p>什么是<code>Map</code>？就是存储键值对的一种数据结构，可以将其比喻成一种关系对照表，就像字典一样，每个词都有对应的解释。<code>Map</code> 是 Java 中的一种集合接口，用于存储键值对，其中每个键对应一个值。让我们通过一些简单的比喻和例子来理解 <code>Map</code>。</p>\n<h3 id=\"1-字典\"><a href=\"#1-字典\" class=\"headerlink\" title=\"1. 字典\"></a>1. 字典</h3><p>想象一本字典，其中每个词都有一个对应的解释。在 Java 中，<code>Map</code> 就像这本字典一样，每个键（词）都有一个对应的值（解释）。</p>\n<h3 id=\"2-基本概念\"><a href=\"#2-基本概念\" class=\"headerlink\" title=\"2. 基本概念\"></a>2. 基本概念</h3><ul>\n<li><strong>键（Key）：</strong> 就像字典中的词，用于查找对应的值。</li>\n<li><strong>值（Value）：</strong> 就像字典中词的解释，与键相关联。</li>\n</ul>\n<h3 id=\"3-常用的-Map-接口方法\"><a href=\"#3-常用的-Map-接口方法\" class=\"headerlink\" title=\"3. 常用的 Map 接口方法\"></a>3. 常用的 <code>Map</code> 接口方法</h3><h4 id=\"添加键值对：\"><a href=\"#添加键值对：\" class=\"headerlink\" title=\"添加键值对：\"></a>添加键值对：</h4><p><code>put(K key, V value)</code>: 将键值对添加到 Map 中。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Map&lt;String, Integer&gt; wordCount = new HashMap&lt;&gt;();\nwordCount.put(\"apple\", 3);\nwordCount.put(\"banana\", 2);</code></pre>\n\n<h4 id=\"获取值：\"><a href=\"#获取值：\" class=\"headerlink\" title=\"获取值：\"></a>获取值：</h4><p><code>get(Object key)</code>: 根据键获取对应的值。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int count = wordCount.get(\"apple\");</code></pre>\n\n<h4 id=\"判断键是否存在：\"><a href=\"#判断键是否存在：\" class=\"headerlink\" title=\"判断键是否存在：\"></a>判断键是否存在：</h4><p><code>containsKey(Object key)</code>: 判断 Map 中是否包含指定的键。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">boolean hasApple = wordCount.containsKey(\"apple\");</code></pre>\n\n<h4 id=\"获取所有键或值的集合：\"><a href=\"#获取所有键或值的集合：\" class=\"headerlink\" title=\"获取所有键或值的集合：\"></a>获取所有键或值的集合：</h4><p><code>keySet()</code>: 返回包含所有键的 Set。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Set&lt;String&gt; words = wordCount.keySet();</code></pre>\n\n<p><code>values()</code>: 返回包含所有值的 Collection。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Collection&lt;Integer&gt; counts = wordCount.values();</code></pre>\n\n<h4 id=\"移除键值对：\"><a href=\"#移除键值对：\" class=\"headerlink\" title=\"移除键值对：\"></a>移除键值对：</h4><p><code>remove(Object key)</code>: 移除指定键的键值对。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">wordCount.remove(\"apple\");</code></pre>\n\n<h4 id=\"获取-Map-的大小：\"><a href=\"#获取-Map-的大小：\" class=\"headerlink\" title=\"获取 Map 的大小：\"></a>获取 Map 的大小：</h4><p><code>size()</code>: 获取 Map 中键值对的数量。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int size = wordCount.size();</code></pre>\n\n<h4 id=\"遍历键值对：\"><a href=\"#遍历键值对：\" class=\"headerlink\" title=\"遍历键值对：\"></a>遍历键值对：</h4><p>使用 <code>entrySet()</code> 方法获取包含键值对的 Set，然后通过增强for循环或迭代器遍历。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">for (Map.Entry&lt;String, Integer&gt; entry : wordCount.entrySet()) {\n    String word = entry.getKey();\n    int count = entry.getValue();\n    System.out.println(word + \": \" + count);\n}</code></pre>\n\n<h2 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a><code>HashMap</code></h2><p>哈希表，听着吓人，但是嘞，没什么复杂的。</p>\n<p>想象一本神奇的记事本，你可以通过写上人名（键）找到对应的秘密信息（值）。这就是 <code>HashMap</code> 的特性，每个键都对应一个值，就像一个名字对应一个秘密。</p>\n<h3 id=\"1-使用-HashMap\"><a href=\"#1-使用-HashMap\" class=\"headerlink\" title=\"1. 使用 HashMap\"></a>1. 使用 HashMap</h3><p>让我们通过一些例子来看看如何使用 <code>HashMap</code>：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建一个 HashMap 来存储人的名字和对应的年龄\n        Map&lt;String, Integer&gt; ageMap = new HashMap&lt;&gt;();\n\n        // 添加键值对\n        ageMap.put(\"Alice\", 15);\n        ageMap.put(\"Bob\", 16);\n        ageMap.put(\"Charlie\", 14);\n\n        // 获取值\n        int aliceAge = ageMap.get(\"Alice\");\n        System.out.println(\"Alice 的年龄是：\" + aliceAge);\n\n        // 判断键是否存在\n        boolean hasBob = ageMap.containsKey(\"Bob\");\n        System.out.println(\"是否包含 Bob？\" + hasBob);\n\n        // 获取所有键的集合\n        System.out.println(\"所有人的名字：\" + ageMap.keySet());\n\n        // 获取所有值的集合\n        System.out.println(\"所有人的年龄：\" + ageMap.values());\n\n        // 移除键值对\n        ageMap.remove(\"Charlie\");\n\n        // 获取 HashMap 的大小\n        System.out.println(\"HashMap 大小：\" + ageMap.size());\n\n        // 遍历键值对\n        for (Map.Entry&lt;String, Integer&gt; entry : ageMap.entrySet()) {\n            String name = entry.getKey();\n            int age = entry.getValue();\n            System.out.println(name + \" 的年龄是：\" + age);\n        }\n    }\n}</code></pre>\n\n<h3 id=\"3-HashMap-的特性\"><a href=\"#3-HashMap-的特性\" class=\"headerlink\" title=\"3. HashMap 的特性\"></a>3. HashMap 的特性</h3><ul>\n<li><strong>键值对存储：</strong> <code>HashMap</code> 存储的是键值对，每个键对应一个值。</li>\n<li><strong>快速查找：</strong> 你可以通过键快速找到对应的值。</li>\n</ul>\n<h3 id=\"4-用途\"><a href=\"#4-用途\" class=\"headerlink\" title=\"4. 用途\"></a>4. 用途</h3><p><code>HashMap</code> 常常用于需要快速查找和存储键值对的场景，比如存储用户名和密码、单词的词频等。</p>\n<p>好！爷弄完了，休息！</p>\n","text":"哥们上周发烧了，就啥也没写，这周看能不能把两周的东西全写了。 第十周这个JavaFX快被人喷烂了，我这里也不想写，我只写有必要学的。 Java IO首先，Java IO 指的是 Java Input/Output（输入/输出）的缩写。在编程中，输入/输出是指程序与外部世界之间的信...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"19 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":44,"path":"api/tags/笔记.json"},{"name":"Java初学","slug":"Java初学","count":10,"path":"api/tags/Java初学.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java-IO\"><span class=\"toc-text\">Java IO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#File%E7%B1%BB\"><span class=\"toc-text\">File类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#File%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">File类中的常用方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">绝对路径与相对路径</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">绝对路径</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">相对路径</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PrintWriter%E7%B1%BB\"><span class=\"toc-text\">PrintWriter类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#BufferedWriter%E7%B1%BB\"><span class=\"toc-text\">BufferedWriter类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#BufferedReader%E7%B1%BB\"><span class=\"toc-text\">BufferedReader类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%81%EF%BC%9F\"><span class=\"toc-text\">什么是流？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E8%8A%82%E6%B5%81%EF%BC%88Byte-Stream%EF%BC%89\"><span class=\"toc-text\">字节流（Byte Stream）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%88Character-Stream%EF%BC%89\"><span class=\"toc-text\">字符流（Character Stream）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#FileInputStream\"><span class=\"toc-text\">FileInputStream</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#FileOutputStream\"><span class=\"toc-text\">FileOutputStream</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%88Collections-Framework%EF%BC%89\"><span class=\"toc-text\">集合框架（Collections Framework）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9A%84%E7%A7%8D%E7%B1%BB\"><span class=\"toc-text\">集合框架的种类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B7%E4%BD%93%E7%9A%84%E9%9B%86%E5%90%88%E7%B1%BB\"><span class=\"toc-text\">具体的集合类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%BF%99%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">为什么要用这些？</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B\"><span class=\"toc-text\">泛型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%EF%BC%9F\"><span class=\"toc-text\">1. 什么是泛型？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%9B%E5%9E%8B%EF%BC%9F\"><span class=\"toc-text\">2. 为什么需要泛型？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%9B%92%E5%AD%90%EF%BC%9A\"><span class=\"toc-text\">3. 使用泛型的盒子：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9A\"><span class=\"toc-text\">4. 泛型的好处：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%9A%84%E9%9B%86%E5%90%88%EF%BC%9A\"><span class=\"toc-text\">5. 示例：使用泛型的集合：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#List\"><span class=\"toc-text\">List</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8%E7%9A%84List%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">常用的List接口方法：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%EF%BC%9A\"><span class=\"toc-text\">添加元素：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%EF%BC%9A\"><span class=\"toc-text\">获取元素：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%9A\"><span class=\"toc-text\">移除元素：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%EF%BC%9A\"><span class=\"toc-text\">判断元素是否存在：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E5%88%97%E8%A1%A8%E5%A4%A7%E5%B0%8F%EF%BC%9A\"><span class=\"toc-text\">获取列表大小：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%81%8D%E5%8E%86%E5%88%97%E8%A1%A8%EF%BC%9A\"><span class=\"toc-text\">遍历列表：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0%EF%BC%9A\"><span class=\"toc-text\">替换元素：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A2%9E%E5%BC%BAFor\"><span class=\"toc-text\">增强For</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">迭代器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">选择使用哪种方式？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ArrayList\"><span class=\"toc-text\">ArrayList</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AFArrayList%EF%BC%9F\"><span class=\"toc-text\">1. 什么是ArrayList？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8ArrayList%EF%BC%9F\"><span class=\"toc-text\">2. 如何使用ArrayList？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-ArrayList%E7%9A%84%E5%A5%BD%E5%A4%84\"><span class=\"toc-text\">3. ArrayList的好处</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%93%8D%E4%BD%9CArrayList\"><span class=\"toc-text\">4. 操作ArrayList</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LinkedList\"><span class=\"toc-text\">LinkedList</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AFLinkedList%EF%BC%9F\"><span class=\"toc-text\">1. 什么是LinkedList？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8LinkedList%EF%BC%9F\"><span class=\"toc-text\">2. 如何使用LinkedList？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-LinkedList%E7%9A%84%E5%A5%BD%E5%A4%84\"><span class=\"toc-text\">3. LinkedList的好处</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%93%8D%E4%BD%9CLinkedList\"><span class=\"toc-text\">4. 操作LinkedList</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Set\"><span class=\"toc-text\">Set</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8%E7%9A%84Set%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">常用的Set接口方法：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%EF%BC%9A-1\"><span class=\"toc-text\">添加元素：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%9A-1\"><span class=\"toc-text\">移除元素：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%EF%BC%9A-1\"><span class=\"toc-text\">判断元素是否存在：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E9%9B%86%E5%90%88%E5%A4%A7%E5%B0%8F%EF%BC%9A\"><span class=\"toc-text\">获取集合大小：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B8%85%E7%A9%BA%E9%9B%86%E5%90%88%EF%BC%9A\"><span class=\"toc-text\">清空集合：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%EF%BC%9A\"><span class=\"toc-text\">遍历集合：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HashSet\"><span class=\"toc-text\">HashSet</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BD%BF%E7%94%A8-HashSet\"><span class=\"toc-text\">1. 使用 HashSet</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-HashSet-%E7%9A%84%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">2. HashSet 的特性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-HashSet-%E7%9A%84%E7%94%A8%E9%80%94\"><span class=\"toc-text\">3. HashSet 的用途</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Map\"><span class=\"toc-text\">Map</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%AD%97%E5%85%B8\"><span class=\"toc-text\">1. 字典</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">2. 基本概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%B8%B8%E7%94%A8%E7%9A%84-Map-%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">3. 常用的 Map 接口方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B7%BB%E5%8A%A0%E9%94%AE%E5%80%BC%E5%AF%B9%EF%BC%9A\"><span class=\"toc-text\">添加键值对：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E5%80%BC%EF%BC%9A\"><span class=\"toc-text\">获取值：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%A4%E6%96%AD%E9%94%AE%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%EF%BC%9A\"><span class=\"toc-text\">判断键是否存在：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%94%AE%E6%88%96%E5%80%BC%E7%9A%84%E9%9B%86%E5%90%88%EF%BC%9A\"><span class=\"toc-text\">获取所有键或值的集合：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A7%BB%E9%99%A4%E9%94%AE%E5%80%BC%E5%AF%B9%EF%BC%9A\"><span class=\"toc-text\">移除键值对：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96-Map-%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%9A\"><span class=\"toc-text\">获取 Map 的大小：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%81%8D%E5%8E%86%E9%94%AE%E5%80%BC%E5%AF%B9%EF%BC%9A\"><span class=\"toc-text\">遍历键值对：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HashMap\"><span class=\"toc-text\">HashMap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BD%BF%E7%94%A8-HashMap\"><span class=\"toc-text\">1. 使用 HashMap</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-HashMap-%E7%9A%84%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">3. HashMap 的特性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E7%94%A8%E9%80%94\"><span class=\"toc-text\">4. 用途</span></a></li></ol></li></ol></li></ol>","author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}},"mapped":true,"prev_post":{"title":"MySQL Review-2","uid":"931d32a5aa688f1d603d588de90831ae","slug":"MySQL-Review-2","date":"2023-12-02T05:52:17.000Z","updated":"2023-12-06T09:47:18.341Z","comments":true,"path":"api/articles/MySQL-Review-2.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/MySQL-image.png","text":"今天继续复习数据库，顺序就按照学校的来，我也不知道从哪里开始讲。 什么是SQL？SQL的全称是 “Structured Query Language”，也就是结构化查询语言，是一种用于访问和处理数据库的标准的计算机语言。 SQL可以干什么？SQL主要分为两种，一种是DDL（Dat...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":44,"path":"api/tags/笔记.json"},{"name":"MySQL复习","slug":"MySQL复习","count":10,"path":"api/tags/MySQL复习.json"}],"author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}}},"next_post":{"title":"MySQL Review-1","uid":"97b03ceace2b3c315b6a7d6611736a00","slug":"MySQL-Review-1","date":"2023-11-18T10:15:15.000Z","updated":"2023-11-18T10:51:37.295Z","comments":true,"path":"api/articles/MySQL-Review-1.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/MySQL-image.png","text":"其实我在想要不要写一个数据库的复习，毕竟最近临近期末，各种考试又到来，数据库好像还是相对来说比较重要的一个技术，那就顺便来讲讲吧，主要以学校为主，以MySQL作为我们的讲解内容。 数据库介绍什么是数据库？先从这个问题开始，顾名思义，数据库（Database）就是按照数据结构来存储...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":44,"path":"api/tags/笔记.json"},{"name":"MySQL复习","slug":"MySQL复习","count":10,"path":"api/tags/MySQL复习.json"}],"author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}}}}