{"title":"Java_Learning(Week9)","uid":"7d4841571c0abc342271e318c113c7dc","slug":"Java-Learning-Week9","date":"2023-11-14T07:22:21.000Z","updated":"2023-11-14T09:07:16.675Z","comments":true,"path":"api/articles/Java-Learning-Week9.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/codeBackground.png","content":"<p>说实话，我看了一下这一周的课件，我感觉学校还是没有讲东西，OOP的思想我上一周应该说的比较详细了，这周需要讲的一些东西应该就是多态和异常了，说实话这会儿讲异常没有什么必要我感觉，其他更重要的东西都还没讲，什么链表，哈希表这些的。</p>\n<p>哦对了，顺便补一下之前拉下的一点东西，讲一下<strong>方法重载（Overload）</strong>和<strong>方法重写（Override）</strong>之间的区别。</p>\n<h1 id=\"重载与重写\"><a href=\"#重载与重写\" class=\"headerlink\" title=\"重载与重写\"></a>重载与重写</h1><p>上周我们简单提了一下方法的重写是什么，现在先来看一下重载吧。</p>\n<h2 id=\"重载-（Overload）\"><a href=\"#重载-（Overload）\" class=\"headerlink\" title=\"重载 （Overload）\"></a>重载 （Overload）</h2><p>简单来说，<code>Overload</code>指的是在同一个类中创建多个具有相同名称但参数不同的方法。这样，可以根据不同的情况来调用这些方法。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Calculator {\n    public int add(int a, int b) {\n        return a + b;\n    }\n\n    public double add(double a, double b) {\n        return a + b;\n    }\n}</code></pre>\n\n<p>在这个例子中，<code>Calculator</code>类有两个<code>add</code>方法，一个用于整数相加，另一个用于浮点数相加。这两个方法都有相同的名称，但是它们的参数不同。这就是方法的重载。</p>\n<p>就是方法名称相同，但是参数类型或者数量不同，就是方法的重载。</p>\n<h3 id=\"方法重载的规则\"><a href=\"#方法重载的规则\" class=\"headerlink\" title=\"方法重载的规则\"></a>方法重载的规则</h3><ol>\n<li><strong>方法名称必须相同：</strong> 重载的方法必须具有相同的名称。</li>\n<li><strong>参数列表必须不同：</strong> 重载的方法必须有不同的参数列表（个数或类型不同）。</li>\n<li><strong>返回类型可以相同也可以不同：</strong> 返回类型可以相同也可以不同，但仅仅通过返回类型的不同是无法进行重载的。</li>\n<li><strong>可以有不同的访问修饰符：</strong> 重载的方法可以有不同的访问修饰符（比如<code>public</code>、<code>private</code>、<code>protected</code>等）。</li>\n<li><strong>可以抛出不同的异常：</strong> 重载的方法可以抛出不同的异常，可以声明新的或者更广的异常</li>\n</ol>\n<h2 id=\"重写（Override）\"><a href=\"#重写（Override）\" class=\"headerlink\" title=\"重写（Override）\"></a>重写（Override）</h2><p>上周已经讲过了，假设你有一个父类（比如动物类），而你想创建一个子类（比如狗类）。父类中可能有一个<code>makeSound</code>方法，用于发出声音。现在，如果你想在子类中改变狗的声音，你可以使用<code>override</code>。</p>\n<p>在Java中，<code>override</code>就是在子类中创建一个与父类相同的方法，但是子类中的这个方法有着自己的实现。这样，当你调用这个方法时，程序会自动调用子类的方法，而不是父类的方法。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Animal {\n    public void makeSound() {\n        System.out.println(\"一般的动物发出的声音\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"汪汪汪！\");\n    }\n}</code></pre>\n\n<p>重写的优势在于让子类能够根据自身需求来实现（重写）父类的方法，使得代码更加灵活和符合具体情境。但是，需要遵循一些规则，如保持方法签名不变，不能改变返回类型，也不能抛出比父类方法更宽泛的异常。</p>\n<h3 id=\"方法重写的规则\"><a href=\"#方法重写的规则\" class=\"headerlink\" title=\"方法重写的规则\"></a>方法重写的规则</h3><ol>\n<li><strong>参数列表必须完全相同：</strong> 重写的方法的参数列表必须与被重写方法的参数列表完全相同。</li>\n<li><strong>返回类型可以不同，但必须是父类返回值的派生类：</strong> 返回类型可以是被重写方法返回类型的子类，但是在Java 5及更早版本中，返回类型必须相同；而在Java 7及更高版本中，返回类型可以不同。</li>\n<li><strong>访问权限不能比被重写方法更低：</strong> 重写的方法的访问权限不能比被重写方法的访问权限更低，例如，如果被重写方法在父类中声明为public，那么在子类中的重写方法不能声明为protected。</li>\n<li><strong>只能重写父类的成员方法：</strong> 只能重写父类的成员方法，不能重写父类的静态方法或实例方法。</li>\n<li><strong>不能重写final方法：</strong> 被声明为final的方法不能被子类重写。</li>\n<li><strong>不能重写static方法，但能够被再次声明：</strong> 被声明为static的方法不能被子类重写，但可以在子类中被再次声明。</li>\n<li><strong>同包中的子类可以重写父类所有方法，除了private和final的方法：</strong> 如果子类和父类在同一个包中，子类可以重写父类所有非private和非final的方法。</li>\n<li><strong>不同包中的子类只能重写父类的声明为public和protected的非final方法：</strong> 如果子类和父类不在同一个包中，子类只能够重写父类的声明为public和protected的非final方法。</li>\n<li><strong>重写的方法能够抛出任何非强制异常，但不能抛出新的强制异常，或者比被重写方法声明的更广泛的强制异常：</strong> 在重写时，可以抛出任何非强制异常，但不能抛出新的强制异常，也不能抛出比被重写方法声明的更广泛的强制异常。</li>\n<li><strong>构造方法不能被重写：</strong> 构造方法不能被继承，因此也不能被重写。</li>\n<li><strong>如果不能继承一个类，则不能重写该类的方法：</strong> 如果无法继承一个类，那么就无法重写该类的方法。</li>\n</ol>\n<p>很多，给爷背就完了。</p>\n<h2 id=\"重写与重载之间的区别\"><a href=\"#重写与重载之间的区别\" class=\"headerlink\" title=\"重写与重载之间的区别\"></a>重写与重载之间的区别</h2><table>\n<thead>\n<tr>\n<th align=\"left\">区别点</th>\n<th align=\"left\">重载方法</th>\n<th align=\"left\">重写方法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">参数列表</td>\n<td align=\"left\">必须修改</td>\n<td align=\"left\">一定不能修改</td>\n</tr>\n<tr>\n<td align=\"left\">返回类型</td>\n<td align=\"left\">可以修改</td>\n<td align=\"left\">一定不能修改</td>\n</tr>\n<tr>\n<td align=\"left\">异常</td>\n<td align=\"left\">可以修改</td>\n<td align=\"left\">可以减少或删除，一定不能抛出新的或者更广的异常</td>\n</tr>\n<tr>\n<td align=\"left\">访问</td>\n<td align=\"left\">可以修改</td>\n<td align=\"left\">一定不能做更严格的限制（可以降低限制）</td>\n</tr>\n</tbody></table>\n<h1 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h1><p>其实上面的重载和重写都是Java多态的体现，那么问题就来了，什么是多态？</p>\n<h2 id=\"什么是多态\"><a href=\"#什么是多态\" class=\"headerlink\" title=\"什么是多态\"></a>什么是多态</h2><p>多态是面向对象编程中的一个重要概念，它允许不同类的对象对同一个消息（方法调用）作出不同的响应。简而言之，同一种行为在不同的对象上可以表现出不同的形态。</p>\n<p>说白了，就是同一个行为具有多个不同的表现形式。</p>\n<p>比如动物会叫，狗叫就是汪汪，猫叫就是喵喵，就是这。</p>\n<h2 id=\"多态的优点\"><a href=\"#多态的优点\" class=\"headerlink\" title=\"多态的优点\"></a>多态的优点</h2><p>这都是教科书上面该写的东西，哪里都一样</p>\n<ol>\n<li><strong>灵活性（Flexibility）：</strong> 多态使得代码更加灵活，能够处理多种不同类型的对象，而无需修改现有的代码。这使得系统更容易适应变化和扩展。</li>\n<li><strong>可扩展性（Extensibility）：</strong> 添加新的类或子类变得更加容易。如果你需要引入新的类型，只需确保它符合已有的接口或继承关系，而不需要修改现有的代码。</li>\n<li><strong>简化代码（Simplified Code）：</strong> 多态性使得代码更简洁，因为相同的操作可以适用于不同类型的对象。这减少了代码的复杂性和冗余性。</li>\n<li><strong>提高代码的可读性和可维护性（Readability and Maintainability）：</strong> 通过使用多态，代码更容易理解和维护，因为它强调了对象的行为而不是具体的实现细节。</li>\n<li><strong>降低耦合度（Reduced Coupling）：</strong> 多态性降低了对象之间的耦合度。通过将操作定义在接口或抽象类上，而不是具体的实现类上，减少了类之间的直接依赖，使得系统更容易修改和维护。</li>\n<li><strong>可替代性（Substitutability）：</strong> 多态性使得可以在不影响代码其他部分的情况下替换对象。这对于在系统中替换部分功能或优化代码是非常有用的。</li>\n</ol>\n<h2 id=\"多态存在的必要条件\"><a href=\"#多态存在的必要条件\" class=\"headerlink\" title=\"多态存在的必要条件\"></a>多态存在的必要条件</h2><ol>\n<li><strong>继承（Inheritance）：</strong> 多态性通常基于继承关系。子类必须继承自父类或实现相同的接口或抽象类，以便能够通过父类或接口类型的引用来引用子类对象。</li>\n<li><strong>方法重写（Method Overriding）：</strong> 多态性要求子类必须重写（Override）父类中的方法。重写的方法在子类中具有相同的签名（方法名、参数列表和返回类型），这样在运行时可以根据对象的实际类型调用正确的方法。</li>\n<li><strong>父类引用指向子类对象（Upcasting）：</strong> 多态性的关键是使用父类类型的引用指向子类对象。这种类型的引用可以容纳任何符合父类或接口的子类对象。</li>\n<li><strong>运行时绑定（Runtime Binding）：</strong> 多态性的实现是在运行时确定的，而不是在编译时。这意味着系统在程序运行时能够动态地选择调用哪个方法，而不是在编译时就确定。</li>\n<li><strong>一致的接口（Consistent Interface）：</strong> 多态性要求所有相关类都要有一致的接口，即它们应该共享相同的方法签名。这可以通过接口、抽象类或共同的基类来实现。</li>\n</ol>\n<p>第五点看不懂没关系，目前还没学到。</p>\n<p>为了理解这么几个必要条件，我们来举个例子。</p>\n<p>假设有一个动物（Animal）类和两个子类：狗（Dog）和猫（Cat）。这里使用了继承、方法重写、父类引用指向子类对象和运行时绑定这些多态性的概念。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// 动物类\nclass Animal {\n    public void makeSound() {\n        System.out.println(\"一般的动物发出声音\");\n    }\n}</code></pre>\n\n<p>这个是动物类，当中有一个<code>makeSound()</code>方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// 狗类\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"汪汪汪！\");\n    }\n\n    public void fetch() {\n        System.out.println(\"狗在接飞盘！\");\n    }\n}</code></pre>\n\n<p>这是狗类，继承了动物类，然后重写了其中的叫声方法，并且拥有自己的一个成员方法是接飞盘。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// 猫类\nclass Cat extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"喵喵喵！\");\n    }\n\n    public void scratch() {\n        System.out.println(\"猫在抓抓！\");\n    }\n}</code></pre>\n\n<p>这个是猫类，同样的，重写了叫声方法，滨区给拥有自己的成员方法</p>\n<p>那么我们写一个测试类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// 父类引用指向子类对象\nAnimal myDog = new Dog();\nAnimal myCat = new Cat();</code></pre>\n\n<p>注意这里，开头我们使用的是<code>Animal</code>声明的，然后<code>new</code>的后面是狗对象，这就是父类引用指向子类对象。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// 调用各自的makeSound方法，运行时绑定确定调用哪个方法\nmyDog.makeSound();  // 运行时调用Dog类的makeSound方法\nmyCat.makeSound();  // 运行时调用Cat类的makeSound方法</code></pre>\n\n<p>然后我们分别调用他们各自的<code>makeSound()</code>，你会发现输出的是他们各自的叫声，因为我们重写了他们各自的方法。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">汪汪汪！\n喵喵喵！</code></pre>\n\n<p>然后我们继续尝试调用他们各自的子类中的成员方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// 父类引用无法调用子类特有的方法（fetch和scratch）\n myDog.fetch();  // 编译错误，Animal类没有fetch方法\n myCat.scratch(); // 编译错误，Animal类没有scratch方法</code></pre>\n\n<p>你会发现编译器已经开始报错了</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">Cannot resolve method 'fetch' in 'Animal'\nCannot resolve method 'scratch' in 'Animal'</code></pre>\n\n<p>因为父类当中并没有这几个方法，那么此时我们可以对我们的对象进行强转。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// 如果我们将引用类型更改为子类类型，就可以调用子类特有的方法\nDog myRealDog = (Dog) myDog;\nmyRealDog.fetch();  // 正常调用fetch方法\n\nCat myRealCat = (Cat) myCat;\nmyRealCat.scratch(); // 正常调用scratch方法</code></pre>\n\n<p>此时就可以继续调用子类当中的方法了</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">狗在接飞盘！\n猫在抓抓！</code></pre>\n\n<p>好！</p>\n<p>这部分就到这里先结束。</p>\n<h1 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h1><p>这会儿讲这个感觉还是有点怪哈，因为我们目前好像没遇到什么异常，最有名的异常应该就是数组越界异常，其他的其实还蛮少的。</p>\n<p>那就先讲什么是异常。</p>\n<h2 id=\"什么是异常？\"><a href=\"#什么是异常？\" class=\"headerlink\" title=\"什么是异常？\"></a>什么是异常？</h2><p>异常就是程序当中的错误，就是报错，就是IDE给你标成红色的时候，那就是出异常了。</p>\n<p>但是并不是所有的错误都是异常，甚至有的错误是可以避免的</p>\n<p>比方说零不能作除数，数组访问不能越界，这些都是一些常见的异常。</p>\n<h2 id=\"异常的分类\"><a href=\"#异常的分类\" class=\"headerlink\" title=\"异常的分类\"></a>异常的分类</h2><p>在Java中，异常分为两个主要类别：已检查异常（Checked Exceptions）和未检查异常（Unchecked Exceptions）。这两者都是 <code>Throwable</code> 类的子类。</p>\n<ol>\n<li><strong>已检查异常（Checked Exceptions）：</strong><ul>\n<li>已检查异常是在编译时被检测到的异常，程序必须显式地处理它们，否则编译器会报错。</li>\n<li>通常是由外部因素引起的，例如输入/输出错误、文件不存在等。</li>\n<li>例如：<code>IOException</code>、<code>ClassNotFoundException</code>。</li>\n</ul>\n</li>\n<li><strong>未检查异常（Unchecked Exceptions）：</strong><ul>\n<li>也称为<strong>运行时异常（Runtime Exceptions）</strong>，是在运行时由Java虚拟机检测到的异常。</li>\n<li>不要求显式地捕获或声明，程序员可以选择处理或者不处理这些异常。</li>\n<li>通常是由程序错误引起的，例如空指针引用、数组越界等。</li>\n<li>例如：<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>。</li>\n</ul>\n</li>\n</ol>\n<p>除了这两个主要的分类之外，还有一种特殊情况：</p>\n<p>那就是<strong>错误（Errors）：</strong></p>\n<ul>\n<li>错误通常指示了一些严重的问题，程序可能无法恢复。与异常不同，错误通常由于系统级问题（例如内存耗尽）引起。</li>\n<li>例如：<code>OutOfMemoryError</code>、<code>StackOverflowError</code>。</li>\n</ul>\n<p>一般出现了Errors，那就一般不归我们管了，我们也管不了这些。</p>\n<p>这些异常和错误类的层次结构如下：</p>\n<pre class=\"line-numbers language-lua\" data-language=\"lua\"><code class=\"language-lua\">Throwable\n|-- Error\n|-- Exception\n    |-- Checked Exceptions\n    |-- Unchecked Exceptions (Runtime Exceptions)</code></pre>\n\n<p>这个层次结构也就是Java当中的类的继承结构。</p>\n<h2 id=\"Exception-类的层次\"><a href=\"#Exception-类的层次\" class=\"headerlink\" title=\"Exception 类的层次\"></a>Exception 类的层次</h2><p><img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/hierarchyOfExceptionClasses.svg\"></p>\n<p>这就是这些类的继承结构，里面是类中含有的一些方法，不用管，看不懂没关系。</p>\n<p>在Java中，异常类都是派生自 <code>Throwable</code> 类。<code>Throwable</code> 类是所有可以作为异常抛出的类和错误的根类。异常类的层次结构主要分为两大类：<code>Error</code> 和 <code>Exception</code>，而 <code>Exception</code> 又分为已检查异常（Checked Exceptions）和未检查异常（Unchecked Exceptions）。</p>\n<ol>\n<li><strong><code>Throwable</code> 类：</strong><ul>\n<li><code>Throwable</code> 是 Java 异常体系的根类。它有两个主要的子类：<code>Error</code> 和 <code>Exception</code>。</li>\n<li>任何可以作为异常抛出的类都是 <code>Throwable</code> 的子类。</li>\n</ul>\n</li>\n<li><strong><code>Error</code> 类：</strong><ul>\n<li><code>Error</code> 类用于表示严重的系统问题，通常无法通过程序来恢复。程序一般不会捕获 <code>Error</code> 类的实例。</li>\n<li>一些常见的 <code>Error</code> 类包括 <code>OutOfMemoryError</code>、<code>StackOverflowError</code> 等。</li>\n</ul>\n</li>\n<li><strong><code>Exception</code> 类：</strong><ul>\n<li><code>Exception</code> 类是所有异常类的父类，它表示程序运行过程中可能遇到的问题。</li>\n<li><code>Exception</code> 类又分为已检查异常和未检查异常。</li>\n</ul>\n</li>\n<li><strong>已检查异常（Checked Exceptions）：</strong><ul>\n<li>已检查异常是在编译时被检测到的异常，程序必须显式地处理它们，否则编译器会报错。</li>\n<li>一些常见的已检查异常包括 <code>IOException</code>、<code>ClassNotFoundException</code> 等。</li>\n</ul>\n</li>\n<li><strong>未检查异常（Unchecked Exceptions，Runtime Exceptions）：</strong><ul>\n<li>未检查异常是在运行时由 Java 虚拟机检测到的异常，不要求显式地捕获或声明，程序员可以选择处理或者不处理这些异常。</li>\n<li>一些常见的未检查异常包括 <code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code> 等。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"捕获异常\"><a href=\"#捕获异常\" class=\"headerlink\" title=\"捕获异常\"></a>捕获异常</h2><p>那么讲了什么是异常，那我们怎么去处理这个异常呢？</p>\n<p>想象一下你正在读一本书，突然有人拿走了这本书。你可以选择哭泣和放弃，或者你可以找到一本相似的书继续阅读。在编程中，当程序遇到问题时，我们可以选择放弃并让程序崩溃，或者我们可以处理这个问题，使程序继续执行。</p>\n<p>在Java中，我们使用<code>try</code>和<code>catch</code>来处理异常。这就像在代码中放置一个安全网，当有问题时，我们可以抓住它并执行一些特殊的代码，而不是让程序崩溃。</p>\n<p>以下是一个简单的例子，假设我们想要读取一个文件中的内容：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\npublic class ReadFileExample {\n    public static void main(String[] args) {\n        try {\n            readFile();\n        } catch (FileNotFoundException e) {\n            System.out.println(\"文件找不到啦！请检查文件是否存在。\");\n        }\n    }\n\n    public static void readFile() throws FileNotFoundException {\n        File file = new File(\"example.txt\");\n        Scanner scanner = new Scanner(file);\n        // 这里是读取文件内容的代码\n        System.out.println(\"成功读取文件！\");\n    }\n}</code></pre>\n\n<p>这里面涉及了Java当中的I/O，看不懂无所谓，只是举个例子，里面还有<code>throws</code>这个关键字，下面会讲到，这里先看。在这个例子中，我们尝试调用<code>readFile</code>方法，这个方法有可能抛出<code>FileNotFoundException</code>异常。我们用<code>try</code>和<code>catch</code>来捕获这个异常。如果文件不存在，我们就会进入<code>catch</code>块，并输出一条消息告诉用户文件找不到。</p>\n<p>此外，我们还可以多重捕获异常，怎么说呢，就是在一个<code>try</code>块后面跟随多个<code>catch</code>块的情况。这样做的目的是为不同类型的异常提供不同的处理逻辑。在Java中，<code>catch</code>块按照它们出现的顺序进行匹配，只有第一个匹配的<code>catch</code>块会执行。</p>\n<p>举个例子：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\npublic class MultiCatchExample {\n    public static void main(String[] args) {\n        try {\n            readFile();\n        } catch (FileNotFoundException e) {\n            System.out.println(\"文件找不到啦！请检查文件是否存在。\");\n        } catch (NullPointerException e) {\n            System.out.println(\"空指针异常！请检查代码中的空引用。\");\n        } catch (Exception e) {\n            System.out.println(\"发生了其他异常：\" + e.getMessage());\n        }\n    }\n\n    public static void readFile() throws FileNotFoundException {\n        File file = null; // 故意设置为null，模拟空指针异常\n        Scanner scanner = new Scanner(file);\n        // 这里是读取文件内容的代码\n        System.out.println(\"成功读取文件！\");\n    }\n}</code></pre>\n\n<p>在这个例子中，<code>readFile</code>方法有可能抛出两种异常：<code>FileNotFoundException</code>和<code>NullPointerException</code>。</p>\n<p>在<code>main</code>方法中的<code>try</code>块后面有两个<code>catch</code>块，第一个捕获<code>FileNotFoundException</code>，第二个捕获<code>NullPointerException</code>。</p>\n<p>如果发生了<code>FileNotFoundException</code>，第一个<code>catch</code>块会执行，如果发生了<code>NullPointerException</code>，则第二个<code>catch</code>块会执行。</p>\n<p>请注意，<code>catch</code>块的顺序很重要。如果把第二个<code>catch</code>块放在第一个之前，那么即使发生了<code>NullPointerException</code>，也会被第一个<code>catch</code>块捕获，因为<code>Exception</code>是<code>NullPointerException</code>的父类。</p>\n<p>有点像<code>if</code>条件语句，但是不太像。</p>\n<h2 id=\"finally关键字\"><a href=\"#finally关键字\" class=\"headerlink\" title=\"finally关键字\"></a>finally关键字</h2><p>想象一下你正在玩积木，突然有人叫你去吃饭。无论你是否玩得高兴，你都应该把积木收拾好，对吧？<code>finally</code> 就像是你要完成的最后一步，无论怎样，都会执行的一段代码。</p>\n<p>在编程中，<code>finally</code> 关键字用于确保一段代码（通常是清理代码）无论发生什么都会被执行。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class FinallyExample {\n\n    public static void main(String[] args) {\n        try {\n            divide(10, 0);\n        } catch (ArithmeticException e) {\n            System.out.println(\"除数不能为零！\");\n        } finally {\n            System.out.println(\"这里的代码总是会执行，无论有没有异常发生。\");\n        }\n    }\n\n    public static void divide(int num1, int num2) {\n        if (num2 == 0) {\n            throw new ArithmeticException(\"除数不能为零！\");\n        } else {\n            int result = num1 / num2;\n            System.out.println(\"结果是：\" + result);\n        }\n    }\n}\n</code></pre>\n\n<p>在这个例子中，我们有一个 <code>divide</code> 方法，它可能会抛出 <code>ArithmeticException</code> 异常，因为我们不能将一个数除以零。在 <code>main</code> 方法中，我们使用 <code>try-catch</code> 块来捕获这个异常，然后使用 <code>finally</code> 关键字来确保无论是否发生异常，都会执行 <code>finally</code> 块内的代码。</p>\n<p>所以，<code>finally</code> 就是那个一定会执行的“清理代码”块，确保在程序执行的最后阶段，无论是否有异常，都能完成一些必要的操作。</p>\n<h2 id=\"throws-throw-关键字\"><a href=\"#throws-throw-关键字\" class=\"headerlink\" title=\"throws/throw 关键字\"></a>throws/throw 关键字</h2><p>那么这就是第二种处理异常的方式，在Java中，<strong>throw</strong> 关键字用于在代码中抛出异常，而 <strong>throws</strong> 关键字用于在方法声明中指定可能会抛出的异常类型。</p>\n<h3 id=\"throws-关键字：\"><a href=\"#throws-关键字：\" class=\"headerlink\" title=\"throws 关键字：\"></a><code>throws</code> 关键字：</h3><p>想象一下你在一个游戏中扔飞盘。有时候飞盘可能会飞得太高，而你不想被砸到头。所以，你在扔飞盘之前说：“我可能会扔得很高，小心头顶！”这就是 <code>throws</code> 的作用。</p>\n<p>在编程中，<code>throws</code> 关键字用于告诉其他人（或其他代码）：“嘿，我这里可能会有异常发生，你需要注意一下！”。具体来说，在方法的声明中使用 <code>throws</code>，你在方法名后面列出可能抛出的异常类型。</p>\n<p>继续上面的例子：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ThrowsExample {\n\n    public static void main(String[] args) {\n        try {\n            doSomething();\n        } catch (FileNotFoundException e) {\n            System.out.println(\"文件找不到啦！请检查文件是否存在。\");\n        }\n    }\n\n    public static void doSomething() throws FileNotFoundException {\n        // 在这里做一些可能抛出 FileNotFoundException 的操作\n        throw new FileNotFoundException(\"这是一个模拟的文件未找到异常\");\n    }\n}</code></pre>\n\n<p>在这个例子中，<code>doSomething</code> 方法可能会抛出 <code>FileNotFoundException</code> 异常，所以我们在方法声明中使用了 <code>throws FileNotFoundException</code>。</p>\n<h3 id=\"throw-关键字：\"><a href=\"#throw-关键字：\" class=\"headerlink\" title=\"throw 关键字：\"></a><code>throw</code> 关键字：</h3><p>现在，想象一下你在捡到了一个石头，然后你发现其实是一个屎蛋，然后你突然想把它扔给别人。这就是 <code>throw</code> 关键字的作用。</p>\n<p>在编程中，<code>throw</code> 关键字用于手动抛出异常。有时候，我们在代码中发现了一些问题，而不是等到程序崩溃，我们可以使用 <code>throw</code> 主动地抛出一个异常。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ThrowExample {\n\n    public static void main(String[] args) {\n        try {\n            checkAge(12);\n        } catch (IllegalArgumentException e) {\n            System.out.println(\"年龄不合法：\" + e.getMessage());\n        }\n    }\n\n    public static void checkAge(int age) {\n        if (age &lt; 18) {\n            throw new IllegalArgumentException(\"年龄必须大于等于18岁\");\n        } else {\n            System.out.println(\"年龄合法，可以继续操作\");\n        }\n    }\n}</code></pre>\n\n<p>在这个例子中，<code>checkAge</code> 方法检查年龄是否合法，如果年龄小于18岁，就会使用 <code>throw</code> 抛出一个 <code>IllegalArgumentException</code> 异常。</p>\n<p><strong>一些注意事项</strong></p>\n<p>注意下面事项：</p>\n<ul>\n<li><code>catch</code> 不能独立于 <code>try</code> 存在。</li>\n<li>在 <code>try/catch</code> 后面添加 <code>finally</code> 块并非强制性要求的。</li>\n<li><code>try</code> 代码后不能既没 <code>catch</code> 块也没 <code>finally</code>块。</li>\n<li><code>try</code>, <code>catch</code>, <code>finally</code> 块之间不能添加任何代码。</li>\n</ul>\n<h2 id=\"声明自定义异常\"><a href=\"#声明自定义异常\" class=\"headerlink\" title=\"声明自定义异常\"></a>声明自定义异常</h2><p>那么，上面讲了这么多，这些异常其实都是Java给我们提供好的异常，但是现实开发中遇到的异常可多了去了，Java的异常不可能覆盖我们可能遇到的异常，这时候自定义异常就显得非常重要了。</p>\n<p>假设我们正在设计一个游戏，玩家的年龄不能小于 18 岁。如果小于 18 岁，我们就会抛出一个自定义的异常，告诉玩家不能玩这个游戏。</p>\n<p>我们可以通过创建一个继承自 <code>Exception</code> 的新类来声明自定义异常</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">// 自定义异常类\nclass AgeTooYoungException extends Exception {\n    public AgeTooYoungException(String message) {\n        super(message);\n    }\n}</code></pre>\n\n<p>然后我们再在测试类当中试一下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CustomExceptionExample {\n\n    public static void main(String[] args) {\n        try {\n            checkPlayerAge(15); // 尝试使用 checkPlayerAge 方法\n        } catch (AgeTooYoungException e) {\n            System.out.println(\"抱歉，你太小了，不能玩这个游戏！\");\n            System.out.println(\"异常信息：\" + e.getMessage());\n        }\n    }\n\n    public static void checkPlayerAge(int age) throws AgeTooYoungException {\n        if (age &lt; 18) {\n            throw new AgeTooYoungException(\"年龄太小，不能玩游戏！\");\n        } else {\n            System.out.println(\"年龄合适，可以开始游戏！\");\n        }\n    }\n}</code></pre>\n\n<p>其实还有更炫的，你可以把我们经常用的<code>System.out.println</code>中的<code>out</code>换成<code>err</code>，这样控制台打印的文字就是红色警告，非常的炫酷。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">抱歉，你太小了，不能玩这个游戏！\n异常信息：年龄太小，不能玩游戏！</code></pre>\n\n<p>在这个例子中，<code>AgeTooYoungException</code> 是我们自定义的异常类，它继承自 <code>Exception</code>。我们使用 <code>checkPlayerAge</code> 方法来检查玩家的年龄，如果年龄小于 5 岁，就抛出 <code>AgeTooYoungException</code> 异常。</p>\n<p>在 <code>main</code> 方法中，我们使用 <code>try-catch</code> 块捕获这个异常，并输出一条友好的消息告诉玩家不能玩这个游戏。</p>\n<p>好了，所以也就讲了这么些东西。</p>\n","text":"说实话，我看了一下这一周的课件，我感觉学校还是没有讲东西，OOP的思想我上一周应该说的比较详细了，这周需要讲的一些东西应该就是多态和异常了，说实话这会儿讲异常没有什么必要我感觉，其他更重要的东西都还没讲，什么链表，哈希表这些的。 哦对了，顺便补一下之前拉下的一点东西，讲一下方法重...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":41,"path":"api/tags/笔记.json"},{"name":"Java初学","slug":"Java初学","count":10,"path":"api/tags/Java初学.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99\"><span class=\"toc-text\">重载与重写</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%BD%BD-%EF%BC%88Overload%EF%BC%89\"><span class=\"toc-text\">重载 （Overload）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E7%9A%84%E8%A7%84%E5%88%99\"><span class=\"toc-text\">方法重载的规则</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%87%8D%E5%86%99%EF%BC%88Override%EF%BC%89\"><span class=\"toc-text\">重写（Override）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E7%9A%84%E8%A7%84%E5%88%99\"><span class=\"toc-text\">方法重写的规则</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">重写与重载之间的区别</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">多态</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81\"><span class=\"toc-text\">什么是多态</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81%E7%9A%84%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">多态的优点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81%E5%AD%98%E5%9C%A8%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">多态存在的必要条件</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">异常</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E5%B8%B8%EF%BC%9F\"><span class=\"toc-text\">什么是异常？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">异常的分类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Exception-%E7%B1%BB%E7%9A%84%E5%B1%82%E6%AC%A1\"><span class=\"toc-text\">Exception 类的层次</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">捕获异常</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#finally%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">finally关键字</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#throws-throw-%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">throws&#x2F;throw 关键字</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#throws-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A\"><span class=\"toc-text\">throws 关键字：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#throw-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A\"><span class=\"toc-text\">throw 关键字：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A3%B0%E6%98%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">声明自定义异常</span></a></li></ol></li></ol>","author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}},"mapped":true,"prev_post":{"title":"MySQL Review-1","uid":"97b03ceace2b3c315b6a7d6611736a00","slug":"MySQL-Review-1","date":"2023-11-18T10:15:15.000Z","updated":"2023-11-18T10:51:37.295Z","comments":true,"path":"api/articles/MySQL-Review-1.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/MySQL-image.png","text":"其实我在想要不要写一个数据库的复习，毕竟最近临近期末，各种考试又到来，数据库好像还是相对来说比较重要的一个技术，那就顺便来讲讲吧，主要以学校为主，以MySQL作为我们的讲解内容。 数据库介绍什么是数据库？先从这个问题开始，顾名思义，数据库（Database）就是按照数据结构来存储...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":41,"path":"api/tags/笔记.json"},{"name":"MySQL复习","slug":"MySQL复习","count":10,"path":"api/tags/MySQL复习.json"}],"author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}}},"next_post":{"title":"Java_Learning(Week8)","uid":"0d78bd92a017cfff181854aa3e1bedda","slug":"Java-Learning-Week8","date":"2023-11-06T10:20:06.000Z","updated":"2023-11-06T12:33:31.073Z","comments":true,"path":"api/articles/Java-Learning-Week8.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/codeBackground.png","text":"因为最近太忙了，所以直接空了三周的笔记没有写，后面看有没有时间再补上吧，这节课，我们直接开始Java编程当中的重头戏——面向对象。 面向对象（OOP）什么是对象？首先先明确一点，对象不是找男女朋友！ 这里我想先引用我很喜欢的一本Java书（Java编程思想，非常好的工具书）当中面...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"10 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":41,"path":"api/tags/笔记.json"},{"name":"Java初学","slug":"Java初学","count":10,"path":"api/tags/Java初学.json"}],"author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}}}}