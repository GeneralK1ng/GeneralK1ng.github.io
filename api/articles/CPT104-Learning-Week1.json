{"title":"CPT104 Learning Week1","uid":"103cf105d957389e86194541d8104f98","slug":"CPT104-Learning-Week1","date":"2024-02-26T09:46:35.000Z","updated":"2024-03-07T11:08:51.319Z","comments":true,"path":"api/articles/CPT104-Learning-Week1.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/CPT104-img.png","content":"<p>开学第一课，操作系统原理。</p>\n<h1 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h1><h2 id=\"什么是进程？\"><a href=\"#什么是进程？\" class=\"headerlink\" title=\"什么是进程？\"></a>什么是进程？</h2><p>进程就是程序在某个数据集合上的一次运行活动，也是操作系统<strong>进行资源分配和保护的基本单位</strong>。</p>\n<p>简单来说，进程就是程序的一次执行过程，程序是静态的，在计算机系统（CPT101）里面都学了，在冯诺依曼结构中，程序静态地存储在硬盘中。当需要执行时，程序被加载到内存，成为一个进程。相对于程序的静态性，进程是动态的，可以看作程序的实例。进程有自己的生命周期，包括创建、运行、等待、挂起、终止等阶段。</p>\n<p>举个例子来说，假设你正在电脑上同时运行着多个程序，比如一个浏览器中的几个网页，每个标签页都是一个进程（对于Chrome来说），它们独立运行并占用系统资源，如内存、CPU等。操作系统负责管理这些进程，确保它们能够正确地共享资源并按照用户的期望进行交互。当我们关闭一个标签页，就会关闭当前一个进程，释放相关的资源，结束它的生命周期，但是如果我浏览器关了，我们可以说进程结束了，但是我们不可以说浏览器这个程序被删除了，它依旧静态的存在于电脑当中。</p>\n<p>进程不仅包含正在运行的程序实体，还包括程序占据的所有系统资源，如CPU、内存、网络资源等。同一程序在同一时刻被运行两次将产生两个独立的进程，每个进程都有自己的资源副本。这强调了进程不仅是运行实体，还涉及其所占据的资源。</p>\n<h2 id=\"进程的组成部分\"><a href=\"#进程的组成部分\" class=\"headerlink\" title=\"进程的组成部分\"></a>进程的组成部分</h2><p>进程主要有三个部分：PCB、数据段、程序段。</p>\n<ol>\n<li><strong>进程控制块（Process Control Block）</strong>：PCB包含了进程的控制信息、管理信息以及资源分配清单。其中包括CPU相关的信息，如寄存器状态，以及操作系统用于控制进程的信息。PCB是操作系统进行调度和管理的重要数据结构。</li>\n<li><strong>数据段（Data Segment）</strong>：数据段保存了进程在运行过程中所需的各种数据，例如程序中定义的各种变量。这部分数据是进程运行时动态变化的，存储在内存中，以支持程序的执行和操作。</li>\n<li><strong>程序段（Code Segment）</strong>：程序段包含了进程的代码，即程序的指令集。这部分代码在进程执行时被加载到内存中，并由CPU执行。在举例中，多个浏览器标签页共享相同的程序段，即Chrome浏览器的代码，但它们拥有独立的PCB和数据段。</li>\n</ol>\n<p>举例来说，如果你在电脑上打开了多个浏览器标签，每个标签页都对应一个独立的进程，拥有独立的PCB和数据段，但它们共享相同的程序段，即浏览器的代码。当你关闭一个标签页时，相应的进程被终止，释放相关资源，但浏览器程序段仍然存在，直到整个浏览器被关闭。</p>\n<p>需要注意的是，PCB是提供给操作系统使用的，用于进行进程调度和管理，而程序段和数据段则是提供给进程自身使用的，用于支持程序的执行和数据存储。</p>\n<h3 id=\"PCB\"><a href=\"#PCB\" class=\"headerlink\" title=\"PCB\"></a>PCB</h3><p>每个进程在系统中有且仅有一个进程控制块（PCB），也被称为进程描述符。PCB是进程存在的唯一标识，它是操作系统用来记录和描述进程状态以及环境信息的关键数据结构。实际上，PCB是操作系统管理进程的主要依据和唯一的资料结构。</p>\n<p>通俗来说，PCB就像是操作系统对每个进程的个人档案，包含了关于进程的所有必要信息。这包括进程的执行状态、寄存器内容、分配的资源清单、以及其他与进程相关的信息。通过维护这个独一无二的标识符，操作系统能够有效地跟踪和管理系统中运行的各个进程。</p>\n<p>一般来说，PCB包含以下四类关键信息：</p>\n<ol>\n<li><strong>进程描述信息：</strong> 用于让操作系统能够区分和识别各个进程。在进程被创建时，操作系统为其分配一个独一无二的身份证号，即进程 ID（PID）。此外，进程描述信息还包括了进程所属的用户 ID（UID）。</li>\n<li><strong>进程控制和管理信息：</strong> 记录着进程的运行情况，例如CPU的使用时间、磁盘使用情况、网络流量使用等。这类信息有助于操作系统更全面地了解和监控各个进程的活动状态。</li>\n<li><strong>资源分配清单：</strong> 记录了操作系统为进程分配了哪些资源，如分配了多少内存、使用了哪些I/O设备、打开了哪些文件等。这有助于确保资源的合理分配和进程的正常运行。</li>\n<li><strong>CPU相关信息：</strong> 当进程在让出CPU时，必须保存其在CPU中的各种信息，如各种寄存器的值。这用于实现进程切换，确保在进程再次运行时能够恢复CPU的状态，从上一次执行的断点处继续。这一过程被称为保存现场信息，是操作系统管理进程切换的重要机制。</li>\n</ol>\n<h2 id=\"进程的状态\"><a href=\"#进程的状态\" class=\"headerlink\" title=\"进程的状态\"></a>进程的状态</h2><p>尽管每个进程都是独立的实体，拥有自己的PCB和内部状态，但进程间通常需要相互交互。一个进程的输出结果可能是另一个进程的输入。例如，如果进程A的执行需要依赖进程B的输出，那么在进程B的输出结果尚未产生之前，进程A就无法继续执行，它会处于阻塞状态。这种状态称为进程的阻塞态。</p>\n<p>经典的进程三态模型如下：</p>\n<ol>\n<li><strong>运行态（Running）：</strong> 进程占用CPU正在执行指令。</li>\n<li><strong>就绪态（Ready）：</strong> 进程具备运行条件，但等待系统分配CPU资源以便运行。一旦获得CPU时间片，就可以立即执行。</li>\n<li><strong>阻塞态/等待态（Blocked/Waiting）：</strong> 进程不具备运行条件，正等待某个事件的完成。例如，等待输入输出完成、等待资源的释放等。在等待期间，进程暂停执行，直到所等待的事件发生，才能转移到就绪态继续执行。</li>\n</ol>\n<img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/Three-State Schematic.png\">\n\n<p>在上图中，关于时间片的理解可以进一步补充：</p>\n<p>在计算机系统中，多个进程并发执行，而这种并发性在宏观层面上意味着它们可以同时运行。然而，在微观层面上，每个进程实际上以一种交替的方式运行，即它们共享CPU资源。为了实现公平调度和资源利用，操作系统将CPU时间划分为一小段一小段的时间片，轮流分配给各个进程。</p>\n<p>当一个进程的时间片耗尽时，它将从运行态转入就绪态，为其他进程让出CPU。这样的时间片轮转机制确保了每个进程都有机会执行，并减少了不公平调度的可能性。被调度的进程将进入运行态，执行指令，直到其时间片用完或发生阻塞事件。</p>\n<p>需要强调的是，阻塞态的转换是由于缺少某些关键资源，但这里不包括CPU时间片。如果一个进程由于时间片用完而从运行态切换为就绪态，它仅仅是等待下一轮的调度，而不是由于资源不足而陷入阻塞。这种调度方式有助于平衡系统中各个进程的执行，确保它们在有限的时间内都能得到处理。</p>\n<p>很多系统中都增加了新建态（new）和终止态（exit），形成<strong>五态模型</strong>：</p>\n<ul>\n<li><strong>新建态</strong>（new）：进程正在被创建时的状态</li>\n<li><strong>终止态</strong>（exit）：进程正在从系统中消失时的状态</li>\n</ul>\n<img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/Five-State Schematic.png\">\n\n<p>观察上图，我们可以明显看到只有就绪态和运行态之间存在相互转换的关系，而其它状态之间都是单向转换的。这意味着进程在生命周期中，主要经历了从新建到就绪、运行、阻塞、终止的顺序。</p>\n<p>为了更有效地管理这些处于不同状态的进程，操作系统依赖于PCB这个关键的数据结构。PCB包含了进程在不同状态下的关键信息，如进程标识符、寄存器状态、资源分配等。通过组织这些PCB，操作系统形成了<strong>进程队列（Process Queue）</strong>，使得可以对不同状态的进程进行有序的调度。</p>\n<p>我的理解是，这个进程队列就像是操作系统的”任务清单”，它根据进程的状态帮助系统有序地决定哪个进程应该获得CPU时间，哪个进程可能需要等待外部事件，以及哪个进程已经完成任务。通过这种方式，操作系统能够实现对多个进程的有效调度和管理，确保系统资源的合理利用和各个进程的公平运行。这种组织结构为操作系统提供了对整个进程生命周期的全局视角，从而更好地满足系统的多任务处理需求。</p>\n<h2 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h2><p>进程控制是对系统中所有进程进行有效管理，以实现进程状态的转换功能，如创建、阻塞、唤醒和终止进程。这些功能通常通过使用原语来实现，操作系统利用原语完成进程控制的基本原理，包括进程同步和互斥、进程通信和管理。</p>\n<p>在这里，<strong>原语（Primitive Instruction）</strong>是指一种特殊的程序，其执行具有原子性。简而言之，原语的运行必须是不可中断的，一气呵成的。这种特性对于确保操作的完整性和一致性至关重要，特别是在多任务环境中，防止多个任务之间发生竞争条件或数据不一致的问题。</p>\n<p>就个人理解而言，原语的使用是为了提供一种严格的、不可分割的执行环境，以确保关键操作的原子性。这有助于避免并发执行中可能出现的问题，例如死锁或竞态条件。在多进程系统中，操作系统使用原语来保障进程之间的协调和有效沟通，从而提高系统的可靠性和稳定性。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/Primitive Instruction.png\">\n\n<h3 id=\"进程的创建\"><a href=\"#进程的创建\" class=\"headerlink\" title=\"进程的创建\"></a>进程的创建</h3><p>进程的创建是操作系统中的一个重要过程，它涉及到分配资源、初始化数据结构等操作。在许多操作系统中，进程的创建通常通过<strong>创建原语（create primitive）</strong>来实现。创建原语的目标是在系统中生成一个新的进程，并为其分配必要的资源。</p>\n<p>创建原语是操作系统中负责启动新进程的基本功能，其主要内容如下：</p>\n<ol>\n<li><strong>在进程列表中增加一项：</strong> 创建原语首先需要在操作系统的进程列表中增加一项，以记录新进程的存在。这个列表维护了系统中所有进程的相关信息。</li>\n<li><strong>从 PCB 池中申请一个空闲的 PCB：</strong>PCB通常是有限的。创建原语需要从 PCB 池中选择一个空闲的 PCB，以存储新进程的信息。如果 PCB 池已满，那么创建失败。</li>\n<li><strong>为新进程分配地址空间：</strong> 操作系统需要为新进程分配合适的地址空间，即为其分配内存。这涉及到确定加载到进程地址空间中的程序，包括代码段、数据段等。</li>\n<li><strong>为新进程分配各种资源：</strong> 创建原语负责为新进程分配必要的资源，这包括但不限于文件描述符、I/O 设备、时间片等。这确保新进程能够访问系统资源并执行任务。</li>\n<li><strong>初始化 PCB：</strong> 操作系统需要初始化新进程的 PCB，包括设置进程标识符、CPU 初始状态等信息。这些信息在进程执行过程中将被使用。</li>\n<li><strong>将新进程状态设置为就绪态：</strong> 最后，创建原语将新进程的状态设置为就绪态，并将其移入就绪队列。这样，新进程就准备好被调度执行了，等待分配CPU时间片。</li>\n</ol>\n<h4 id=\"创建进程\"><a href=\"#创建进程\" class=\"headerlink\" title=\"创建进程\"></a>创建进程</h4><p>创建进程的一般步骤包括：</p>\n<ol>\n<li><strong>分配唯一标识符：</strong> 系统为新进程分配一个唯一的进程标识符（Process ID，PID），这个标识符在系统中是唯一的，用于标识和区分不同的进程。</li>\n<li><strong>分配资源：</strong> 新进程需要一些资源，如内存空间、文件描述符、CPU时间片等。创建原语负责分配这些资源，确保新进程能够正常运行。</li>\n<li><strong>初始化数据结构：</strong> 操作系统需要为新进程建立相应的数据结构，其中包括进程控制块（PCB）。PCB包含了进程的各种信息，如进程状态、寄存器值、程序计数器等。</li>\n<li><strong>加载程序：</strong> 将新进程的程序加载到内存中，使其可以执行。这通常涉及将程序代码、数据段等加载到合适的内存地址。</li>\n<li><strong>启动进程：</strong> 最后，创建原语启动新进程，使其进入就绪态，等待被调度执行。</li>\n</ol>\n<p>创建原语通常是操作系统提供给开发者的一个接口，可以通过系统调用的方式调用这个原语。在UNIX/Linux系统中，<code>fork()</code> 是一个典型的创建原语，它会创建一个新的进程，将父进程的副本传递给子进程。</p>\n<p>在Windows系统中，<code>CreateProcess()</code> 是用于创建新进程的API函数。这个函数接受一系列参数，包括要执行的可执行文件、命令行参数、进程属性等，然后创建并启动一个新进程。</p>\n<p>创建原语是多任务操作系统中非常基础和关键的功能，确保了系统可以同时运行多个独立的任务。</p>\n<h4 id=\"创建时机\"><a href=\"#创建时机\" class=\"headerlink\" title=\"创建时机\"></a>创建时机</h4><ol>\n<li><strong>用户程序执行请求：</strong> 当用户执行一个程序或应用时，操作系统可能会创建一个新的进程来运行这个程序。这是最常见的进程创建场景，例如用户在终端中启动一个应用程序。</li>\n<li><strong>系统启动：</strong> 操作系统启动时，会创建一些初始的进程来执行系统初始化和启动操作。这些进程可能包括初始化进程、内核进程等，用于确保系统正常运行。</li>\n<li><strong>系统服务请求：</strong> 操作系统可能需要在后台执行一些系统服务或守护进程，这些服务可能会在特定事件或条件下被触发，从而导致新进程的创建。</li>\n<li><strong>中断或异常：</strong> 当系统发生中断或异常事件时，可能需要创建一个新的进程来处理这些事件。例如，一个硬件设备产生了中断，操作系统可能需要创建一个处理中断的进程。</li>\n<li><strong>应用程序请求：</strong> 有些应用程序可能需要动态地创建新的进程来执行特定的任务。这通常是在需要执行独立任务或子任务时触发的。</li>\n<li><strong>定时任务：</strong> 操作系统可能会根据预定的时间表或计划创建新的进程来执行定时任务，例如定期执行系统维护任务。</li>\n</ol>\n<h3 id=\"撤销-终止进程\"><a href=\"#撤销-终止进程\" class=\"headerlink\" title=\"撤销/终止进程\"></a>撤销/终止进程</h3><p>进程的终止也称为撤销，进程完成特定工作或出现严重错误后必须被终止。引起进程终止的事件有三种：</p>\n<ul>\n<li>正常结束：进程自己请求终止（exit 系统调用）</li>\n<li>异常结束：比如整数除 0，非法使用特权指令，然后被操作系统强行终止</li>\n<li>外界干预：Ctrl + Alt + delete 打开进程管理器，用户手动杀死进程</li>\n</ul>\n<p>进程的撤销是指终止一个正在运行的进程并释放其占用的资源。<strong>撤销原语</strong>是用于实现这个过程的基本功能，它负责完成终止进程、释放资源以及清理进程控制块（PCB）等任务。</p>\n<p>撤销进程的一般步骤包括：</p>\n<ol>\n<li><strong>标识进程：</strong> 系统需要确定要被终止的是哪个进程。通常，进程标识符（PID）用于唯一标识每个进程，通过这个标识符可以找到要撤销的进程。</li>\n<li><strong>释放资源：</strong> 撤销原语需要释放由进程占用的各种资源，包括内存空间、文件描述符、I/O 设备等。这确保了这些资源可以被其他进程或系统使用。</li>\n<li><strong>清理 PCB：</strong> 进程控制块（PCB）包含了关于进程的各种信息。在进程撤销时，系统需要清理并释放这些信息，以便空出 PCB 供其他进程使用。</li>\n<li><strong>终止进程：</strong> 撤销原语会向操作系统指示终止进程的操作，使其从运行态转变为终止态。这可能包括向进程发送终止信号，通知它结束执行。</li>\n<li><strong>回收 PCB：</strong> 终止的进程所使用的 PCB 变得无效，系统可以将其回收到 PCB 池中，以备将来新进程的创建。</li>\n</ol>\n<p>在UNIX/Linux系统中，<code>exit()</code> 函数是一个典型的撤销原语，它会使得进程正常终止。在Windows系统中，<code>ExitProcess()</code> 函数用于退出当前进程。</p>\n<h3 id=\"进程的阻塞和唤醒\"><a href=\"#进程的阻塞和唤醒\" class=\"headerlink\" title=\"进程的阻塞和唤醒\"></a>进程的阻塞和唤醒</h3><p>进程的阻塞和唤醒是多任务操作系统中管理进程状态的重要概念。阻塞指的是使一个进程暂时停止执行，直到满足某些条件；而唤醒则是将一个阻塞的进程重新激活，使其可以继续执行。这种机制有助于有效地利用系统资源和协调进程之间的执行顺序。</p>\n<p>阻塞原语和唤醒原语是用于实现这些操作的基本功能，它们通常是由操作系统提供的系统调用或函数。</p>\n<p><strong>阻塞原语</strong>的主要目标是将进程从运行态转移到阻塞态，其过程包括：</p>\n<ol>\n<li><strong>标识进程：</strong> 系统需要确定要阻塞的是哪个进程。通常使用进程标识符（PID）来唯一标识每个进程。</li>\n<li><strong>设置阻塞条件：</strong> 阻塞原语需要设置导致进程阻塞的条件。这可以是等待某个事件发生，如等待输入、等待信号等。</li>\n<li><strong>切换状态：</strong> 进程的状态从运行态切换到阻塞态。这意味着该进程暂时停止执行，等待满足阻塞条件后再次被唤醒。</li>\n</ol>\n<p><strong>唤醒原语</strong>则是用于将阻塞的进程重新激活，使其从阻塞态转移到就绪态，以便可以再次被调度执行。其过程包括：</p>\n<ol>\n<li><strong>标识进程：</strong> 系统需要确定要唤醒的是哪个进程。同样，通常使用进程标识符（PID）来标识。</li>\n<li><strong>清除阻塞条件：</strong> 唤醒原语需要清除导致进程阻塞的条件，以便使其可以继续执行。</li>\n<li><strong>切换状态：</strong> 进程的状态从阻塞态切换到就绪态，表示该进程可以被调度执行。</li>\n</ol>\n<p>在UNIX/Linux系统中，阻塞原语通常包括 <code>wait()</code> 系统调用，它用于等待子进程的终止。唤醒原语则可以通过发送信号（如 <code>signal()</code> 函数）来激活等待中的进程。</p>\n<p>在Windows系统中，阻塞原语可以包括 <code>WaitForSingleObject</code> 或 <code>WaitForMultipleObjects</code> 等函数，而唤醒原语可以通过 <code>SetEvent</code> 或 <code>ReleaseSemaphore</code> 等函数来实现。</p>\n<p>阻塞原语和唤醒原语的作用正好相反，它们是多任务操作系统中用于管理进程状态的关键机制。阻塞原语用于将进程从运行态切换到阻塞态，而唤醒原语则将阻塞的进程重新激活，使其从阻塞态转移到就绪态，等待调度执行。</p>\n<p>一个有趣的点是，如果某个进程使用阻塞原语主动将自己阻塞，那么唤醒原语就成为了唯一的方式来唤醒它。这是因为阻塞的原因通常涉及等待某个事件的发生，而这个事件的发生通常只能由外部因素触发，例如其他进程的操作、硬件中断等。因此，阻塞和唤醒是一对密切相关的操作，阻塞了什么就需要唤醒什么，否则被阻塞的进程可能陷入永久的阻塞状态。</p>\n<p>在理解阻塞和唤醒原语的概念时，可以将其比喻为进程的“休眠”和“唤醒”过程。进程使用阻塞原语主动进入休眠，等待某个特定的条件满足；而唤醒原语则是唤醒那些处于休眠状态的进程，让它们准备好执行。</p>\n<p>这种对称的设计有助于实现进程之间的协同工作和资源共享，同时确保了系统的可靠性和效率。在实际应用中，开发者需要谨慎地使用阻塞和唤醒原语，以避免潜在的死锁和资源争夺问题。</p>\n<h2 id=\"进程的上下文切换\"><a href=\"#进程的上下文切换\" class=\"headerlink\" title=\"进程的上下文切换\"></a>进程的上下文切换</h2><p>所谓进程的上下文切换，就是说各个进程之间是共享 CPU 资源的，不可能一个进程永远占用着 CPU 资源，不同的时候进程之间需要切换，使得不同的进程被分配 CPU 资源，这个过程就是进程的上下文切换，<strong>一个进程切换到另一个进程运行</strong>。</p>\n<p>因为进程是由内核进行管理和调度的，所以<strong>进程的上下文切换一定发生在内核态</strong>。</p>\n<p>上下文切换的一般步骤包括：</p>\n<ol>\n<li><strong>保存当前进程的上下文：</strong> 切换原语会保存当前运行进程的所有必要信息，以便将来能够恢复该进程的执行状态。这包括寄存器的值、程序计数器的值、堆栈指针等。</li>\n<li><strong>选择另一个进程：</strong> 操作系统会根据某种调度算法选择下一个要执行的进程。这可能涉及就绪队列、优先级调度等策略。</li>\n<li><strong>加载新进程的上下文：</strong> 切换原语将加载新选择的进程的保存的上下文信息，将其状态还原为上次保存的时刻，以便它可以继续执行。</li>\n<li><strong>更新进程控制块（PCB）：</strong> 操作系统可能需要更新相关的数据结构，如就绪队列或进程表，以反映进程的状态变化。</li>\n<li><strong>将控制权交给新进程：</strong> 现在，新选择的进程处于运行态，可以继续执行。控制权从上一个进程转移到当前进程。</li>\n</ol>\n<p>在实际的操作系统中，切换原语的实现通常涉及汇编级的指令，因为它需要直接操作底层硬件状态。在UNIX/Linux系统中，<code>context_switch()</code> 函数可用于表示上下文切换的实现。</p>\n<p>上下文切换是一个开销较大的操作，因为它涉及到保存和恢复大量的进程状态信息。因此，设计高效的调度算法和减少上下文切换的频率是操作系统的一项重要任务。</p>\n<h1 id=\"进程的调度\"><a href=\"#进程的调度\" class=\"headerlink\" title=\"进程的调度\"></a>进程的调度</h1><h2 id=\"调度器\"><a href=\"#调度器\" class=\"headerlink\" title=\"调度器\"></a>调度器</h2><p>调度器本身也是一个程序，目的是为了给执行用户的程序提供资源，包含了一个决定一组程序中谁会赢得CPU时钟周期的算法。</p>\n<p>在桌面机，嵌入式设备或大型机等不同的环境中，产生了不同的调度器。我们一般针对不同层面，分为下面几种调度器：</p>\n<ol>\n<li><strong>高级调度器（long-term scheduler）</strong>： 通常用于面向批处理的多程序环境中，通过均衡内存中的任务以欧化系统资源，包括CPU，内存和硬盘存储等。</li>\n<li><strong>中级调度器（medium-term scheduler）</strong>：跟踪CPU上执行的进程的动态内存用量来决定是否要增加或减少“多通道程度“（内存中竞争CPU的进程个数），以防止”<strong>颠簸</strong>“。颠簸即当前的进程集合的内存需求超过了系统容量，导致进程在各自的执行中变得缓慢。</li>\n<li><strong>低级调度器（short-term scheduler）</strong>：负责在当前驻留的内存里的进程中选择一个来运行。这篇内容设计的算法主要关注的都是低级调度器。</li>\n</ol>\n<h2 id=\"调度的步骤\"><a href=\"#调度的步骤\" class=\"headerlink\" title=\"调度的步骤\"></a>调度的步骤</h2><p>在低级调度器中，一般划分为：<em>非抢占式</em>和<em>抢占式</em>。非抢占式的调度器中，一个进程要不然就一直执行到底，要不然就自己主动资源放弃处理器，以处理I/O请求，调度器只是安排先后顺序；而抢占式调度器里，调度器从当前进程手中把处理器抢走，交给另一个进程，有这么一个主动的动作。不管是哪一种，调度器的执行步骤一般如下：</p>\n<ol>\n<li>获得处理器的控制权</li>\n<li>把当前正在运行的进程状态（PCB，process control block）保存下来</li>\n<li>选择一个新的进程来执行</li>\n<li>把新选择出来的进程分发给处理器运行，这一步会把第二步中的状态再加载到CPU寄存器中。</li>\n</ol>\n<p>可以看出，在调度器调度过程中，进程状态很重要，它包括了很多信息：程序执行到哪儿了（PC指针）以便回来继续执行，程序在内存中的足迹等等。所有的信息会用一个数据结构，进程控制块PCB描述。</p>\n<p>PCB包含了所有必须的描述进程的相关信息，是操作系统中很重要的数据结构，而PCB的维护一般是由一个队列来完成的，称作就绪队列。就绪队列的数据结构的正确表示关系到调度器的性能。</p>\n<h1 id=\"进程间通信\"><a href=\"#进程间通信\" class=\"headerlink\" title=\"进程间通信\"></a>进程间通信</h1><p>进程间通信（Inter-process Communication，IPC）是指在多任务操作系统中，不同进程之间进行数据交换和通信的机制。进程间通信是为了实现进程之间的协同工作、资源共享和信息传递而设计的。在一个系统中，有时候不同的进程需要相互协作，共同完成某项任务，这就需要它们能够有效地进行通信。</p>\n<p>下面是两种常见的进程间通信的方式：</p>\n<ol>\n<li><strong>消息队列（Message Passing）：</strong> 消息传递（message passing）是IPC中常用的数据传递方式，即将数据抽象成一个个的消息进行传递。不同的IPC设计有不同的消息抽象，且消息传递往往需要一个“中间人”（如共享内存）。</li>\n<li><strong>共享内存（Shared Memory）：</strong> 共享内存允许多个进程访问同一块物理内存区域，进程可以直接读写这个共享区域的内容。这是一种高效的通信方式，但需要特殊的同步机制来避免冲突。</li>\n</ol>\n<h2 id=\"进程间通信的分类\"><a href=\"#进程间通信的分类\" class=\"headerlink\" title=\"进程间通信的分类\"></a>进程间通信的分类</h2><h3 id=\"Direct-and-indirect-communication\"><a href=\"#Direct-and-indirect-communication\" class=\"headerlink\" title=\"Direct and indirect communication\"></a>Direct and indirect communication</h3><p>通过通信进程交换的消息驻留在<strong>临时队列</strong>中</p>\n<p><strong>队列消息的三种方式</strong></p>\n<p>① 零容量 - 0 messages，等同发送方必须等到接收方，同步发送。</p>\n<p>② 有限容量 - n messages的有限长度，队列满了后，发送方结束发送；同理队列为空时，接收方结束接收。</p>\n<p>③ 无限容量 - 只有理论意义</p>\n<h4 id=\"直接通信\"><a href=\"#直接通信\" class=\"headerlink\" title=\"直接通信\"></a>直接通信</h4><p>进程必须明确命名彼此:</p>\n<ul>\n<li>send (P, message) – send a message to process P</li>\n<li>receive(Q, message) – receive a message from process Q</li>\n</ul>\n<p>直接通信是当进程使用特定的进程识别号进行通信时实现的，但是很难提前识别发送者。</p>\n<h4 id=\"间接通信\"><a href=\"#间接通信\" class=\"headerlink\" title=\"间接通信\"></a>间接通信</h4><p>或者创建一个新的mailbox (port)</p>\n<p>然后通过这个mailbox来发送和接受消息，实现通信</p>\n<p>最后再销毁这个mailbox</p>\n<h3 id=\"Synchronous-and-asynchronous-communication\"><a href=\"#Synchronous-and-asynchronous-communication\" class=\"headerlink\" title=\"Synchronous and asynchronous communication\"></a>Synchronous and asynchronous communication</h3><p>在进程间通信中，消息传递可以是阻塞的（blocking）或非阻塞的（non-blocking）。这涉及到消息发送和接收的同步性，以及进程在消息发送或接收时是否会被阻塞。</p>\n<h3 id=\"阻塞（Blocking）与同步（Synchronous）\"><a href=\"#阻塞（Blocking）与同步（Synchronous）\" class=\"headerlink\" title=\"阻塞（Blocking）与同步（Synchronous）\"></a>阻塞（Blocking）与同步（Synchronous）</h3><ol>\n<li><strong>Blocking Send（阻塞发送）：</strong> 在阻塞发送中，发送者在发送消息后会被阻塞，直到接收者成功接收到消息。这意味着发送者需要等待消息被完全接收，然后才能继续执行其他操作。这种方式保证了消息的可靠性，因为发送者知道消息已被成功传递。</li>\n<li><strong>Blocking Receive（阻塞接收）：</strong> 在阻塞接收中，接收者在没有收到消息之前会一直被阻塞。接收者会等待直到有消息可用，然后再继续执行。这种方式确保了接收者只在有有效消息时才继续执行。</li>\n</ol>\n<p>阻塞的消息传递被认为是同步的，因为发送者和接收者都在消息传递的过程中保持同步，它们彼此都在等待对方的动作。</p>\n<h3 id=\"非阻塞（Non-blocking）与异步（Asynchronous）\"><a href=\"#非阻塞（Non-blocking）与异步（Asynchronous）\" class=\"headerlink\" title=\"非阻塞（Non-blocking）与异步（Asynchronous）\"></a>非阻塞（Non-blocking）与异步（Asynchronous）</h3><ol>\n<li><strong>Non-blocking Send（非阻塞发送）：</strong> 在非阻塞发送中，发送者发送消息后会立即继续执行，而不必等待接收者的响应。这意味着发送者不会被消息传递所阻塞，即使接收者还没有接收到消息。</li>\n<li><strong>Non-blocking Receive（非阻塞接收）：</strong> 在非阻塞接收中，接收者尝试接收消息，但如果没有消息可用，它会立即返回而不是被阻塞。这样接收者可以在等待消息的同时继续执行其他任务。</li>\n</ol>\n<p>非阻塞的消息传递被认为是异步的，因为发送者和接收者不需要在消息传递过程中等待对方的动作。它们可以并行执行其他任务，而不必受到消息传递的干扰。</p>\n","feature":true,"text":"开学第一课，操作系统原理。 进程什么是进程？进程就是程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位。 简单来说，进程就是程序的一次执行过程，程序是静态的，在计算机系统（CPT101）里面都学了，在冯诺依曼结构中，程序静态地存储在硬盘中。当需要执行时，...","link":"","photos":[],"count_time":{"symbolsCount":"9.7k","symbolsTime":"9 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":51,"path":"api/tags/笔记.json"},{"name":"CPT104","slug":"CPT104","count":2,"path":"api/tags/CPT104.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B\"><span class=\"toc-text\">进程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%EF%BC%9F\"><span class=\"toc-text\">什么是进程？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86\"><span class=\"toc-text\">进程的组成部分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#PCB\"><span class=\"toc-text\">PCB</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">进程的状态</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">进程控制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">进程的创建</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B\"><span class=\"toc-text\">创建进程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">创建时机</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%92%A4%E9%94%80-%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B\"><span class=\"toc-text\">撤销&#x2F;终止进程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E5%92%8C%E5%94%A4%E9%86%92\"><span class=\"toc-text\">进程的阻塞和唤醒</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2\"><span class=\"toc-text\">进程的上下文切换</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">进程的调度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B0%83%E5%BA%A6%E5%99%A8\"><span class=\"toc-text\">调度器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B0%83%E5%BA%A6%E7%9A%84%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">调度的步骤</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">进程间通信</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">进程间通信的分类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Direct-and-indirect-communication\"><span class=\"toc-text\">Direct and indirect communication</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%9B%B4%E6%8E%A5%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">直接通信</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%97%B4%E6%8E%A5%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">间接通信</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Synchronous-and-asynchronous-communication\"><span class=\"toc-text\">Synchronous and asynchronous communication</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%98%BB%E5%A1%9E%EF%BC%88Blocking%EF%BC%89%E4%B8%8E%E5%90%8C%E6%AD%A5%EF%BC%88Synchronous%EF%BC%89\"><span class=\"toc-text\">阻塞（Blocking）与同步（Synchronous）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%88Non-blocking%EF%BC%89%E4%B8%8E%E5%BC%82%E6%AD%A5%EF%BC%88Asynchronous%EF%BC%89\"><span class=\"toc-text\">非阻塞（Non-blocking）与异步（Asynchronous）</span></a></li></ol></li></ol></li></ol>","author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}},"mapped":true,"prev_post":{"title":"CPT104 Learning Week2","uid":"92c1c7c7f1c0da34a8e6904f96b9e4c0","slug":"CPT104-Learning-Week2","date":"2024-03-07T08:30:23.000Z","updated":"2024-03-07T09:42:26.942Z","comments":true,"path":"api/articles/CPT104-Learning-Week2.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/CPT104-img.png","text":"在此之前我要先晒卡，以表达我写本篇文章时喜悦的心情。 好，言归正传，操作系统，我在想要不要再写一个Linux的笔记？正好最近在看相关的东西？ 无所谓，先看课件。 线程引入在此之前，我们先做一个类比。 首先，我想说明线程和进程是如何工作的。我能想到的最佳方法（除了深入研究实时系统的...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"笔记","slug":"笔记","count":51,"path":"api/tags/笔记.json"},{"name":"CPT104","slug":"CPT104","count":2,"path":"api/tags/CPT104.json"}],"author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}},"feature":true},"next_post":{"title":"CPT101 Review-7","uid":"9f40b949505ca9d69d0cd0fe93485a8a","slug":"CPT101-Review-7","date":"2024-01-07T06:15:23.000Z","updated":"2024-01-07T08:14:30.934Z","comments":true,"path":"api/articles/CPT101-Review-7.json","keywords":null,"cover":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/CPT101-img.png","text":"冯·诺依曼模型冯·诺依曼模型（Von Neumann architecture）是计算机体系结构的一种基本设计范式，由匈牙利数学家和计算机科学家约翰·冯·诺依曼（John von Neumann）于20世纪40年代提出。这个模型成为了现代计算机体系结构的基础，几乎所有的通用计算机...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"13 mins."},"categories":[],"tags":[{"name":"CPT101复习","slug":"CPT101复习","count":7,"path":"api/tags/CPT101复习.json"},{"name":"笔记","slug":"笔记","count":51,"path":"api/tags/笔记.json"}],"author":{"name":"General_K1ng","slug":"blog-author","avatar":"https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/avatar.png","link":"/","description":"一名正在努力学习计算机的菜鸟","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/BILIBILI.svg","link":"https://space.bilibili.com/32927332"},"csdn":{"icon":"/svg/csdn.svg","link":"https://blog.csdn.net/qq_34849354"},"github":{"icon":"/svg/GitHub.svg","link":"https://github.com/GeneralK1ng"},"QQ":{"icon":"/svg/QQ.svg","link":"tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2822688858"}}}},"feature":true}}