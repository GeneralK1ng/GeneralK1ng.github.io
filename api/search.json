[{"id":"9f40b949505ca9d69d0cd0fe93485a8a","title":"CPT101 Review-7","content":"冯·诺依曼模型冯·诺依曼模型（Von Neumann architecture）是计算机体系结构的一种基本设计范式，由匈牙利数学家和计算机科学家约翰·冯·诺依曼（John von Neumann）于20世纪40年代提出。这个模型成为了现代计算机体系结构的基础，几乎所有的通用计算机都采用了冯·诺依曼模型。\n冯·诺依曼模型的关键特征包括以下几点：\n\n存储程序： 冯·诺依曼模型使用存储程序的概念，即指令和数据都存储在同一存储器中。这与之前的一些计算机体系结构不同，这些计算机在执行程序之前需要将程序加载到计算机中。在冯·诺依曼模型中，程序被存储在内存中，可以被计算机按照顺序读取和执行。\n二进制表示： 冯·诺依曼模型使用二进制来表示指令和数据。计算机中的所有信息，包括指令、数据和地址，都以二进制形式存储和处理。\n中央处理单元（CPU）： CPU是冯·诺依曼计算机的核心部分，负责执行存储在内存中的指令。CPU包括运算器（Arithmetic Logic Unit，ALU）和控制器（Control Unit，CU）。运算器执行算术和逻辑运算，而控制器负责解释指令、控制数据流和执行程序。\n存储器： 存储器用于存储指令和数据。在冯·诺依曼模型中，存储器被划分为指令存储器和数据存储器，但它们通常是统一的内存空间。\n输入/输出设备： 冯·诺依曼计算机通过输入/输出设备与外部世界进行通信。这些设备可以是键盘、鼠标、显示器、磁盘驱动器等。\n顺序执行： 指令按照顺序一条一条地执行，每条指令都由控制器解释和执行。这种顺序执行的方式使得计算机能够灵活地执行各种任务。\n\n冯·诺依曼模型的优点在于其简洁性和通用性。这个模型为计算机的发展奠定了基础，使得计算机可以执行各种不同的任务，而不需要物理上重新设计硬件。冯·诺依曼模型的基本概念成为现代计算机体系结构的基础，直到今天仍然广泛应用。\n计算机的主要组成部分CPU计算机的中央处理器（CPU）是系统的核心，负责执行计算机程序中的指令。CPU包含多个部分，每个部分都有特定的功能，共同协作以实现计算和控制。以下是CPU的主要功能和组成部分：\n\n控制单元（Control Unit，CU）：\n功能： 控制数据在计算机内部的流动，协调和管理指令的执行。\n\n\n算术逻辑单元（Arithmetic Logic Unit，ALU）：\n功能： 执行算术和逻辑运算，包括加法、减法、乘法、除法等数学运算，以及比较和逻辑判断。\n\n\n寄存器（Registers）：\n功能： 临时存储CPU需要快速访问的数据和指令。\n包括累加器、程序计数器、指令寄存器等。\n\n\n缓存（Cache）：\n功能： 存储临时数据，以便更快地访问经常使用的数据。\n分为多级缓存，如L1缓存和L2缓存。\n\n\n时钟（Clock）：\n功能： 提供计时信号，同步CPU内部各个部分的工作。\n按时钟周期执行指令，划分为时钟周期和时钟频率。\n\n\n指令寄存器（Instruction Register，IR）：\n功能： 存储当前执行的指令，从内存中取出的指令会存储在指令寄存器中，以供执行。\n\n\n程序计数器（Program Counter，PC）：\n功能： 存储下一条要执行的指令的地址。\n在每次指令执行后自动递增，以指向下一条指令。\n\n\n状态寄存器（Flag Register）：\n功能： 存储标志位，用于指示CPU的状态和执行结果，如零标志、进位标志等。\n\n\n总线接口（Bus Interface）：\n功能： 通过内部和外部总线与其他系统组件（如内存、输入输出设备）进行数据交换。\n\n\n\n这些部分共同协作，使CPU能够高效地执行各种计算任务。控制单元指导指令的执行流程，ALU执行实际的计算，寄存器和缓存提供临时存储，时钟同步各个部分的操作，而总线接口使CPU能够与其他硬件组件通信。这种协同作用使得计算机能够迅速、准确地执行各种计算任务。\n考虑一个简单的加法操作，我们使用一个包含 ALU、寄存器和时钟的基本 CPU。\n\n主储存器（Main Memory）主存储器（Main Memory），也称为随机存取存储器（RAM），是计算机系统中用于存储正在运行的程序和数据的关键组件。主存储器在计算机启动时被操作系统加载，它的内容是易失性的，即在断电时会丢失。下面是主存储器的一些重要方面：\n\n内存单元（Memory Cells）：\n功能： 主存储器被划分为许多小的存储单元，每个单元存储一个数据位。每个单元都有一个唯一的地址。\n\n\n地址总线（Address Bus）：\n功能： 用于指定内存中的特定单元。地址总线的位数决定了内存的寻址能力，即能够寻址的最大存储单元数。\n\n\n数据总线（Data Bus）：\n功能： 传输CPU和主存储器之间的数据。数据总线的宽度决定了每次数据传输的位数，通常与CPU的数据总线宽度相匹配。\n\n\n存储单元的大小和字长（Word Size）：\n功能： 描述每个存储单元能够容纳的位数。字长与计算机的体系结构和处理器有关，通常是8位、16位、32位或64位。\n\n\n主存储器的种类：\nRAM（随机存取存储器）： 包括动态随机存储器（DRAM）和静态随机存储器（SRAM）。DRAM需要定期刷新以保持数据，而SRAM是静态的，不需要刷新，但成本较高。\nROM（只读存储器）： 存储固定的程序和数据，不易修改。包括EPROM、EEPROM和闪存等。\n\n\n内存层次结构：\n功能： 包括多级缓存和主存储器，以提高数据访问速度。高速缓存用于存储CPU经常访问的数据，而主存储器用于存储更大量的数据。\n\n\n内存访问时间和带宽：\n功能： 内存访问时间是CPU从请求数据到实际获取数据所需的时间。带宽指的是在单位时间内传输到或从内存的数据量。快速的内存访问和高带宽对于提高计算机性能至关重要。\n\n\n内存管理单元（Memory Management Unit，MMU）：\n功能： 负责将逻辑地址（由程序生成的地址）映射为物理地址（在实际硬件上的地址），并处理虚拟内存等内存管理任务。\n\n\n\n主存储器在计算机系统中起到了承载程序和数据的关键作用。它的大小、速度和类型对计算机性能有重要影响。存储层次结构的设计和内存管理单元的工作都是为了提高数据的访问效率和整体系统的性能。\n然后在此基础上就是这样来表示：\n\n输入输出单元（I/O Units）输入输出单元（I/O Units）是计算机系统中负责处理与外部设备通信的组件。这些单元允许计算机与各种外部设备进行数据交换，包括键盘、鼠标、打印机、硬盘驱动器、网络适配器等。输入输出单元通常包括以下几个重要的组成部分：\n\n输入输出控制器（I/O Controller）：\n功能： 管理和协调计算机与外部设备之间的数据传输。\n负责将数据从内存传输到外部设备或将外部设备的数据传输到内存。\n\n\n设备驱动程序（Device Drivers）：\n功能： 是操作系统中的软件模块，用于与特定硬件设备通信。\n提供了一个标准的接口，使操作系统能够控制和与各种设备进行交互。\n\n\n端口（Ports）：\n功能： 提供物理或逻辑接口，允许外部设备与计算机连接。\n可以是串口、并口、USB端口、HDMI端口等，每种端口对应不同类型的设备连接。\n\n\n中断控制器（Interrupt Controller）：\n功能： 处理硬件中断，通知CPU有外部事件需要处理。\n使计算机能够响应外部设备的请求，而不需要不断地轮询检查。\n\n\n缓冲区（Buffer）：\n功能： 用于临时存储输入输出数据，协调不同速度的设备之间的数据传输。\n避免了设备之间的速度不匹配导致的数据丢失或延迟。\n\n\n通信接口（Communication Interface）：\n功能： 提供计算机与网络通信的能力，例如网络适配器。\n负责处理网络数据包的发送和接收。\n\n\nDMA控制器（Direct Memory Access Controller）：\n功能： 允许外部设备直接访问计算机内存，减轻CPU负担。\n提高数据传输效率，特别是在大量数据需要快速传输时。\n\n\nI/O端口地址空间（I/O Port Address Space）：\n功能： 提供给CPU访问I/O设备的地址空间，通过这些地址可以与外部设备进行通信。\n\n\n\n输入输出单元的主要任务是协调和管理计算机系统与外部设备之间的数据传输，以确保数据能够有效地在计算机系统和外部设备之间流动。这样，计算机系统就能够与用户交互，并与各种外部设备协同工作，实现各种功能。\n\n主板（Mother Board）介绍计算机主板是计算机系统中的核心组件，连接并协调各个硬件设备，确保它们能够正常工作。主板上有许多组成部分，每个部分都有其独特的功能。以下是计算机主板的主要组成部分及其功能：\n\n中央处理器插槽（Central Processing Unit Socket）：\n功能： 放置中央处理器（CPU），负责执行计算机的指令。\n\n\n内存插槽（Memory Slots）：\n功能： 安装内存模块，存储正在执行的程序和数据，提供快速访问速度。\n\n\n芯片组（Chipset）：\n功能： 控制和协调数据流动，管理系统中的各种硬件组件。\n\n\n扩展插槽（Expansion Slots）：\n功能： 提供安装扩展卡的位置，如图形卡、声卡、网络适配器等，以扩展计算机的功能。\n\n\n输入/输出接口（I/O Ports）：\n功能： 提供连接外部设备的接口，如USB端口、HDMI端口、音频接口等。\n\n\nBIOS/UEFI芯片（BIOS/UEFI Chip）：\n功能： 存储计算机的基本输入/输出系统（BIOS）或统一可扩展固件接口（UEFI），启动和初始化系统硬件。\n\n\n电源连接口（Power Connectors）：\n功能： 提供电源连接，将电能传递给主板及其组件。\n\n\nCMOS电池（CMOS Battery）：\n功能： 供电给CMOS芯片，保存计算机的基本配置信息，如日期、时间和硬件设置。\n\n\n南桥（Southbridge）：\n功能： 管理次要的系统组件，如硬盘驱动器、USB控制器和音频控制器。\n\n\n北桥（Northbridge）：\n功能： 管理主要的系统组件，如内存、图形接口和PCI Express控制器。\n\n\nSATA接口（SATA Ports）：\n功能： 提供连接硬盘驱动器和光盘驱动器的接口。\n\n\nPCI Express插槽（PCI Express Slots）：\n功能： 提供高带宽的扩展插槽，用于连接图形卡、网络适配器等高性能设备。\n\n\nUSB控制器（USB Controller）：\n功能： 管理USB接口，支持连接各种外部设备。\n\n\n音频芯片（Audio Chip）：\n功能： 控制计算机的音频输入和输出。\n\n\n网络接口控制器（Network Interface Controller，NIC）：\n功能： 管理网络连接，控制计算机与局域网或互联网的通信。\n\n\n\n主要组成三个主要子系统\n中央处理器（CPU）\n主存储器\n输入输出单元（I/O Units）\n\n交换数据\n中央处理器（CPU）：\n由算术逻辑单元（ALU）、控制单元和寄存器组成。\nALU执行计算和逻辑操作。\n控制单元协调和控制指令的执行。\n寄存器存储临时数据和指令。\n\n\n主存储器：\n包括随机存取存储器（RAM）和只读存储器（ROM）。\nRAM用于存储正在运行的程序和数据。\nROM包含系统启动所需的固定程序。\n\n\n输入输出单元：\n包括连接计算机与外部设备的各种接口。\n数据通过输入输出控制器传递，通过各种接口（如USB、HDMI、网络端口）与外部设备通信。\n\n\n\n他们三者之间通过总线（bus）进行数据交换\n\n总线（Bus）： 一组电子线路，允许数据在各个子系统之间传输。\n数据通过地址总线和数据总线传递，控制信号通过控制总线传递。\nCPU通过地址总线选择要访问的内存位置，通过数据总线进行读取或写入操作。\n\n• 数据流动的基本过程：\n\nCPU向内存发出请求。\n内存通过总线将数据传递给CPU。\nCPU对数据进行处理，可能会写回内存。\n输入输出单元通过总线与外部设备进行通信。\n\n示意图以下是一个简单的图来表示数据的传递：\n\n如果复杂一点，就是这样：\n\n如果看不懂，那就举一个例子，比方说我们现在需要对一个图像进行处理\n\n协处理器（Coprocessor）介绍协处理器是计算机体系结构中的一种特殊处理器，其设计用于执行特定类型的计算任务，以协助主处理器（Central Processing Unit，CPU）完成特定的运算。\n\n协处理器（Coprocessor）：一种辅助处理器，用于处理特定类型的运算，以提高计算机的性能和功能。\n浮点运算单元（Floating-Point Unit，FPU）：一种协处理器，专门用于执行浮点数运算，包括浮点加法、减法、乘法和除法等。\n图形处理器（Graphics Processing Unit，GPU）：一种广泛用于图形和并行计算的协处理器，主要用于处理图形和图像相关任务。\n向量处理器（Vector Processor）：一种协处理器，专门用于执行向量运算，例如同时对一组数据进行加法或乘法。\n数字信号处理器（Digital Signal Processor，DSP）：一种专门设计用于执行数字信号处理任务的协处理器，常用于音频和图像处理。\n协同处理器（Coprocessor）：一般指与主处理器协同工作的任何辅助处理器，可以包括浮点运算单元、向量处理器等。\n并行处理（Parallel Processing）：使用多个处理器或协处理器同时执行任务，以提高整体性能。\nSIMD（Single Instruction, Multiple Data）：一种并行处理的架构，其中一条指令同时作用于多个数据元素，通常由向量处理器实现。\nMIMD（Multiple Instruction, Multiple Data）：一种并行处理的架构，其中多个处理器独立执行不同的指令，通常用于多核处理器系统。\n\n协处理器的使用可以显著提高计算机系统的性能，特别是在需要大量浮点运算、图形处理或并行计算的应用中。不同类型的协处理器针对不同的应用领域和任务设计，以满足多样化的计算需求。\n主要类别当涉及到计算机的协处理器时，我们通常指的是一类微处理器，它们执行一些特定的功能，这些功能主处理器（CPU）要么无法执行，要么执行效率不如协处理器高。以下是两个主要类别的协处理器以及它们的专业功能：\n\n数学协处理器（Math Coprocessor）：\n功能（Function）：执行数学运算，特别是涉及浮点数的复杂计算。\nCPU不能执行的任务：浮点运算、科学计算和其他需要高精度数学处理的任务。\n例子（Example）：浮点运算单元（FPU）是一种常见的数学协处理器，负责加速浮点数运算。\n\n\n图形协处理器（Graphics Coprocessor）：\n功能（Function）：处理图形和图像相关的任务，包括渲染和加速图形处理。\nCPU不能执行的任务：3D图形渲染、视频解码和其他图形密集型工作。\n例子（Example）：图形处理器（GPU）是一种广泛应用的图形协处理器，用于加速图形相关计算。\n\n\n\n这些协处理器的存在使得计算机系统能够更高效地执行特定任务，因为它们专门设计用于处理与这些任务相关的计算。协处理器和主处理器之间通过协同工作，共同提高了整体系统的性能，特别是在需要大量数学计算或图形处理的应用中。\n总线总线（Bus）在计算机中是一种用于数据传输的通信系统，它连接了计算机内部的各个组件，如中央处理器（CPU）、内存、输入输出设备等。总线起着数据传输和信息交换的桥梁作用，使得计算机内部各个部分能够协同工作。以下是对计算机总线的详细解释：\n作用\n数据传输： 总线用于在计算机内各个组件之间传输数据，包括指令、数据和控制信息。\n信息交换： 通过总线，不同的硬件组件可以彼此通信，共享信息。这使得中央处理器能够与内存、输入输出设备等进行有效的沟通。\n系统协调： 总线有助于协调系统中不同部分的工作，确保数据的正确流动和处理。\n\n组成总线通常被分为三个主要部分：\n\n数据总线（Data Bus）： 用于传输数据，包括指令和信息。数据总线的宽度决定了每次可以传输的数据位数。\n地址总线（Address Bus）： 用于指定数据的存储位置，即内存地址。地址总线的宽度决定了系统能够寻址的内存空间大小。\n控制总线（Control Bus）： 用于传输控制信号，包括读/写、时钟、中断等控制信息，以及其他与数据传输相关的控制信号。\n\n工作原理\n初始化： 在计算机启动时，总线的初始状态被设定。这包括总线的宽度、时钟频率等。\n通信协议： 计算机系统内的各个组件必须遵循一定的通信协议，以确保正确的数据传输和处理。\n地址识别： 当中央处理器需要读取或写入数据时，它通过地址总线发送目标内存地址。其他组件通过监测地址总线的状态来确定是否是自己的地址。\n数据传输： 中央处理器通过数据总线向内存或其他设备发送数据，或者从中读取数据。控制总线用于传输控制信号，指导数据的读写操作。\n同步和时序： 总线操作需要保持同步，以确保不同组件的操作在正确的时序下进行。时钟信号通常用于同步整个系统。\n\n为什么选择总线？每个硬件单元都连接到这些总线上。这是构建复杂系统的简单方式，其中每个单元都能够与其他单元进行通信。这种设计使得插入新单元和替换故障单元时的干扰很小。\n\n通信： 总线的存在使得各个硬件单元之间能够轻松地进行通信。通过总线，中央处理器可以向内存发送指令，图形处理器可以向显示器发送图像数据，输入设备可以将用户的指令传递给中央处理器，等等。这种通信是系统正常运作的关键。\n系统扩展： 新的硬件单元可以相对容易地添加到系统中，而不会对现有的系统结构产生太大的干扰。这种可扩展性使得计算机系统能够适应不断变化的需求，同时提供更强大的计算能力。\n故障处理： 当硬件单元发生故障时，可以相对容易地将其从总线上断开，并替换为一个正常的单元，而不会对整个系统产生重大的影响。这种模块化的设计有助于系统的可维护性和可靠性。\n\n总的来说，总线的存在提供了一种灵活、可扩展且容错的系统架构，使得计算机能够更有效地处理各种任务，并且更容易适应硬件的变化和故障的修复。这种设计理念在计算机系统的发展中一直是至关重要的。\n总线和点对点连接总线的连接方式\n集中连接： 在总线连接中，所有组件都通过一组共享的导线（总线）连接在一起。这样的设计允许所有组件共享相同的通信通道，简化了连接结构。\n简化通信： 总线允许多个组件通过相同的通信通道传输数据，使得各个组件之间的通信变得简单。但在同一时刻，只有一个组件能够使用总线进行数据传输。\n易于扩展： 添加新组件相对容易，因为它们只需连接到总线上即可。总线连接适用于中小规模系统，例如个人计算机。\n\n点对点的连接方式\n分散连接： 在点对点连接中，每个组件之间都有专门的连接线，即点对点连接。每对组件之间需要一条独立的通信路径。\n复杂的连接结构： 随着系统中组件数量的增加，点对点连接的路径数量呈  的增长，其中  为组件的数量。这导致了复杂的连接结构。\n数据高速公路： 每个点对点连接可能需要一条全宽度的数据高速公路，使得所需的导线数量急剧增加。例如，32位数据线和6条控制线可能会导致大量的导线。\n\n问题\n导线数量增多： 点对点连接的主要问题之一是需要大量的导线。这样的复杂连接结构使得系统设计更为困难，而且可能导致电磁干扰等问题。\n系统复杂度提高： 点对点连接方式对系统的管理和维护提出了更高的要求，因为每次添加新组件都需要建立新的连接。\n\n总线连接的优势\n导线数量较少： 总线连接所需的导线数量远远小于点对点连接。这样的设计降低了系统的复杂性，使得连接更为简单。\n单一数据传输通道： 总线一次只能传输一个数据项，类似于一条铁路线。这样的设计在简单系统中可以工作良好，但对于一些大规模的高性能系统，可能会出现总线瓶颈（Bus Bottleneck）的问题。\n\n总线瓶颈（Bus Bottleneck）的问题\n性能限制： 由于总线一次只能传输有限的数据量，即使提高处理器的速度也不能充分发挥其性能。这被称为总线瓶颈，是总线连接方式的一个局限。\n难以解决： 增加处理器的速度并不能解决总线瓶颈的问题，因为总线仍然是数据传输的瓶颈。为了提高整个系统的性能，可能需要采用其他更先进的互连技术。\n\n点对点连接的劣势\n导线数量增多： 点对点连接需要大量的导线，这使得系统的物理布局和维护变得更加复杂。这也可能导致电磁干扰等问题。\n系统复杂性提高： 点对点连接对系统的管理和维护提出了更高的要求，因为每次添加新组件都需要建立新的连接。\n\n解决方案\n互连技术： 针对总线瓶颈问题，一些先进的互连技术被引入，例如高速总线、点对点互连网络（如光纤通信），以提高系统的整体性能。\n并行计算： 通过引入并行计算，允许多个处理器同时执行任务，从而缓解了总线瓶颈的问题。\n系统设计优化： 在设计系统时，工程师需要权衡总线连接和点对点连接之间的优缺点，选择适当的互连方案，以满足特定的性能和可扩展性需求。\n\n寄存器当涉及到计算机的寄存器时，它们是CPU内部的小型、高速内存块，用于临时存储数据和地址变量。以下是一些常见的CPU寄存器以及它们的主要作用：\n\n指令指针 (Instruction Pointer, IP) 或 程序计数器 (Program Counter, PC)：\n作用：存储下一条要执行的指令的地址。\n每当一条指令被执行，指令指针会自动增加，指向下一条指令的地址，以便顺序执行程序。\n\n\n累加器 (Accumulator) - AX, EAX（在Pentium中）：\n作用：通用数据寄存器，用于存储运算的中间结果或操作数。\n在一些体系结构中，累加器常用于算术运算和逻辑运算。\n\n\n指令寄存器 (Instruction Register, IR)：\n作用：存储当前正在执行的指令。\n指令寄存器中保存了当前被取出并正在执行的指令，CPU根据其中的指令码执行相应的操作。\n\n\n内存地址寄存器 (Memory Address Register, MAR)：\n作用：在总线传输期间，临时存储内存地址。\n当CPU需要读取或写入内存时，内存地址寄存器暂时保存目标内存地址，确保数据被正确地加载到或写入内存中。\n\n\n内存缓冲寄存器 (Memory Buffer Register, MBR)：\n作用：在总线传输期间，临时存储数据。\nMBR保存从内存中读取的数据或将要写入内存的数据，通过总线与内存进行数据传输。\n\n\n\n这些寄存器在指令的执行过程中相互配合，协同工作。指令指针指向下一条要执行的指令，累加器存储运算的中间结果，指令寄存器保存当前执行的指令，而内存地址寄存器和内存缓冲寄存器则协助CPU与主内存进行数据交互。这种协同工作使得CPU能够高效地执行计算机程序。\n指令集计算机与处理器之间的交流是通过机器语言进行的。机器语言是一种特定处理器能够理解的指令集合，这些指令被设计成能够在计算机上直接执行，而无需翻译。机器语言指令集合也被称为指令集体系结构（Instruction Set Architecture, ISA）。\n要点\n机器语言指令集：\n机器语言指令集是一组特定处理器能够理解和执行的指令。\n指令集决定了处理器能够执行的基本操作，例如加法（ADD）、减法（SUB）、递增（INC）、递减（DEC）等。\n\n\n机器语言指令：\n机器语言指令是针对特定CPU设计的二进制代码，表示一条计算机程序中的基本操作。\n这些指令是直接由CPU执行的，无需进一步翻译。\n\n\n不同CPU的指令集：\n不同的处理器架构具有不同的指令集，因此特定的机器语言指令只能在与之兼容的处理器上执行。\n例如，x86架构的指令集与ARM架构的指令集是不同的，因此同一份源代码需要根据目标处理器进行适当的编译。\n\n\n机器码和汇编语言：\n机器语言也被称为机器码，是计算机能够直接执行的二进制形式的指令。\n汇编语言是一种人类可读的低级编程语言，它使用助记符（mnemonics）来表示机器语言指令，提供更容易理解和编写的界面。\n\n\n基本操作：\n机器语言指令集包括各种基本操作，如算术运算（ADD、SUB）、逻辑运算、数据传输、分支跳转等，这些指令充分利用了CPU内部的寄存器和运算单元。\n\n\n\n机器语言为计算机提供了最底层的操作指令，允许程序直接与硬件进行交互。程序员可以使用汇编语言将高级语言编写的程序翻译成对应的机器语言，以便在特定的处理器上执行。机器语言的直接执行使得计算机能够高效地执行各种任务。\n取指令-执行循环（Fetch-Execute Cycle）基本介绍指令是如何执行的基本过程被称为取指令-执行循环（Fetch-Execute Cycle）或机器周期。这是一个循环过程，其中程序中的每一条指令都被执行。该循环包括以下步骤：\n\n取指令（Fetch）：\n在这一阶段，计算机从存储器（通常是主内存）中读取下一条指令。\n指令指针（或程序计数器）存储了当前要执行的指令的地址，该地址被用于访问内存。\n\n\n解码（Decode）：\n一旦指令被取出，CPU会解码它。解码的过程涉及将二进制指令翻译成CPU能够理解和执行的控制信号。\n解码阶段确定了指令的操作类型、操作数的位置以及执行其他与指令相关的必要操作。\n\n\n执行（Execute）：\n在执行阶段，CPU执行指令所指定的操作。这可能包括算术运算、逻辑运算、数据传输等。\n执行阶段还可能影响标志寄存器的状态，例如设置零标志或进位标志，以便在后续的条件分支中使用。\n\n\n回写（Write Back）：\n在某些情况下，执行阶段可能会导致对寄存器或内存的写入操作。这些写入操作在回写阶段完成，将结果存储回寄存器或内存中。\n\n\n重复：\n一旦一条指令的执行完成，指令指针会自动增加，指向下一条要执行的指令的地址。整个过程随后重复，执行下一条指令。\n\n\n\n这个取指令-执行循环是计算机的基本操作方式，它允许计算机按照程序的顺序逐条执行指令。这个循环的速度非常快，以至于在极短的时间内，计算机能够执行数百万条指令。这种高效率是计算机在处理各种任务时的基础。\n具体讲解机器周期（Machine Cycle）是计算机执行指令的基本周期性过程，通常由取指令周期（Fetch Cycle）和执行周期（Execute Cycle）组成。下面详细解释机器周期的两个主要阶段：\n\n取指令周期（Fetch Cycle）：\n取指令阶段（Fetch Instruction）： CPU从存储器（通常是主内存）中读取下一条指令。指令的地址由指令指针（或程序计数器）提供。\n指令译码阶段（Decode Instruction）： 取出的指令被解码成CPU能够理解的控制信号。这个阶段确定指令的操作类型、操作数的位置等。\n更新指令指针阶段： 当取指令阶段完成后，指令指针被更新，指向下一条要执行的指令的地址。\n\n\n执行周期（Execute Cycle）：\n执行阶段（Execute Instruction）： CPU执行指令所指定的操作，包括算术运算、逻辑运算、数据传输等。\n访存阶段（Memory Access）： 在某些指令中，可能需要访问内存，这个阶段用于读取或写入内存中的数据。\n写回阶段（Write Back）： 如果执行阶段导致对寄存器或内存的写入操作，结果将在这个阶段写回寄存器或内存。\n\n\n\n整个机器周期包含取指令周期和执行周期，这两个阶段交替进行。一条指令的执行完成后，CPU将自动开始下一条指令的取指令周期，这种循环不断重复，直到程序执行完毕。\n这里是一个简单的机器周期的示意图：\n\n比方说，如果我要循环计算1到100的和，这个指令的机器周期是如何执行的呢？\n我们先考虑这个循环怎么写，用伪代码先写一下：\nsum = 0\nfor i = 1 to 100\n    sum = sum + i\n\n这个循环的周期示意图如下：\n\n取指令周期在机器周期的“取指令阶段”中，具体步骤可以进一步细化如下：\n\n将指令指针（IP）寄存器中的地址复制到地址总线：\n在“取指令阶段”开始时，计算机将指令指针（IP）寄存器中存储的地址复制到地址总线上。地址总线是连接CPU和内存的通道，它传递指向下一条指令的地址。\n\n\n将地址传递到内存地址寄存器（MAR）：\n通过地址总线，将指令指针（IP）中的地址传递到内存地址寄存器（MAR）。MAR保存了即将被访问的内存地址。\n\n\n递增指令指针（IP）：\n在指令执行完成后，指令指针（IP）被递增，为下一轮机器周期做好准备。这确保了程序的下一条指令将在内存中的正确位置。\n\n\n内存选择并将内容复制到数据总线：\n根据MAR中的地址，内存选择相应的位置，并将该位置的内容复制到数据总线上。数据总线是CPU与内存之间传递数据的通道。\n\n\nCPU将指令代码从数据总线复制到指令寄存器（IR）：\n在数据总线上的内容包含下一条指令的二进制代码。CPU将这些代码复制到指令寄存器（IR）中，以便进一步的解码和执行。\n\n\n开始指令的解码：\n解码阶段开始。指令寄存器（IR）中的二进制代码被解释成CPU能够理解的控制信号。解码确定了指令的操作类型、操作数的位置等，为执行阶段提供了必要的信息。\n\n\n\n在这个过程中，计算机系统通过地址总线和数据总线进行信息的传递，确保指令能够被正确地提取、解码和执行。这个取指令阶段是机器周期的起始点，为计算机执行程序提供了基本的指导。\n执行周期在机器周期的“执行阶段”，实际的执行操作取决于指令的类型。让我们以一条MOV（Move）指令的执行为例，具体包括以下步骤：\n\nIP被复制到地址总线并锁存到内存：\n首先，指令指针（IP）的内容被复制到地址总线上，并通过地址总线传递到内存。这个过程将确保CPU与正确的内存地址通信。\n\n\nIP被递增：\n在这一步骤中，指令指针（IP）被递增，以指向下一条指令的地址。这保证了程序的正常流程，CPU将执行程序中的下一条指令。\n\n\n从内存中选取的值被复制到数据总线：\n根据经过递增后的IP的地址，内存选择相应的位置，将该位置的内容复制到数据总线上。数据总线是CPU与内存之间传递数据的通道。\n\n\nCPU将数据总线上的值复制到AX寄存器：\n在这个阶段，CPU将数据总线上的内容复制到AX寄存器中。在这个例子中，指令是MOV AX, 256，所以从内存中读取的值（256）将被加载到AX寄存器中。\n\n\n\n总体而言，执行阶段的步骤取决于具体的指令。不同的指令会涉及不同的操作，可能包括内存读写、寄存器操作、算术运算等。这里的例子是MOV指令，它主要用于将一个值从一个地方移动到另一个地方。在执行阶段，CPU根据指令的需求从内存中读取数据，并将其传输到寄存器中。\nCISC &amp; RISCCISC（Complex Instruction Set Computing）和RISC（Reduced Instruction Set Computing）是两种不同的计算机体系结构设计理念，它们在指令集的设计和执行方式上有着显著的区别。\n介绍CISCCISC（复杂指令集计算）:\n\n特点： CISC架构的特点是指令集非常丰富且复杂，一条指令可以执行多个低级操作，甚至包括复杂的内存访问模式。指令长度通常变化，有些指令可能需要多个时钟周期才能执行完成。\n应用： CISC架构主要应用在大型主机和个人计算机（PC）等系统上，如x86架构。\n优点： 单条指令可以执行多个操作，有助于提高程序的紧凑性。\n缺点： 复杂的指令集会导致硬件更复杂，难以达到高性能。指令的复杂性可能导致较长的时钟周期。\n\nRISCRISC（精简指令集计算）:\n\n特点： RISC架构的特点是指令集相对简单，每条指令只执行一个基本的操作，指令长度通常是固定的，而且执行速度相对较快。\n应用： RISC架构主要应用在嵌入式系统和一些高性能计算机上，如ARM和MIPS架构。\n优点： 简化的指令集有助于简化处理器的硬件设计，提高执行效率，使处理器更容易实现流水线和乱序执行等技术。\n缺点： 由于每个指令执行的操作较为简单，某些情况下可能需要更多的指令来完成复杂的任务。\n\n比较\nCISC vs. RISC： CISC处理器通常有更多的指令，每条指令执行的工作更复杂，而RISC处理器则倾向于简化指令集，每条指令执行的工作更单一。\n性能： 在相同的时钟频率下，RISC处理器通常能够提供更高的性能，因为简化的指令集有助于更好地利用流水线和其他硬件优化。\n成本： RISC处理器的硬件相对较简单，制造成本可能更低，但CISC处理器的广泛应用使得它们在市场上仍然存在。\n\n组织方式RISC（精简指令集计算）\n在RISC架构中，一条指令通常由一个字（word）表示，字的长度是固定的。这种设计使得指令的解析和执行相对简单，因为每条指令的长度都是已知的，不需要额外的解析步骤。\nRISC指令通常相对简单，执行一个基本操作，如加载寄存器、执行算术运算等。因此，每条指令的长度都趋向于保持一致，这有助于设计更加流水线化和高效的执行单元。\n\nCISC（复杂指令集计算）\n在CISC架构中，一条指令可能由多个字组成，长度可能是可变的。CISC指令可能包含多个操作，甚至可能包括复杂的内存寻址模式。这种多字节的指令需要多次取指令操作才能完全获取，并且在解析和执行上可能更加复杂。\nCISC指令的长度和复杂性可以使得在处理器中解析和执行指令变得更为复杂，因为指令的长度和格式可能是不确定的。\n\n比较\n在RISC中，指令的固定长度和简单性使得指令的解析和执行相对更加高效和直接。\n在CISC中，由于指令的复杂性和可变长度，可能需要更多的时钟周期来解析和执行指令，因为一条指令的多个字可能需要多个时钟周期才能完全获取。\n\n总体而言，这个差异体现了RISC的设计原则，即保持指令简单和固定长度，以便在执行过程中更好地利用流水线和其他硬件优化。而CISC则追求提供更丰富和功能强大的指令集，以便用更少的指令完成更多的工作，但这可能会引入一些复杂性。选择CISC或RISC架构通常取决于特定应用的需求以及对性能和成本的权衡。\n\n\n\n\n\n\n\n\n\nRISC（精简指令集计算）被认为更快的原因主要有以下几点：\n\n空出的芯片区域用于加速常用指令的性能：\n\n\n在RISC架构中，由于指令较为简单，每条指令的长度相对较短，因此在芯片上会留下一些空闲的区域。这些空闲区域可以被用来集中优化对性能影响较大的常用指令。例如，这些区域可以用于增加缓存大小，提高指令和数据的访问速度，或者用于实现更高级的流水线技术，以加速指令的执行。\n\n\n更容易优化设计：\n\n\nRISC架构的指令集相对简单，这使得处理器的硬件设计更容易进行优化。设计人员可以专注于提高执行单元的效率、增加流水线阶段、实现更高级的超标量或乱序执行等技术，而无需过多考虑复杂指令集所带来的复杂性。\n\n\n更容易从高级语言翻译成小型指令集：\n\n\nRISC架构的指令集通常更接近高级编程语言的结构，这使得从高级语言翻译成硬件可执行的指令更为简单。简化的指令集有助于编译器生成更高效、更紧凑的机器代码，减少了编译器的复杂性。这样的优势在编译过程中能够更有效地使用硬件资源，生成更优化的程序。\n\n","slug":"CPT101-Review-7","date":"2024-01-07T06:15:23.000Z","categories_index":"","tags_index":"CPT101复习,笔记","author_index":"General_K1ng"},{"id":"19c587a1fa2f0478e7eecddf0c905e63","title":"CPT101 Review-6","content":"操作系统（Operating Systems）什么是操作系统？操作系统（Operating System，简称OS）是管理计算机硬件和软件资源的系统软件。它提供了一个用户和计算机硬件之间的接口，使得应用程序可以运行并与计算机硬件交互。\n操作系统的发展流程发展流程\nOS/360 for IBM System/360 (1960s):\nIBM System/360是IBM推出的一系列主机计算机。\nOS/360是为System/360设计的操作系统，标志着主机系统操作系统的发展。\n\n\nUnix (1970s):\nUnix是由贝尔实验室的Ken Thompson、Dennis Ritchie等人开发的多用户、多任务操作系统。\nUnix的设计理念影响了许多后来的操作系统。\n\n\nMS-DOS for IBM PC and Mac OS for Apple Macintosh (1980s):\nMS-DOS是微软为IBM个人计算机开发的操作系统。\nMac OS是苹果Macintosh计算机的操作系统。\n\n\nWindows 95, 98, NT (1990s):\nWindows 95和98是微软推出的桌面操作系统，具有图形用户界面。\nWindows NT是微软推出的面向企业的操作系统，后来成为Microsoft桌面操作系统的基础。\n\n\nMac OS X (2001):\nApple于2001年发布的Mac OS X是基于Unix内核的重新构建的操作系统，融合了苹果的用户界面设计。\n\n\nLinux, BSD Unix:\nLinux是一个开源的Unix-like操作系统内核，广泛应用于服务器和嵌入式系统。\nBSD Unix是Berkeley Software Distribution的一系列Unix操作系统的衍生。\n\n\n\n窗口界面操作系统经历了40多年的演进，“…但令人惊讶的是，在技术核心方面变化并不大，只有窗口界面的引入真正使其与过去不同。” \n\n技术核心相对稳定：\n操作系统的技术核心，即内核，负责管理硬件和提供基本服务。这一部分确实相对稳定，因为它需要满足基本的计算和资源管理需求。\n\n\n窗口界面的引入：\n引入窗口界面是操作系统演进的一个显著变化。窗口界面使得用户可以更直观地与计算机交互，提高了用户友好性。\n\n\n持续的稳定性需求：\n计算机系统对稳定性和可靠性有着极高的要求。任何操作系统的更新和演进都需要在保持核心稳定性的同时引入新功能。\n\n\n软件兼容性：\n由于大量软件和应用程序依赖于操作系统，为了确保向后兼容性，操作系统的变化可能会受到限制，以保持对旧版软件的支持。\n\n\n工业标准的影响：\n某些操作系统可能成为特定领域或工业的标准，限制了其在技术方面的大规模变革，以避免对生态系统的不稳定影响。\n\n\n\n重要名词和英语单词\nDesktop Operating System: 桌面操作系统，用于个人计算机的操作系统。\nUnix Core: Unix内核，操作系统的核心部分，提供基本的系统功能。\nGraphical User Interface (GUI): 图形用户界面，通过图形元素（如图标、按钮）而不是命令行来与用户交互。\nOpen Source: 开源，指软件的源代码是公开可用的，用户可以查看、修改和分享。\n\n操作系统的功能操作系统有多个关键功能，其中之一是解释和执行由以下两类实体发出的命令：\n\n用户：\n操作系统作为用户与计算机交互的接口，接收和执行用户发出的各种命令。这包括通过命令行、图形用户界面（GUI）或其他交互方式输入的指令。\n\n\n应用程序：\n操作系统负责解释和执行由正在运行的应用程序发出的命令。应用程序通过操作系统与硬件和其他系统资源进行交互，以完成特定的任务。\n\n\n\n用户命令的解释和执行\n命令解释：\n操作系统负责解释用户发出的命令。这可能涉及到语法分析和命令解码，以确保操作系统正确理解用户的要求。\n\n\n命令执行：\n一旦命令被解释，操作系统会采取相应的行动。这可能包括分配资源、调度任务、管理文件系统、处理输入输出等。\n\n\n\n应用程序命令的解释和执行\n应用程序接口（API）：\n操作系统提供应用程序接口，允许应用程序通过特定的接口与操作系统通信。这使得应用程序能够请求操作系统执行各种操作。\n\n\n资源管理：\n操作系统负责为应用程序分配和管理系统资源，例如内存、处理器时间、文件系统空间等。这确保了多个应用程序能够共享计算机资源。\n\n\n\n操作系统的目的基本目的操作系统有两个基本目的，分别是管理和提供功能：\n管理\n有效控制和操作硬件：\n操作系统通过管理硬件资源，如中央处理器、内存、硬盘等，以确保它们被有效地分配和使用。这有助于提高计算机的整体性能和效率。\n\n\n\n提供功能\n为用户提供功能：\n高效访问计算机设备：\n操作系统旨在提供用户对计算机设备的高效访问，无论是通过命令行还是图形用户界面。这确保了用户可以轻松地与计算机交互，执行各种任务。\n\n\n公平访问计算机设备：\n操作系统致力于确保所有用户对计算机设备的访问是公平的，避免某个用户或应用程序占用过多资源，导致其他用户受影响。\n\n\n受保护的访问计算机设备：\n操作系统提供了安全机制，以确保用户的访问是受保护的。这包括对文件和系统资源的权限管理，以防止未经授权的访问。\n\n\n与用户的交互：\n操作系统作为用户与计算机之间的接口，促使用户能够通过命令或图形界面与计算机进行交互。这包括提供反馈、错误提示等。\n\n\n\n\n\n洋葱环模型（Onion Ring Model）实现操作系统目的的洋葱环模型为了实现操作系统的目的，操作系统软件通常被组织成多个层次，这就是所谓的“洋葱环模型”。\n为什么需要多个层次？\n抽象与模块化：\n多层次结构允许将操作系统功能划分为各个抽象层次和模块，使得系统更容易理解和维护。每个层次提供特定的功能，同时隐藏底层细节。\n\n\n简化系统设计和维护：\n分层的结构使得系统的设计更加模块化，可以更容易地进行修改、更新或扩展某个特定层次，而无需影响整个系统。\n\n\n提高系统的可扩展性：\n多层次结构使得系统更易于扩展。新功能或改进可以被添加到适当的层次，而不会对整个系统产生过多的影响。\n\n\n实现清晰的接口：\n每个层次都定义了与其他层次的明确接口，通过这些接口，层次之间的通信和协作变得更加清晰和可管理。\n\n\n提高系统的可维护性：\n多层次结构降低了系统的复杂性，使得在不同层次上进行调试、测试和维护更加容易。每个层次可以独立地进行测试，而无需考虑整个系统的复杂性。\n\n\n支持分布式开发：\n不同的团队可以专注于开发和维护特定层次，而无需过多关注其他层次的细节。这种分布式开发模型有助于提高开发效率。\n\n\n\n洋葱环模型的层次结构典型的洋葱环模型包括多个层次，例如：\n\n用户接口层\nShell层\n系统调用层\n进程管理层\n文件系统层\n硬件抽象层\n\n每个层次负责不同的功能，通过定义清晰的接口使得它们能够有效地协同工作，从而实现了操作系统的各种目的。\n操作系统作为计算机的门卫（Gatekeeper）\n计算机的使用者入口：\n操作系统充当计算机的门卫，用户通过它与计算机进行交互。用户通过命令行、图形用户界面或其他方式向操作系统发出命令，然后由操作系统翻译和执行这些命令。\n\n\n安全性与权限控制：\n操作系统负责确保计算机系统的安全性，通过实施权限控制和身份验证机制，防止未经授权的访问。这使得操作系统成为计算机系统的保护门卫。\n\n\n\n操作系统作为计算机的管家（Butler）\n整体效率的决定者：\n操作系统在很大程度上决定了计算机的整体效率。通过有效的硬件资源管理、任务调度和性能优化，操作系统确保计算机系统以最佳方式运行。\n\n\n资源的分配和协调：\n作为管家，操作系统负责资源的分配和协调。它决定哪个程序在什么时候运行，如何分配内存、处理器时间和其他关键资源，以保持系统的平衡。\n\n\n问题解决和服务提供：\n操作系统作为管家解决了许多与硬件和软件交互相关的问题。它提供了各种服务，包括文件管理、网络连接、设备驱动程序等，以便用户和应用程序能够无缝地使用计算机。\n\n\n用户体验的改善：\n通过提供友好的用户界面和有效的资源管理，操作系统有助于提高用户体验。这包括快速响应用户请求、最小化等待时间和提供直观的界面。\n\n\n\n操作系统的综合作用通过充当门卫和管家，操作系统不仅提供了计算机系统的安全性和保护，还确保了计算机系统的整体效率和用户体验。这两个角色共同构成了操作系统在计算机生态系统中的核心位置，为用户和应用程序提供了可靠的计算环境。\n![Onion Ring Model](https://cdn.jsdelivr.net/gh/GeneralK1ng/My_Blog_IMG@main/img/Onion Ring Model.png)\n操作系统核心：直接处理硬件\n核心概念：\n操作系统的核心是直接与硬件交互的部分，通常被称为内核（Kernel）。\n\n\n内核功能：\n内核包含处理硬件的关键功能，例如设备驱动程序、内存分配器等。\n\n\n设备驱动程序：\n内核中的设备驱动程序允许操作系统与计算机硬件进行通信。这包括对处理器、存储设备、网络接口等的控制。\n\n\n内存分配器：\n内核负责有效地管理计算机的内存。它分配内存给运行的程序，并在程序结束时回收这些资源。\n\n\n\n命令行界面（CLI）：为用户提供系统可访问性\nCLI概念：\n命令行界面是操作系统提供给用户的一种交互方式，用户通过在命令行中输入文本命令与系统进行通信。\n\n\n用户可访问性：\nCLI提供了一种灵活而强大的方式，使用户能够直接与操作系统交互。用户可以通过命令行执行各种任务，如文件管理、进程控制等。\n\n\n自动化和脚本：\nCLI允许用户编写脚本自动执行一系列命令，提高了效率和一致性。\n\n\n系统管理员工具：\n对于系统管理员和高级用户而言，CLI是管理系统的强大工具。它提供了对系统深层次设置和配置的直接访问。\n\n\n\n洋葱环模型的层次结构再思考\n内核和CLI的位置：\n操作系统的洋葱环模型中，内核通常位于最底层，直接与硬件交互。CLI位于用户接口层次，为用户提供了直接的系统访问。\n\n\n用户与硬件的中间层次：\n在内核和CLI之间，可能还存在其他层次，如系统调用、进程管理、文件系统等。这些层次共同形成了洋葱环的结构，每个层次都有其特定的功能和作用。\n\n\n\n现代操作系统并行处理多个程序\nDOS：\nDOS（磁盘操作系统）是早期个人计算机上使用的操作系统之一。在DOS中，一次只能运行一个程序，要运行第二个程序，必须等待当前程序完成。这样的单任务操作系统在效率上存在一些限制。\n后台处理（Background Spooling）：\nDOS引入了后台处理，提供了最小程度的并发性。例如，可以在后台进行打印作业，而用户可以在此期间进行其他任务。\n\n\n\n\nWindows、Unix和Linux：\n在现代操作系统中，如Windows、Unix和Linux，实现了更高程度的并发性和多任务处理。\n多任务处理（Multi-tasking）：\n现代操作系统支持多任务处理，允许多个程序同时运行。这使得用户可以在不同的应用程序之间切换，而不必等待一个程序完成。\n\n\n多用户支持（Multi-user）：\n现代操作系统还支持多用户，允许多个用户同时访问计算机系统。每个用户都有自己的用户环境和资源。\n\n\n\n\n\n并行和分时系统的效率对比\nDOS的效率：\nDOS的单任务模型可能导致效率低下，因为用户必须等待一个程序完成才能执行下一个。\n\n\n现代操作系统的效率：\nWindows、Unix和Linux等现代操作系统通过多任务处理提高了效率。多个程序可以同时运行，允许用户更充分地利用计算机资源。\n\n\n多任务处理的好处：\n提高了系统的响应速度，允许用户同时运行多个应用程序，提高了计算机的整体效率。\n\n\n\n与操作系统的交互命令行解释器（CLI）\nDOS：\n在DOS中，用户通过在命令行中键入命令与操作系统进行交互。例如，用户可以键入命令来运行程序、管理文件等。\n\n\nUnix/Linux：\nUnix和Linux系统使用Shell脚本，这是一系列指令的脚本文件。用户可以通过在终端中输入命令来执行这些脚本，实现各种系统和应用程序的操作。\n\n\nWindows/Mac OS X：\n在Windows和Mac OS X中，用户通常通过使用鼠标点击图标来与操作系统进行交互。这种图形用户界面（GUI）提供了直观的可视化方式，用户可以通过图形元素进行操作。\n\n\n\n用户程序内的函数调用（API）\nAPI（应用程序接口）：\n\n用户程序可以通过API与操作系统进行交互。API是一组允许应用程序与操作系统进行通信的函数和工具。\n\n\n示例：C代码段：\n#include &lt;stdio.h&gt;\n...\nvoid main() {\n    printf(\"Hello world!\");\n}\n\n在这个例子中，printf 是C语言的一个标准库函数，它通过API调用操作系统的输出功能来显示 “Hello world!”。\n\n\n交互方式的选择\n命令行 vs. 图形界面：\n命令行提供了更灵活的方式，适用于对命令和脚本熟悉的用户，而图形界面提供了更直观和用户友好的交互方式，适用于不熟悉命令的用户。\n\n\nAPI调用：\n通过API调用，用户程序可以直接与操作系统交互，执行各种操作，如文件管理、内存分配等。\n\n\n\n用户与操作系统的交互示例\n命令行交互：\n用户在终端中输入命令，例如 ls（在Unix/Linux中列出文件和目录）。\n\n\n图形界面交互：\n用户在文件管理器中使用鼠标点击图标，例如双击文件以打开它。\n\n\nAPI调用：\n用户程序通过API调用，如上述的C代码段，与操作系统进行通信，执行特定的功能。\n\n\n\n这些不同的交互方式为用户提供了多样性的选择，以适应他们的技能水平和工作需求。\n示例考虑你正在进行Java练习的情境：\n编写Java程序：\n\n你编写了一个Java程序，假设文件名为 MyProc.java。\n\n编译Java程序：\n\n为了将Java源代码转换为可执行的字节码，你需要运行Java编译器（javac）。\n\n在命令行中输入命令：\n\n你在命令行中键入以下命令并按回车键：\njavac MyProc.java\n\n命令解释和执行：\n\n操作系统的命令行解释器（或Shell）解释并执行你键入的命令。在这种情况下，它启动了Java编译器（javac）。\n\nJava编译器执行：\n\nJava编译器（javac）接收到你的命令并开始编译 MyProc.java 文件。它检查代码的语法和语义，生成对应的字节码文件（.class 文件）。\n\n输出结果：\n\n如果没有编译错误，你将在屏幕上看到一些编译过程的输出，告诉你编译是否成功。如果有错误，它将指示错误的位置和类型。\n\n运行Java程序：\n\n一旦成功编译，你可以运行Java程序。在命令行中键入以下命令并按回车键：\njava MyProc\n\n这将启动Java虚拟机（JVM），执行编译后的字节码文件。\n\n\n结果：\n\n如果程序执行无误，你将在屏幕上看到Java程序的输出结果。\n\n观察：\n\njavac 是一个需要执行的程序。\n任何程序在执行之前都应该存在于主存（RAM）中。\n因此，javac 需要从磁盘加载到主存中，然后才能被执行。\n\n问题：由谁或什么来完成这个任务？\n\n回答：操作系统。\n\n在上述例子中，当你输入 javac MyProc.java 时，javac 这个程序的可执行文件（二进制文件）必须从硬盘加载到计算机的主内存中，然后由操作系统负责执行。\n加载过程：\n\n加载到内存：\n操作系统负责将 javac 的二进制文件从硬盘加载到主存中，通常会将其放入可执行文件的部分。\n\n\n执行程序：\n一旦加载完成，操作系统将启动 javac，开始执行它。这涉及操作系统对程序计数器和其他寄存器的设置，以及为程序提供必要的资源。\n\n\n程序执行：\njavac 开始执行，它会读取并处理 MyProc.java 文件，并执行编译操作。整个过程在主内存中进行。\n\n\n\n另一个Linux示例在Linux中，当你键入 ls 命令并按回车键时，该命令将列出当前目录中的文件，类似于DOS中的 dir 命令。\n用户输入命令：\n\n你在终端中键入以下命令并按回车键：\nls\n\n命令解释和执行：\n\n操作系统的命令行解释器（Shell）解释并执行你键入的命令。在这种情况下，它启动了 ls 程序。\n\nls程序的运行：\n\n当 ls 程序运行时，它需要获取当前目录中文件的信息以进行显示。\n\n信息来源：\n\n问题：是谁或什么提供了这些文件信息？\n回答：操作系统。ls 程序通过向适当的系统程序发出请求，从而获取文件信息。\n\n操作过程：\n\n当 ls 程序运行并需要列出当前目录中的文件时，它不会直接访问硬盘或文件系统。相反，它通过系统调用向操作系统请求有关文件的信息。\n操作系统的文件系统管理模块（File System Manager）负责处理这些请求。它提供了对文件系统的访问，并返回 ls 程序所需的文件信息。\n\n操作系统操作的复杂性示例：接受用户命令的复杂操作\n为了接受用户的命令，操作系统必须执行以下一系列复杂的操作：\n\n接收键盘输入：\n从键盘接收输入的按键。\n\n\n解释输入命令：\n将输入的按键解释为一个有效的命令。\n\n\n确定程序文件的位置：\n确定与该命令相关的程序文件的位置。\n\n\n从存储设备中读取文件块：\n从辅助存储设备（如硬盘）中读取程序文件的适当块到主内存。\n\n\n为程序设置上下文：\n设置程序执行所需的上下文，包括程序的初始状态、环境等。\n\n\n转移控制给执行的程序：\n将控制传递给将要执行的程序。\n\n\n在程序完成后恢复控制：\n当程序执行完成后，恢复控制给操作系统。\n\n\n\n每个步骤的说明：\n\n接收键盘输入：\n操作系统需要检测和接收来自键盘的输入，这可能涉及到中断处理等机制。\n\n\n解释输入命令：\n操作系统需要识别并解释用户输入的命令，以便知道如何处理接下来的步骤。\n\n\n确定程序文件的位置：\n操作系统需要确定与用户输入的命令相关联的程序文件在存储设备上的位置。\n\n\n从存储设备中读取文件块：\n操作系统必须从硬盘等辅助存储设备中读取程序文件的相应块，将其加载到主内存中。\n\n\n为程序设置上下文：\n操作系统需要设置程序执行所需的初始状态和环境，以便程序正确运行。\n\n\n转移控制给执行的程序：\n操作系统将控制传递给将要执行的程序，使得程序可以开始运行。\n\n\n在程序完成后恢复控制：\n操作系统需要在程序执行完成后，恢复对系统的控制，可能包括释放资源、更新系统状态等。\n\n\n\n操作系统复杂性的原因：\n\n操作系统执行许多涉及底层硬件和高层软件抽象的任务，这些任务需要有效地协调和管理系统资源，以便为用户和应用程序提供一致且可靠的计算环境。\n\n如果多个程序同时执行，操作系统必须包括以下内容：\n\n分配内存和其他资源的程序（内存管理器）：\n为每个程序分配必要的内存和其他系统资源，确保它们之间不会发生冲突。\n\n\n为每个程序分配CPU时间的程序（调度器）：\n协调和分配CPU时间，确保每个程序都有机会执行，并避免系统资源的浪费。\n\n\n维护每个程序的完整性的程序（安全内核）：\n确保每个程序在执行过程中保持数据和系统的完整性，防止非法访问和破坏。\n\n\n其他任务：\n还有许多其他任务，例如文件管理、网络管理、设备驱动程序等，这些都是由操作系统协调和管理的。\n\n\n\n操作系统处理任务的复杂性：\n\n以上只是操作系统执行的一小部分任务的示例。操作系统需要处理各种复杂的任务，以提供高效、可靠和安全的计算环境。\n内存管理、进程调度、安全性等：\n操作系统需要有效地分配和管理内存，调度程序执行的进程，并保障系统的安全性。\n\n\n文件管理、网络管理等：\n同时，操作系统还负责文件系统的管理、网络连接的维护、设备驱动程序的加载等任务。\n\n\n多任务、多用户支持：\n如果操作系统支持多任务和多用户，它必须更加复杂，以便同时处理多个用户和程序的需求。\n\n\n\n\n计算机网络计算机网络的影响或许是对冯·诺依曼原始蓝图产生最深远变革的领域。\n\n变革的内容：\n计算机网络引入了一系列对冯·诺依曼计算机原始蓝图的变革。\n\n\n操作系统与网络的关系：\n操作系统通常提供对网络设施的访问，通过网络API（例如套接字接口）使计算机可以连接到网络。\n\n\n计算机网络的定义：\n计算机网络是相互连接的、自治的计算机集合，旨在促进快速的信息交换。\n\n\n\n操作系统与计算机网络的关联：\n\n网络API的提供：\n操作系统通过提供网络API（Application Programming Interface）的方式，允许应用程序与网络进行交互。套接字接口是其中常见的一个例子。\n\n\n资源共享与通信：\n计算机网络提供了资源共享的机会，允许计算机之间进行通信和协作。操作系统在这个过程中起到协调和管理的作用。\n\n\n分布式计算：\n计算机网络使得分布式计算成为可能，多台计算机可以合作完成复杂的任务。操作系统需要处理分布式环境下的任务分配、通信、同步等问题。\n\n\n远程访问：\n通过计算机网络，用户可以远程访问其他计算机上的资源。操作系统需要提供远程访问的支持，并确保安全性和可靠性。\n\n\n\n网络的影响：\n\n计算机网络的引入改变了计算机系统的性质，从单一孤立的系统转变为相互连接的系统集合。这种变革对操作系统的功能和设计产生了深远的影响，使其适应了分布式、协同工作的新环境。\n\n为什么要使用计算机网络？增加计算能力：\n\n分布式计算项目：\n通过计算机网络，可以将多个计算机连接在一起，形成分布式计算系统。分布式计算项目如SETI@home和Folding@home利用网络上的多台计算机协同工作，以增加计算能力来解决复杂的科学问题。\n\n\n\n共享宝贵资源：\n\n打印机、大容量磁盘等资源的共享：\n计算机网络允许多个计算机共享重要的资源，如打印机、大容量磁盘、程序和数据库等。例如，在XJTLU有一个中央打印系统和一个中央文件系统，为整个学校提供了共享服务。\n\n\n\n方便用户之间的交互：\n\n方便用户在不同位置工作时的交互：\n计算机网络为用户提供了方便的交互方式，使得用户可以在不同位置的个人计算机上协同工作。这在在线游戏等应用中尤其显著。\n\n\n\n信息触手可及：\n\n信息随时可得：\n计算机网络使得信息变得更加容易获得。用户可以通过网络随时随地获取所需的信息，这使得信息更加容易传播和分享。\n\n\n\n通过计算机网络，我们不仅能够提高计算能力、共享宝贵资源，还能够方便地协同工作和获取信息。这为用户提供了更灵活和高效的计算环境。\n客户端-服务端计算介绍客户端： 发起请求的一方。\n服务器： 提供服务的一方。\n在客户端-服务器计算中，通常有两个主要角色：客户端和服务器。\n客户端：\n\n客户端是发起请求的一方。它通常是用户使用的终端设备，例如个人电脑、智能手机或平板电脑。客户端负责发出请求并处理从服务器返回的响应。\n\n服务器：\n\n服务器是提供服务的一方。它是一台或多台计算机，运行着特定的服务或应用程序，以响应来自客户端的请求。服务器的目标是满足客户端的需求，提供所请求的服务或资源。\n\n客户端-服务器模型的工作流程：\n\n客户端发起请求：\n客户端向服务器发出请求，请求特定的服务或资源。\n\n\n服务器处理请求：\n服务器接收到客户端的请求后，会执行相应的服务或检索所需的资源。\n\n\n服务器返回响应：\n服务器将处理结果或所请求的资源返回给客户端。\n\n\n客户端处理响应：\n客户端接收到服务器的响应后，进行相应的处理，可能是显示内容、执行操作，或者其他交互。\n\n\n\n客户端-服务器模型的优势：\n\n分布式计算：\n客户端和服务器可以分布在不同的地理位置，实现分布式计算。\n\n\n资源共享：\n通过客户端-服务器模型，可以实现资源的有效共享，客户端通过请求服务器来获取所需的服务或资源。\n\n\n可伸缩性：\n可以根据需要增加或减少服务器，以应对不同规模的请求。\n\n\n\n客户端-服务器计算模型是一种广泛应用的架构，它在分布式系统、互联网和各种应用程序中发挥着关键作用。\n客户端-服务器交互在客户端-服务器模型中，交互通常遵循以下步骤：\n\n客户端发起请求：\n客户端通过向服务器发送请求消息来开始交互。请求消息通常包含客户端需要的服务或资源的详细信息。\n\n\n服务器响应：\n服务器接收到客户端的请求后，会进行相应的处理，并向客户端发送响应消息。响应消息包含请求的结果、所请求的资源，或其他必要的信息。\n\n\n客户端处理响应：\n客户端接收到服务器的响应后，会根据响应中的信息进行相应的处理。这可能包括显示内容、执行操作，或者触发其他交互。\n\n\n\nWeb浏览器中的示例：\n\n当你从远程站点打开网页时，可以通过查看浏览器的状态栏了解客户端-服务器交互的情况。\n\n状态栏显示：\n\n在浏览器的状态栏中，你可以看到加载网页的过程，其中可能包括以下信息：\n连接建立： 浏览器与服务器建立连接的过程。\n请求发送： 浏览器向服务器发送请求的阶段。\n响应接收： 浏览器接收服务器的响应的阶段。\n加载完成： 网页加载完成，可以查看或与之交互。\n\n\n\n通过观察这些状态，你可以了解客户端与服务器之间的交互过程，以及网页加载的不同阶段。这种交互模型是许多网络应用程序背后的基础，例如Web浏览器、电子邮件客户端等。\n\n在这个示例中，我们模拟了一个完整的客户端-服务器交互过程，包括前端和后端的角色，以及与数据库的交互。下面是每个步骤的详细说明：\n\n打开浏览器：\n客户端打开浏览器，访问网页。\n\n\n请求前端资源：\n浏览器向服务器请求前端资源，如index.html、script.js、style.css等。\n\n\n请求后端数据：\n前端在加载完成后，向后端发送请求，请求后端数据。这可能是通过AJAX请求或其他方式。\n\n\n查询数据库：\n后端接收到请求后，执行数据库查询操作，例如从数据库中选择所有数据。\n\n\n返回数据库数据：\n数据库返回查询结果给后端。\n\n\n返回后端数据：\n后端将从数据库获取的数据封装在响应中，返回给前端。\n\n\n返回前端资源和数据：\n前端收到后端响应后，同时也获取到了请求的前端资源和后端数据。\n\n\n渲染网页：\n浏览器使用获取到的前端资源和后端数据，渲染最终的网页。\n\n\n\n","slug":"CPT101-Review-6","date":"2024-01-05T14:42:31.000Z","categories_index":"","tags_index":"CPT101复习,笔记","author_index":"General_K1ng"},{"id":"a352c287ad7a743761ffe31d8c5cee8c","title":"Crash Course For CPT107-3","content":"高中都学过简单逻辑吧，这里跟那一套一模一样，然后多背一点东西，做题嘎嘎顺。\n各种符号\n逻辑连接词（Logical Connectives）：\n合取（Conjunction）： ∧\n解释：表示逻辑与（AND），当且仅当所有连接的命题都为真时，合取命题为真。\n\n\n析取（Disjunction）： ∨\n解释：表示逻辑或（OR），只要连接的命题中至少有一个为真，析取命题就为真。\n\n\n非（Negation）： ¬\n解释：表示逻辑非（NOT），对连接的命题取反。\n\n\n条件（Implication）： →\n解释：表示如果…那么…，当且仅当前件为假或者后件为真时，条件命题为真。\n\n\n双条件（Biconditional）： ↔\n解释：表示当且仅当，连接的两个命题同时为真或同时为假时，双条件命题为真。\n\n\n\n\n量词（Quantifiers）：\n全称量词（Universal Quantifier）： ∀\n解释：表示对所有的，用来表达一个命题对于集合中的每个元素都成立。\n\n\n存在量词（Existential Quantifier）： ∃\n解释：表示存在，用来表达集合中存在一个元素使得命题成立。\n\n\n\n\n等于和不等于：\n等于： =\n解释：表示相等。\n\n\n不等于： ≠\n解释：表示不相等。\n\n\n\n\n括号：\n圆括号： ( )\n解释：用于改变运算的优先级，明确表达式的结构。\n\n\n方括号： [ ]\n解释：通常用于表示集合。\n\n\n花括号： { }\n解释：通常用于表示集合或者集合的扩展。\n\n\n\n\n集合运算符：\n并集（Union）： ∪\n解释：表示集合的并，包含两个集合中的所有元素。\n\n\n交集（Intersection）： ∩\n解释：表示集合的交，包含同时属于两个集合的所有元素。\n\n\n补集（Complement）： ‘\n解释：表示集合的补，包含不属于给定集合的所有元素。\n\n\n子集（Subset）： ⊆\n解释：表示一个集合是另一个集合的子集或者相等。\n\n\n真子集（Proper Subset）： ⊂\n解释：表示一个集合是另一个集合的子集，但并非相等。\n\n\n\n\n谓词逻辑符号：\n谓词（Predicate）： P(x)\n解释：表示一个参数的命题函数，其中 x 是变量。\n\n\n全称限定符（Universal Quantifier）： ∀x P(x)\n解释：表示对于所有 x，谓词 P(x) 都成立。\n\n\n存在限定符（Existential Quantifier）： ∃x P(x)\n解释：表示存在某个 x，使得谓词 P(x) 成立。\n\n\n等价于： ≡\n解释：表示两个命题在逻辑上是等价的。\n\n\n推导： ⊢\n解释：表示逻辑推导。\n\n\n\n\n\n给爷背背析取  不是 00 就是 1，合取  不是11 就是 0 \n 只要不是 10 就是 1 \n 只要不是 11 和 00 就是 0\n值为 1 的那排叫成真赋值（小项），用小写  加二进制下标，用析取连起来（1 为真，0 为假）\n值为 0 的那排叫成假赋值（大项），用大写  加二进制下标，用合取连起来（0 为真，1 为假）\n解释\n非（Negation）： \n\n解释：表达式  在逻辑上表示，如果 A 为真，则  为假；如果 A 为假，则  为真。\n\n真值表：\n\n\n\nA\n\n\n\n\n0\n1\n\n\n1\n0\n\n\n\n\n\n析取（Disjunction）： \n\n解释：表达式  在逻辑上表示，如果至少有一个命题为真，则整个表达式为真。\n\n真值表：\n\n\n\nA\nB\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n1\n\n\n\n小项（真赋值）：，，，\n\n\n\n合取（Conjunction）： \n\n解释：表达式  在逻辑上表示，只有当两个命题同时为真时，整个表达式为真。\n\n真值表：\n\n\n\nA\nB\n\n\n\n\n0\n0\n0\n\n\n0\n1\n0\n\n\n1\n0\n0\n\n\n1\n1\n1\n\n\n\n大项（假赋值）：，，，\n\n\n\n蕴含（Implication）： \n\n解释：表达式  在逻辑上表示，如果 A 为假或者 B 为真，则整个表达式为真。\n\n真值表：\n\n\n\nA\nB\n\n\n\n\n0\n0\n1\n\n\n0\n1\n1\n\n\n1\n0\n0\n\n\n1\n1\n1\n\n\n\n\n\n双条件（Biconditional）： \n\n解释：表达式  在逻辑上表示，A 和 B 同时为真或同时为假时，整个表达式为真。\n\n真值表：\n\n\n\nA\nB\n\n\n\n\n0\n0\n1\n\n\n0\n1\n0\n\n\n1\n0\n0\n\n\n1\n1\n1\n\n\n\n\n\n\n逻辑运算律双重否定（Double Negation）： \n\n解释：表示对命题 A 进行两次否定操作。在经典逻辑中，双重否定等价于命题本身，即 。\n\n真值表：\n\n\n\nA\n\n\n\n\n\n0\n1\n0\n\n\n1\n0\n1\n\n\n\n\n双重否定的真值表显示，对于任何命题 A， 的值与 A 的值相同。因此，双重否定率等于原命题。\n恒等律（Identity Laws）：\n\n解释：与真（True）合取的结果仍为原命题，或者与假（False）析取的结果仍为原命题。\n\n\n\n\n\nA\n\n\n\n\n0\n0\n\n\n1\n1\n\n\n\n\n\n\n\nA\n\n\n\n\n0\n0\n\n\n1\n1\n\n\n\n\n零律（Zero Laws）：\n\n解释：与假合取的结果为假，或者与真析取的结果为真。\n\n\n\n\n\nA\n\n\n\n\n0\n0\n\n\n1\n0\n\n\n\n\n\n\n\nA\n\n\n\n\n0\n1\n\n\n1\n1\n\n\n\n\n幂等律（Idempotent Laws）：\n\n解释：一个命题与自身合取的结果仍为原命题，或者与自身析取的结果仍为原命题。\n\n\n\n\n\nA\n\n\n\n\n0\n0\n\n\n1\n1\n\n\n\n\n\n\n\nA\n\n\n\n\n0\n0\n\n\n1\n1\n\n\n\n\n补律（Complement Laws）：\n\n解释：一个命题与其否定进行合取的结果为假，与其否定进行析取的结果为真。\n\n\n\n\n\nA\n\n\n\n\n\n0\n1\n0\n\n\n1\n0\n0\n\n\n\n\n\n\n\nA\n\n\n\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n\n\n交换律（Commutative Laws）：\n\n解释：合取和析取的顺序不影响结果。\n\n\n\n\n\nA\nB\n\n\n\n\n\n0\n0\n0\n0\n\n\n0\n1\n0\n0\n\n\n1\n0\n0\n0\n\n\n1\n1\n1\n1\n\n\n\n\n\n\n\nA\nB\n\n\n\n\n\n0\n0\n0\n0\n\n\n0\n1\n1\n1\n\n\n1\n0\n1\n1\n\n\n1\n1\n1\n1\n\n\n\n\n结合律（Associative Laws）：\n\n解释：合取和析取的组合不依赖于括号的位置。\n\n\n\n\n\nA\nB\nC\n\n\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n0\n1\n0\n0\n\n\n0\n1\n0\n0\n0\n\n\n0\n1\n1\n0\n0\n\n\n1\n0\n0\n0\n0\n\n\n1\n0\n1\n0\n0\n\n\n1\n1\n0\n0\n0\n\n\n1\n1\n1\n1\n1\n\n\n\n\n\n\n\nA\nB\nC\n\n\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n0\n1\n1\n1\n\n\n0\n1\n0\n1\n1\n\n\n0\n1\n1\n1\n1\n\n\n1\n0\n0\n1\n1\n\n\n1\n0\n1\n1\n1\n\n\n1\n1\n0\n1\n1\n\n\n1\n1\n1\n1\n1\n\n\n\n\n分配律（Distributive Laws）：\n\n解释：合取对析取的分配，以及析取对合取的分配。\n\n\n\n\n\nA\nB\nC\n\n\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n0\n1\n0\n0\n\n\n0\n1\n0\n0\n0\n\n\n0\n1\n1\n0\n0\n\n\n1\n0\n0\n0\n0\n\n\n1\n0\n1\n1\n1\n\n\n1\n1\n0\n1\n1\n\n\n1\n1\n1\n1\n1\n\n\n\n\n\n\n\nA\nB\nC\n\n\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n0\n1\n0\n0\n\n\n0\n1\n0\n0\n0\n\n\n0\n1\n1\n1\n1\n\n\n1\n0\n0\n1\n1\n\n\n1\n0\n1\n1\n1\n\n\n1\n1\n0\n1\n1\n\n\n1\n1\n1\n1\n1\n\n\n\n\n德·摩根律（De Morgan’s Laws）：\n\n\n\n\n这两个等式表明，对一个合取或析取的否定等价于分别对每个命题进行否定，然后改变合取和析取的操作。下面是每个德·摩根律的真值表演示：\n\n对合取的德·摩根律：\n\n\n\n\n\nA\nB\n\n\n\n\n\n\n\n\n0\n0\n0\n1\n1\n1\n1\n\n\n0\n1\n0\n1\n1\n0\n1\n\n\n1\n0\n0\n1\n0\n1\n1\n\n\n1\n1\n1\n0\n0\n0\n0\n\n\n\n\n\n对析取的德·摩根律：\n\n\n\n\n\nA\nB\n\n\n\n\n\n\n\n\n0\n0\n0\n1\n1\n1\n1\n\n\n0\n1\n1\n0\n1\n0\n0\n\n\n1\n0\n1\n0\n0\n1\n0\n\n\n1\n1\n1\n0\n0\n0\n0\n\n\n\n\n\n\n蕴含等值式：\n\n\n解释：蕴含关系  等价于逻辑表达式 ，即如果 A 不成立或者 B 成立，则整个蕴含关系成立。\n\n\n\n\nA\nB\n\n\n\n\n\n\n0\n0\n1\n1\n1\n\n\n0\n1\n1\n1\n1\n\n\n1\n0\n0\n0\n0\n\n\n1\n1\n1\n0\n1\n\n\n等价蕴含等值式：\n\n\n解释：两个命题等价于它们之间的双向蕴含关系，即如果 A 蕴含 B 且 B 蕴含 A，则两者等价。\n\n\n\n\nA\nB\n\n\n\n\n\n\n\n0\n0\n1\n1\n1\n1\n\n\n0\n1\n0\n1\n0\n0\n\n\n1\n0\n0\n0\n1\n0\n\n\n1\n1\n1\n1\n1\n1\n\n\n归谬律：\n\n\n\n\n\n\nA\nB\n()\n()\n()\n()\n\n\n\n0\n0\n1\n1\n1\n1\n\n\n0\n1\n1\n1\n1\n1\n\n\n1\n0\n0\n1\n0\n0\n\n\n1\n1\n1\n0\n0\n0\n\n\n假言移位：\n\n\n\n解释：如果从 A 推导出 B，那么从非 B 推导出非 A，反之亦然。\n\n\n\n\n\nA\nB\n()\n()\n()\n()\n\n\n\n0\n0\n1\n1\n1\n1\n\n\n0\n1\n1\n0\n1\n1\n\n\n1\n0\n0\n1\n0\n0\n\n\n1\n1\n0\n0\n1\n1\n\n\n翻译这种题就跟着感觉走，一般都不会错的，除非你看不懂英语。。。\n拿一道去年的题为例\n让域包含所有学生和课程的集合。定义以下谓词：\n\n : 表示  是一门课程。\n : 表示  是一名学生。\n : 表示学生  选修了课程 。\n\n现在，我们来翻译一些句子为逻辑表达式：\n\nEvery student has taken some course.\n逻辑表达式: \n\n\nSome student has not taken any course.\n逻辑表达式: \n\n\nA student has taken a course.\n逻辑表达式: \n\n\nNo student has taken every course.\n逻辑表达式: \n\n\nEvery student has taken every course.\n逻辑表达式: \n\n\nA student has taken at least 2 courses.\n逻辑表达式: \n\n\n\n","slug":"Crash-Course-For-CPT107-3","date":"2023-12-29T09:00:46.000Z","categories_index":"","tags_index":"笔记,CPT107","author_index":"General_K1ng"},{"id":"7ade6902988a1db49ee704f6a0260b79","title":"Crash Course For CPT107-2","content":"突然意识到一章估计讲不完，那今天就一直继续写完，我的计划是只整理到逻辑，然后后面的概率和排列组合怎么想高考过的再差也不可能不会。\n继续接着上面的集合，来讲闭包。\n闭包什么是闭包，妈的我也不知道，但是我会做题，这就够了。\n根据我看题的感觉，闭包类似于一种补全关系的意思，先这么理解着。\n自反闭包自反闭包是将一个关系变成自反关系的过程。如果关系  在某个集合上不是自反的，那么可以通过添加一些元素，使得关系变成自反的。这个过程被称为自反闭包。\n定义 设  是一个集合， 是  上的二元关系。 的自反闭包（denoted as ）是最小的自反关系，使得  包含  中的所有元素。也就是说， 包含  中的所有有序对，同时对于每个元素 ， 也包含在  中。\n形式上，自反闭包  (或者 )定义为：其中  表示将  中的所有元素与所有的自反元素  结合起来。\n例如，如果  而 ，那么  就是 。\n性质\n自反闭包是自反关系。\n自反闭包是包含原始关系的最小自反关系。\n\n对称闭包对称闭包是将一个关系变成对称关系的过程。如果关系  在某个集合上不是对称的，那么可以通过添加一些元素，使得关系变成对称的。这个过程被称为对称闭包。\n定义设  是一个集合， 是  上的二元关系。 的对称闭包（denoted as ) 是最小的对称关系，使得  包含  中的所有元素。也就是说， 包含  中的所有有序对，同时对于每个元素 ，也要包含相应的 。\n形式上，对称闭包  或者  定义为：其中  表示将  中的所有元素与它们的镜像元素  结合起来。\n例如，如果  而 ，那么    就是 。\n性质\n对称闭包是对称关系。\n对称闭包是包含原始关系的最小对称关系。\n\n传递闭包传递闭包是将一个关系变成传递关系的过程。如果关系  在某个集合上不是传递的，那么可以通过添加一些元素，使得关系变成传递的。这个过程被称为传递闭包。\n定义 设  是一个集合， 是  上的二元关系。 的传递闭包（denoted as ) 是最小的传递关系，使得  包含  中的所有元素。也就是说， 包含  中的所有有序对，同时对于每三个元素 ，当  且  时，必须有 。\n形式上，传递闭包  （或者  ） 可以通过以下方式构建：\n\n初始化  。\n对于每一对元素 ，如果存在  使得  且 ，则添加  到  中。\n\n重复步骤2，直到没有新的元素可以添加为止。\n说白了，你就把缺了的关系给补上让它具有传递关系就行，这就是闭包。\n妈的。\n例如，如果  而 ，则  就是  。\n性质\n传递闭包具有传递关系。\n传递闭包是包含原始关系的最小传递关系。\n\n等价关系定义 是一个非空集合， 是  上的一个二元关系，若  具有自反性，对称性，传递性，则说  是  上的等价关系。\n等价关系将集合  划分成一些互不相交的等价类，每个等价类都是集合  的一个子集，其中包含了彼此等价的元素。\n例如，如果  而 ，则  是等价关系。等价类为 ，它们互不相交，且并集为整个集合 。\n性质\n等价类的划分： 等价关系将集合划分成互不相交的等价类，每个元素属于且仅属于一个等价类。\n唯一性： 对于集合  上的等价关系，存在唯一的划分，使得每个等价类都是一个子集。\n\n偏序关系偏序关系是一个二元关系的特殊性质，它具有自反性、反对称性和传递性三个性质。偏序关系用于定义一个集合中元素之间的偏序关系，这种关系不要求每一对元素都相互比较，但对那些可比较的元素，关系必须满足一定的性质。\n定义设  是一个非空集合， 是  上的一个二元关系，若  有自反性，反对称性，传递性，则称  是  上的一个偏序关系。并称  是一个偏序集。\n比如我们有 ， 是  上一个关系，其中  为：我们先快速地画出关系图，来快速判断这个关系，发现是满足自反性，反对称性和传递性的，那么这就是一个偏序集合\n\n覆盖 什么是覆盖，定义我也没看懂，但是意思差不多就是画个关系图，你就看上面这个关系图，2覆盖1，为什么？因为2和1之间插不进去别的元素了，4就不覆盖1，为什么？因为4和1中间夹了一个2，差不多就这个意思，覆盖这个概念就是为了画哈斯图用，如果存在覆盖，那么这个节点的一条线就不能连，然后从下到上进行绘制就行。\n画出上面那个的哈斯图如下：\n\n构建哈斯图的步骤：\n\n节点表示： 对偏序集中的每个元素都创建一个节点，节点的位置通常按照偏序关系的次序排列。\n边表示： 对于偏序集中的每个覆盖关系 ⋖，在图中添加一个从  指向  的有向边。\n\n在哈斯图中，每个节点代表偏序集中的一个元素，按照覆盖关系连起来，最后就画出来了，能做题就行。\n某某元极小元： 如果偏序集合中的元素  满足：对于所有 ，如果 ，则 ，那么  被称为极小元。换句话说，没有其他元素与它比它更小。\n极大元： 如果偏序集合中的元素  满足：对于所有 ，如果 ，则 ，那么  被称为极小元。换句话说，没有其他元素与它比它更大。\n最小元： 如果偏序集合中的元素  满足：对于所有 ，如果 ，那么  被称为最小元。最小元是集合中所有元素的下界。\n最大元： 如果偏序集合中的元素  满足：对于所有 ，如果 ，那么  被称为最大元。最大元是集合中所有元素的上界。\n需要注意的是，极小元和最小元不一定相同，极大元和最大元也不一定相同。在一些情况下，集合可能没有极小元、极大元、最小元或最大元。\n上下界最小上界和最大下界是偏序集合中的两个重要概念，它们分别对应于元素的最小上界（least upper bound，简称 LUB）和最大下界（greatest lower bound，简称 GLB）。这些概念有助于描述偏序集合中元素之间的上界和下界关系。\n\n最小上界（LUB）： 对于偏序集合中的元素  和 ，如果存在元素  使得  且 ，则  是  和  的最小上界。这表示  是大于等于  和  的最小元素。\n最大下界（GLB）： 对于偏序集合中的元素  和 ，如果存在元素  使得  且 ，则  是  和  的最大下界。这表示  是小于等于  和  的最小元素。\n\n函数映射 和  是两个非空集合， 是  的一个子集，即  。若对于任意的 ，存在唯一的  ，使得 ，则称  是  到  的一个函数（映射）。\n\n集合  和 ：  和  是两个非空的集合。通常，我们将  称为定义域（domain）， 称为值域（codomain）。\n子集 ：  是  的一个子集。这里的  表示笛卡尔积，即所有可能的有序对 ，其中  且 。\n对于任意 ： 对于定义域  中的任意元素 ，我们考虑映射  中的有序对 。\n存在唯一的 ： 存在一个值  属于值域 ，使得 。这表示每个元素  在映射下都有一个对应的唯一值 。\n唯一性： 如果存在  对应多个 ，那么  就不是函数。在函数中，每个  对应一个唯一的 。\n\n总的来说，映射就是一种规则，它将定义域  中的每个元素映射到值域  中的唯一元素。这种映射关系可以用箭头图示，其中每个箭头表示一个有序对 ，表示  映射到 。在数学中，我们通常使用函数符号  表示函数，其中  是映射， 是定义域， 是值域。\n单射函数（injective）如果它在不同的输入值上产生不同的输出值。换句话说，每个不同的输入都映射到值域中的不同输出。\n给定函数 ，它是一个单射函数，如果对于  中的任意两个不同的元素  和 ，都有 。这意味着不同的输入必定映射到不同的输出。\n形式化地，一个函数  是单射的定义如下：\n如果对于  中的任意  和 ，当  时，有 ，则  是单射函数。\n简而言之，不同的输入不能映射到相同的输出。\n每个输入都有它独特的映射。如果两个不同的输入有相同的输出，那么函数就不是单射的。\n连续的单射函数一定单调？\n这是正确的，我们可以用反正法来证明，正好复习一下。\n只考虑闭区间  ，当  的情况。\n假设存在  ，使得  ，，因为 ，所以有 。\n\n若 ，对区间  使用介值定理，即 ，使得 ，矛盾。\n若 ，对区间  使用介值定理，即 ，使得 ，矛盾。\n\n所以假设错误， 在  上恒成立，即  为单调递增函数，递减同理。\n满射函数（surjective）满射函数是另一种函数的性质，它与单射函数相对应。一个函数被称为满射（surjective），如果它覆盖了值域中的每一个元素，换句话说，对于值域中的每个元素，都存在定义域中的至少一个元素与之对应。\n给定函数 ，它是一个满射函数，如果对于  中的任意元素 ，存在  中的至少一个元素 ，使得 。这表示函数  能够映射到值域  的每一个元素。\n形式化地，一个函数  是满射的定义如下：\n对于  中的任意 ，存在  中的至少一个 ，使得 。\n这意味着值域  中的每个元素都有至少一个原像（pre-image）在定义域  中。满射函数确保了函数的映射不会留下值域中的任何空隙。\n需要注意的是，一个函数可以是单射、满射，或者同时是单射和满射，这种情况被称为双射（bijective）。当一个函数是双射时，它在不同输入值之间是一一对应的，并且覆盖了整个值域，没有任何遗漏或重复。\n双射函数（bijective）\n一个函数  被称为双射函数（bijective），如果它既是单射，也是满射。\n形式化地，一个函数  是双射的定义如下：\n\n单射性（Injective）： 对于  中的任意两个不同的元素  和 ，当  时，有 。\n满射性（Surjective）： 对于  中的任意元素 ，存在  中的至少一个元素 ，使得 。\n\n\n\n简而言之，一个函数是双射函数，当且仅当它在不同的输入值上产生不同的输出值（单射性），并且它覆盖了值域中的每一个元素（满射性）。\n双射函数具有一些重要的性质：\n\n一一对应： 对于不同的输入  和 ，它们有不同的输出  和 ，确保了一一对应的关系。\n可逆性： 由于每个值域中的元素都有对应的原像，双射函数是可逆的。这意味着存在一个逆映射 ，使得  和  对于所有  和  成立。\n\n双射是可逆的充分必要条件！！！\n鸽巢原理鸽巢原理（Pigeonhole Principle）是组合数学中的一项基本原理，它在许多问题的解决中起着重要作用。该原理的核心思想是，在将对象放入容器（鸽巢）时，如果对象的数量多于容器的数量，那么至少有一个容器必须包含两个或更多的对象。这个原理的直观解释是，如果你试图将很多“鸽子”放入很少的“巢穴”，那么至少有一个“巢穴”将不得不容纳多个“鸽子”。\n鸽巢原理有两种形式：弱鸽巢原理（Weak Pigeonhole Principle）和强鸽巢原理（Strong Pigeonhole Principle）。\n\n弱鸽巢原理（Weak Pigeonhole Principle）： 如果有n + 1个对象要放到n个容器中，那么至少有一个容器会包含至少两个对象。\n数学表达式：如果有  个元素被放入  个容器中，那么至少有一个容器包含两个或更多的元素。\n这个原理可以通过反证法来证明。假设所有的容器中都只包含一个元素，但是总共有  个元素，这是不可能的，因为只有  个容器。因此，至少有一个容器包含两个或更多的元素。\n\n强鸽巢原理（Strong Pigeonhole Principle）： 如果有mn + 1个对象要放到n个容器中，那么至少有一个容器会包含至少m + 1个对象。\n数学表达式：如果有  个元素被放入  个容器中，那么至少有一个容器包含  个或更多的元素。\n强鸽巢原理的证明通常更复杂，但其基本思想与弱鸽巢原理相似。通过反证法，可以证明在这种情况下至少存在一个容器包含更多的元素。\n\n\n例子1：生日问题考虑一个房间里有多少人才能确保至少有两个人生日相同？假设有365天，即一年的天数。根据鸽巢原理，当你有366个人时，就可以确保至少有两个人有相同的生日，因为你试图将366个“鸽子”放入365个“巢穴”中。\n例子2：抽屉原理假设你有10双袜子，其中每双袜子的颜色都不同。如果你在盲目状态下从这些袜子中随机取出11只袜子，根据鸽巢原理，至少有一双袜子的颜色是相同的，因为你试图将11只袜子放入10个“巢穴”中。\n例子3：图论中的应用在图论中，鸽巢原理也经常用于证明存在性问题。例如，考虑一个有7个点的完全图，其中每两个点之间都有边相连。如果你试图用不同颜色为这7个点着色，那么根据鸽巢原理，至少有一个颜色将被使用两次，因为你试图将7个“鸽子”放入6个“巢穴”中。\n","slug":"Crash-Course-For-CPT107-2","date":"2023-12-29T06:13:08.000Z","categories_index":"","tags_index":"笔记,CPT107","author_index":"General_K1ng"},{"id":"f149fe3b0d48e404f320a7e5e6c42caa","title":"Crash Course For CPT107-1","content":"快要考试了哈，没事，最近我也才开始学习离散数学，这篇文章主要帮助各位以最快的速度上手CPT107这门课程，看完不一定会，但是会做题就行。\n反证法反证法，高中应该都学过，这里直接给一个模板，然后大伙自己去找题试试。\n模板\n\n\n\n\n\n\n\n\n命题： 假设命题 P 不成立。\n步骤：\n\n假设反证法： 假设命题 P 不成立，即存在一个对象（或条件），使得 P 为假。\n推导出矛盾： 利用这一假设，推导出矛盾的结论（通常通过数学推理）。\n得出结论： 由于假设 P 不成立导致了矛盾，所以我们的假设是错误的，即命题 P 是成立的。\n\n术语和符号这里放一点常用的术语，虽然我想大伙不至于英语看不懂。\n\nAssume (by Contradiction): 假设，为了推导矛盾而假设。\nContrapositive: 一个命题的逆否命题。\nNegation: 一个命题的否定。\nDerive a Contradiction: 推导出一个矛盾。\nExistence of a Counterexample: 假设存在一个反例。\nSuppose Not (Negation): 假设否定命题是真的。\nLogical Implication: 逻辑蕴含。\nProof by Contradiction: 反证法。\nConclude: 由矛盾得出结论。\nFinal Conclusion: 证明的最终结论。\nAssumption (Hypothesis): 最初的假设。\nAbsurdity: 在证明中达到的荒谬结论。\nInfer Contrary to Assumption: 推导出与最初假设相反的结论。\nContradict the Hypothesis: 达到与假设相矛盾的地步。\n\n例子中文命题： 有无穷多个素数\n反证法： \n步骤 1-矛盾假设：为了引起矛盾，假设存在有限个素数。\n步骤 2-推导矛盾： 设  是所有素数的列表，现在考虑 。\n步骤 3-证明假设导致矛盾：  要么是素数，要么是合数。如果  是素数，那么我们找到了不在列表中的新素数。如果  是合数，那么它必定有一个素因子。然而，这个素因子不能是  中的任何一个，因为他们都不能整除  。这意味着存在另一个不在我们列表中的素数。\n步骤 4-结论： 无论如何，我们假设只有有限个素数都导致了矛盾。因此，必须存在无穷多个素数。\n英文Proposition: There are infinitely many prime numbers.\nProof by Contradiction:\nStep 1: Assume by Contradiction: Suppose, for the sake of contradiction, that there are only finitely many prime numbers.\nStep 2: Derive a Contradiction: Let  be the list of all prime numbers. Now, consider the number .\nStep 3: Show that the assumption leads to a contradiction:  is either prime or composite. If  is prime, then we have found a new prime not in our list. If  is composite, then it must have a prime factor. However, this prime factor cannot be any of  because none of them divides  evenly. This implies the existence of another prime not in our list.\nStep 4: Conclusion: Either way, our assumption that there are only finitely many primes leads to a contradiction. Therefore, there must be infinitely many prime numbers.\n数学归纳法数学归纳法可太简单了，高中都学过，直接套用就行了，我也跟上面一样给出一个模板。\n模板\n\n\n\n\n\n\n\n\n1. 命题陈述： \n这里， 是关于自然数  的命题。\n2. 基础步骤（基础情形）： 证明  成立。\n3. 归纳假设： 假设对于某个正整数 ，命题  成立，即  为真。\n4. 归纳步骤： 证明当  时，命题  也成立。\n5. 证明过程： 证明  成立\n（这里列举具体的数学式子和推导过程）\n6. 结论： 由数学归纳法，对于所有的自然数 ，命题  成立。\n术语和符号\nBasis Step（基础步骤）: 证明命题对于基础情形，通常是 ，成立。\nInductive Hypothesis（归纳假设）: 中文： 假设命题对于某个任意但固定的正整数  成立。\nInductive Step（归纳步骤）: 证明如果命题对于  成立，那么它也对于  成立。\nBase Case（基本情形）: 在基础步骤中证明的初始情形。\nInductive Step Assumption（归纳步骤假设）: 在归纳步骤中假设命题对于  成立的假设。\nInductive Conclusion（归纳结论）: 根据归纳假设和步骤得出命题对于所有  成立的结论。\n\n例子中文命题：我们要证明对于所有正整数 ，上述命题成立。\n归纳法证明：\n1. 基础步骤： \n证明当  时，命题成立：左边右边因此，基础情形成立。\n2. 归纳假设： 假设对于某个正整数  ，命题  成立。\n3. 归纳步骤：  证明当  时，命题  成立。4. 证明过程：左边根据归纳假设归纳假设代入右边因此，当  时，命题成立。\n5. 结论： 由数学归纳法，对于所有的自然数 ，命题  成立。\n英文Proposition:Proof by Mathematical Induction:\n1. Base Step:\nShow that the proposition holds for .Therefore, the base step holds.\n2. Inductive Hypothesis: Assume that for some positive integer  ，the proposition holds.\n3. Inductive Step:  Prove that if the proposition holds for  , then it also holds for .4. Proof Process:Therefore, the proposition holds for  .\n5. Conclusion: By mathematical induction, the proposition  holds for all natural numbers .\n集合集合的运算集合的运算就是集合的交，并，补，还有几个新的什么对称差，差运算之类的。\n并集（Union）：\n\n定义：设A和B是两个集合，它们的并集是一个新集合，包含了A和B中的所有元素，但不重复计数。\n符号：\n例子：如果  和  ，那么 。\n\n交集（Intersection）：\n\n定义：设A和B是两个集合，它们的交集是一个新集合，包含了同时属于A和B的所有元素。\n符号： \n例子：如果  和  ，那么 。\n\n补集（Complement）：\n\n定义：设U是全集，A是U的一个子集，A的补集包含了U中不属于A的所有元素。\n符号：或者 \n例子：如果  且  ，那么 。\n\n差集（Difference）：\n\n定义：设A和B是两个集合，A与B的差集是一个新集合，包含了属于A而不属于B的所有元素。\n符号：\n例子：如果  和  ，那么 。\n\n对称差集（Symmetric Difference）：\n\n定义：设A和B是两个集合，A与B的对称差集是一个新集合，包含了属于A而不属于B，以及属于B而不属于A的所有元素。\n符号：\n例子：如果  和  ，那么 。\n\n幂集（Power Set）：\n\n定义：对于给定集合A，它的幂集是所有A的子集的集合，包括A本身和空集。\n符号： 或者  \n例子：如果  ，那么\n\n换句话说，幂集包含了原集合的所有可能的子集。如果原集合  有  个元素，那么其幂集就有  个元素，包括空集和  本身。\n例如，对于一个包含3个元素的集合，其幂集将包括  个子集，如下所示：\n笛卡尔积有序二元组有序二元组一般用小括号表示，形式为 (a, b)，其中 a 和 b 分别是两个元素，而它们的顺序是有意义的，即 (a, b) 不等于 (b, a)。\n具体来说，有序二元组的定义如下：\n定义： 设  和  是两个集合，有序二元组是指由一个来自  的元素和一个来自  的元素按照一定的顺序组成的，通常表示为 ，其中  是  中的元素， 是  中的元素。\n不用管那么多，继续往下。\n笛卡尔积集它是由两个集合的所有可能的有序二元组所构成的集合。笛卡尔积集通常用符号 “×” 表示。\n定义： 设  和  是两个集合，它们的笛卡尔积集（Cartesian product）表示为 ，定义为所有形如  的有序二元组的集合，其中  属于 ， 属于 。\n数学上表示为：例如，如果 ，，那么笛卡尔积集  就是：注意，有序二元组中的顺序是重要的，所以 (1, x) 和 (x, 1) 是不同的元素。\n那么在笛卡尔积集中一共有多少个有序二元组呢？小学生都知道只要A和B中的元素个数相乘即可。\n二元关系定义定义1设 A 和 B 是两个集合，二元关系  是  的子集，即 。如果元素  属于 ，则表示  与  之间存在关系。通常用  或  表示元素  与元素  之间存在关系 。\n定义2设  是集合  和  上的二元关系，那么  的逆关系  定义为包含所有满足  的有序对  ，其中 。\n数学上表示为：这个可简单了，求一组关系的逆你只要直接把其中的有序对反转就可以了，没有那么高大上的东西。\n例如，如果 ，那么 。\n定义3设  是从集合  到集合  的关系， 是从集合  到集合  的关系，那么  是从集合  到集合  的复合关系，定义为：直观地说，   中的元素  表示存在一个中间元素 ，使得  属于  且  属于 。\n复合顺序很重要，一般情况下并不等于，而且根据教材不同也分为左复合和右复合，妈的我也不知道我们教材是以什么为主的。\n性质自反关系(reflexive relation)设  是一个集合， 是  上的二元关系。关系  是自反的，如果对于集合  中的每个元素 ，都有 。\n数学上表示为：是自反的例如，如果  而  则  是自反的，因为每个元素都与自己相关联。\n\n反自反关系(anti-reflexive relation)设  是一个集合， 是  上的二元关系。关系  是反自反的，如果对于集合  中的每个元素 ，都有 。\n数学上表示为：是反自反的例如，如果  而  则  是反自反的，因为每个元素都不与自己相关联\n\n自反和反自反的关系： 一个关系可能是自反的，也可能是是反自反的，不能同时具备这两个性质，但是可以既不是自反也不是反自反的。\n对称关系(symmetrical relation)设  是一个集合， 是  上的二元关系。关系  是对称的，如果对于任意 ，当   时必有 。\n数学上表示为：是对称的例如，如果  而  ，则  是对称的。\n\n反对称关系(anti-symmetrical relation)设  是一个集合， 是  上的二元关系。关系  是反对称的，如果对于  中的每对元素 ，当  时，有 。\n数学上表示为：是反对称的例如，如果  而 ，则  是反对称的。\n\n传递关系(transitive relation)设  是一个集合， 是  上的二元关系。关系  是传递的，如果对于  中的每三个元素，当  且  时，必须有 。\n数学上表示为：是传递的例如，如果  而 ，则  就不是传递的，因为缺少了  这个有序二元组。\n\n\n如果关系是自反的，反对称的和传递的，那么它被称为偏序关系。\n如果关系是自反的、传递的和对称的，那么它被称为等价关系。\n\n总结要点\n对称性和反对称性可能同时都不存在\n自反性和反自反性可能同时都不存在\n当关系为空集的时候，满足反自反性，对称性，反对称性以及传递性，除了自反性其他都满足\n\n关系图上面见到的几个图就是所谓的关系图，我们可以通过关系图来非常直观的判断某个关系是否具有这些性质，比如我直接拿一道去年的题来看看这个关系具有哪些性质。\n我们来画出它的关系图：\n\n首先对于每个元素，你会发现都有一个自环，每个都有自环代表着该关系具有自反性，那么他就一定不能具有反自反性。\n然后我们看对称性，对于对称性来说，如果A指向B，那么就一定要有B指向A，那么看这个图显然不是这个样子。\n再看反对称性，对于反对称性来说，如果有A指向B，那么就一定不能有B指向A，也就是说没有双向的箭头，那么这个图就符合反对称性。\n再看传递性，传递性就是如果有A到B，B到C，这种箭头，那么就一定要有A到C这个箭头才行，那么看图就能发现这个图是满足传递性的。\n所以这个关系S就具有自反性，反对称性以及传递性，很直观的就能看出来，而且如果具有自反性，反对称性和传递性的话，我们就说这个关系是**偏序(Partial)**的。\n","slug":"Crash-Course-For-CPT107-1","date":"2023-12-29T02:24:21.000Z","categories_index":"","tags_index":"笔记,CPT107","author_index":"General_K1ng"},{"id":"2a328082fca1ff4ae5cd632b6f599daa","title":"CPT101 Review-5","content":"继续讲这个字符相关的一些知识，看了一眼CPT101的课件为什么每周只有一节课但是会有两个课件。。。\n字母数字字符计算机系统中处理的数据通常包括字母、数字和其他字符，这些统称为alphanumeric characters（字母数字字符）。让我们逐一讨论这三种类型的字符：\n\nLetters（字母）:\n字母通常包括英文字母，例如大写字母 ‘A’ 到 ‘Z’ 和小写字母 ‘a’ 到 ‘z’。\n在计算机系统中，字母通常用ASCII码（美国信息交换标准代码）或Unicode编码表示。每个字母都有一个唯一的数字值，计算机使用这些数字值来存储和处理字母数据。\n\n\nNumbers（数字）:\n数字包括从 ‘0’ 到 ‘9’ 的阿拉伯数字。\n同样，数字也使用ASCII码或Unicode编码进行表示。计算机可以执行各种数学和算术运算，因此数字在计算机系统中是非常重要的。\n\n\nOther Characters（其他字符）:\n这一类包括各种标点符号、符号和特殊字符，如句号（.）、逗号（,）、感叹号（!）、问号（?）、括号（()）、星号（*）等。\n除了常见的标点符号，还包括一些特殊字符，如换行符（newline）、制表符（tab）等，它们在文本处理和格式化中起着重要作用。\n\n\n\n二进制编码因为计算机内部所有的数据都是用二进制序列表示的，所以问题就是如何表示这些字母数字字符。\n\n编码的需求：\n由于计算机只能处理二进制数据，字母、数字和其他字符需要被映射到二进制序列。这个过程被称为编码。\n字符的二进制编码使计算机能够存储、传输和处理各种类型的数据，而不仅仅是字母和数字。\n\n\n编码的选择：\n选择字符的二进制编码方式可能是任意的。不同的编码方案存在，如ASCII（美国信息交换标准代码）和Unicode。\nASCII是一种基本的字符编码，为英文字母、数字和一些常见符号分配了唯一的二进制值。Unicode则更加广泛，支持世界上几乎所有的语言字符。\n\n\n一致性和标准：\n尽管选择编码的方式可能是任意的，但重要的是要保持一致性。即使选择不同的编码方案，不同的计算机系统也应该能够正确地解释和处理数据。\n标准变得至关重要。例如，如果一台计算机使用ASCII编码，而另一台计算机使用Unicode编码，数据的传输和解释就可能会出现问题。通过遵循共同的标准，可以确保不同系统之间的兼容性。\n\n\n\n为什么需要标准？\n\n一致性： 标准确保在不同的系统和应用程序之间有一致的数据表示，避免了混淆和错误的发生。\n互操作性： 标准使得不同的计算机和设备能够共同协作，交换和处理数据。\n可维护性： 使用标准使得系统更易于维护和升级，因为不同部分之间的交互是可预测的。\n\n各种编码方式在计算机系统中，有几种常见的字母数字编码方式，其中包括ASCII码、EBCDIC码和Unicode。\n\nASCII码（美国信息交换标准代码）:\nASCII是一种广泛采用的字符编码，最初设计为7位二进制编码，可以表示128个不同的字符。后来，为了适应更多字符的需求，ASCII的扩展版本（Extended ASCII）引入了8位编码，允许表示256个字符。\nASCII覆盖了基本的拉丁字母、数字、标点符号和控制字符，并为各种应用提供了一致的字符表示方式。这使得在不同的计算机系统和应用程序之间进行文本数据的交换变得更加容易。\n\n\nEBCDIC码（Extended Binary Coded Decimal Interchange Code）:\nEBCDIC是IBM（国际商业机器公司）主机计算机系统上使用的一种字符编码方式，通常采用8位编码。与ASCII不同，EBCDIC主要用于IBM大型机和中型机的系统，而不是个人计算机。\nEBCDIC包含更多的字符，包括字母、数字、标点符号和一些特殊字符。尽管EBCDIC与ASCII在字符表示上存在差异，但通过转换工具，可以在它们之间进行互操作。\n\n\nUnicode:\nUnicode是一种较新的字符编码标准，最初设计为16位编码，可表示65,536（2^16）个字符。Unicode的目标是为世界上所有的语言和符号提供统一的编码方案，以解决ASCII和其他编码方案无法完全覆盖的问题。\nUnicode的16位编码空间迅速被证明不足以容纳所有的字符需求。因此，Unicode进行了扩展，现在有32位编码空间，允许编码超过两亿个字符。这种扩展版的Unicode通常称为UTF-32（Unicode Transformation Format）。\n\n\n\n总结：\n\nASCII、EBCDIC和Unicode都是用于表示字母数字字符的编码方式，它们在不同的场景和系统中得到应用。\nASCII主要用于个人计算机和互联网，EBCDIC用于IBM主机系统，而Unicode则成为一个全球性的标准，用于支持各种语言和符号。Unicode的普及有助于解决跨语言和国际化的文本表示问题。\n\nASCII码ASCII（American Standard Code for Information Interchange）码是一种基本的字符编码标准，用于在计算机和其他设备之间传输文本信息。ASCII最初设计为7位编码，可以表示128个字符，包括控制字符和可打印字符。由于后来的扩展，ASCII的8位版本也得到了广泛的应用，允许表示256个字符。\n基本结构：\n\nASCII码使用二进制来表示字符。最初设计是7位二进制，因此能表示的字符范围是0到127。每个字符都被赋予一个唯一的7位二进制值。\n后来的扩展版本（Extended ASCII）使用了8位二进制，扩展到0到255的范围，以支持更多的字符。\n\n字符范围：\n\nASCII码包含了基本的拉丁字母、阿拉伯数字、标点符号、控制字符和一些特殊字符。\n控制字符用于控制设备和通信，例如换行符（LF）、回车符（CR）、制表符（Tab）等。\n可打印字符包括空格、字母、数字和常见的标点符号。\n\nASCII表：\n\nASCII字符及其对应的二进制值可以在ASCII表中找到。每个字符都有一个唯一的ASCII码，方便计算机系统在文本处理和通信中进行一致的字符表示。\n\nASCII扩展字符集：\n\nExtended ASCII对原始ASCII进行了扩展，通过使用8位二进制，支持更多的字符，包括特殊符号、外文字符和其他符号。这样，ASCII码就能够满足更多语言和应用的需求。\n\n应用：\n\nASCII码是计算机系统中最常用的字符编码之一，广泛应用于文本处理、通信协议、编程和许多其他领域。\n在网络通信中，例如电子邮件、网页等，文本通常使用ASCII码表示。\n\n那么这个表长什么样子呢？\n\n就长这样，感觉考试应该不会考这种背诵吧。。\n拓展表ASCII码表仅使用了可能的8位（1字节）模式中的一半。这是因为ASCII最初设计为7位编码，只使用了0到127的范围。后来的8位扩展版本使用了剩余的128到255的范围，用于表示额外的符号、线形、外文字符等。\n这个8位扩展部分是ASCII的Extended ASCII版本，也称为High ASCII。它包括了许多特殊符号、外文字符、图形符号和其他不在基本ASCII范围内的字符。以下是一些Extended ASCII中常见的字符：\n\n\n\nASCII (7-bit)\nASCII (8-bit)\nCharacter\n\n\n\n…\n128\nÇ\n\n\n…\n129\nü\n\n\n…\n130\né\n\n\n…\n…\n…\n\n\n…\n160\n¡\n\n\n…\n161\ní\n\n\n…\n…\n…\n\n\n…\n255\nÿ\n\n\n分类ASCII码表中的字母编码的顺序与字母表中字母的字母顺序相一致。这种设计有助于使字符编码更加直观和易于记忆。同时，ASCII码表可以分为两个主要类别：打印字符（Printing characters）和控制字符（Control characters）。\n\nPrinting Characters (打印字符):\n打印字符是能够在屏幕上或打印机上直接显示的字符。它们产生可见的输出，包括字母、数字、标点符号和其他可视字符。这些字符通常用于文本的显示和输出，用户可以直接看到它们的表示。\n\n\nControl Characters (控制字符):\n控制字符是不可见的字符，用于控制设备和通信。它们不会直接产生可见的输出，而是用于执行一些特殊的操作或控制输出的位置和格式。\n一些常见的控制字符及其作用包括：\n换行符 (LF，ASCII码为10): 用于将光标移动到下一行，类似于按下”Enter”键。\n回车符 (CR，ASCII码为13): 用于将光标移动到行首，通常与换行符一起使用。\n制表符 (Tab，ASCII码为9): 在文本中创建水平制表格，通常用于对齐文本。\n响铃符 (Bell，ASCII码为7): 产生声音或闪烁光标，用于引起注意。\n控制字符组合 (例如，Control-C): 通过组合键盘上的Ctrl键和其他按键，可以生成控制字符，用于触发某些特殊的命令或操作。\n\n\n控制字符的主要作用包括：\n控制输出位置： 通过制表符等控制字符，可以在文本中创建格式和对齐。\n触发动作： 通过特定的控制字符，可以触发设备上的特定动作，比如响铃符产生声音。\n通信状态： 一些控制字符用于在计算机和输入/输出设备之间传递状态信息，例如Ctrl-C通常用于中断运行的程序。\n\n\n\n\n\n局限性\n显示要求的限制：\nASCII码最初设计时只使用了7位二进制，后来扩展到8位以支持更多字符。然而，对于现代基于Windows的字处理软件等应用程序，ASCII码的8位表示仍然有一些限制。\n许多现代字处理软件需要更多的字符集，包括各种语言的特殊字符、符号和表情符号。由于ASCII只有256个可能的字符，这可能无法满足日益增长的全球化和多语言需求。\n\n\n处理国际字符集的全球软件市场需求：\nASCII码在最初设计时主要关注美国英语，因此并未完全满足全球范围内处理国际字符集的需求。随着计算机的普及和全球化的发展，全球软件市场对于能够处理多语言字符集的需求逐渐增加。\n许多国际字符集，如汉字、日语假名、西里尔字母等，无法用ASCII码表示。这促使了更为复杂和全面的字符编码方案的发展，如Unicode。\n\n\n\n就像这个笑话图片里面说的一样：\n\n那么我们就迎来了大集合，Unicode。\nUnicodeUnicode（统一码，也叫万国码）是一种字符编码标准，用于在计算机系统中表示和处理文本。它的设计目标是支持全球范围内所有语言的字符，包括各种字母、符号、汉字、表情符号等，以满足多语言和多文化的需求。Unicode提供了一个统一的、标准化的字符集，以替代早期的字符编码方案，如ASCII。\n以下是Unicode的一些关键特点和概念：\n\n编码方式：\n最初，Unicode使用16位编码，可以表示2^16（65536）个字符。这个字符集称为基本多文种平面（Basic Multilingual Plane，BMP）。\n由于BMP容量有限，无法涵盖全球所有字符，因此Unicode进行了扩展。扩展版本使用32位编码，可以表示超过2^21个字符。\n\n\n字符集范围：\nUnicode包括了世界上几乎所有语言的字符，涵盖了字母、数字、标点符号、汉字、西里尔字母、阿拉伯字符、印度文字等。\nUnicode还包括一些专用字符，如表情符号、数学符号、箭头等，以满足各种应用的需求。\n\n\n字符表示：\n每个Unicode字符都有一个唯一的代码点，它是一个正整数，用来标识该字符。例如，拉丁字母’A’的Unicode代码点是U+0041。\nUnicode代码点可以表示为U+XXXX的形式，其中XXXX是一个代表16进制数的数字。\n\n\nUTF（Unicode Transformation Format）:\nUTF是一种用于在计算机内存和外部存储介质中存储Unicode字符的编码方式。\nUTF-8、UTF-16和UTF-32是最常见的UTF变体。它们使用不同的字节序列来表示Unicode字符，允许有效地表示不同范围的字符。\n\n\n全球性和兼容性：\nUnicode的全球性和兼容性使得它成为处理多语言文本的标准。不同的操作系统、应用程序和设备都能够使用Unicode，确保文本数据在不同环境中的正确显示和处理。\n\n\n\n数字表示\n整数的表示：\n整数是没有小数部分的整数值。在计算机中，整数可以使用不同的表示方式，包括二进制、八进制、十进制和十六进制等。\n二进制表示： 在计算机内部，整数通常以二进制形式存储。例如，二进制数1101表示十进制的13。整数的二进制表示是通过对位进行加权求和来实现的。\n十进制表示： 十进制是我们日常生活中常用的表示方式，整数直接以十进制形式表示。例如，数字123表示整数123。\n十六进制和八进制表示： 这些是在计算机编程中经常使用的进制。十六进制使用0-9和A-F表示16个数字，而八进制使用0-7表示。\n\n\n实数的表示：\n实数包括整数部分和小数部分，可以表示正数和负数。在计算机中，实数的表示方式通常涉及浮点数表示。\n浮点数表示： 浮点数使用科学计数法的形式，即尾数和指数的组合。例如，1.23可以表示为1.23 x 10^0，其中1.23是尾数，0是指数。在计算机中，浮点数采用IEEE 754标准，用于存储单精度（32位）和双精度（64位）浮点数。\n定点表示： 定点表示是一种表示实数的方法，其中小数点的位置是固定的。这对于一些嵌入式系统和特定应用场景可能更适用。\n\n\n\n在任何数字表示中，需要考虑精度和范围。例如，浮点数在表示大范围的实数时可能存在精度损失。计算机科学家和工程师需要根据应用的需求选择适当的数字表示方法，并了解在不同情境下的性能和准确性权衡。\n整数表示在计算机中，整数通常以二进制形式表示，而通常使用的位数是32位，即4个字节。这种表示方式称为32位整数表示，它支持范围更广的整数值。\nTwo’s Complement（二进制补码）:\n\nTwo’s complement是表示和处理负整数的一种常见方法。在这个表示法中，负整数的二进制表示是其正整数表示的补码形式。这种方法具有许多有用的性质，例如，它可以通过简单的加法和减法操作来处理负数。\n\n例子:\n\n考虑一个32位整数，例如，00000101 00000000 00000000 00000111。这是一个正整数，它的十进制值为13474279。\n如果我们要表示负数，我们可以使用Two’s Complement。首先，计算正整数的二进制补码。对于正数13474279，其二进制表示是00000101 00000000 00000000 00000111。然后，取反并加1，得到补码11111010 11111111 11111111 11111001。这是负整数-13474279的二进制表示。\n\nTwo’s Complement的优势:\n\nTwo’s Complement在计算机系统中被广泛使用，因为它具有一些优势，例如简化加法和减法操作，且不需要专门的减法电路。\n它使得计算机可以更容易地执行算术运算，同时减小了硬件的复杂性。\n\n补码的计算步骤1: 找到整数的二进制表示\n确定整数的绝对值的二进制表示：\n将整数的绝对值转换为二进制形式，忽略符号。这包括确定整数的二进制表示中的位数，以及每个位上的二进制值。\n\n\n确定二进制表示的位数：\n对于32位整数，将二进制表示补齐为32位。在有符号整数的表示中，最高位是符号位。\n\n\n\n步骤2: 计算补码\n对正整数，补码即是其二进制表示：\n对于正整数，其补码就是其二进制表示，因为正整数的原码、反码和补码都相同。\n\n\n对于负整数，计算补码：\n取正整数的反码：将每个位取反，即0变为1，1变为0。\n对反码加1：在反码的基础上加1，得到补码。\n\n\n\n总结来说就是一句话，如果是正数，那就是二进制，如果是负数，二进制取反再加1\n例子：让我们以一个8位整数为例，计算整数-5的二进制补码。\n步骤1: 找到整数的二进制表示\n5的二进制表示是0000 0101。\n\n步骤2: 计算补码\n反码是1111 1010。\n补码是反码加1，即1111 1011。\n\n所以，整数-5的8位二进制补码是1111 1011。\n总结：\n对于正整数，补码即为其二进制表示。\n对于负整数，补码是取其正整数的反码并加1。\n\n浮点数表示实数的表示通常涉及到浮点数表示，而IEEE 754标准是最广泛使用的浮点数表示和运算标准。IEEE 754定义了浮点数的格式、特殊值以及一系列在这些值上执行的浮点运算。\nIEEE 754浮点数表示：\n浮点数格式：\nIEEE 754标准定义了几种浮点数格式，包括单精度（32位）和双精度（64位）浮点数。这些格式分为三个部分：符号位、指数位和尾数位。\n对于单精度浮点数，通常采用1位符号位、8位指数位和23位尾数位。对于双精度浮点数，分别是1位符号位、11位指数位和52位尾数位。\n\n\n浮点数表示：\n一个浮点数的表示基本上可以分为三个部分：符号、指数和尾数。符号位表示数的正负，指数位确定数的数量级，尾数位表示数的精度。\n例如，单精度浮点数的二进制表示为：(-1)^s * 1.f * 2^(e-127)，其中s是符号位，f是尾数位，e是指数位。\n\n\n特殊值：\nIEEE 754定义了一些特殊的浮点数值，如正无穷大、负无穷大、NaN（Not a Number）等，以处理在计算中可能遇到的特殊情况。\n\n\n浮点数运算：\nIEEE 754标准还定义了浮点数的一系列运算，包括加法、减法、乘法和除法。这些运算的结果遵循浮点数的规范，考虑了舍入误差和溢出等问题。\n\n\n\n\n程序中的变量声明在程序中声明变量是向编译器说明在程序运行期间将要使用的变量，并告诉编译器为这些变量保留正确数量的内存空间。此外，还指定了变量的编码、解码和表示方案。\n声明变量的目的：\n内存分配：\n当你声明一个变量时，编译器负责分配适当大小的内存以存储该变量的值。不同类型的变量需要不同大小的内存空间，如char通常需要1字节，short需要2字节，long需要4字节，long double需要8字节。\n\n\n数据类型说明：\n变量声明中的数据类型告诉编译器如何解释这段内存中的位模式。不同的数据类型使用不同的编码和解码规则。\n\n\n\nchar letter;              // 声明一个字符变量，占用1字节\nshort count;              // 声明一个短整型变量，占用2字节\nlong world_population;    // 声明一个长整型变量，占用4字节\nlong double world_weight; // 声明一个长双精度浮点数变量，占用8字节\n\n其他注意事项：\n变量名称：\n变量名用于在程序中标识和引用变量。在上述示例中，letter、count、world_population和world_weight是变量的名称。\n\n\n初始值：\n变量声明时可以选择提供初始值。例如，int x = 10;将创建一个整数变量x，并将其初始化为10。\n\n\n作用域：\n变量声明的作用域定义了变量在程序中的可见性和生命周期。变量可以是全局的（在整个程序中可见）或局部的（在特定代码块或函数中可见）。\n\n\n类型修饰符：\n在一些编程语言中，还可以使用类型修饰符来提供更多信息，例如const表示常量、volatile表示易失性等。\n\n\n\n","slug":"CPT101-Review-5","date":"2023-12-12T06:42:00.000Z","categories_index":"","tags_index":"CPT101复习,笔记","author_index":"General_K1ng"},{"id":"6a06535b3bcdc549550c9f79e3c5e8f7","title":"CPT101 Review-4","content":"继续复习下一节。\n数据，信息，知识这三者是我们在对于信息处理时的三个不同的抽象阶段。\n\n数据（Data）：\n数据是原始的、未经加工的事实或细节。它是离散的、不加组织的符号或符号集合，通常是数字、文字、图像等的表示。\n数据本身并没有给予任何含义，只有在一定的上下文中才能被理解。例如，数字”25”在没有上下文的情况下，它只是一个数字，没有明确的含义。\n\n\n信息（Information）：\n信息是对数据进行组织和解释后的产物。当数据被放置在特定的背景或语境中，它就变得有意义了。\n信息传达了某种意义，它带有一定的内容、结构和上下文，使其能够为人们提供有用的知识。举例来说，如果我们知道”25”是指温度，那么”25°C”就成为一条信息。\n\n\n知识（Knowledge）：\n知识是对信息进行理解和应用的能力。它涉及到对信息的深层次思考、分析和推理，使其成为有用的认知。\n知识不仅仅是关于事实的了解，还包括对事物之间关系的洞察、模式的识别以及在特定上下文中应用信息的能力。例如，知识可能涉及到使用特定温度信息来判断天气是否适合户外活动。\n\n\n\n在计算机系统中，这三个概念通常是层层递进的。数据是信息的基础，信息是知识的基础。计算机系统的目标之一就是从海量的数据中提炼出有用的信息，进而形成可应用的知识。数据、信息和知识的处理是信息技术和计算机科学领域的核心内容之一。\n信息的测量在信息科学中，我们通常使用一些度量标准来衡量信息的量或信息的不确定性。两个主要的概念是熵（Entropy）和信息量（Information Content）。\n\n熵（Entropy）：\n熵是信息理论中用来度量信息的不确定性或随机性的概念。在信息论中，熵越高，信息的不确定性就越大。\n一个系统的熵可以通过其可能状态的概率分布来计算。如果系统的状态几乎是确定的，熵就很低，因为我们已经知道系统将处于某个状态。相反，如果系统的状态是随机的，熵就很高，因为我们对系统的下一个状态一无所知。\n具体来说，对于一个离散概率分布，熵的计算公式为： 其中， 是系统处于状态   的概率，对所有可能的状态  求和。\n\n\n信息量（Information Content）：\n信息量是表示某个事件的信息多少的度量。当我们得知一个发生的事件时，我们获得的信息量应该是意外性的度量。\n如果一个事件是非常常见或几乎确定会发生的，那么得知这个事件发生所提供的信息量就很小。相反，如果一个事件是非常罕见或不太可能发生的，得知这个事件发生所提供的信息量就很大。\n信息量的计算通常与概率有关，可以使用以下公式表示： 其中， 是事件  发生的概率。这个公式确保了在事件概率较小的情况下信息量较大。\n\n\n\n信息熵信息熵是信息理论中的一个概念，用于量化一组可能结果的不确定性或惊讶程度。它通常用来衡量一个事件、一个随机变量或一条消息所传达的平均信息量。\n比方说：\n\n‘今天晚上11点洛杉矶将发生恐怖袭击。’\n这个陈述携带更多的信息熵。原因在于恐怖袭击的发生是一个意外和罕见的事件。这个陈述传达的信息更为令人惊讶和不确定，因此具有更高的信息熵。在信息理论中，高熵表示更多的信息量。\n\n\n‘今天的天气很好。’\n这个陈述携带较少的信息熵。天气信息通常更可预测和普遍。如果天气一直很好，它就成为一个常规和预期的事件，从而导致较低的信息熵。在这种情况下，陈述提供的信息较少惊讶，因此具有较低的信息熵。\n\n\n\n信息熵的水平与与事件相关的不确定性和惊讶程度有关。罕见或意外事件具有更高的信息熵，而常见和可预测事件具有较低的信息熵。信息熵是信息理论中的重要概念，因为它使我们能够量化和比较不同消息或事件的不确定性或惊讶程度。\n数据编码在计算机科学和信息处理中，数据编码是一种将数据转换为计算机可以理解和处理的形式的方法。两种常见的数据编码方式是数字编码（Numeric Codes）和字符编码（Character Codes）。\n\n数字编码（Numeric Codes）：\n数字编码是使用数字来表示信息的方法。在数字编码中，每个符号或字符都被映射到一个数字，这个数字可以被计算机硬件和软件直接处理。\n例如，二进制编码是一种数字编码方式，其中只使用0和1两个数字表示信息。其他数字编码系统可能使用更多的数字，比如十进制、十六进制等。\n\n\n字符编码（Character Codes）：\n字符编码是将字符映射到数字或二进制表示的方法。它允许计算机处理和存储文本信息。\nASCII（美国信息交换标准代码）是字符编码的一个常见例子。在ASCII中，每个字符都被赋予一个唯一的数字值。Unicode是另一个字符编码标准，它支持更广泛的字符集，包括不同语言和符号。\n\n\n\n这两种编码方式在计算机系统中有着广泛的应用：\n\n数字编码 通常用于表示数字、整数、浮点数等数值数据。计算机内部处理数据时，数字编码可以更有效地执行数学运算。\n字符编码 则用于表示文本数据，包括字母、数字、标点符号等。不同的字符编码系统支持不同的字符集，因此可以用于处理多语言文本。\n\n\n用户输入文字、数字、图像和声音的过程，然后进行相应的数据转换，最终在计算机内部进行存储和处理。之后，数据通过字符解码、直接解码、图像处理和数字到模拟转换进行恢复，并最终以文字、数字、图像和声音的形式输出。\n字母数字数据（Alphanumeric data）绝大多数数据最初以字母、数字和标点符号的形式存在，这被称为字母数字数据。它们在计算机中以二进制数表示。\n\n字母数字数据的形式：\n大多数数据包含了字母、数字和标点符号，这构成了字母数字数据的形式。\n例如，个人姓名、地址、标识号码、代码等都属于字母数字数据。\n\n\n在计算机中的表示：\n这些字母数字字符在计算机中以二进制数的形式表示。\n计算机使用ASCII码或Unicode等字符编码系统，将字母数字字符映射为相应的二进制数字，从而能够存储和处理这些数据。\n\n\n\n比特比特（Bit）：\n\n比特是信息的最基本单位，它包含了足够区分两个选择的信息（1 或 0，是 或 不是等）。\n我们通常将这两个选择看作是数字 0 和 1。\n两个选择由两态元素表示，例如存储单元的电荷状态，可以是充电（1）或未充电（0）。\n\n在计算机科学和信息理论中，比特是信息的最小单元，是二进制系统中的基础。这是由于计算机中的所有数据和指令都可以用一串比特来表示。比特的两个可能状态，通常用 0 和 1 表示，反映了数字逻辑的基本原理。\n比特的概念：\n\n一个比特能够表示两种状态，如打开或关闭、存在或不存在、是或否等。\n比特是计算机中信息处理和存储的基础。所有其他数据类型和信息都可以通过比特的组合来表示。\n\n两态元素的例子：\n\n计算机内存单元可以看作是两态元素的例子。当内存单元充电时，我们可以将其表示为1；当未充电时，我们可以表示为0。这种二元状态的组合形成了计算机内部的数据表示方式。\n\n比特的重要性：\n\n比特的概念对于理解计算机的运作和信息处理至关重要。所有的数字、文字、图像、声音等数据最终都可以转换为比特的形式进行存储和处理。\n比特也是计算机网络和通信领域的基石，因为信息在网络中以比特的形式传输。\n\n二进制数系统二进制数制是一种基于 2 的数制系统，也被称为“基数为 2 的数制”或“双进制数制”。在二进制数制中，每个数字位的权重是 2 的幂。它是计算机领域中最基础和常用的数制之一，因为计算机内部使用二进制来表示和处理信息。\n概念\n数字表示：\n二进制系统中，数字由 0 和 1 组成。每个二进制数字位称为一个比特（bit）。\n例如，二进制数 1101 表示 .\n\n\n权重和位值：\n二进制数中的每一位都有一个权重，其权重是 2 的幂。最右边的位的权重为 2^0，依次向左递增。\n例如，二进制数  中，从右到左，第一个位的权重是 ，第二个位的权重是 ，以此类推。\n\n\n位运算：\n由于二进制中只有两个数字（0 和 1），位运算（如与、或、异或）在计算机中广泛使用。这些运算对于处理和操纵比特非常重要。\n\n\n转换：\n二进制可以与其他进制之间相互转换。例如，将十进制数转换为二进制数，或反过来。\n\n\n\n示例：\n\n十进制数 13 在二进制中表示为 1101。\n二进制数 1010 表示 。\n\n计算机中的应用\n计算机内部使用二进制表示数据，因为它对于逻辑电路和数字电子设备的设计更为方便。\n机器语言和汇编语言等低级编程语言通常使用二进制表示指令和数据。\n\n二进制数转换为十进制数这个很简单，小学应该都学过，上面也提到了，总体步骤就三个：\n\n写出二进制数：\n将给定的二进制数写出，从最高位到最低位。\n\n\n为每位确定权重：\n从右到左，为每个二进制位确定其对应的权重。最右边的位的权重是 ，依次向左递增。\n\n\n计算十进制值：\n对于每个二进制位，将其值与相应权重相乘，然后将这些部分和相加。\n\n\n\n考虑二进制数  转换为十进制数：因此， 转换为十进制是 。\n通用规则：\n\n对于 位的二进制数，权重从 到 。\n二进制数中的每个位只有两个可能的值，即 0 或 1。\n\n十进制数转换为二进制数这个有一点复杂，但是小学应该都学过短除法，可以自己百度。\n比方说：\n考虑十进制数  转换为二进制数：\n进行短除法，将 21 除以 2。记录余数 1。\n将商 10 再次除以 2。记录余数 0。\n将新的商 5 再次除以 2。记录余数 1。\n将新的商 2 再次除以 2。记录余数 0。\n最后，将最终的商 1 再次除以 2。记录余数 1。\n将记录的余数反向排列，得到二进制数。\n记住，这里是反向排列！\n\n二进制 vs. 十进制\n紧凑性：\n十进制表示法相对于二进制来说更加紧凑。在十进制中，每个数字位可以表示 0 到 9 的十种可能性，而在二进制中，每个数字位只能表示 0 或 1。\n举例来说，十进制数 22 在二进制中表示为 10110。这显示了相同的数值在二进制中需要更多的位数来表示，因此十进制更加紧凑。\n\n\n人类友好性：\n十进制对于人类而言更为方便。我们平时使用的数字系统就是十进制，因此我们对十进制的理解更为直观。\n十进制适用于日常计数和描述，而且人们更容易在十进制下进行数学运算和表达。\n\n\n计算机友好性：\n二进制对计算机更为“方便”和自然。计算机内部使用的是二进制系统，因为它符合计算机底层硬件的物理性质，如开关的两种状态（ON/OFF）。\n二进制适用于数字电路和逻辑门的设计，利用了电子元件的两种状态来表示数字和执行计算。\n\n\n技术实现：\n十进制更适合人类使用的日常活动，例如货币、时间等，因为这些活动通常使用十进制的度量单位。\n二进制更适用于计算机内部数据表示和处理，因为计算机的操作是通过电子开关的开启和关闭来实现的，这是二进制的基本特性。\n\n\n\n十进制更适合人类的日常生活和数学运算，而二进制更适合计算机的底层操作和数据存储。\n十六进制（Hexadecimal）十六进制（Hexadecimal）是一种基数为 16 的数制系统，使用 0-9 和 A-F（或 a-f）共 16 个字符表示数字。在计算机科学和编程领域，十六进制常用于表示二进制数据的更紧凑形式。\n概念\n符号表示：\n十六进制使用 0-9 表示数字 0 到 9，同时使用 A-F（或 a-f）表示 10 到 15，其中 A 表示 10，B 表示 11，一直到 F 表示 15。\n\n\n基数和权重：\n十六进制是基数为 16 的系统，每个位置的权重是 16 的幂。从右到左，权重依次为 ,,,…。\n\n\n与二进制的关系：\n十六进制非常方便地与二进制相互转换。一个十六进制数的每一位可以直接对应于四个二进制位，这使得在表示二进制数据时更为紧凑。\n\n\n示例：\n十六进制数经常以前缀 “0x”（或 “0X”）开头，以表示其数制。例如， 表示十进制数 42，其中 2A 中的 2 表示 ，A 表示 。\n\n\n\n转换示例：\n\n十六进制到二进制：\n将每个十六进制数字替换为对应的四位二进制数即可。\n\n\n十六进制到十进制：\n将每个十六进制数字乘以相应权重并相加。\n\n\n二进制到十六进制：\n将二进制数按照每四位一组转换为对应的十六进制数字。\n\n\n\n十六进制与二进制\n紧凑性：\n十六进制更加紧凑，因为一个十六进制数字可以表示四个二进制位。每个十六进制数字等效于一个四位的二进制数，这使得在表示二进制数据时更为简便。\n\n\n对应关系：\n每个十六进制数字对应于四位二进制数，具体对应关系如下：\n\n\n\n0: 0000    4: 0100    8: 1000    C: 1100\n1: 0001    5: 0101    9: 1001    D: 1101\n2: 0010    6: 0110    A: 1010    E: 1110\n3: 0011    7: 0111    B: 1011    F: 1111\n\n二进制到十六进制转换将二进制数转换为十六进制数是一种常见的操作，其中每四个二进制位对应于一个十六进制数字。\n将二进制数分组：\n\n从二进制数的右侧开始，每四个二进制位一组，不足四位的在左侧补0。\n\n找到对应的十六进制数字：\n\n将每个四位二进制数转换为对应的十六进制数字。使用下表进行对应：\n\n0000: 0    1000: 8\n0001: 1    1001: 9\n0010: 2    1010: A\n0011: 3    1011: B\n0100: 4    1100: C\n0101: 5    1101: D\n0110: 6    1110: E\n0111: 7    1111: F\n\n排列得到十六进制数：\n\n将得到的十六进制数字从右向左排列，得到最终的十六进制数。\n\n示例：\n考虑二进制数 1101 1010 1011  的转换：\n\n将二进制数分组得到 1101 1010 1011。\n将每组四位二进制数转换为十六进制得到 。\n\n因此， 转换为十六进制为 \n注意事项：\n\n每个四位的二进制数可以直接映射到一个十六进制数字，这样就可以更紧凑地表示大型二进制数。\n这种转换在计算机领域中常用于优化和简化二进制数据的表示，尤其是在寻址和存储等方面。\n\n十六进制转换成十进制这个跟二进制转换成十进制差不多，没什么区别，就是权重不一样的问题。\n自己看上面。\n对应的，十进制转十六进制，byd都会十进制转二进制了，那就先转二进制然后用二进制再转十六进制不就好了？\nQ&amp;A定义“比特”：比特（bit）是信息的最小单元，是计算机中最基本的数据单元，可以表示二进制的0或1。\n**十进制表示法比二进制更紧凑。 (T or F) **：正确。\n二进制对计算机更“方便”是因为？：这是因为计算机内部使用的是二进制系统，其硬件电路更容易实现对二进制数据的处理和存储。这使得计算机能够更有效地执行基本操作，例如逻辑运算和位操作。\n每个数字都可以用作基数。 (T or F)：错误。不是每个数字都可以用作基数。基数是表示数字的系统中使用的数字的数量，通常是正整数。数字通常用来表示进制系统中的位数。\n十六进制表示法使用？作为基数：十六进制表示法使用16作为基数，因此它包括0-9的十个数字和A-F的六个字母，分别表示10-15。\n八进制表示法使用？作为基数：八进制表示法使用8作为基数，因此它包括0-7的八个数字。\n为什么我们使用十六进制，或者说基数为16的数字表示法？ 十六进制常用于计算机科学和编程领域，原因如下：\n\n紧凑性： 十六进制表示法比二进制更紧凑，因为一个十六进制数字可以表示4个二进制位。这样有助于人们更容易读写和记忆长的二进制串。\n二进制转换： 十六进制与二进制之间的转换相对简单，每个十六进制数字对应于4位二进制，这样在处理二进制数据时更为方便。\n颜色表示： 在计算机图形学和Web开发中，RGB颜色通常以十六进制表示，例如#RRGGBB，其中RR、GG、BB分别表示红、绿、蓝分量。\n\nASCII编码需要多少比特进行编码？ ASCII（美国信息交换标准代码）使用7位来表示每个字符，因此每个字符需要7比特进行编码。原始的ASCII标准使用了7位，后来扩展的ASCII标准使用了8位，但常用的ASCII字符仍然只需要7位。\n","slug":"CPT101-Review-4","date":"2023-12-11T10:50:04.000Z","categories_index":"","tags_index":"CPT101复习,笔记","author_index":"General_K1ng"},{"id":"6ab5e8bf78dcc1c37aef3c4bb9344969","title":"CPT101 Review-3","content":"继续复习下一章，总感觉每节课讲的东西相似性都好高。\n机器指令和高级语言不是，之前都讲过了为什么还有。\n\n机器指令（Machine Instructions）：\n定义：机器指令是计算机硬件可以直接执行的基本操作。每一条机器指令对应于一个特定的操作，如加法、乘法、加载数据等。计算机的中央处理单元（CPU）能够理解和执行这些指令。\n指令集体系结构（Instruction Set Architecture，ISA）：ISA 定义了计算机体系结构的底层接口，包括机器指令的种类、格式以及它们的操作码。ISA 是硬件和软件之间的桥梁，确保软件能够正确地与硬件交互。\n机器指令的执行过程：计算机通过从内存中读取指令，解码指令，执行指令，然后更新状态来执行程序。机器指令直接操作计算机硬件，因此它们对应的是底层的硬件操作。\n\n\n高级语言（High-Level Language，HLL）：\n定义：高级语言是一种更接近人类语言的编程语言，例如C、Java、Python等。它们通过抽象化，提供了更高层次的抽象，使程序员能够更容易地表达算法和逻辑。\n编译和解释：HLL 代码需要通过编译器或解释器转换为机器代码才能在计算机上执行。编译器将整个源代码文件转换为目标机器代码，而解释器逐行解释执行源代码。\n优势：HLL 提高了程序员的生产力，使得编写和维护程序更加容易。程序员可以更专注于问题的逻辑结构，而不必过于关注底层的硬件细节。\n劣势：相对于直接使用机器指令编写的程序，HLL 代码可能会在性能上有所损失。这是因为编译器或解释器引入了额外的开销，而且有时候难以充分利用底层硬件的特性。\n\n\n\n语义鸿沟“Semantic gap”是一个计算机科学领域的术语，用于描述不同抽象层次之间的理解或表达上的差异。在计算机系统和编程语言中，语义差距通常涉及高级语言（High-Level Language，HLL）和机器指令之间的差异。\n\n在高级语言和机器指令之间的语义差距：\n高级语言层次：高级语言（如C、Java、Python）提供了更抽象的编程概念，允许程序员使用更自然、更易读的语法来表达算法和逻辑。高级语言屏蔽了底层硬件细节，提供了更高层次的抽象。\n机器指令层次：机器指令是计算机硬件能够直接执行的低级指令。它们通常包括对寄存器和内存的直接访问，以及基本的算术和逻辑操作。机器指令更接近计算机硬件的实际操作。\n语义差距：语义差距体现在高级语言和机器指令之间的概念和操作的不同。高级语言的一个语句可能对应多条机器指令，而机器指令的执行可能需要多个高级语言语句。此外，一些高级语言特性（如对象、异常处理）在机器指令层面可能没有直接的对应。\n\n\n解决语义差距的方法：\n编译器和解释器：编译器负责将高级语言的代码翻译成机器指令，而解释器则逐行地执行高级语言代码。这两者都是为了解决高级语言和机器指令之间的语义差距。\n优化技术：编译器通常会应用各种优化技术，以尽量减小高级语言和机器指令之间的性能差距。这包括指令调度、寄存器分配、循环展开等技术，以便生成更有效率的机器代码。\n抽象层次的设计：计算机体系结构的设计需要考虑如何提供足够的抽象，使得高级语言可以方便地映射到底层硬件，同时不牺牲性能。指令集体系结构的设计就是为了在高级语言和机器指令之间提供适当的抽象。\n\n\n\n翻译也就是说，人类说的，就算是这些高级语言直接给机器去看，机器也是看不懂的，那么就需要有一种可以翻译给机器看的工具。\n\n编译器（Compilers）：\n定义：编译器是一种特殊程序，负责将高级语言（HLL）的源代码翻译成目标机器的机器代码。这个过程被称为编译，生成的目标代码可以在计算机上直接执行。\n翻译过程：编译器分为多个阶段，包括词法分析、语法分析、语义分析、中间代码生成、优化和目标代码生成等。每个阶段都有特定的任务，最终目的是将高级语言的抽象表示翻译成等效的机器指令。\n优势：编译的目标代码通常在运行时执行效率较高，因为编译器可以进行全局的优化，产生针对目标平台的高效代码。\n\n\n汇编器（Assemblers）：\n定义：汇编器是一种翻译程序，负责将汇编语言中的助记符（mnemonics）翻译成对应的二进制机器码。汇编语言是一种低级别的编程语言，更接近机器指令的表示形式。\n翻译过程：汇编器的任务是将汇编语言源代码中的助记符和操作数转换为机器指令的二进制表示。例如，将MOV（移动数据）或ADD（加法）等指令转换为相应的二进制码。\n优势：与编译器不同，汇编器生成的目标代码是针对特定的机器体系结构的，因此更加直接和底层。这使得程序员可以更好地控制生成的机器代码。\n\n\n解释器（Interpreters）：\n定义：解释器是一种程序，能够在运行时逐行解释高级语言代码并将其转换为机器指令。与编译器不同，解释器不生成目标代码文件，而是动态地执行源代码。\n翻译过程：解释器逐行解释高级语言的源代码，将其翻译成机器指令并立即执行。这个过程是即时的，不需要事先生成目标代码文件。\n优势：解释器使得程序的修改和调试更加灵活，因为程序员可以在运行时查看和修改代码。然而，由于解释的性质，解释执行通常比编译执行慢一些。\n\n\n\n几种ERROR\n编译时错误：\n定义：编译时错误是在程序编译阶段发生的错误。这些错误阻止程序从源代码成功地转换为机器代码。\n处理：当发生编译时错误时，编译器会生成错误消息，指示错误在源代码中的位置和性质。程序员需要查看并修复这些错误，然后才能成功编译程序。\n\n\n链接：解决外部引用：\n定义：链接是在编译后发生的过程，在这个过程中，链接器组合各个编译的代码模块并解决它们之间的外部引用，创建最终的可执行文件。\n处理：在链接过程中，链接器解析当前模块中未定义但在其他模块中引用的符号和地址。如果存在未解决的外部引用，链接将失败。程序员需要确保所有必要的模块和库正确链接。\n\n\n链接时错误：\n定义：链接时错误发生在链接阶段，当链接器遇到未解决的符号或不兼容的模块时。\n处理：如果发生链接时错误，程序员需要检查链接器提供的错误消息。这些消息通常指示引起问题的符号或引用。需要通过在链接过程中提供缺失或正确的模块或库来解决这些错误。\n\n\n装载时错误：\n定义：装载时错误发生在可执行文件被加载到内存执行时。这些错误可能包括缺失的动态库或不兼容的可执行文件格式。\n处理：当发生装载时错误时，操作系统或加载程序会生成错误消息。程序员需要确保所有必需的库可用并且兼容。解决装载时错误可能涉及提供必要的依赖项或以正确的设置重新编译程序。\n\n\n\n\n链接链接（Linking）是计算机程序开发中的一个重要概念，涉及将由多个源代码文件或模块组成的大型程序的各部分整合在一起，形成可执行文件的过程。这一过程包括解析符号、地址映射和生成最终的可执行文件。以下是链接的主要概念和工作原理：\n\n大型程序的模块化设计：\n原因：大型程序通常被分解为多个独立的模块或部分，这样做有多个好处。首先，模块化设计提高了代码的可维护性，每个模块可以独立开发和测试。其次，团队可以并行地开发不同的模块，提高了开发效率。最后，模块化设计使得代码更易于理解和重用。\n\n\n模块之间的引用：\n需求：在大型程序中，一个模块可能需要引用另一个模块中的数据或子程序。这种引用涉及到如何在编译时和链接时处理这些跨模块的引用。\n\n\n符号解析：\n定义：当一个模块引用另一个模块的数据或函数时，引用的标识符称为符号。在链接阶段，需要解析这些符号，确定它们的确切地址。\n\n\n地址映射：\n定义：链接器负责将各个模块的地址映射到最终的内存位置。这包括分配内存地址，解决相对地址，确保各个模块之间的地址空间不冲突。\n\n\n生成可执行文件：\n定义：最终链接的结果是生成一个可执行文件，该文件包含了所有模块的机器代码，并且这些代码已经被正确地组织和映射到内存中。这个可执行文件可以被加载到内存并执行。\n\n\n静态链接 vs. 动态链接：\n静态链接：在编译时将所有模块的代码和数据都合并到一个单独的可执行文件中。这个文件独立于外部的模块，因此可以在不同的环境中运行。\n动态链接：在运行时，程序使用动态链接库（DLL）或共享对象文件来链接程序。这样，多个程序可以共享同一份库，减小了可执行文件的大小。\n\n\n\n\n这个图表包括了编写代码、编译阶段、链接阶段、装载阶段、执行阶段和错误处理，详细展示了链接阶段的符号解析和地址映射过程。\n\n编译器无法解决模块间引用：\n原因：编译器负责将源代码翻译成二进制代码，但在这个过程中，它无法解决对其他模块的引用。编译器只能将当前模块的源代码翻译成机器代码，对于其他模块的代码或数据的确切位置和内容，编译器是不了解的。\n意义：这导致了在编译阶段，对其他模块的引用仍然是符号化的，也就是说，它们只是符号或标识符，并没有具体的内存地址或数据。\n\n\n链接器的作用：\n定义：链接器在整个程序构建过程中发挥了关键作用。它的任务是将编译器生成的各个模块的二进制代码组合在一起，同时解决模块间的外部引用。\n解决外部引用：链接器通过将模块的符号与其具体的内存地址相连接，解决了这些外部引用。在这一过程中，符号解析将模块中使用的符号映射到其他模块中相应的符号。\n生成可执行文件：链接器的最终目标是生成一个可以被加载和执行的可执行文件。这个文件包含了所有模块的代码和数据，它们都已经被正确地连接和映射。\n\n\n外部引用的符号化：\n状态：在链接之前，那些引用其他模块的地方仍然是符号，而不是具体的内存地址。这些外部引用是待解决的符号。\n\n\n链接器的错误处理：\n查找模块或代码：当链接器在连接过程中找不到被引用的模块或代码时，它将报告错误。这可能是由于模块未被正确编译、模块不存在，或者符号引用的代码或数据未在可用的模块中找到。\n错误报告：链接器的错误报告通常指示出错的地方和原因，使得程序员能够定位和解决这些问题。\n\n\n\n库文件Library files（库文件）是在计算机科学和软件开发中常见的一种文件类型，它们起到了组织和重用代码的重要作用。Library files 包含了预先编写好的代码、函数、类或数据结构，这些可以被其他程序或模块引用。以下是有关 Library files 的详细解释：\n用最简单的话来说，库文件就像是一本工具书。你可以在这本书里找到很多已经写好的方法和函数，比如计算两个数字相加的方法、判断条件的方法等等。这些方法就是工具书里的“章节”或“知识点”。\n有两种主要类型的库文件：\n\n静态库：就像你把整本工具书都复印下来，放在你的书包里。这样，当你需要用到书里的方法时，它们就直接在你的程序里，方便使用。但是，这也让你的书包变得有点大。\n动态库：这次，你只带了一份“使用说明书”（头文件），里面写着怎么使用工具书里的方法。而真正的工具书（库文件）在需要的时候才被拿出来，用完再放回去。这样，书包轻巧了很多，但是使用的时候需要一点点额外的工作。\n\n在写程序的时候，我们需要告诉计算机去哪里找这些库文件，就像告诉它在哪里找工具书一样。这个过程就是链接阶段，而链接器就像是我们的导航，帮我们把各个部分都连接在一起。\n在Unix系统中，这些库文件通常存放在 /lib 和 /usr/lib 这两个文件夹里，就像把字典放在图书馆一样。而在Windows系统中，这些库文件通常是DLL（动态链接库）文件，就好比把字典分成了几个部分，只在需要的时候拿出来用。\n所以，简单来说，这些库文件就是程序员提前写好的方法书，我们可以在程序中引用它们，但要想真正使用，就得在链接的时候把它们连接到我们的程序里。\n解释器\n\n逐行解释：解释器按行读取高级语言代码。\n翻译成低级语言：解释器将每一行翻译成计算机能执行的低级语言。\n逐行执行：计算机逐行执行翻译后的低级语言。\n输出结果：程序执行完毕，输出最终结果。\n\n在这个流程中，错误可能发生在两个地方：\n\n语法错误：当解释器读取高级语言代码时，如果发现了语法错误，就会在翻译这一步骤报告错误。\n运行时错误：当计算机执行翻译后的低级语言时，如果发现了运行时错误（比如除零错误），就会在执行这一步骤报告错误。\n\n工作流程可以直接看上面的图，举个例子来说的话：\n\n高级语言代码：程序员用高级语言（比如BASIC或Java）编写程序。\n转换为中间形式：解释器首先将这些高级语言的指令转换成一种叫做中间形式的东西，它包含了很多小的单元，我们称之为“标记”（Tokens）。\n例子：在Java中，这些标记可以是诸如 static、boolean、file、string、void、return等。\n\n\n解码执行：然后，这些标记会被传递给解释器的解码器，它的工作就是根据这些标记选择合适的例行程序或方法进行执行。\n例子：如果解释器看到 static 这个标记，它会知道要处理静态方法；如果看到 return，它会知道要处理返回值的相关操作。\n\n\n执行：最后，解释器开始执行所选的例行程序或方法。\n\n这个过程就好像在翻译一本书一样：我们先将原文（高级语言代码）翻译成中间语言（标记），然后根据中间语言选择合适的翻译规则（解码执行），最后按照规则翻译成另一种语言（机器语言），以便计算机能够理解和执行。\n在这个过程中可能发生的错误：\n\n如果高级语言代码有语法错误，解释器会在转换为中间形式的过程中报告错误。\n如果在执行的时候遇到了问题，比如尝试使用一个不存在的方法，解释器也会报告相应的运行时错误。\n\n对比编译器编译器（Compilers）1. 整体翻译： 编译器就像是一本翻译专家。当你写好整个程序（比如用高级语言写的）时，编译器会把整个程序一次性地翻译成计算机能理解的机器代码。\n2. 独立翻译和执行： 翻译和执行是分开的步骤。首先，整个程序被翻译成机器代码，然后这个机器代码可以被多次执行，就像你只需翻译一次一样。\n3. 例子： 就好比你写一篇文章，翻译专家把整篇文章都翻译成另一种语言，然后其他人可以反复阅读这篇翻译好的文章。\n解释器（Interpreters）1. 逐行翻译： 解释器像是一个实时翻译的人。当你写好一行代码时，解释器会逐行地翻译并立即执行。\n2. 翻译和执行交替进行： 翻译和执行是交替进行的。一行代码翻译一行，然后立即执行。这就像是你一边说一边由翻译人员实时翻译。\n3. 例子： 想象你在旅行，每当你说一句话，导游都会立即翻译并告诉司机要去哪里。这就是解释器的工作方式。\n对比：\n编译器是整体的翻译专家，而解释器是实时的翻译人员。\n编译器的翻译和执行是分开的，而解释器的翻译和执行是交替进行的。\n\nC语言的编译，链接和执行\nJava的编译，链接和执行\n解释器和计算机硬件的相似性解释器在某种程度上类似于计算机硬件（中央处理器，CPU）。它们都是按照一条指令一次执行的原理工作。\n\n逐条执行： 就像计算机硬件逐条执行机器指令一样，解释器逐条执行高级语言的指令。\n虚拟机概念： 由于解释器一次执行一条指令，有时候我们将其称为虚拟机。它是一个在软件层面上模拟硬件行为的机器。\n例子： 一个典型的例子是Java虚拟机（JVM）。JVM被称为Java虚拟机，因为它执行Java字节码，这是一种中间代码，而不是直接执行机器代码。JVM充当了一个虚拟的计算机，能够解释和执行Java程序。\n\nJava虚拟机（JVM）Java虚拟机（JVM）是一种特殊的解释器，它执行Java程序。它有以下特点：\n\n字节码执行： JVM不直接执行Java源代码，而是将Java源代码编译成字节码。字节码是一种中间形式，类似于汇编语言，但不是直接的机器代码。\n平台独立性： 由于JVM执行字节码，Java程序可以在任何安装了Java虚拟机的计算机上运行，而不受底层硬件和操作系统的影响。这使得Java具有良好的跨平台性。\n动态优化： JVM还具有一些优化机制，例如即时编译（Just-In-Time Compilation，JIT）。JIT编译器将字节码转换为本地机器代码，从而提高程序的执行效率。\n垃圾回收： JVM还负责Java程序的内存管理，包括垃圾回收。这有助于释放不再使用的内存，提高程序的健壮性。\n\n代码的共享与复用在软件开发中，代码共享和重用是一个重要的问题。当我们开发新系统时，如何有效地重用已有的经过验证的软件呢？有几种解决方案：\n1. 源代码级别的子程序和宏库（Source-level Subroutines and Macro Libraries）这是一种基本的重用方法。开发者可以编写通用的子程序（也称为函数或方法）和宏，然后将它们保存在库中。其他开发者可以在新的项目中引用这些库，并在其源代码中调用这些子程序或宏。\n优势：\n\n灵活性高，可以根据需要进行修改和定制。\n代码的可读性好，因为直接看到了源代码。\n\n缺点：\n\n每次使用都需要重新编译，可能导致额外的工作量和时间消耗。\n不够灵活，因为源代码一旦编译，就不再能够适应不同的环境或需求。\n\n2. 预转换的可重定位二进制库（Pre-translated Re-locatable Binary Libraries）这种方法是在开发阶段将源代码编译成可重定位的二进制库，而不是在每次使用时都重新编译。其他开发者可以将这些预编译的库链接到他们的项目中。\n优势：\n\n节省了重新编译的时间，提高了效率。\n提供了一定程度的代码隐藏，因为其他开发者不直接看到源代码。\n\n缺点：\n\n编译时需要考虑目标平台，可能导致平台兼容性问题。\n不够灵活，因为库的功能和接口在编译时已经确定，无法在运行时进行修改。\n\n3. 动态库和动态链接（Dynamic Libraries and Dynamic Linking）这是一种更为灵活和动态的重用方法。在运行时，程序可以动态地加载和链接库，而不是在编译时。这种方式在现代软件开发中非常常见。\n优势：\n\n具有更高的灵活性，可以在运行时加载和卸载库。\n允许共享库的不同版本，避免了一些版本兼容性问题。\n节省了存储空间，因为库在运行时才被加载。\n\n缺点：\n\n运行时开销相对较高，因为需要进行动态链接。\n一些错误可能在运行时才被发现，而不是在编译时。\n\n\n\n源代码级别的子程序和宏库： Main.c 调用了 Util.c 中的功能。这是源代码级别的重用。\n预转换的可重定位二进制库（静态库）： 当有新的 Util_v2.c 版本时，它被编写、编译，并形成静态库。Main.c 可以链接到这个静态库，形成可执行文件。\n动态库和动态链接： 当有新的 Util_v3.c 版本时，它被编写、编译，并形成动态库。Main.c 可以链接到这个动态库，形成可执行文件。动态库在运行时加载，而不是在编译时链接。\n\n源代码级别的子程序和宏库意图：使用源代码级别的子程序和宏库的目的是在开发新系统时，通过以下步骤实现代码重用：\n\n获取库例程的副本： 获取库中的例程的副本，通常是复制源代码或者从已有的库中提取。\n将其编辑到新代码中： 将所选的例程编辑并整合到新的代码中，以满足新系统的需求。\n一起进行整体翻译： 最终，将整个代码进行翻译，生成新系统的可执行文件。\n\n缺点：\n代码归属问题： 由于对库中例程的编辑和整合，产生了一个问题，即这些修改后的例程的归属问题。谁拥有修改后的代码？是原始库的所有者还是进行了修改的开发者？\n维护责任问题： 同样，由于进行了修改，存在一个维护责任的问题。谁应该负责维护这些修改后的代码？是原始库的维护者还是修改代码的开发者？\n\n预转换的可重定位二进制库意图：预转换的可重定位二进制库的意图在于：\n\n预先翻译为可重定位二进制代码： 库中的例程在开发之前被预先翻译为可重定位二进制代码。这表示这些库例程已经编译成机器代码，但其地址信息还没有最终确定。\n可以链接到新代码中，但不能更改： 这些预转换的库可以被链接到新的代码中，但不能被修改。开发者可以使用这些例程，但不能编辑它们。\n\n接受度：这种方式已经被广泛接受，并在当今所有的软件开发中仍然是必不可少的。它提供了一种有效的代码重用方式，同时降低了代码所有权和维护责任的不确定性。\n缺点：然而，这种方式也有缺点：\n\n每个程序拥有私有副本的缺点： 每个程序都需要拥有自己的私有副本库，这会浪费宝贵的内存空间，并在多任务系统中交换时浪费时间。\n\n‘可重定位’的含义：在这个上下文中，”可重定位” 意味着生成的二进制代码中包含了一些未定的地址信息。这些地址信息在加载时会被系统调整，以便适应新程序的地址空间。这种可重定位性使得库例程可以在不同的程序中使用，因为加载时可以动态调整地址，而不会导致冲突。\n动态库和动态链接意图：动态库和动态链接的主要目标是：\n\n加载使用已经加载到内存中的“公共”例程的程序： 允许程序加载已经在内存中的“公共”例程，而不是在每个程序中都拷贝一份。这样可以避免内存浪费，提高效率。\n通过内存管理系统映射内存驻留的库： 内存中驻留的库被映射到程序的地址空间中，通过内存管理系统控制访问，避免多次拷贝代码。\n映射到什么地方： 动态库在内存中被映射到特定的地址空间，以便程序可以调用其中的例程。\n\n接受度：这种方式取得了成功，特别是通过微软的ActiveX标准。动态链接和动态库已经成为现代软件开发的重要组成部分。\n优势：\n节省内存空间： 动态库的代码不需要每个程序都拷贝一份，因此节省了内存空间。\n避免多个代码副本： 动态链接避免了多个程序之间存在相同代码的问题，因为它们共享动态库。\n运行时加载： 动态库在运行时加载，而不是在编译时链接，这提高了灵活性和可维护性。\n\nMicrosoft’s ActiveX：ActiveX 是由微软公司提出的一种技术标准，它使得在网络环境中能够运行各种不同类型的程序。ActiveX 控件是可以被嵌入到网页中的可执行程序，允许在网页上运行交互式应用程序。这个标准成功地推动了动态链接和动态库的应用，特别是在Windows平台上。\nQ&amp;A高级编程语言（HLL）的四个例子是：\n\nC++\nJava\nPython\nRuby\n\n翻译填补计算机系统中的语义差距（True or False？）\n\nTrue\n\n翻译的三种不同方式及其关键作用：\n\n源代码翻译（Source-to-Source Translation）：\n关键作用： 将源代码从一种高级语言翻译成另一种高级语言，便于跨平台开发和移植。\n\n\n编译器翻译（Compiler Translation）：\n关键作用： 将高级语言源代码翻译成机器语言或中间代码，使计算机能够执行程序。\n\n\n解释器翻译（Interpreter Translation）：\n关键作用： 逐行解释执行源代码，无需编译成机器代码，便于调试和交互式开发。\n\n\n\n当发生编译时错误时，我们应该做什么？\n\n当编译时错误发生时，需要检查源代码中的错误，并逐一修复这些错误。这可能涉及到语法错误、类型错误或其他编译器无法处理的问题。修复错误后，重新进行编译。\n\n链接的目的是什么？\n\n目的：\n 链接是将多个目标文件合并成一个可执行文件的过程，其主要目的有三：\n\n符号解析（Symbol Resolution）： 将程序中使用的符号与其实际地址关联起来，解决外部引用。\n地址绑定（Address Binding）： 将程序中的变量和地址关联，使得程序在内存中正确加载。\n库链接（Library Linking）： 将程序中使用的库函数的代码合并到可执行文件中，减少对外部库的依赖。\n\n\n\n‘Loading’在程序编译后的‘linking’之前执行。（True or False?）\n\nFalse\n解释： 在编译后，程序首先进行链接（linking），将多个模块组合成一个可执行文件。加载（loading）则发生在链接之后，将可执行文件加载到内存中供计算机执行。\n\n程序模块可以分别进行编译。（True or False?）\n\nTrue\n解释： 是的，程序的不同模块可以分别进行编译，这种模块化的编译方式有助于提高代码的可维护性和灵活性。\n\n编译器可以将一个模块翻译成二进制代码，但无法解决对其他模块的引用。这发生在什么时候？\n\n当编译器无法解决对其他模块的引用时，这通常发生在链接阶段。编译器生成的目标文件中可能包含对其他模块或库的引用，而这些引用的解析和绑定发生在链接过程中。\n\n库文件如果链接到程序代码中是可用的。（True or False?）\n\nTrue\n解释： 是的，将库文件链接到程序代码中是常见的做法。这样可以使程序访问库中定义的函数和功能，提供了代码重用和模块化开发的优势。\n\n解释器通常将程序代码转换成什么？\n\n解释器通常将程序代码转换成中间代码或直接执行代码，而不是生成独立的可执行文件。这中间代码可以由解释器逐行执行，或者通过虚拟机进行解释执行。\n\n程序编译的输出是什么？\n\n程序编译的输出是目标文件或可执行文件。目标文件包含了源代码翻译成的机器代码或中间代码，而可执行文件是链接了所有必要模块并准备好在计算机上运行的文件。\n\n两种情况下解释器比编译器更有用的场景是：\n\n交互式开发（Interactive Development）： 在交互式开发中，解释器能够逐行执行代码，立即显示结果，方便程序员调试和测试。\n动态语言支持（Dynamic Language Support）： 解释器对于动态语言的支持更为灵活，能够在运行时动态地处理类型和内存管理，而不需要预先编译生成可执行文件。\n\n解释器有时被称为虚拟机，因为…？\n\n解释器有时被称为虚拟机，因为它能够模拟计算机硬件的行为，通过逐行执行中间代码或直接执行源代码来实现程序的运行。\n\n代码共享的三种方法包括：\n\n静态链接（Static Linking）： 在编译时将代码合并成一个可执行文件，形成独立的执行单元。\n动态链接（Dynamic Linking）： 在运行时加载共享库文件，以便多个程序可以共享相同的库，减少内存占用。\n代码复制（Code Duplication）： 直接将代码复制到多个地方，以实现共享，但可能导致代码冗余。\n\n宏库的两个缺点（或问题）是：\n\n可读性和维护性差： 宏库中的宏通常是代码片段的文本替换，可能导致代码可读性差，难以维护和调试。\n潜在的命名冲突： 使用宏库时，可能出现命名冲突的问题，因为宏在全局范围内进行文本替换，可能与其他部分的代码发生冲突。\n\n库可以链接到程序代码中，但不能被修改。（True or False?）\n\nTrue\n解释： 是的，库文件通常被链接到程序代码中，但一旦链接完成，它们通常不能被修改。程序在运行时可以使用这些库提供的功能，但不能直接修改库中的代码。\n\n使用预先翻译的程序库进行程序执行的缺点是什么？\n\n性能损失： 预先翻译的程序库可能不够灵活，无法优化以适应不同的执行环境，导致性能损失。\n版本兼容性： 如果程序库和目标环境的版本不匹配，可能导致兼容性问题，需要额外的处理和管理。\n\n存在一个动态库和动态链接的事实标准。（True or False?）\n\nTrue\n解释： 是的，存在一些事实上的标准，例如在许多Unix-like系统中广泛使用的ELF（Executable and Linkable Format）格式，以及在Windows系统中使用的DLL（Dynamic Link Library）格式。这些标准定义了动态库的结构和动态链接的规范，使得不同的软件和系统能够更好地协同工作。\n\n","slug":"CPT101-Review-3","date":"2023-12-10T10:39:50.000Z","categories_index":"","tags_index":"CPT101复习,笔记","author_index":"General_K1ng"},{"id":"e585c831fab448b304cde81e18fc31a2","title":"CPT101 Review-2","content":"期末考试，细算留一个月用来复习好像是真的有点紧了，甚至现在都不只一个月。\n101就按部就班，下周需要复习107，101就跟着感觉走算了。\nIPO模型Input-Process-Output (IPO) 模型是描述计算机功能和工作原理的基本概念。这个模型简要地阐述了计算机是如何接收输入、经过处理后产生输出的过程。\n\nInput（输入）：\n输入是计算机系统接收的信息、数据或指令。\n输入可以来自各种来源，包括键盘、鼠标、触摸屏、传感器、网络等。\n输入可以是用户提供的命令、数据、或外部设备发送的信号。\n\n\nProcess（处理）：\n处理阶段是计算机对输入进行操作、运算和处理的阶段。\n在这个阶段，计算机执行各种算法、程序和操作，以转换输入数据为有意义的输出。\n处理包括运算、逻辑判断、存储、检索等操作，这些都是由计算机的中央处理单元（CPU）执行的。\n\n\nOutput（输出）：\n输出是计算机处理完输入后生成的结果、数据或信息。\n输出可以呈现在屏幕上，通过打印机输出，或者通过网络传送给其他系统。\n输出可以是用户期望的反馈、计算结果、图形显示等。\n\n\n\n组成部分施Input-Process-Output（IPO）模型和von Neumann模型需要三个主要组成部分：\n\n硬件（Hardware）：\n硬件包括计算机的物理部分，是实体的组成部分。\n输入设备、中央处理单元（CPU）、内存、输出设备、存储设备以及总线系统等都属于硬件。\n硬件提供了执行计算、存储数据和与外部环境交互的基本能力。\n\n\n软件（Software）：\n软件是计算机程序和数据的集合，是一系列指令的集合，指导硬件执行各种任务。\n操作系统是一种关键的系统软件，管理硬件资源，提供用户与计算机的接口。\n应用程序是用户使用的软件，例如文字处理软件、游戏、图形设计工具等。\n\n\n被操纵的数据（Data that is being manipulated）：\n数据是计算机系统的关键元素，是输入、处理和输出的基础。\n输入数据是通过输入设备提供给计算机的信息。\n处理阶段涉及对数据的运算、逻辑判断、转换等操作。\n输出数据是计算机处理后生成的结果，可以是文本、图形、声音等形式。\n\n\n\n这三个组成部分共同构成了计算机系统，实现了输入、处理和输出的整个工作过程。von Neumann模型也涵盖在这个框架内，它是一种描述计算机体系结构的模型，其中指令和数据存储在同一存储器中，由中央处理单元按顺序执行。这个模型强调了程序存储器的概念，使计算机能够根据存储在内存中的指令来执行不同的任务。\n硬件硬件是计算机系统的物理组成部分，它执行计算、存储和输入输出等基本功能。以下是硬件的主要组成部分：\n\n中央处理单元（Central Processing Unit，CPU）：\n\nCPU是计算机的核心，负责执行指令并控制其他硬件组件。\n它包括算术逻辑单元（ALU）执行算术和逻辑运算，控制单元执行指令的控制和协调。\n\n\n内存（Memory）：\n\n内存用于存储当前正在执行的程序和数据。\n随机存取存储器（RAM）提供了临时存储，以便CPU能够快速访问和修改数据。\n只读存储器（ROM）存储固定的程序和数据，通常用于存储系统引导程序。\n\n\n输入设备（Input Devices）：\n\n输入设备允许用户将数据或指令输入计算机系统。\n常见的输入设备包括键盘、鼠标、触摸屏、扫描仪、摄像头和传感器等。\n\n\n输出设备（Output Devices）：\n\n输出设备用于显示计算机处理后的结果。\n显示器、打印机、扬声器等都是常见的输出设备。\n\n\n存储设备（Storage Devices）：\n\n也叫二级存储（Secondary storage）\n\n存储设备用于永久性存储数据和程序。\n\n硬盘驱动器、固态硬盘、光盘驱动器等属于存储设备，提供长期的数据保存。\n\n\n\n总线系统（Bus System）：\n\n总线是计算机内部各个组件之间传输数据和指令的通道。\n数据总线传输数据，地址总线指定数据的存储位置，控制总线传输控制信号。\n\n\n图形处理单元（Graphics Processing Unit，GPU）：\n\nGPU专门用于处理图形和图像相关的计算。\n在图形渲染、游戏图形处理等方面发挥着重要作用。\n\n\n主板（Motherboard）：\n\n主板是所有硬件组件的主要连接点，提供电源和数据传输的基础。\n它包括CPU插槽、内存插槽、扩展插槽（用于插入显卡、网卡等），以及连接各个组件的总线。\n\n\n电源供应（Power Supply）：\n\n电源供应单元为计算机提供所需的电能。\n它将电能转换为适用于计算机各个组件的电压和电流。\n\n\n\n软件我怎么记得上篇讲过这些？\n软件是计算机系统中的非物理部分，它是一组指令和数据的集合，用于指导计算机硬件执行各种任务。软件可以分为两类：系统软件和应用软件。\n\n系统软件（System Software）：\n操作系统（Operating System）：操作系统是系统软件的核心，它管理计算机的硬件和提供用户与计算机系统交互的界面。常见的操作系统包括Windows、macOS、Linux等。\n设备驱动程序（Device Drivers）：设备驱动程序是与硬件通信的软件，它们允许操作系统与硬件设备进行交互。每个硬件组件通常都需要相应的设备驱动程序。\n\n\n应用软件（Application Software）：\n办公套件（Office Suites）：包括文字处理、电子表格、演示文稿等应用程序，如Microsoft Office、Google Workspace等。\n图形设计和多媒体软件：用于图形设计、视频编辑、音频处理等，如Adobe Creative Cloud套件、Final Cut Pro等。\n游戏软件：用于娱乐和游戏的应用程序，如电子游戏、电子竞技等。\n开发工具（Development Tools）：用于创建和调试软件的工具，如集成开发环境（IDE）和编译器。\n浏览器（Web Browsers）：用于访问互联网和浏览网页的应用程序，如Chrome、Firefox、Safari等。\n数据库管理系统（Database Management Systems，DBMS）：用于管理和组织数据的软件，如MySQL、Microsoft SQL Server等。\n安全软件：包括防病毒软件、防火墙等，用于保护计算机免受恶意软件和网络威胁。\n\n\n固件（Firmware）：\n固件是嵌入在硬件设备中的特殊软件，它提供设备的基本控制和功能。\n例如，计算机主板上的BIOS（Basic Input/Output System）是一种固件，它在计算机启动时提供基本的硬件初始化。\n\n\n中间件（Middleware）：\n中间件是连接不同软件应用程序和硬件系统的软件层，它简化了应用程序之间的通信和数据交换。\n例如，数据库中间件用于连接应用程序和数据库，使它们能够相互通信。\n\n\n\n机器指令机器指令（Machine Instructions）是计算机体系结构中的基本操作指令，直接由中央处理单元（CPU）执行。这些指令是以二进制形式编码的，每个指令对应着一条特定的操作，例如算术运算、逻辑运算、数据传输等。机器指令是计算机程序的最底层表示，也被称为机器码。\n常见机器指令\n算术指令：\nADD：加法\nSUB：减法\nMUL：乘法\nDIV：除法\n\n\n逻辑指令：\nAND：逻辑与\nOR：逻辑或\nXOR：异或\nNOT：逻辑非\n\n\n数据传输指令：\nMOV：将数据从一个位置传送到另一个位置\nLOAD：从内存中加载数据到寄存器\nSTORE：将数据从寄存器存储到内存中\n\n\n分支和跳转指令：\nJUMP：无条件跳转\nJZ：如果零跳转（通常用于条件分支）\nJE：如果相等跳转\nJNE：如果不相等跳转\n\n\n比较指令：\nCMP：比较两个操作数\n\n\n加载和存储指令：\nLDR：加载寄存器\nSTR：存储寄存器\n\n\n控制指令：\nNOP：空操作（No Operation）\nHLT：停机（Halt，停止执行）\n\n\n\n这些指令直接与计算机的硬件架构相关，不同的处理器架构可能有不同的机器指令集。例如，x86架构和ARM架构使用不同的指令集。程序员通常使用高级编程语言（如C、Java）编写程序，而编译器将高级代码翻译成相应计算机体系结构的机器指令。\n重要概念\nCPU执行机器指令：\nCPU（Central Processing Unit，中央处理单元）是计算机的核心部件，负责执行机器指令。\n机器指令是二进制形式的指令码，直接由CPU执行。每个指令对应于一个特定的操作，如算术运算、逻辑运算、数据传输等。\n\n\n每个CPU有自己的指令集：\n每个CPU都有自己的指令集，也称为指令架构（Instruction Set Architecture，ISA）。\n一个指令集通常包含100到200条指令，用于执行各种操作。\n每个指令集在硬件层面定义了CPU支持的操作，包括指令的格式、操作数的寻址方式等。\n\n\n指令集是固定的：\n对于特定的CPU，其指令集是固定的，不能被改变。\n这意味着在该CPU上运行的程序必须使用该CPU支持的指令集编写。\n\n\n不同CPU的指令集相似但没有标准化：\n虽然不同CPU的指令集可能有一些相似之处，但没有一个通用的、标准的指令集。\n常见的指令集包括x86、ARM、MIPS等，它们分别用于不同的CPU架构。\n这也是为什么编写能在不同架构上运行的程序需要进行适配或重新编译的原因。\n\n\n\n与高级语言的关系机器指令（Machine Instructions）和高级编程语言（High-Level Programming Language，HLL）之间存在密切的关系，但它们在计算机编程的不同层次上发挥着不同的作用。\n\n机器指令：\n机器指令是计算机硬件能够直接执行的二进制指令。\n每个机器指令对应着特定的硬件操作，例如算术运算、逻辑运算、数据传输等。\n机器指令是计算机体系结构的底层表示，直接由CPU执行。\n\n\n高级编程语言（HLL）：\n高级编程语言是为了使程序员更容易编写和理解程序而设计的。\n这些语言使用类似于人类语言的语法和结构，使得程序更易读写。\n常见的高级编程语言包括C、C++、Java、Python等。\n\n\n编译器和解释器：\n高级编程语言的代码需要被转换成机器指令，以便计算机能够执行。\n编译器和解释器是执行这一转换的工具。\n编译器将整个源代码一次性翻译成机器码，并生成可执行文件，例如Windows上的.exe文件。\n解释器逐行翻译和执行源代码，无需生成可执行文件。Python和JavaScript是使用解释器执行的例子。\n\n\n抽象层次：\n高级编程语言提供了对计算机底层硬件的抽象，使得程序员不需要直接处理机器指令。\n这种抽象层次使程序更容易编写、理解和维护。\n\n\n可移植性：\n高级编程语言的一个重要优势是可移植性，即相同的高级代码可以在不同的计算机架构上运行。\n编译器和解释器负责将高级代码转换成特定计算机架构的机器指令。\n\n\n\n但是为什么用高级语言写的程序仍然要翻译成机器码呢？\n主要是因为计算机硬件只能理解和执行特定的机器指令。计算机的中央处理单元（CPU）是直接执行机器指令的，这些指令是以二进制形式编码的。\n\n硬件执行机器指令：\n计算机硬件（CPU）只能理解和执行机器指令，这是计算机体系结构的基本特性。\n机器指令是二进制编码的硬件级别指令，直接在硬件上执行。\n\n\n计算机体系结构差异：\n不同的计算机体系结构（例如x86、ARM、MIPS等）有不同的机器指令集。\n高级编程语言的代码需要根据目标计算机的体系结构进行翻译，以生成相应的机器指令。\n\n\n性能优化：\n通过编译器或解释器将高级代码翻译成机器代码，可以进行一些性能优化。\n编译器可以进行静态分析，优化代码结构以提高执行效率。\n\n\n可移植性：\n将高级代码翻译成机器代码可以提高程序的可移植性，使其能够在不同的计算机体系结构上运行。\n只需重新编译或解释，而不需要重写整个程序。\n\n\n隐藏底层细节：\n高级编程语言提供了对计算机底层硬件的抽象，使得程序员不需要直接处理底层的机器指令。\n这种抽象层次提高了程序的可读性和可维护性。\n\n\n\n冯-诺依曼模型冯诺依曼，我不介绍了，自己百度。\n冯·诺依曼模型（von Neumann architecture）是一种计算机体系结构，它由匈牙利数学家冯·诺伊曼在20世纪中期提出。这一模型在计算机科学和计算机工程领域中起到了巨大的影响，成为现代计算机设计的基石。冯·诺依曼模型主要包括以下关键概念：\n\n存储程序概念（Stored Program Concept）： 冯·诺依曼模型的一个关键概念是将程序存储在计算机的存储器中，使计算机能够按顺序执行存储在内存中的指令。这使得用户能够灵活地改变和存储程序，而不需要改变硬件。\n存储器（Memory）： 程序和数据都存储在同一种类型的内存中。这意味着程序的指令和数据都以二进制形式存储在内存中，而处理器可以根据需要读取这些数据。\n中央处理器（Central Processing Unit，CPU）： 冯·诺依曼模型包含一个中央处理器，负责执行存储在内存中的指令。CPU包括算术逻辑单元（ALU）用于执行算术和逻辑运算，以及控制单元（Control Unit）用于管理指令的执行过程。\n指令集架构（Instruction Set Architecture，ISA）： 冯·诺依曼计算机使用指令集架构，其中包含一组可以由CPU执行的指令。ISA定义了CPU能够理解和执行的所有操作，包括算术运算、逻辑运算、数据传输等。\n顺序执行（Sequential Execution）： 冯·诺依曼计算机以顺序的方式执行存储在内存中的指令。每个指令按照顺序从内存中取出并由CPU执行，然后执行下一条指令。这确保了程序的正确执行顺序。\n输入/输出（I/O）： 冯·诺依曼计算机通过输入/输出设备与外部世界进行通信。输入设备（如键盘和鼠标）和输出设备（如显示器和打印机）允许计算机与用户进行交互，并进行数据的输入和输出。\n\n通用性\n可执行程序控制：\n计算机被设计成由可执行程序控制的通用机器。这意味着计算机可以执行各种任务，这些任务由程序提供的指令来完成。\n\n\n程序作为指令列表：\n程序本质上是一系列指令的列表，指导计算机执行特定任务。这些指令按顺序存储在计算机的内存中。\n\n\n统一内存用于程序和数据：\n程序和程序使用的数据都存储在计算机的内存中。这意味着指令和数据使用二进制代码表示，并可以从相同的存储介质中访问。\n\n\n可重写内存：\n冯·诺依曼机器之所以强大，其中一个原因是内存可重写。这使得在执行任务的过程中能够灵活地更改和更新程序以及存储和修改数据。\n\n\n主动执行的处理器：\n处理器（或中央处理单元，CPU）是计算机的主动部分，负责执行程序指令。它按照程序的指导执行算术和逻辑操作，使计算机能够执行各种计算任务。\n\n\n通用性质：\n这些特性的结合，包括可执行程序控制、使用指令列表、程序和数据的统一存储、可重写内存以及主动执行的处理器，使得冯·诺依曼机器具有通用计算设备的性质。通过简单地更改程序中的指令，计算机能够执行各种任务，使其适应不同的计算需求。\n\n\n\n潜在问题潜在问题：\n\n如何区分数据和指令： 因为它们都由二进制代码表示，计算机如何区分数据和指令呢？\n16位指令代码的多义性： 在不同的情况下，16位指令代码可能表示一个数字或两个字符。\n\n解决方案：\n\n指令和数据存储在内存中： 冯·诺依曼体系结构通过将指令和数据存储在同一内存中，使它们成为了计算机中的同一类信息。这使得在程序执行时，计算机能够灵活地读取和处理指令和数据。\nCPU知道从哪里获取程序指令： 中央处理单元（CPU）有能力识别并区分指令和数据。它通过程序计数器等机制知道从内存的哪个位置获取下一条指令，以确保按照正确的顺序执行程序。\n指令和数据采用特殊编码形式： 为了让CPU理解，指令和数据必须采用特殊的编码形式。指令集架构（ISA）定义了CPU可以理解和执行的所有操作，确保指令以及与之相关的数据能够在计算机内部进行正确的解释和处理。\n\n历史\n冯·诺依曼：\n术语“冯·诺依曼体系结构”最早出现在他于1945年6月30日发表的《EDVAC报告初稿》（First Draft of a Report on the EDVAC）中。这份报告描述了他对一种新型计算机结构的构想，成为冯·诺依曼体系结构的奠基石。\n\n\n康拉德·祖泽（Konrad Zuse）：\n1936年，祖泽在专利申请中提到了类似的概念。祖泽是一位德国工程师和计算机科学家，他的工作也对计算机发展产生了重要影响，尽管他的成就在当时并不为广泛认知。\n\n\nJ.W. Mauchly 和 J.P. Eckert：\n在1943年12月，Mauchly和Eckert在他们对ENIAC的研究中写道存储程序的概念。ENIAC是一台通用的存储程序计算机，是世界上第一台大规模电子计算机之一。他们的工作对后来冯·诺依曼体系结构的发展起到了关键作用。\n\n\n\n自己百度！\n哈佛体系结构\n冯·诺依曼体系结构的持久性：\n冯·诺依曼体系结构的规范在过去60多年中仍然保持有效，并且几乎所有今天的计算机都实现了这一体系结构。其灵活性和通用性使得它成为计算机设计的主导范式。\n\n\n哈佛体系结构的变体：\n分离数据和程序： 最近，一种变体——哈佛体系结构，逐渐崭露头角。\n需要不同的内存和访问总线： 哈佛体系结构通过将程序和数据存储在不同的内存中，并使用不同的访问总线来实现这种分离。这与冯·诺依曼体系结构中使用统一内存的方式形成对比。\n提高传输速率的意图： 这种分离的设计旨在提高数据传输速率，从而提高计算机的吞吐量。哈佛体系结构通过同时从程序存储器和数据存储器中提取信息，可以在某种程度上实现并行操作。\n\n\n哈佛体系结构的吞吐量优势：\n并行访问： 哈佛体系结构的一个优势在于，由于数据和指令存储在不同的存储器中，CPU可以同时从两个存储器中获取信息，而不会出现竞争或冲突。在某些情况下，这种并行访问可以提高系统的整体性能。\n分离内存总线： 使用不同的内存和访问总线还有助于减少由于程序和数据访问之间的冲突而导致的延迟。\n\n\n\n\nQ&amp;A1. 用图示说明输入-处理-输出模型的概念：\n\n2. 给出了当前一代数字计算机的基本结构的模型是什么？\n\n当前一代数字计算机的基本结构模型是冯·诺依曼体系结构。\n\n3. 过程由什么控制？\n\n过程由计算机的控制单元（Control Unit）控制。\n\n4. 强调实现输入-处理-输出和冯·诺依曼模型所需的三个组件：\n\n输入（Input）： 数据从外部源输入计算机系统。\n处理（Process）： 中央处理器（CPU）执行存储在内存中的指令，对数据进行处理。\n输出（Output）： 处理结果被发送到外部，或者在计算机内部用于进一步处理或存储。\n\n5. 列举5个计算机硬件的例子：\n\n中央处理器（CPU）\n内存（RAM）\n硬盘驱动器（HDD）\n图形处理器（GPU）\n主板（Motherboard）\n\n6. 识别计算机内执行计算和其他操作的主动部分是什么？\n\n主动执行计算和其他操作的部分是中央处理器（CPU）。CPU包括算术逻辑单元（ALU）执行算术和逻辑运算，以及控制单元（Control Unit）管理程序执行的过程。\n\n7. 计算机的哪一部分存储数据和程序，以供CPU访问？\n\n存储数据和程序以供CPU访问的部分是主存储器（RAM，Random Access Memory）。\n\n8. 提供三个次要存储的例子。\n\n三个次要存储的例子包括：\n硬盘驱动器（Hard Disk Drive，HDD）\n固态硬盘（Solid State Drive，SSD）\n光盘（例如，DVD或CD）\n\n\n\n9. 提供三个输入设备的例子。\n\n三个输入设备的例子包括：\n键盘\n鼠标\n触摸屏\n\n\n\n10. 提供三个输出设备的例子。\n\n三个输出设备的例子包括：\n显示器\n打印机\n音响系统\n\n\n\n11. 定义“软件”。\n\n软件（Software） 是指计算机程序和与之相关的数据，包括操作系统、应用程序和所有其他执行特定任务的代码。软件是一系列指令的集合，用于控制计算机硬件执行各种任务。\n\n12. 两个模型——输入-处理-输出模型和冯·诺依曼模型之间的区别是什么？\n\n输入-处理-输出模型： 这个模型强调计算系统的基本功能，即接收输入、进行处理，然后产生输出。它并未涉及计算机内部的存储和控制。\n冯·诺依曼模型： 这个模型不仅包括了输入-处理-输出的概念，还强调了将程序和数据存储在同一存储器中的特点。它包括中央处理器、存储器、输入/输出设备和控制单元等组件，形成了一个完整的计算机系统。\n\n13. 对于特定的计算机，机器指令集通常是固定的。是真的还是假的？\n\n真的。 对于特定的计算机体系结构，机器指令集通常是硬件固定的，它定义了CPU可以理解和执行的一组指令。\n\n14. 存在一个面向行业目的的标准指令集。是真的还是假的？\n\n真的。 有一些标准的指令集体系结构，例如x86（Intel和AMD处理器使用的指令集）、ARM（广泛用于移动设备和嵌入式系统）等，这些被广泛应用于整个行业。\n\n15. 高级编程语言（HLLs）比机器指令更适合编程。为什么？\n\n是真的。 高级编程语言（HLLs）提供了更抽象、更易读、更易编写的语法和结构，使程序员能够更方便地表达和理解算法和逻辑。相比之下，机器指令更接近计算机硬件的底层细节，编写和理解相对更为困难。\n\n16. 提到四大类机器指令。\n\n数据传输指令（Data Transfer Instructions）： 在寄存器和内存之间传输数据。\n算术运算指令（Arithmetic Instructions）： 执行算术运算，如加法、减法、乘法和除法。\n逻辑运算指令（Logical Instructions）： 执行逻辑运算，如与、或、非等。\n控制指令（Control Instructions）： 控制程序的流程，包括分支（跳转）、循环等。\n\n17. 为什么高级编程语言（HLL）程序在执行之前需要被翻译？\n\nHLL程序需要被翻译，因为计算机的中央处理器（CPU）只能理解和执行机器语言指令。HLL程序首先被翻译成机器语言的形式，这个过程通常包括编译（Compile）或解释（Interpret）的步骤，以便在计算机上执行。\n\n18. 什么是冯·诺依曼模型？\n\n冯·诺依曼模型是一种计算机体系结构，它包括一个中央处理器（CPU）、内存（存储程序和数据的地方）、输入/输出设备以及一个用于传输数据和指令的总线。这个模型强调了程序和数据存储在同一内存中，并由CPU按照顺序执行。\n\n19. 计算机的存储器中同时保存了?和?，两者都由?表示。\n\n计算机的存储器中同时保存了程序（Program）**和**数据（Data）**，两者都由二进制代码（Binary Codes）**表示。\n\n20. 识别冯·诺依曼瓶颈是什么？\n\n冯·诺依曼瓶颈是指在冯·诺依曼体系结构中，由于程序和数据共享同一存储器和总线，导致数据传输速率受限，从而影响了计算机的性能。这一瓶颈在数据传输过程中可能导致CPU等待数据的时间增加，限制了整体性能。\n\n21. 计算机如何区分数据和指令，因为它们都由二进制代码表示？\n\n计算机通过指令集架构（ISA）来区分数据和指令。指令集架构定义了CPU可以理解和执行的操作指令。计算机根据指令的不同来执行不同的操作，因此在执行时能够区分数据和指令。\n\n22. 冯·诺依曼机器和哈佛体系结构之间的主要区别是什么？\n\n主要区别：\n冯·诺依曼机器：程序和数据共享同一存储器，使用相同的总线进行访问。\n哈佛体系结构：程序和数据分别存储在不同的存储器中，使用不同的总线进行访问。\n\n\n\n23. 为什么要使用哈佛体系结构？\n\n动机：\n提高数据传输速率和系统吞吐量。\n通过使用独立的存储器和总线，允许程序和数据同时访问，从而提高并行性。\n更适合嵌入式系统和一些特定应用领域。\n\n\n\n24. 使用哈佛体系结构的额外成本是什么？\n\n额外成本：\n需要额外的硬件资源来实现独立的指令存储器和数据存储器，以及独立的总线系统。\n这可能导致芯片面积增大，设计复杂度增加，制造成本上升。\n\n\n\n25. 大多数桌面CPU具有一个内部的“指令缓存”供给控制单元和一个完全独立的“数据缓存”。这是模仿哪种计算机体系结构？\n\n这模仿的是哈佛体系结构。在哈佛体系结构中，指令和数据分别存储，通常有独立的缓存用于提高访问效率。这种配置允许CPU在执行指令的同时访问数据，提高了整体性能。\n\n","slug":"CPT101-Review-2","date":"2023-12-08T10:02:43.000Z","categories_index":"","tags_index":"CPT101复习,笔记","author_index":"General_K1ng"},{"id":"ef8bd82be23cedfc8cb7a2a8f2b9f3ab","title":"MySQL Review-10","content":"继续来到数据库的规范化，也就是一种优化数据库结构的一种范式。\n数据库的规范化良好数据库设计规范最小化属性数量：\n\n数据库应该包含最少数量的属性，足以支持企业的数据需求。这有助于保持数据库的简洁性，提高查询效率，并降低维护成本。只有必要的属性应该包含在数据库中，避免不必要的冗余。\n\n具有紧密逻辑关系的属性在同一关系中：\n\n相关的属性应该组织在同一关系（表）中，以反映它们之间的紧密逻辑关系。这有助于简化查询和维护操作，并提高数据库的一致性。例如，如果有关联的用户信息和订单信息，它们应该存储在同一关系中，而不是分散在不同的表中。\n\n最小冗余：\n\n数据库设计应该避免冗余，即相同的数据不应该在数据库中存储多次。冗余数据可能导致更新异常、插入异常和删除异常，从而影响数据库的一致性。每个属性只应该在数据库中表示一次，除非它是外键的一部分或完全是外键。外键是关联两个表的字段，允许在表之间建立关系。\n\n外键的例外：\n\n外键是一种属性，它们与另一个表中的主键或唯一键形成关联。尽管规范化目标是减少冗余，但外键是一个例外，因为它们用于建立表之间的关系。在这种情况下，外键的一部分或整体可能在多个表中出现，但这是为了保持关系完整性。在外键的情况下，允许属性在不同表中多次出现，以便确保相关表之间的关联性。\n\n什么是数据库的规范化数据库规范化是一种数据库设计的方法，旨在通过组织数据库表的结构，减少数据冗余、提高数据一致性，并防止数据异常。这个过程通过将表拆分成更小、更紧凑的结构，以确保每个表都包含相关的数据，并且每个数据项都只在数据库中存储一次。这有助于减小数据库的复杂性，提高查询性能，并减少数据更新时的潜在问题。\nER建模与规范化实体关系建模（ER建模）和规范化是数据库设计中两个关键的步骤，它们各自关注不同的方面，但又相互关联，通常在数据库设计的不同阶段应用。\nER建模（Entity-Relationship Modeling）：定义： ER建模是一种用于描述数据库中数据实体、它们之间的关系和属性的图形化方法。它使用实体、关系和属性等概念，通过图形表示来描述数据模型，以便更好地理解和沟通数据库的结构。\n特点：\n\n概念性： ER模型提供了一个概念性的视图，使人们能够从高层次上理解数据库中的实体以及它们之间的关系。\n易于理解： 通过使用图形符号，ER模型使数据库设计更加可视化和易于理解。\n关注业务需求： ER模型着重于捕捉业务需求和实体之间的关系，而不涉及具体的表结构。\n\n规范化（Normalization）：定义： 规范化是一种通过设计数据库表结构，以最小化冗余、降低数据异常的方法。这通常涉及将表拆分成更小的、更精确的结构，以确保每个表都符合特定的范式。\n特点：\n\n结构化： 规范化关注数据库表的结构，以确保数据存储是结构化的、一致的，且没有不必要的冗余。\n范式： 通过遵循范式的规则，规范化确保表的设计符合特定的标准，如第一范式、第二范式和第三范式等。\n提高性能： 通过减小表的大小，规范化有助于提高查询性能，并减少数据更新时的潜在问题。\n\n关联：\n设计阶段： ER建模通常是在数据库设计的早期阶段进行的，用于捕捉业务需求和关系。规范化通常发生在ER建模之后，用于优化数据库表的结构。\n相互关联： ER模型的实体和关系可以为规范化提供一个起点。规范化过程中可能需要调整表结构，以更好地反映ER模型中定义的实体和它们之间的关系。\n业务和性能： ER建模更侧重于业务需求和关系，而规范化更关注数据库的结构和性能。\n\n数据冗余的问题数据冗余是指在数据库中存储相同信息的多个副本或冗余副本。虽然在某些情况下可能会选择故意引入一些冗余以提高查询性能，但通常情况下，过多的数据冗余可能导致一系列问题，包括：\n\n更新异常： 当存在数据冗余时，如果更新操作只更新了其中一个副本而忘记更新其他副本，可能导致数据的不一致性。这被称为更新异常，其中数据的更新不同步，导致数据库中存在不一致的信息。\n插入异常： 插入异常发生在试图插入新数据时，由于要求插入的数据所依赖的其他信息尚未存在，导致插入操作无法完成。这通常是由于数据分散在多个地方造成的，而不是集中存储。\n删除异常： 删除异常发生在尝试删除某些数据时，由于这些数据同时被其他数据所引用，删除操作可能导致丢失不想删除的相关信息。这使得删除操作变得复杂并且可能引起问题。\n数据不一致性： 数据冗余使得难以保持数据的一致性。如果同一信息的不同副本之间存在不一致，用户可能会看到相互矛盾的数据。\n空间浪费： 存储相同的信息多次会导致空间浪费，尤其是在大型数据库中。这不仅浪费了物理存储空间，还增加了备份和维护的成本。\n查询困难： 数据冗余可能导致查询变得复杂，因为相同的信息分散在不同的地方。这可能需要使用更复杂的查询来获取一致和完整的结果。\n\n范式功能依赖在数据库理论中，功能依赖（Functional Dependency） 是指一个属性的值在给定其他属性的值的条件下，能够确定另一个属性的值。简而言之，如果我们知道某个属性（称为依赖项）的值，就能够唯一确定另一个属性（称为依赖源）的值，那么我们说依赖源函数依赖于依赖项。\n在关系数据库中，功能依赖是关系模型中一种重要的概念，通常用于规范化数据库设计。它有助于确保数据库表的结构能够遵循一些基本原则，防止冗余数据、维持数据的一致性，同时减小数据更新异常的风险。\n功能依赖的表示在关系数据库中，我们用箭头（→）表示功能依赖。如果属性 X 的值决定了属性 Y 的值，我们写作 X → Y。\n例如，假设有一个学生表包含学生的学号（StudentID）和姓名（StudentName），则可以表示为：\nStudentID→StudentNameStudentID→StudentName\n这表示在给定学生的学号的情况下，能够唯一确定学生的姓名。\n完全函数依赖如果一个属性完全依赖于另一组属性，而不依赖于这组属性的任何子集，那么我们称这是一个完全函数依赖。\n例如，如果一个表中有 \nStudentID→StudentNameStudentID→StudentName 和 StudentID,\n Course→GradeStudentID, Course→Grade，那么我们可以说 Grade 完全依赖于 StudentID 和 Course。\n部分函数依赖相反，如果一个属性依赖于另一组属性中的一部分，而不是全部，那么我们称这是一个部分函数依赖。\n例如，如果 StudentID, Course→GradeStudentID, Course→Grade，但 StudentID→GradeStudentID→Grade 不成立，那么我们可以说 Grade 部分依赖于 StudentID 和 Course。\n传递函数依赖如果一个属性依赖于另一组属性，而这组属性又依赖于另一组属性，那么我们称这是一个传递函数依赖。\n例如，如果 A→BA→B 和 B→CB→C，那么我们可以说 A→CA→C 是一个传递函数依赖。\n例子假设我们要创建一个学生课程成绩的数据库表，我们可以使用 MySQL 来创建一个包含学生信息、课程信息和成绩的表。以下是一个简单的例子，演示了不同类型的功能依赖。\n-- 创建学生表\nCREATE TABLE Students (\n    StudentID INT PRIMARY KEY,\n    StudentName VARCHAR(50) NOT NULL,\n    BirthDate DATE\n);\n\n-- 创建课程表\nCREATE TABLE Courses (\n    CourseID INT PRIMARY KEY,\n    CourseName VARCHAR(50) NOT NULL\n);\n\n-- 创建成绩表\nCREATE TABLE Grades (\n    StudentID INT,\n    CourseID INT,\n    Grade INT,\n    PRIMARY KEY (StudentID, CourseID),\n    FOREIGN KEY (StudentID) REFERENCES Students(StudentID),\n    FOREIGN KEY (CourseID) REFERENCES Courses(CourseID)\n);\n\n在上面的例子中，我们创建了三个表：Students（学生表）、Courses（课程表）和Grades（成绩表）。\n\n完全函数依赖的例子：\nGrades表中的Grade完全依赖于StudentID和CourseID。这是因为给定了StudentID和CourseID的情况下，可以唯一确定相应的Grade。\n\n\n部分函数依赖的例子：\n如果我们假设一个学生只修一个课程，那么Grades表中的Grade部分依赖于StudentID。这是因为给定了StudentID，我们就能唯一确定该学生的所有课程成绩。\n\n\n传递函数依赖的例子：\n如果我们在Students表中添加了一个属性BirthDate，并假设CourseID是与BirthDate存在传递依赖关系，那么我们可以说StudentID传递函数依赖于CourseID。这是因为StudentID依赖于BirthDate，而CourseID又依赖于StudentID。请注意，这种情况可能不符合实际业务场景，只是为了演示传递函数依赖的概念。\n\n\n\n依赖传递传递依赖是指如果一个属性 A 依赖于属性 B，并且属性 B 依赖于属性 C，则我们可以说属性 A 传递依赖于属性 C。这是一种由依赖关系链条构成的概念，其中属性之间的依赖不是直接的，而是通过其他属性传递的。\n例子考虑一个关系模型，其中有三个属性 A、B 和 C，满足以下依赖关系：在这种情况下，我们可以得出传递依赖：这是因为 A 通过 B 间接地依赖于 C。\n传递依赖的性质：\n传递依赖是由直接依赖关系构成的： 传递依赖并不是一种新的独立关系，而是由直接依赖关系的链条构成的。在上面的例子中，传递依赖  是由直接依赖  和 构成的。\n依赖链可能是多层的： 传递依赖的链条可能涉及多个属性。在上述例子中，我们只有两层的传递，但在更复杂的关系模型中，这种链条可能更长。\n传递依赖的方向是单向的： 传递依赖是单向的，即 A 传递依赖于 C，并不意味着 C 传递依赖于 A。\n\n三大范式\n第一范式 (1NF)： 保证每个表中的每一列都是原子的，不可再分。这意味着每个单元格中的数据不再包含嵌套结构或多个值。\n第二范式 (2NF)： 在满足第一范式的基础上，确保表中的非主键列完全依赖于全部主键而不是部分主键。这有助于消除数据部分依赖性。\n第三范式 (3NF)： 在满足第二范式的基础上，确保表中的非主键列之间没有传递依赖关系。这有助于消除数据传递依赖性。\n\n第一范式第一范式（First Normal Form，1NF）是数据库规范化的第一个步骤，它确保数据库表中的数据是原子性的，即每一列都包含不可再分的原子数据。以下是第一范式的一些关键特点和要点：\n特点原子性：\n\n第一范式要求每个表中的每一列都包含不可再分的原子数据。这意味着每一列中不能包含集合、数组、记录或其他类似的结构，而应该是单一的、不可再分的数据类型。\n\n唯一性：\n\n表中的每一行都应该是唯一的，没有重复的行。这是数据库表的基本特性，但在第一范式中，强调了确保每一行都是唯一的。\n\n有序性无关：\n\n第一范式与数据的顺序无关，即数据的存储顺序不影响数据的可访问性或完整性。在表中，行的顺序不重要，重要的是每一行都包含正确的、原子的数据。\n\n例子考虑一个包含学生课程成绩的表，不符合第一范式的情况：\n\n\n\nStudentID\nCourses\nGrades\n\n\n\n1\nMath, Physics\nA, B\n\n\n2\nChemistry, Computer Science\nA, A\n\n\n上述表中的”Courses”和”Grades”列包含多个数据项，不是原子的。为了符合第一范式，我们可以将这个表分解为两个表：\n– 学生表\n\n\n\nStudentID\n\n\n\n1\n\n\n2\n\n\n– 课程成绩表\n\n\n\nStudentID\nCourse\nGrade\n\n\n\n1\nMath\nA\n\n\n1\nPhysics\nB\n\n\n2\nChemistry\nA\n\n\n2\nComp. Science\nA\n\n\n这样，每个表都包含原子数据，并且不再存在多个值的情况。\n第一范式是数据库规范化的基础，确保数据的原子性，使得数据库结构更加清晰、可维护，同时避免了与非规范化数据结构相关的问题。在实际设计中，应该始终考虑将表调整为满足第一范式的形式。\n第二范式第二范式（Second Normal Form，2NF）是数据库规范化的第二步，它建立在第一范式的基础上，解决了包含部分依赖的问题。第二范式的关键思想是确保表中的所有非主键列完全依赖于主键，而不是依赖于主键的部分属性。以下是第二范式的一些关键特点和要点：\n特点完全函数依赖：\n\n第二范式要求表中的非主键列完全函数依赖于主键。换句话说，如果一个表的主键是由多个属性组成的，那么所有其他非主键列都应该完全依赖于这个组合主键，而不是只依赖于主键的一部分。\n\n消除部分依赖：\n\n通过确保所有非主键列都完全依赖于主键，第二范式帮助消除了表中的部分依赖关系。部分依赖是指表中的某些列仅依赖于主键的一部分。\n\n例子考虑一个包含学生课程成绩的表，不符合第二范式的情况：\n\n\n\nStudentID\nCourse\nProfessor\nGrade\n\n\n\n1\nMath\nDr. Smith\nA\n\n\n1\nPhysics\nDr. Johnson\nB\n\n\n2\nChemistry\nDr. Davis\nA\n\n\n2\nComp. Science\nDr. Smith\nA\n\n\n在上述表中，主键是 (StudentID, Course)，其中”Professor”列只依赖于主键的一部分（”Course”），这违反了第二范式。为了符合第二范式，我们可以将表分解为这几个表：\n– 学生表\n\n\n\nStudentID\n\n\n\n1\n\n\n2\n\n\n– 课程表\n\n\n\nCourse\nProfessor\n\n\n\nMath\nDr. Smith\n\n\nPhysics\nDr. Johnson\n\n\nChemistry\nDr. Davis\n\n\nComp. Science\nDr. Smith\n\n\n– 课程成绩表\n\n\n\nStudentID\nCourse\nGrade\n\n\n\n1\nMath\nA\n\n\n1\nPhysics\nB\n\n\n2\nChemistry\nA\n\n\n2\nComp. Science\nA\n\n\n现在，“Professor”只依赖于“Course”，而不再依赖于主键，因此符合第二范式的要求。\n第二范式通过确保表中的非主键列完全依赖于主键，帮助规范化数据库表结构，提高数据的一致性和完整性。在实际数据库设计中，应该仔细分析表的依赖关系，以确保它们符合第二范式的要求。\n第三范式第三范式（Third Normal Form，3NF）是数据库规范化的第三步，它建立在第二范式的基础上，解决了表中的传递依赖问题。第三范式的核心思想是确保表中的所有非主键列都不传递依赖于主键，即不存在非主键列之间的传递依赖关系。以下是第三范式的一些关键特点和要点：\n特点消除传递依赖：\n\n第三范式要求表中的非主键列不应该传递依赖于主键。如果一个非主键列依赖于主键，而另一列依赖于这个非主键列，那么就存在传递依赖。\n\n避免冗余数据：\n\n通过消除传递依赖，第三范式有助于避免表中的冗余数据。这有助于数据库结构的清晰性、一致性和减小存储空间的需求。\n\n例子考虑一个包含学生课程成绩的表，不符合第三范式的情况：\n\n\n\nStudentID\nCourse\nProfessor\nProfessorOffice\nGrade\n\n\n\n1\nMath\nDr. Smith\nRoom 101\nA\n\n\n1\nPhysics\nDr. Johnson\nRoom 105\nB\n\n\n2\nChemistry\nDr. Davis\nRoom 103\nA\n\n\n2\nComp. Science\nDr. Smith\nRoom 101\nA\n\n\n在上述表中，”ProfessorOffice”列依赖于”Professor”，而”Professor”又依赖于主键。这导致了传递依赖，不符合第三范式的要求。为了符合第三范式，我们可以将表分解为这几个表：\n– 学生表\n\n\n\nStudentID\n\n\n\n1\n\n\n2\n\n\n– 课程表\n\n\n\nCourse\nProfessor\n\n\n\nMath\nDr. Smith\n\n\nPhysics\nDr. Johnson\n\n\nChemistry\nDr. Davis\n\n\nComp. Science\nDr. Smith\n\n\n– 教授表\n\n\n\nProfessor\nProfessorOffice\n\n\n\nDr. Smith\nRoom 101\n\n\nDr. Johnson\nRoom 105\n\n\nDr. Davis\nRoom 103\n\n\n– 课程成绩表\n\n\n\nStudentID\nCourse\nGrade\n\n\n\n1\nMath\nA\n\n\n1\nPhysics\nB\n\n\n2\nChemistry\nA\n\n\n2\nComp. Science\nA\n\n\n这样，每个表都不存在传递依赖，符合第三范式的要求。\n第三范式通过消除表中的传递依赖，帮助规范化数据库表结构，确保非主键列之间没有不必要的依赖关系。在实际数据库设计中，应该仔细分析表的依赖关系，以确保它们符合第三范式的要求，提高数据库的结构清晰性和一致性。\n实操比方说如果我们要设计一个图书管理系统，首先我们应该怎么办？\n肯定是先进行ER模型的建立。\nER模型设计在ER模型中，我们可能有以下几个实体和它们之间的关系：\n\n实体：图书（Book）、作者（Author）、图书馆成员（Library Member）\n关系：图书与作者之间是“写作”关系，图书馆成员与图书之间是“借阅”关系。\n\n我们还可以画出这几个关系的ER图\n\n数据库设计根据ER模型，我们可以设计初始的数据库表结构：\n– 图书表\n\n\n\nBookID\nTitle\nISBN\nAuthorID\n\n\n\n1\n“Introduction…”\n“123456789”\n1\n\n\n2\n“Database Des…”\n“987654321”\n2\n\n\n– 作者表\n\n\n\nAuthorID\nAuthorName\n\n\n\n1\n“John Smith”\n\n\n2\n“Jane Doe”\n\n\n– 图书馆成员表\n\n\n\nMemberID\nMemberName\nMemberEmail\n\n\n\n101\n“Alice Johnson”\n“alice@email.com“\n\n\n第一范式（1NF）确保每列都包含原子数据，消除重复的列。\n好像这个表已经满足第一范式了，所以跳过。\n第二范式（2NF）确保非主键列完全依赖于主键。\n– 图书表\n\n\n\nBookID\nTitle\nISBN\n\n\n\n1\n“Introduction…”\n“123456789”\n\n\n2\n“Database Des…”\n“987654321”\n\n\n– 作者表\n\n\n\nAuthorID\nAuthorName\n\n\n\n1\n“John Smith”\n\n\n2\n“Jane Doe”\n\n\n– 图书作者关系表\n\n\n\nBookID\nAuthorID\n\n\n\n1\n1\n\n\n2\n2\n\n\n– 图书馆成员表\n\n\n\nMemberID\nMemberName\nMemberEmail\n\n\n\n101\n“Alice Johnson”\n“alice@email.com“\n\n\n第三范式（3NF）仔细一看，这样好像也已经复合第三范式了。。。\n总结那就总结一下：\n第一范式（1NF）：目标： 确保数据库表字段的原子性。\n例子： 如果有一个包含用户信息的字段，如 “广东省 10086”，根据第一范式，应该拆分成 “省份：广东省” 和 “电话号码：10086” 两个字段，以确保每个字段都是原子的，不可再分。\n第二范式（2NF）：目标： 除了满足第一范式，表必须有一个主键；非主键列必须完全依赖于主键。\n例子： 考虑一个选课关系表，包含学号、学生姓名、年龄、课程名称、成绩和学分。如果学分完全依赖于课程名称，而姓名和年龄完全依赖于学号，那么这不符合第二范式。解决方法是拆分成学生表、课程表和选课关系表，确保每个表有自己的主键，消除部分依赖。\n第三范式（3NF）：目标： 除了满足第二范式，非主键列必须直接依赖于主键，不能存在传递依赖。\n例子： 考虑一个学生关系表，包含学号、学生姓名、年龄、学院ID、学院地点和学院电话。如果学院地点和学院电话直接依赖于学院ID，而学院ID又依赖于学号，存在传递依赖，不符合第三范式。解决方法是拆分成学生表和学院表，确保非主键列直接依赖于主键。\n2NF 和 3NF 的区别：\n2NF： 考虑非主键列是否完全依赖于主键。\n3NF： 考虑非主键列是否直接依赖于主键，避免传递依赖。\n\n","slug":"MySQL-Review-10","date":"2023-12-08T07:08:26.000Z","categories_index":"","tags_index":"笔记,MySQL复习","author_index":"General_K1ng"},{"id":"501d84f5a19f74694418ac5dda2db98c","title":"MySQL Review-9","content":"这一章开始就是我们所谓的八股文了，但是考试又要考，你拿他有什么办法？\n数据库设计设计数据库，这是开发过程中非常关键的一个步骤，它涉及到如何组织和存储数据，以便系统可以有效地检索和管理信息。\n\n需求分析： 在设计数据库之前，首先需要了解系统的需求。这包括确定系统将要存储和处理的数据类型，以及用户希望从数据库中检索的信息。\n概念设计： 在这个阶段，你需要识别和定义系统中的实体，这些实体可以是人、地点、事件等。还需要确定这些实体之间的关系。使用实体-关系图（ER图）等工具进行可视化表示。\n逻辑设计： 将概念设计转换为逻辑设计。在这个阶段，你需要确定如何将实体和关系转换为数据库表。每个实体应该成为一个表，每个属性应该成为表中的列。确定主键、外键等约束。\n规范化： 数据库规范化是一个重要的步骤，它有助于减少数据冗余并提高数据库的性能。规范化的目标是将数据组织成符合某种标准形式的表，以便降低冗余并提高数据存储效率。\n\n接下来就是建表，外键，约束这些东西了，这一节应该目的在于抽象地教你如何进行数据库建表前的准备设计工作，让你有的放矢。\n实体-关系建模实体-关系建模（Entity-Relationship Modeling，简称ER建模）是一种用于可视化和描述数据库中数据结构的方法。ER建模是数据库设计的早期阶段，它通过图形化表示来表达实体、属性和实体之间的关系。这种建模方法通常使用实体-关系图（ER图）。\n以下是ER建模中的关键概念：\n\n实体（Entity）： 实体是系统中可以区分和识别的一个独立的事物，它可以是一个对象、一个人、一个地点或一个概念。在ER图中，实体通常用圆角框表示。\n\n属性（Attribute）： 属性是描述实体特征的信息，它为实体提供更多的详细信息。例如，一个”学生”实体可以有属性如姓名、学号、出生日期等。属性通常用椭圆形表示。\n\n关系（Relationship）： 关系表示实体之间的联系。在ER图中，关系通常用菱形表示，链接的末端显示基数。关系可以是一对一、一对多或多对多的。例如，一个”学生”实体和一个”课程”实体之间可以有关系，表示学生和课程之间的选修关系。\n基数比\n\nCardinality Ratios（基数比率）是在实体-关系模型（ER模型）中用于描述实体之间关系的一个重要概念。它指的是一个关系中参与的实体之间的数量关系。Cardinality Ratios有三种主要类型：一对一（One-to-One）、一对多（One-to-Many）、多对多（Many-to-Many）。\n\n一对一（One-to-One）：\n在一对一关系中，一个实体的一个实例只能关联到另一个实体的一个实例，反之亦然。\n例如，一个人可能只有一个身份证号码，而一个身份证号码也只能对应一个人。\n\n\n一对多（One-to-Many）：\n在一对多关系中，一个实体的一个实例可以关联到另一个实体的多个实例，但反过来不成立。\n例如，一个作者可以写多本书，但一本书只能由一个作者编写。\n\n\n多对多（Many-to-Many）：\n在多对多关系中，一个实体的多个实例可以关联到另一个实体的多个实例，这是一种比较灵活的关系。\n例如，学生可以选择多门课程，而一门课程也可以被多个学生选修。\n\n\n\n设计ER模型ER建模的步骤如下：\n\n识别实体： 从需求分析中确定系统中的实体，这可以是物理实体或概念实体。\n识别属性： 为每个实体确定相关的属性，这些属性描述了实体的特征。\n确定关系： 确定实体之间的关系，表示实体之间的联系。\n确定主键： 为每个实体确定主键，确保每个实体都有一个唯一标识。\n确定外键： 在需要的情况下，确定外键以建立实体之间的关联。\n绘制ER图： 使用ER图工具（纸和笔、绘图软件等）绘制实体、属性、关系之间的图形表示。\n\n 按照学校的例子：\n一所大学由若干系组成。每个系提供若干门课程。每门课程由若干模块组成。学生注册某门课程，并在完成该课程时学习模块。每个模块由相应系的一名讲师教授（几名讲师在同一系工作），每个讲师辅导一组学生。一名讲师可以教授多个模块，但只能在一个系工作。\n1. 实体识别：\n学校（University）\n部门（Department）\n课程（Course）\n模块（Module）\n学生（Student）\n讲师（Lecturer）\n\n2. 属性定义：学校（University）：\n属性：UniversityID (Primary Key), Name, Location\n\n部门（Department）：\n属性：DepartmentID (Primary Key), Name\n\n课程（Course）：\n属性：CourseID (Primary Key), Name\n\n模块（Module）：\n属性：ModuleID (Primary Key), Name\n\n学生（Student）：\n属性：StudentID (Primary Key), Name, Address, DateOfBirth\n\n讲师（Lecturer）：\n属性：LecturerID (Primary Key), Name, Address, DateOfBirth\n\n3. 关系识别：\n学校（University）与部门（Department）之间存在一对多关系，一个学校可以有多个部门，但一个部门只属于一个学校。\n部门（Department）与课程（Course）之间存在一对多关系，一个部门可以提供多门课程，但一门课程只属于一个部门。\n课程（Course）与模块（Module）之间存在一对多关系，一门课程可以包括多个模块，但一个模块只属于一门课程。\n学生（Student）与课程（Course）之间存在多对多关系，一个学生可以注册多门课程，一门课程也可以有多名学生。\n模块（Module）与讲师（Lecturer）之间存在一对多关系，一个模块由一个讲师教授，但一个讲师可以教授多个模块。\n讲师（Lecturer）与部门（Department）之间存在一对多关系，一个讲师属于一个部门，但一个部门可以有多个讲师。\n\n4. 主键和外键：\n每个实体都有一个主键（Primary Key）用于唯一标识实体的每个实例。\n外键（Foreign Key）用于建立实体之间的关系。例如，部门（Department）表中的UniversityID可以作为外键与学校（University）表中的UniversityID关联。\n\n\n这个就是一个简单的ER图，以下是它的主键和外键关系。\n\n这里图里面的一对多，多对多啊这些的只是为了方便呈现，其实按照学校的要求这里应该写两者之间的关系名称，然后用菱形方框框起来，而且属性必须用椭圆形分别连出来，但是我的画图工具并不支持，所以记住就行。\n","slug":"MySQL-Review-9","date":"2023-12-07T11:54:31.000Z","categories_index":"","tags_index":"笔记,MySQL复习","author_index":"General_K1ng"},{"id":"d8d61b16d43fe3afec63384e99b4a265","title":"MySQL Review-8","content":"继续把索引一讲。。。\n索引在MySQL中，索引是一种用于提高数据库查询性能的数据结构。它类似于书籍的目录，可以帮助数据库引擎快速定位和检索数据。索引的主要作用是加速数据的检索过程，减少数据库的查询时间。在MySQL中，常见的索引类型包括主键索引、唯一索引、普通索引、全文索引等。\n优缺点优点\n提高查询性能： 索引能够显著提高SELECT查询的速度，因为它们允许数据库引擎更快地定位和访问所需的数据行。通过减少需要扫描的数据量，索引可以大大减小查询的执行时间。\n加速排序和分组操作： 如果查询包含ORDER BY或GROUP BY子句，索引可以加速这些排序和分组操作，因为索引存储了按照特定列排列的数据。\n加速连接操作： 当在多个表之间进行连接操作时，索引可以加速连接的执行，特别是在连接的列上创建索引。\n加速唯一性检查： 唯一索引确保列中的值是唯一的，这可以加速唯一性检查的过程，例如在插入新记录时。\n加速全文搜索： 如果表中包含文本数据，并使用全文索引，可以通过索引来加速全文搜索的操作。\n\n缺点\n写操作的性能可能降低： 对表进行INSERT、UPDATE和DELETE等写操作时，索引也需要更新。因此，频繁的写操作可能导致性能下降。\n占用额外存储空间： 索引数据结构会占用磁盘空间，特别是在大型表上。这需要在性能提升和存储开销之间进行权衡。\n过多的索引可能导致性能下降： 如果表上存在过多的索引，可能会导致查询优化器选择不恰当的索引，或者在更新操作时需要维护大量的索引，从而降低性能。\n\n作用因为MySQL这种关系型数据库不同于Redis这种利用内存来高速缓存的非关系型数据库，MySQL的数据是存储在硬盘或者说磁盘上的，查询数据的时候，如果没有索引，那么就会一次性将所有的数据加载到内存当中，然后再进行查询筛选，但是磁盘的IO是非常耗时间的，如果数据量大的话，这个用时就更长了。\n如果有了索引之后，就不需要加载所有的数据了，因为MySQL底层采用的B+树进行维护，而且一般的层数在2-4层左右，所以不管多大的数据量，最多也就只需2-4次的磁盘IO。\n简而言之，加速。\n情况有些时候其实不需要建立索引，而有些时候又必须建立索引。\n需要建立索引的情况\n频繁的查询操作： 如果某个列经常用于WHERE子句、JOIN条件或ORDER BY子句，建立索引可以显著提高查询性能。\n唯一性约束： 如果某列需要保持唯一性，例如主键列或唯一键列，建议为该列创建唯一索引。\n连接操作： 当在多个表之间进行连接操作时，对连接列创建索引可以加速连接的执行。\n排序和分组操作： 如果查询包含ORDER BY或GROUP BY子句，通过为相关列创建索引可以提高排序和分组操作的性能。\n全文搜索： 如果需要执行全文搜索，可以使用全文索引加速搜索操作。\n\n不需要建立索引的情况\n小表： 对于小型表，全表扫描可能比使用索引更为高效，因为索引引入的开销可能超过了全表扫描的成本。\n高写入负载： 如果表经常执行INSERT、UPDATE和DELETE等写操作，索引的维护成本可能会超过读操作的性能提升，因此需要权衡。\n频繁更新的列： 如果某列经常被更新，特别是对于大型表，建立索引可能会降低性能，因为每次更新都需要更新索引。\n不会用于查询的列： 对于不会出现在查询条件中的列，创建索引是没有意义的。\n短字符串列： 对于短字符串列，全表扫描的代价可能较小，而索引的额外开销可能不值得。\n\nMySQL索引的数据结构\nB+Tree索引： B+Tree是B-Tree的一种变体，常用于实现聚簇索引（在InnoDB存储引擎中，默认的主键索引就是聚簇索引）。与B-Tree相比，B+Tree将数据仅存储在叶子节点上，非叶子节点只包含键值，这有助于提高范围查询和排序操作的性能。\n哈希索引： 哈希索引使用哈希表数据结构，适用于等值查询。哈希索引在查询速度上非常快，但不适用于范围查询和排序操作。MySQL中的MyISAM存储引擎支持哈希索引，但InnoDB等存储引擎通常不使用哈希索引作为主索引。\n\nB+ Tree1. 树的结构： 想象一棵树，它有根部（最上面的节点）和一些分支。这个树是平衡的，就是说每个分支的高度都是一样的。\n2. 数据的存储： 假设我们要在这棵树上存储一些数据，比如数字。这些数字将被放在叶子（最底部的节点）上。\n3. 排序和查找： 想象一下，如果我们要找一个数字，我们可以从根部开始，按照一定的规则（比如说，如果要找的数字比当前节点的数字大，就往右走；反之，就往左走），最终找到我们需要的数字。\n4. B+Tree的特点： B+Tree索引就像这样的一棵树，但有一些特殊之处：\n\n只有叶子节点存储数据： 所有的数据都存储在叶子节点上，而非叶子节点只存储索引。\n叶子节点是有序的链表： 叶子节点按照顺序形成一个链表，方便范围查找和排序操作。\n平衡性： 树的所有分支的高度是一样的，这确保了查找效率。\n\n5. 为什么使用B+Tree： 使用B+Tree索引有几个好处：\n\n快速查找： 通过树的结构，我们可以快速找到需要的数据，不需要遍历整个表。\n适用于范围查找： 由于叶子节点是有序的链表，B+Tree适合进行范围查找，比如查找某个范围内的数据。\n适用于排序： B+Tree的有序性使得对数据进行排序非常高效。\n\n\n哈希索引1. 键和箱子： 假设你有很多钥匙（键），而你想快速找到它们存放在哪里。哈希索引就好像有一堆箱子，每个箱子上都有一个标签（哈希值）。\n2. 哈希函数： 为了找到正确的箱子，你可以使用一个神奇的函数（哈希函数），这个函数可以把每个钥匙转换成一个特殊的数字（哈希值）。这个数字告诉你应该把钥匙放到哪个箱子里。\n3. 查找过程： 当你想找到一个特定的钥匙时，你只需要把这个钥匙交给哈希函数，得到一个哈希值，然后直接去找标签上是这个哈希值的箱子。这样就很快找到了你要的东西。\n区别\n哈希索引不支持排序，因为哈希表是无序的。\n哈希索引不支持范围查找。\n哈希索引不支持模糊查询及多列索引的最左前缀匹配。\n因为哈希表中会存在哈希冲突，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点。\n\n分类主键索引（Primary Key Index）\n主键索引是一种唯一性索引，用于唯一标识表中的每一行数据。\n每个表只能有一个主键索引。\n主键索引自动创建，如果表定义中没有指定主键，则系统会选择一个唯一的列作为主键。\n\nCREATE TABLE example (\n    id INT PRIMARY KEY,\n    name VARCHAR(50)\n);\n\n唯一索引（Unique Index）\n唯一索引确保索引列中的所有值都是唯一的，但允许有空值。\n表可以有多个唯一索引。\n\n例子就不写了，跟上面差不多，相当于你在创建主键和唯一键的时候，底层就已经创建了索引，为了加快检索速度。\n普通索引（Normal Index）\n普通索引是最基本的索引类型，没有唯一性或空值的限制。\n可以对表中的一个或多个列创建普通索引。\n\nCREATE TABLE example (\n    id INT,\n    name VARCHAR(50),\n    INDEX idx_name (name)\n);\n\n如果已经有创建好的表，你可以使用CREATE INDEX语句来添加索引。以下是一般的语法格式：\nCREATE [UNIQUE] INDEX index_name\nON table_name (column1, column2, ...);\n\n\nindex_name：索引的名称，应该是唯一的，用于标识这个索引。\ntable_name：要添加索引的表名。\ncolumn1, column2, ...：要包含在索引中的列名。\n\n例如，如果你有一个名为 employees 的表，包含列 employee_id 和 last_name，你可以创建一个索引来加速按 last_name 进行查询的操作：\nCREATE INDEX idx_last_name\nON employees (last_name);\n\n如果你希望创建一个唯一索引，确保 last_name 的值是唯一的，可以使用以下语法：\nCREATE UNIQUE INDEX idx_last_name_unique\nON employees (last_name);\n\n需要注意的是，虽然可以在已经存在的表上添加索引，但在生产环境中，最好在设计表的时候就考虑好哪些字段需要索引，以及使用何种类型的索引。添加索引可能会导致表的锁定和大量的I/O操作，因此需要谨慎使用，特别是在大型表上。\n如果你的表很大，想要添加索引的话。。。那可能需要的时间就会非常的长。\n全文索引（Full-Text Index）\n全文索引用于在文本数据上执行全文搜索。\n主要用于对大文本字段（如TEXT和VARCHAR）进行高效的搜索操作。\n\nCREATE TABLE articles (\n    id INT,\n    title VARCHAR(100),\n    content TEXT,\n    FULLTEXT (title, content)\n);\n\n集合操作对集合（Set）的操作，它包括并集（UNION）、交集（INTERSECT）、差集（EXCEPT）等。然而，MySQL并没有提供标准的INTERSECT和EXCEPT操作符，但可以通过其他方式来实现相似的效果。以下是一些关于MySQL中SET操作的基本解释：\nUNION（并集）：\n\nUNION操作用于合并两个查询的结果集，返回不重复的行。语法如下：\n\nSELECT column1, column2, ...\nFROM table1\nUNION\nSELECT column1, column2, ...\nFROM table2;\n\n这将返回两个查询的结果的并集。\nINTERSECT（交集）：\n\nMySQL并没有内建的INTERSECT操作符。但可以通过使用INNER JOIN或IN子查询等方式来模拟交集的效果。例如：\n\nSELECT column1, column2, ...\nFROM table1\nWHERE column1 IN (SELECT column1 FROM table2);\n\n这将返回两个表的交集。\nEXCEPT（差集）：\n\n同样，MySQL没有内建的EXCEPT操作符。可以使用LEFT JOIN或NOT IN子查询等方法来模拟差集。例如：\n\nSELECT column1, column2, ...\nFROM table1\nWHERE column1 NOT IN (SELECT column1 FROM table2);\n\n这将返回在table1中但不在table2中的行。\n其他SET操作：\n\nMySQL还支持一些其他的集合操作，如UNION ALL（返回所有行，包括重复的行）、INTERSECT ALL、EXCEPT ALL等。这些操作在语法上与对应的不带ALL的操作类似，但会保留所有行，包括重复的。\n\n空值的处理条件中的空值在SQL的SELECT语句中，WHERE子句使用三值逻辑（three-valued logic）。三值逻辑是一种逻辑系统，其中逻辑语句的真（True）、假（False）以及第三个可能的值是未知（Unknown）。\n在上下文中，当使用WHERE子句时，该子句中的条件会产生三种可能的结果：\n\nTrue（真）： 满足条件，符合要求的行将被返回。\nFalse（假）： 不满足条件，不符合要求的行将被排除。\nUnknown（未知）： 条件对于某些行是未知的或不适用。这种情况下，行也会被排除，因为WHERE子句要求返回的是条件为True的行。\n\n这种三值逻辑在处理包含NULL值的情况时尤为重要。在SQL中，与NULL值的比较通常返回未知，因此，当涉及到NULL值的条件时，WHERE子句可能会产生未知的结果。例如，如果你有一个条件是 column1 = 10，而column1中有NULL值，那么由于NULL的比较结果是未知，这个条件就会被视为未知，相应的行将不会包括在结果中。\n举个例子来说：\n让我来建立一个这个student表格\nCREATE TABLE students (\n    student_id INT PRIMARY KEY,\n    name VARCHAR(50),\n    age INT,\n    grade INT\n);\n\nINSERT INTO students (student_id, name, age, grade) VALUES\n(1, 'Alice', 20, 85),\n(2, 'Bob', 22, 92),\n(3, 'Charlie', NULL, 75),\n(4, 'David', 21, NULL),\n(5, 'Eva', NULL, NULL);\n\n现在，我们将使用一个带有条件的SELECT语句，以演示三值逻辑的概念：\n-- 返回年龄大于等于21岁的学生\nSELECT * FROM students WHERE age &gt;= 21;\n\n在这个例子中，我们希望选择年龄大于等于21岁的学生。这里有几个情况：\n\nAlice（20岁） - 不符合条件，排除。\nBob（22岁） - 符合条件，包括在结果中。\nCharlie（NULL岁） - 由于NULL的比较结果是未知，所以他的行也被排除。\nDavid（21岁） - 符合条件，包括在结果中。\nEva（NULL岁） - 由于NULL的比较结果是未知，所以她的行也被排除。\n\n那么如果我的查询语句加上了这个条件会怎么样？\n-- 返回年龄大于等于21岁或者年龄是NULL的学生\nSELECT * FROM students WHERE age &gt;= 21 OR age IS NULL;\n\n这样就会考虑空值，然后就会返回符合条件的行。\n算术中的空值当对包含NULL的列进行算术运算时，结果将为NULL。在SQL中，任何包含NULL值的算术运算都会导致结果为NULL，这反映了NULL的未知或缺失值的性质。\n举个例子，想象一下表格：\nCREATE TABLE numbers (\n    num1 INT,\n    num2 INT\n);\n\nINSERT INTO numbers (num1, num2) VALUES\n(10, 5),\n(NULL, 8),\n(15, NULL),\n(NULL, NULL);\n\n现在，如果我们尝试进行一些算术运算：\n-- 尝试加法运算\nSELECT num1 + num2 AS result FROM numbers;\n\n在这个查询中，我们尝试对表格中的两列进行加法运算。然而，由于表格中包含NULL值，结果列将包含NULL值：\n\n\n\nresult\n\n\n\n15\n\n\n\n\n\n\n\n\n\n\n\n这是因为在任何涉及到NULL的算术运算中，结果都是NULL。这种行为是为了确保对未知或缺失值的任何运算都不会导致不确定的结果。\n如果你希望在执行算术运算时考虑NULL值，并希望将NULL值视为0，可以使用COALESCE函数或IFNULL函数：\n-- 使用COALESCE函数将NULL视为0\nSELECT COALESCE(num1, 0) + COALESCE(num2, 0) AS result FROM numbers;\n\n这样就会忽略NULL将它视为0进行计算：\n\n\n\nresult\n\n\n\n15\n\n\n8\n\n\n15\n\n\n0\n\n\n聚合中的空值COUNT函数：\n\nCOUNT函数用于计算行数，但是它会忽略包含NULL值的列，除非指定了列名或使用COUNT(*)。\n如果要计算包括NULL在内的行数，可以使用COUNT(*)。\n\nSUM、AVG和其他数学函数：\n\n在执行数学函数如SUM和AVG时，它们会忽略包含NULL值的行。\n如果希望将NULL值视为0，可以使用COALESCE或IFNULL函数进行处理。\n\n-- 计算总和，将NULL视为0\nSELECT SUM(COALESCE(column1, 0)) FROM table_name;\n\nMAX和MIN函数：\n\nMAX和MIN函数会忽略包含NULL值的行，除非使用MAX(column_name)或MIN(column_name)指定了列名。\n\n-- 获取包含NULL的列的最大值\nSELECT MAX(column1) FROM table_name;\n\n\n使用MAX(column_name)或MIN(column_name)可以考虑包含NULL的行。\n\nGROUP BY子句：\n\n在使用GROUP BY子句进行分组时，NULL值会被分为一组。\n\n-- 按列分组，NULL被分为一组\nSELECT column1, COUNT(*) FROM table_name GROUP BY column1;\n\n\n如果要在GROUP BY中将NULL值视为一个特定的值，可以使用COALESCE或IFNULL函数进行处理。\n\n-- 使用COALESCE将NULL值视为'Unknown'，然后按列分组\nSELECT COALESCE(column1, 'Unknown') AS grouped_column, COUNT(*) FROM table_name GROUP BY grouped_column;\n\nORDER BY子句：\n默认排序规则：\n\n默认情况下，对于升序排序（ORDER BY column1 ASC），NULL值会被认为是最小值，因此会出现在排序的最前面。\n对于降序排序（ORDER BY column1 DESC），NULL值会被认为是最大值，因此会出现在排序的最后面。\n\n-- 默认升序排序，NULL在最前面\nSELECT * FROM table_name ORDER BY column1 ASC;\n\n-- 默认降序排序，NULL在最后面\nSELECT * FROM table_name ORDER BY column1 DESC;\n\n使用COALESCE或IFNULL进行定制排序：\n\n你还可以使用COALESCE或IFNULL函数在ORDER BY子句中进行定制排序，将NULL视为特定的值。\n\n-- 使用COALESCE将NULL视为'Unknown'，然后按列升序排序\nSELECT * FROM table_name ORDER BY COALESCE(column1, 'Unknown') ASC;\n\n-- 使用IFNULL将NULL视为0，然后按列降序排序\nSELECT * FROM table_name ORDER BY IFNULL(column1, 0) DESC;\n\n总结通过一个例子来进行一个简单的总结：\n-- 建表语句\nCREATE TABLE employees (\n    employee_id INT PRIMARY KEY,\n    first_name VARCHAR(50),\n    last_name VARCHAR(50),\n    age INT,\n    salary DECIMAL(10, 2),\n    department_id INT,\n    hire_date DATE\n);\n\n-- 插入数据\nINSERT INTO employees (employee_id, first_name, last_name, age, salary, department_id, hire_date)\nVALUES\n(1, 'John', 'Doe', 30, 50000.00, 1, '2020-01-15'),\n(2, 'Jane', 'Smith', 28, 60000.00, NULL, '2019-05-20'),\n(3, 'Bob', 'Johnson', 35, NULL, 2, '2021-03-10'),\n(4, 'Alice', 'Williams', NULL, 55000.00, 1, '2022-02-05'),\n(5, 'Charlie', 'Brown', 32, 70000.00, NULL, NULL);\n\n然后这张表的全貌就是这样子：\n\n\n\nid\nfirst_name\nlast_name\nage\nsalary\ndepartment_id\nhire_date\n\n\n\n1\nJohn\nDoe\n30\n50000.00\n1\n2020-01-15\n\n\n2\nJane\nSmith\n28\n60000.00\n\n2019-05-20\n\n\n3\nBob\nJohnson\n35\n\n2\n2021-03-10\n\n\n4\nAlice\nWilliams\n\n55000.00\n1\n2022-02-05\n\n\n5\nCharlie\nBrown\n32\n70000.00\n\n\n\n\n现在我们来分别执行一下SQL语句\n比较运算符：-- 选择年龄大于等于30岁或者年龄是NULL的员工\nSELECT * FROM employees WHERE age &gt;= 30 OR age IS NULL;\n\n执行结果如下\n\n\n\nid\nfirst_name\nlast_name\nage\nsalary\ndepartment_id\nhire_date\n\n\n\n1\nJohn\nDoe\n30\n50000.00\n1\n2020-01-15\n\n\n3\nBob\nJohnson\n35\n\n2\n2021-03-10\n\n\n4\nAlice\nWilliams\n\n55000.00\n1\n2022-02-05\n\n\n5\nCharlie\nBrown\n32\n70000.00\n\n\n\n\n可以看到筛选出来的结果是包含年龄为NULL的，如果我们删掉后面这个条件：\nSELECT * FROM employees WHERE age &gt;= 30;\n\n结果就变成了：\n\n\n\nid\nfirst_name\nlast_name\nage\nsalary\ndepartment_id\nhire_date\n\n\n\n1\nJohn\nDoe\n30\n50000.00\n1\n2020-01-15\n\n\n3\nBob\nJohnson\n35\n\n2\n2021-03-10\n\n\n5\nCharlie\nBrown\n32\n70000.00\n\n\n\n\n可以看到空值在条件判断中默认是忽略的，原因看上面。\n聚合函数：-- 计算平均工资，将NULL值视为0\nSELECT AVG(COALESCE(salary, 0)) AS avg_salary FROM employees;\n\n执行结果如下：\n\n\n\navg_salary\n\n\n\n47000.000000\n\n\n可以看到我们将空值视为了0，如果我们直接计算该列的平均值呢？\n-- 计算平均工资，不将NULL值视为0\nSELECT AVG(salary) AS avg_salary FROM employees;\n\n可以看到执行结果就变成了：\n\n\n\navg_salary\n\n\n\n58750.000000\n\n\n因为他把工资列为NULL的行都忽略了，并没有纳入平均值的计算，所以导致平均值计算变得不准确，所以实际开发中还是要根据实际情况进行调用。\n排序：-- 按入职日期降序排序，将NULL值放在最后\nSELECT * FROM employees ORDER BY hire_date IS NULL, hire_date DESC;\n\n然后就能看到结果为：\n\n\n\nid\nfirst_name\nlast_name\nage\nsalary\ndepartment_id\nhire_date\n\n\n\n4\nAlice\nWilliams\n\n55000.00\n1\n2022-02-05\n\n\n3\nBob\nJohnson\n35\n\n2\n2021-03-10\n\n\n1\nJohn\nDoe\n30\n50000.00\n1\n2020-01-15\n\n\n2\nJane\nSmith\n28\n60000.00\n\n2019-05-20\n\n\n5\nCharlie\nBrown\n32\n70000.00\n\n\n\n\n条件中的处理：-- 选择属于部门2或者部门是NULL的员工\nSELECT * FROM employees WHERE department_id = 2 OR department_id IS NULL;\n\n返回结果为：\n\n\n\nid\nfirst_name\nlast_name\nage\nsalary\ndepartment_id\nhire_date\n\n\n\n2\nJane\nSmith\n28\n60000.00\n\n2019-05-20\n\n\n3\nBob\nJohnson\n35\n\n2\n2021-03-10\n\n\n5\nCharlie\nBrown\n32\n70000.00\n\n\n\n\n","slug":"MySQL-Review-8","date":"2023-12-06T11:13:57.000Z","categories_index":"","tags_index":"笔记,MySQL复习","author_index":"General_K1ng"},{"id":"dc1ef9ee097f4e4c28b3dcd1a91e91c5","title":"MySQL Review-7","content":"继续继续。。。\nGROUP BYGROUP BY 是 MySQL 中用于对查询结果进行分组的子句。它通常与聚合函数（如 SUM、COUNT、AVG 等）一起使用，以便对每个组应用聚合操作。使用 GROUP BY 可以将结果集按照一个或多个列的值分成不同的组。\n基本的 GROUP BY 语法如下：\nSELECT column1, column2, ..., aggregate_function(column)\nFROM table\nWHERE condition\nGROUP BY column1, column2, ...;\n\n\ncolumn1, column2, ...: 要检索的列的名称。\naggregate_function(column): 对每个组应用的聚合函数，可以是 SUM、COUNT、AVG 等。\ntable: 要查询的表的名称。\nWHERE condition: 可选的筛选条件。\nGROUP BY column1, column2, ...: 指定按哪些列进行分组。\n\n以下是一些使用 GROUP BY 的示例：\n用法1. 按单个列分组：-- 按部门分组，并计算每个部门的平均工资\nSELECT department_id, AVG(salary) AS avg_salary\nFROM employees\nGROUP BY department_id;\n\n2. 按多个列分组：-- 按部门和性别分组，并计算每个组的员工数量\nSELECT department_id, gender, COUNT(*) AS employee_count\nFROM employees\nGROUP BY department_id, gender;\n\n3. 使用聚合函数：-- 按部门分组，并计算每个部门的员工数量和总工资\nSELECT department_id, COUNT(*) AS employee_count, SUM(salary) AS total_salary\nFROM employees\nGROUP BY department_id;\n\n4. 结合 HAVING 子句：-- 按部门分组，并筛选出平均工资超过 50000 的部门\nSELECT department_id, AVG(salary) AS avg_salary\nFROM employees\nGROUP BY department_id\nHAVING avg_salary &gt; 50000;\n\n5. 使用表达式进行分组：-- 按出生年份分组，并计算每个年份的员工数量\nSELECT YEAR(birthdate) AS birth_year, COUNT(*) AS employee_count\nFROM employees\nGROUP BY birth_year;\n\nHavingHAVING 关键字在 SQL 中用于过滤聚合函数的结果。它通常与 GROUP BY 子句一起使用，用于筛选分组后的结果。HAVING 在过滤分组数据时起到与 WHERE 类似的作用，但 HAVING 主要用于聚合函数的筛选。\n基本的语法结构如下：\nSELECT column1, column2, aggregate_function(column3)\nFROM table_name\nGROUP BY column1, column2\nHAVING condition;\n\n\ncolumn1, column2: 要检索的列的名称，可以是一个或多个列。\naggregate_function(column3): 对某一列进行聚合函数操作，例如 SUM、COUNT、AVG 等。\ntable_name: 要检索数据的表的名称。\nGROUP BY column1, column2: 用于指定分组的列。\ncondition: 用于筛选分组数据的条件。\n\n以下是一些 HAVING 关键字的使用示例：\n用法1. 使用 HAVING 过滤聚合结果：SELECT department, AVG(salary) as avg_salary\nFROM employees\nGROUP BY department\nHAVING AVG(salary) &gt; 50000;\n\n上述查询将返回每个部门的平均工资，但只包括那些平均工资超过 50000 的部门。\n2. 结合 COUNT 和 HAVING：SELECT department, COUNT(employee_id) as employee_count\nFROM employees\nGROUP BY department\nHAVING COUNT(employee_id) &gt; 10;\n\n上述查询将返回每个部门的员工数量，但只包括那些员工数量超过 10 人的部门。\n3. 使用 SUM 和 HAVING：SELECT product_id, SUM(quantity) as total_quantity\nFROM order_details\nGROUP BY product_id\nHAVING SUM(quantity) &gt; 1000;\n\n上述查询将返回每个产品的总销售数量，但只包括那些总销售数量超过 1000 的产品。\n4. 结合 GROUP BY 和 HAVING：SELECT department, AVG(salary) as avg_salary\nFROM employees\nWHERE hire_date &gt; '2022-01-01'\nGROUP BY department\nHAVING AVG(salary) &gt; 50000;\n\n在这个例子中，WHERE 子句用于在分组之前过滤数据，而 HAVING 子句用于筛选符合条件的分组。\n实操假设我们有一个 orders 表，其中包含订单的信息，如下：\n-- 创建 orders 表\nCREATE TABLE orders (\n    order_id INT PRIMARY KEY,\n    customer_id INT,\n    order_date DATE,\n    total_amount DECIMAL(10, 2)\n);\n\n-- 插入一些示例数据\nINSERT INTO orders VALUES (1, 101, '2023-01-10', 150.00);\nINSERT INTO orders VALUES (2, 102, '2023-02-15', 200.50);\nINSERT INTO orders VALUES (3, 101, '2023-02-20', 120.00);\nINSERT INTO orders VALUES (4, 103, '2023-03-05', 350.75);\nINSERT INTO orders VALUES (5, 102, '2023-03-12', 180.25);\n\n现在，我们希望按照 customer_id 分组，并计算每个客户的订单数量和总订单金额。以下是一个使用 GROUP BY 的查询：\n-- 按照 customer_id 分组，并计算每个客户的订单数量和总订单金额\nSELECT customer_id, COUNT(*) AS order_count, SUM(total_amount) AS total_amount\nFROM orders\nGROUP BY customer_id;\n\n在这个查询中，我们使用了 GROUP BY customer_id 将结果按照 customer_id 列分组。然后，我们使用 COUNT(*) 计算每个客户的订单数量，并使用 SUM(total_amount) 计算每个客户的总订单金额。\n结果应该如下所示：\n\n\n\ncustomer_id\norder_count\ntotal_amount\n\n\n\n101\n2\n270.00\n\n\n102\n2\n380.75\n\n\n103\n1\n350.75\n\n\n可以清楚的看到，101的顾客下单数为2，并且总共消费了270.00，以此类推，这就是结果。\n然后我们还可以这样：\n-- 按照 customer_id 分组，计算每个客户的订单数量和总订单金额，\n-- 并筛选出订单数量超过 1 个且总订单金额超过 300 的客户\nSELECT customer_id, COUNT(*) AS order_count, SUM(total_amount) AS total_amount\nFROM orders\nGROUP BY customer_id\nHAVING order_count &gt; 1 AND SUM(total_amount) &gt; 300;\n\n就会得到订单数大于一切总消费大于300的顾客：\n\n\n\ncustomer_id\norder_count\ntotal_amount\n\n\n\n102\n2\n380.75\n\n\n聚合函数终于到达这一部分，怎么说呢，这一部分都很简单，都封装好了，你直接调用就可以了。\n1. COUNT()用于计算行的数量。\n-- 计算 employees 表中的总行数\nSELECT COUNT(*) FROM employees;\n\n2. SUM()用于计算数值列的总和。\n-- 计算 employees 表中工资的总和\nSELECT SUM(salary) FROM employees;\n\n3. AVG()用于计算数值列的平均值。\n-- 计算 employees 表中工资的平均值\nSELECT AVG(salary) FROM employees;\n\n4. MIN()用于找出数值列中的最小值。\n-- 找出 employees 表中最低的工资\nSELECT MIN(salary) FROM employees;\n\n5. MAX()用于找出数值列中的最大值。\n-- 找出 employees 表中最高的工资\nSELECT MAX(salary) FROM employees;\n\n6. GROUP_CONCAT()用于将组内的值连接成一个字符串。通常与GROUP BY一起使用。\n-- 将每个部门的员工姓名连接成字符串\nSELECT department_id, GROUP_CONCAT(first_name) AS employee_names\nFROM employees\nGROUP BY department_id;\n\n7. GROUP_CONCAT() with ORDER BYGROUP_CONCAT() 还可以结合 ORDER BY 子句，对连接的结果进行排序。\n-- 将每个部门的员工姓名连接成按照姓名升序排序的字符串\nSELECT department_id, GROUP_CONCAT(first_name ORDER BY first_name ASC) AS employee_names\nFROM employees\nGROUP BY department_id;\n\n8. GROUP_CONCAT() with DISTINCTGROUP_CONCAT() 可以与 DISTINCT 一起使用，以确保连接的结果中不包含重复的值。\n-- 将每个部门的不重复员工姓名连接成字符串\nSELECT department_id, GROUP_CONCAT(DISTINCT first_name) AS employee_names\nFROM employees\nGROUP BY department_id;\n\n9. IFNULL() / COALESCE()用于返回第一个非 NULL 的表达式。IFNULL() 是 MySQL 特有的，而 COALESCE() 是标准 SQL 的函数，两者在大多数情况下是等效的。\n-- 返回工资列，如果为 NULL，则返回 0\nSELECT IFNULL(salary, 0) FROM employees;\n\n-- 或者使用 COALESCE\nSELECT COALESCE(salary, 0) FROM employees;\n\n10. CONCAT()用于将两个或多个字符串连接在一起。\n-- 连接 first_name 和 last_name 列\nSELECT CONCAT(first_name, ' ', last_name) AS full_name FROM employees;\n\n11. SUBSTRING()用于提取字符串的子串。\n-- 提取 first_name 列的前三个字符\nSELECT SUBSTRING(first_name, 1, 3) AS short_name FROM employees;\n\n12. DATE_FORMAT()用于将日期格式化为指定的字符串。\n-- 格式化 order_date 列为 '年-月-日' 形式\nSELECT DATE_FORMAT(order_date, '%Y-%m-%d') AS formatted_date FROM orders;\n\n13. RAND()用于生成一个介于 0 和 1 之间的随机数。\n-- 生成一个随机数\nSELECT RAND() AS random_number;\n\n14. ROUND()用于将数值四舍五入到指定的小数位数。\n-- 将 salary 列四舍五入到两位小数\nSELECT ROUND(salary, 2) AS rounded_salary FROM employees;\n\n15. UPPER() / LOWER()用于将字符串转换为大写或小写。\n-- 将 first_name 列转换为大写\nSELECT UPPER(first_name) AS upper_name FROM employees;\n\n-- 将 last_name 列转换为小写\nSELECT LOWER(last_name) AS lower_name FROM employees;\n\n16. TRIM()用于去除字符串两端的空格或指定字符。\n-- 去除 description 列两端的空格\nSELECT TRIM(description) AS trimmed_description FROM products;\n\n17. LENGTH() / CHAR_LENGTH()用于返回字符串的字符数或字节数。\n-- 返回 first_name 列的字符数\nSELECT LENGTH(first_name) AS name_length FROM employees;\n\n-- 或者使用 CHAR_LENGTH\nSELECT CHAR_LENGTH(first_name) AS name_length FROM employees;\n\n18. DATEDIFF()用于计算两个日期之间的天数差。\n-- 计算订单的创建日期和现在之间的天数差\nSELECT DATEDIFF(NOW(), order_date) AS days_since_order FROM orders;\n\n19. IF() / CASE WHEN用于条件判断。\n-- 如果 salary 大于 50000，则返回 'High'，否则返回 'Low'\nSELECT employee_id, first_name, last_name, \n       IF(salary &gt; 50000, 'High', 'Low') AS salary_status\nFROM employees;\n\n或者使用 CASE WHEN：\nSELECT employee_id, first_name, last_name,\n       CASE WHEN salary &gt; 50000 THEN 'High' ELSE 'Low' END AS salary_status\nFROM employees;\n\n20. COUNT(DISTINCT column)用于计算唯一值的数量。\n-- 计算 employees 表中不同部门的数量\nSELECT COUNT(DISTINCT department_id) AS distinct_departments FROM employees;\n\n21. IN()用于判断某个值是否在一个集合中。\n-- 查询订单中客户ID为101、102、103的订单\nSELECT * FROM orders WHERE customer_id IN (101, 102, 103);\n\n22. CONVERT() / CAST()用于将一个类型的值转换为另一个类型。\n-- 将字符串 '123' 转换为整数类型\nSELECT CONVERT('123', SIGNED) AS converted_value;\n\n或者使用 CAST()：\nSELECT CAST('123' AS SIGNED) AS casted_value;\n\n23. LOCATE()查找子字符串在给定字符串中的位置。它返回子字符串在字符串中的起始位置，如果找不到则返回 0。\n-- 返回 'is' 在 'This is a sample string' 中的位置\nSELECT LOCATE('is', 'This is a sample string') AS position;\n\n-- 从第 6 个字符开始，在 'This is a sample string' 中查找 'is'\nSELECT LOCATE('is', 'This is a sample string', 6) AS position;\n\n-- 如果 'apple' 存在于 'This is an apple' 中，返回子字符串的位置，否则返回 0\nSELECT IF(LOCATE('apple', 'This is an apple'), LOCATE('apple', 'This is an apple'), 'Not found') AS position;\n\n\n\n\n\n\n\n\n\n\n\n","slug":"MySQL-Review-7","date":"2023-12-06T08:42:20.000Z","categories_index":"","tags_index":"笔记,MySQL复习","author_index":"General_K1ng"},{"id":"5248bd149e90c578d377990ba1015e7f","title":"MySQL Review-6","content":"这一节来讲关系非常复杂的JOIN，有各种JOIN，一个一个看。\nJOIN开始前放一个关系图，来自runoob\n\nok，这就是我们要学的各种复杂的关系。\nINNER JOININNER JOIN 是 MySQL 中用于连接两个或多个表的一种常见的连接类型。它根据两个表之间的共同列的匹配行将这些表组合在一起。INNER JOIN 只返回匹配条件为真的行，排除了不匹配的行。\n基本的 INNER JOIN 语法如下：\nSELECT table1.column1, table1.column2, table2.column3, ...\nFROM table1\nINNER JOIN table2 ON table1.common_column = table2.common_column;\n\n\ntable1.column1, table1.column2, ...: 要检索的列的名称，可以是一个或多个列，通常是来自第一个表。\ntable2.column3, ...: 同样是要检索的列的名称，通常是来自第二个表。\ntable1 和 table2: 要连接的两个表的名称。\ncommon_column: 两个表之间共同的列，用于匹配行的条件。\n\n以下是一些 INNER JOIN 的使用示例：\n用法1. 连接两个表的共同列：SELECT employees.employee_id, employees.first_name, employees.last_name, departments.department_name\nFROM employees\nINNER JOIN departments ON employees.department_id = departments.department_id;\n\n上述查询将返回员工的信息以及他们所属的部门名称，通过连接 employees 表和 departments 表的 department_id 列。\n2. 连接多个表：SELECT orders.order_id, customers.customer_name, products.product_name\nFROM orders\nINNER JOIN customers ON orders.customer_id = customers.customer_id\nINNER JOIN order_details ON orders.order_id = order_details.order_id\nINNER JOIN products ON order_details.product_id = products.product_id;\n\n上述查询连接了 orders、customers、order_details 和 products 四个表，返回了订单号、客户名称以及产品名称的信息。\n3. 连接表并添加条件：SELECT employees.employee_id, employees.first_name, employees.last_name, departments.department_name\nFROM employees\nINNER JOIN departments ON employees.department_id = departments.department_id\nWHERE employees.salary &gt; 50000;\n\n上述查询在连接 employees 表和 departments 表的基础上，添加了一个条件，只返回工资超过 50000 的员工信息。\n这样没有感觉，有电脑的可以直接来看这个例子。\n实操假设我们有两个表：employees 和 departments。employees 表存储员工的信息，departments 表存储部门的信息。两个表通过 department_id 列关联。下面是创建这两个表的 SQL 建表语句：\n-- 创建 employees 表\nCREATE TABLE employees (\n    employee_id INT PRIMARY KEY,\n    first_name VARCHAR(50),\n    last_name VARCHAR(50),\n    department_id INT,\n    salary INT\n);\n\n-- 插入一些示例数据\nINSERT INTO employees VALUES (1, 'John', 'Doe', 1, 60000);\nINSERT INTO employees VALUES (2, 'Jane', 'Smith', 2, 55000);\nINSERT INTO employees VALUES (3, 'Bob', 'Johnson', 1, 62000);\nINSERT INTO employees VALUES (4, 'Alice', 'Williams', 2, 58000);\n\n-- 创建 departments 表\nCREATE TABLE departments (\n    department_id INT PRIMARY KEY,\n    department_name VARCHAR(50)\n);\n\n-- 插入一些示例数据\nINSERT INTO departments VALUES (1, 'IT');\nINSERT INTO departments VALUES (2, 'HR');\n\n现在，我们可以使用 INNER JOIN 来查询员工的信息以及他们所在部门的名称。以下是一个使用 INNER JOIN 的查询示例：\n-- 使用 INNER JOIN 查询员工信息和部门名称\nSELECT employees.employee_id, employees.first_name, employees.last_name, employees.salary, departments.department_name\nFROM employees\nINNER JOIN departments ON employees.department_id = departments.department_id;\n\n上述查询将返回以下结果：\n\n\n\nemployee_id\nfirst_name\nlast_name\nsalary\ndepartment_name\n\n\n\n1\nJohn\nDoe\n60000\nIT\n\n\n2\nJane\nSmith\n55000\nHR\n\n\n3\nBob\nJohnson\n62000\nIT\n\n\n4\nAlice\nWilliams\n58000\nHR\n\n\nLEFT JOINLEFT JOIN 是 MySQL 中的一种连接类型，它返回左表中的所有行，并包括右表中匹配的行。如果右表中没有匹配的行，结果集中将包含 NULL 值。\n基本的 LEFT JOIN 语法如下：\nSELECT table1.column1, table1.column2, table2.column3, ...\nFROM table1\nLEFT JOIN table2 ON table1.common_column = table2.common_column;\n\n\ntable1.column1, table1.column2, ...: 要检索的列的名称，通常是来自左表。\ntable2.column3, ...: 同样是要检索的列的名称，通常是来自右表。\ntable1 和 table2: 要连接的两个表的名称。\ncommon_column: 两个表之间共同的列，用于匹配行的条件。\n\n以下是一些 LEFT JOIN 的使用示例：\n用法1. 连接两个表的共同列：SELECT employees.employee_id, employees.first_name, employees.last_name, departments.department_name\nFROM employees\nLEFT JOIN departments ON employees.department_id = departments.department_id;\n\n上述查询将返回所有员工的信息以及他们所在部门的名称，即使员工所在的部门在 departments 表中没有对应的记录。\n2. 连接多个表：SELECT orders.order_id, customers.customer_name, products.product_name\nFROM orders\nLEFT JOIN customers ON orders.customer_id = customers.customer_id\nLEFT JOIN order_details ON orders.order_id = order_details.order_id\nLEFT JOIN products ON order_details.product_id = products.product_id;\n\n上述查询连接了 orders、customers、order_details 和 products 四个表，返回了订单号、客户名称以及产品名称的信息。如果某个订单没有关联的客户或产品，对应的字段将包含 NULL 值。\n3. 结合 LEFT JOIN 和条件：SELECT employees.employee_id, employees.first_name, employees.last_name, departments.department_name\nFROM employees\nLEFT JOIN departments ON employees.department_id = departments.department_id\nWHERE employees.salary &gt; 50000;\n\n上述查询在连接 employees 表和 departments 表的基础上，添加了一个条件，只返回工资超过 50000 的员工信息。\n实操假设我们有两个表：students 和 courses。students 表存储学生的信息，courses 表存储课程的信息。两个表通过 student_id 列关联。下面是创建这两个表的 SQL 建表语句：\n-- 创建 students 表\nCREATE TABLE students (\n    student_id INT PRIMARY KEY,\n    first_name VARCHAR(50),\n    last_name VARCHAR(50),\n    age INT,\n    department VARCHAR(50)\n);\n\n-- 插入一些示例数据\nINSERT INTO students VALUES (1, 'John', 'Doe', 22, 'Computer Science');\nINSERT INTO students VALUES (2, 'Jane', 'Smith', 21, 'Mathematics');\nINSERT INTO students VALUES (3, 'Bob', 'Johnson', 23, 'Physics');\nINSERT INTO students VALUES (4, 'Alice', 'Williams', 22, 'Chemistry');\n\n-- 创建 courses 表\nCREATE TABLE courses (\n    course_id INT PRIMARY KEY,\n    course_name VARCHAR(50),\n    student_id INT,\n    FOREIGN KEY (student_id) REFERENCES students(student_id)\n);\n\n-- 插入一些示例数据\nINSERT INTO courses VALUES (101, 'Introduction to Computer Science', 1);\nINSERT INTO courses VALUES (102, 'Linear Algebra', 2);\n\n现在，我们可以使用 LEFT JOIN 来查询所有学生以及他们选修的课程。以下是一个使用 LEFT JOIN 的查询示例：\n-- 使用 LEFT JOIN 查询学生信息以及选修的课程\nSELECT students.student_id, students.first_name, students.last_name, students.age, students.department, courses.course_name\nFROM students\nLEFT JOIN courses ON students.student_id = courses.student_id;\n\n上述查询将返回以下结果：\n\n\n\nstudent_id\nfirst_name\nlast_name\nage\ndepartment\ncourse_name\n\n\n\n1\nJohn\nDoe\n22\nComputer Science\nIntroduction to CS\n\n\n2\nJane\nSmith\n21\nMathematics\nLinear Algebra\n\n\n3\nBob\nJohnson\n23\nPhysics\n\n\n\n4\nAlice\nWilliams\n22\nChemistry\n\n\n\n在这个例子中，LEFT JOIN 将 students 表和 courses 表连接在一起，通过它们的 student_id 列进行匹配。查询结果包含了所有学生的信息以及他们选修的课程，即使有的学生没有选修任何课程，对应的字段将包含 NULL 值。\n这里可以涉及一下RIGHT JOIN，其实RIGHT JOIN就相当于把LEFT JOIN反过来。\n-- 使用 RIGHT JOIN 查询学生信息以及选修的课程\nSELECT students.student_id, students.first_name, students.last_name, students.age, students.department, courses.course_name\nFROM students\nRIGHT JOIN courses ON students.student_id = courses.student_id;\n\n然后就会发现就返回了这两行，因为右外连接后，只会保留右表拥有的，而如果左表没有的则会用null值填充。\n\n\n\nstudent_id\nfirst_name\nlast_name\nage\ndepartment\ncourse_name\n\n\n\n1\nJohn\nDoe\n22\nComputer Science\nIntroduction to CS\n\n\n2\nJane\n3 1SELECT column1, column22FROM table13WHERE EXISTS (SELECT 1 FROM table2 WHERE condition);sql\n21\nMathematics\nLinear Algebra\n\n\nNATURAL JOINNATURAL JOIN 是一种在 MySQL 中进行表连接的方法，它基于两个表之间具有相同列名的原则，自动匹配这些相同列名的列进行连接。在 NATURAL JOIN 中，不需要显式指定连接条件，系统会自动根据相同列名进行匹配。\n基本的 NATURAL JOIN 语法如下：\nSELECT columns\nFROM table1\nNATURAL JOIN table2;\n\n\ncolumns: 要检索的列的名称。\ntable1 和 table2: 要连接的两个表的名称。\n\n以下是一些关于 NATURAL JOIN 的使用示例：\n用法1. 连接两个表：SELECT employees.employee_id, employees.first_name, employees.last_name, employees.salary, departments.department_name\nFROM employees\nNATURAL JOIN departments;\n\n上述查询将返回所有员工的信息以及他们所在部门的名称，通过自动匹配 employees 表和 departments 表中相同列名的列，即 department_id。\n2. 连接多个表：SELECT orders.order_id, customers.customer_name, products.product_name\nFROM orders\nNATURAL JOIN customers\nNATURAL JOIN order_details\nNATURAL JOIN products;\n\n上述查询连接了 orders、customers、order_details 和 products 四个表，返回了订单号、客户名称以及产品名称的信息，通过自动匹配相同列名的列。\n3. 使用 WHERE 子句限定条件：SELECT employees.employee_id, employees.first_name, employees.last_name, employees.salary, departments.department_name\nFROM employees\nNATURAL JOIN departments\nWHERE employees.salary &gt; 50000;\n\n上述查询在连接 employees 表和 departments 表的基础上，添加了一个条件，只返回工资超过 50000 的员工信息。\n\n\n\n\n\n\n\n\n\nNATURAL JOIN 简化了连接条件的书写，但也有一些潜在的问题和注意事项：\n\n潜在的歧义： 如果两个表中有多个相同列名的列，NATURAL JOIN 可能导致歧义，因此在设计数据库时需要小心避免这种情况。\n性能问题： NATURAL JOIN 的性能可能不如显式指定连接条件的 INNER JOIN，因为它需要在运行时自动匹配列。\n不够灵活： 由于 NATURAL JOIN 自动匹配所有相同列名的列，可能会导致连接的列不受控制，降低了查询的灵活性。\n\n实操这个和INNER JOIN很像，建表语句也采用上面一样的。\n我们可以使用 NATURAL JOIN 来查询所有员工的信息以及他们所在部门的名称，通过自动匹配 employees 表和 departments 表中相同列名的列，即 department_id。\n-- 使用 NATURAL JOIN 查询员工信息和部门名称\nSELECT employee_id, first_name, last_name, salary, department_name\nFROM employees\nNATURAL JOIN departments;\n\n上述查询将返回以下结果：\n\n\n\nemployee_id\nfirst_name\nlast_name\nsalary\ndepartment_name\n\n\n\n1\nJohn\nDoe\n60000\nIT\n\n\n2\nJane\nSmith\n55000\nHR\n\n\n3\nBob\nJohnson\n62000\nIT\n\n\n4\nAlice\nWilliams\n58000\nHR\n\n\n在这个例子中，NATURAL JOIN 自动匹配了 employees 表和 departments 表中相同列名的列（即 department_id），并返回了所有员工的信息以及他们所在部门的名称。\n但是如果我们更改一下，如果出现了NULL值，NATURAL JOIN会发生什么？\nUPDATE employees t SET t.department_id = null WHERE t.employee_id = 3\n\n然后我们再执行相同的SQL语句，此时就会发现返回结果为：\n\n\n\nemployee_id\nfirst_name\nlast_name\nsalary\ndepartment_name\n\n\n\n1\nJohn\nDoe\n60000\nIT\n\n\n2\nJane\nSmith\n55000\nHR\n\n\n4\nAlice\nWilliams\n58000\nHR\n\n\n这是因为NATURAL JOIN 在处理含有 NULL 值的列时可能引发一些问题，因为 NULL 值会被视为不相等。在自动匹配列名时，如果有 NULL 值，匹配的结果可能不符合预期。\n所以这玩意，不太好用。\nOUTER JOINOUTER JOIN 是一种连接类型，它包括左外连接 (LEFT OUTER JOIN 或简称为 LEFT JOIN)、右外连接 (RIGHT OUTER JOIN 或简称为 RIGHT JOIN) 以及全外连接 (FULL OUTER JOIN 或简称为 FULL JOIN)。OUTER JOIN 用于连接两个表，并返回满足连接条件的行，同时保留没有匹配行的记录，用 NULL 值填充这些缺失的部分。\n1. 左外连接 (LEFT OUTER JOIN 或 LEFT JOIN)左外连接返回左表中的所有行，并包括右表中匹配的行。如果右表中没有匹配的行，则结果集中右表的列将包含 NULL 值。\n跟上面讲的一样，这里提一下\n基本的语法如下：\nSELECT columns\nFROM table1\nLEFT JOIN table2 ON table1.column_name = table2.column_name;\n\n2. 右外连接 (RIGHT OUTER JOIN 或 RIGHT JOIN)右外连接返回右表中的所有行，并包括左表中匹配的行。如果左表中没有匹配的行，则结果集中左表的列将包含 NULL 值。\n基本的语法如下：\nSELECT columns\nFROM table1\nRIGHT JOIN table2 ON table1.column_name = table2.column_name;\n\n3. 全外连接 (FULL OUTER JOIN 或 FULL JOIN)哈哈，MySQL中不支持这个连接，但可以使用 LEFT JOIN 和 UNION 或者 RIGHT JOIN 和 UNION 的组合来模拟实现全外连接的效果。\n来个例子：\n-- 创建 students 表\nCREATE TABLE students (\n    student_id INT PRIMARY KEY,\n    first_name VARCHAR(50),\n    last_name VARCHAR(50)\n);\n\n-- 插入一些示例数据\nINSERT INTO students VALUES (1, 'John', 'Doe');\nINSERT INTO students VALUES (2, 'Jane', 'Smith');\nINSERT INTO students VALUES (3, 'Bob', 'Johnson');\n\n-- 创建 courses 表\nCREATE TABLE courses (\n    course_id INT PRIMARY KEY,\n    course_name VARCHAR(50)\n);\n\n-- 插入一些示例数据\nINSERT INTO courses VALUES (101, 'Math');\nINSERT INTO courses VALUES (102, 'English');\nINSERT INTO courses VALUES (103, 'History');\n\n然后我们使用左右分别连接然后进行合集操作。\n-- 左外连接\nSELECT students.student_id, students.first_name, students.last_name, courses.course_name\nFROM students\nLEFT JOIN courses ON students.student_id = courses.course_id\n\nUNION\n\n-- 右外连接\nSELECT students.student_id, students.first_name, students.last_name, courses.course_name\nFROM students\nRIGHT JOIN courses ON students.student_id = courses.course_id;\n\n然后返回\n\n\n\nid\nfirst_name\nlast_name\ncourse_name\n\n\n\n1\nJohn\nDoe\n\n\n\n2\nJane\nSmith\n\n\n\n3\nBob\nJohnson\n\n\n\n\n\n\nMath\n\n\n\n\n\nEnglish\n\n\n\n\n\nHistory\n\n\n这里先使用左外连接获取所有学生以及他们选修的课程，然后使用右外连接获取所有课程以及它们的学生。最后通过 UNION 合并这两个结果集，得到类似全外连接的效果。\nORDER BYORDER BY 是 MySQL 中用于对查询结果进行排序的子句。它允许你按照一个或多个列的升序（ASC）或降序（DESC）顺序对结果进行排序。ORDER BY 子句通常位于 SQL 查询的最后。\n基本的 ORDER BY 语法如下：\nSELECT column1, column2, ...\nFROM table\nORDER BY column1 [ASC|DESC], column2 [ASC|DESC], ...;\n\n\ncolumn1, column2, ...: 要检索的列的名称。\ntable: 要查询的表的名称。\nORDER BY column1 [ASC|DESC], column2 [ASC|DESC], ...: 指定一个或多个列以及它们的排序顺序。默认是升序（ASC），如果要降序排序，则使用 DESC。\n\n以下是一些使用 ORDER BY 的示例：\n用法1. 按单个列排序：-- 按工资降序排序员工信息\nSELECT employee_id, first_name, last_name, salary\nFROM employees\nORDER BY salary DESC;\n\n2. 按多个列排序：-- 先按部门升序排序，再按工资降序排序员工信息\nSELECT employee_id, first_name, last_name, department_id, salary\nFROM employees\nORDER BY department_id ASC, salary DESC;\n\n3. 对字符串列排序：-- 按学生姓名升序排序学生信息\nSELECT student_id, first_name, last_name\nFROM students\nORDER BY first_name ASC;\n\n4. 按计算列排序：-- 按工资和奖金之和降序排序员工信息\nSELECT employee_id, first_name, last_name, salary, bonus, (salary + bonus) AS total_compensation\nFROM employees\nORDER BY total_compensation DESC;\n\nORDER BY 子句也可以与其他子句一起使用，例如 WHERE、GROUP BY、HAVING 等，以便更灵活地组织查询。\n注意事项指定正确的列名： 确保在 ORDER BY 子句中指定的列名确实存在于查询结果中。否则，可能会导致语法错误或不符合预期的结果。\n-- 错误的示例：指定了不存在的列名\nSELECT employee_id, first_name, last_name\nFROM employees\nORDER BY non_existent_column;\n\n处理 NULL 值： 在排序时，NULL 值的处理可能需要格外小心。默认情况下，对于升序排序，NULL 值会被排在最前面；而对于降序排序，NULL 值会被排在最后面。你可以使用 ORDER BY column_name ASC NULLS FIRST 或 ORDER BY column_name DESC NULLS LAST 来明确指定 NULL 值的位置。\n-- 将 NULL 值排在最后面的示例\nSELECT employee_id, first_name, last_name\nFROM employees\nORDER BY last_name ASC NULLS LAST;\n\n处理文本排序： 当排序文本列时，可能会受到大小写敏感性和特定字符集的影响。确保在排序之前了解数据库的默认排序规则，并在必要时使用 COLLATE 子句指定排序规则。\n-- 指定不区分大小写的排序规则\nSELECT student_id, first_name, last_name\nFROM students\nORDER BY last_name COLLATE utf8_general_ci;\n\n谨慎使用排序表达式： 如果在 ORDER BY 中使用了表达式，确保表达式的结果是可排序的。有些表达式可能会导致无法预测的排序结果。\n-- 错误的示例：在 ORDER BY 中使用非可排序的表达式\nSELECT employee_id, first_name, last_name\nFROM employees\nORDER BY CONCAT(last_name, first_name);\n\n性能注意： 在大型数据集上进行排序可能会影响性能。确保只对需要排序的列进行排序，避免不必要的开销。\n-- 错误的示例：对所有列进行排序\nSELECT *\nFROM employees\nORDER BY employee_id;\n\n使用 LIMIT 时排序的影响： 如果你在查询中使用了 LIMIT 子句，排序的效果可能会受到限制的影响。ORDER BY 通常是在应用 LIMIT 之前完成的，因此你可能会得到按照排序顺序的前几行，而不是按照整个结果集排序。\n-- 在排序之前应用 LIMIT 的示例\nSELECT employee_id, first_name, last_name\nFROM employees\nORDER BY last_name ASC\nLIMIT 10;\n\n\n\n\n\n","slug":"MySQL-Review-6","date":"2023-12-06T07:14:37.000Z","categories_index":"","tags_index":"笔记,MySQL复习","author_index":"General_K1ng"},{"id":"383417e51810f2ed41db351deff5d8e2","title":"MySQL Review-5","content":"继续继续，接着上一篇继续讲这个逻辑运算符。\n逻辑运算符学过编程的应该都能看懂，与或非嘛。\nAND（&amp;&amp;）： 逻辑与运算符，用于结合两个条件，只有当两个条件都为真时，整个条件才为真。\nSELECT *\nFROM employees\nWHERE department = 'IT' AND salary &gt; 50000;\n\nOR（||）： 逻辑或运算符，用于结合两个条件，只要其中一个条件为真，整个条件就为真。\nSELECT *\nFROM employees\nWHERE department = 'HR' OR department = 'Finance';\n\nNOT（!）： 逻辑非运算符，用于否定一个条件，如果条件为真，则返回假，如果条件为假，则返回真。\nSELECT *\nFROM employees\nWHERE NOT department = 'IT';\n\n或者使用 &lt;&gt; 运算符：\nSELECT *\nFROM employees\nWHERE department &lt;&gt; 'IT';\n\nIN： 用于匹配一列中的任何值与指定的值列表之一。\nSELECT *\nFROM employees\nWHERE department IN ('IT', 'HR', 'Finance');\n\nBETWEEN AND： 用于匹配一个范围内的值。\nSELECT *\nFROM products\nWHERE price BETWEEN 50 AND 100;\n\nLIKE： 用于匹配模式，常与通配符一起使用。\nSELECT *\nFROM employees\nWHERE last_name LIKE 'S%';\n\nIS NULL 和 IS NOT NULL： 用于匹配空值和非空值。\nSELECT *\nFROM employees\nWHERE manager_id IS NULL;\n\n这些逻辑运算符可以结合使用，以创建更复杂的条件，以满足特定的查询需求。在使用逻辑运算符时，注意运算符的优先级，可以使用括号来明确指定运算的顺序，以确保查询的逻辑正确性。例如：\nSELECT *\nFROM employees\nWHERE (department = 'IT' OR department = 'HR') AND salary &gt; 50000;\n\n注意事项运算符的优先级： 不同的逻辑运算符具有不同的优先级。当多个逻辑运算符同时出现时，确保清楚了解它们的优先级，可以使用括号来明确指定运算的顺序。例如，AND 的优先级高于 OR。\nSELECT *\nFROM employees\nWHERE department = 'IT' OR department = 'HR' AND salary &gt; 50000;\n\n上述查询中，AND 的优先级高于 OR，所以实际上是 department = 'IT' OR (department = 'HR' AND salary &gt; 50000)。\n为了消除歧义，最好使用括号明确指定优先级：\nSELECT *\nFROM employees\nWHERE (department = 'IT' OR department = 'HR') AND salary &gt; 50000;\n\n避免过度复杂的逻辑： 避免创建过于复杂的逻辑条件，以免导致难以理解和维护的查询。如果逻辑条件变得复杂，可能需要将其拆分为多个简单的条件，以提高可读性。\n注意 NULL 的处理： 在涉及到 NULL 值的比较时，要小心使用 IS NULL 和 IS NOT NULL。NULL 的比较结果可能是未知的，因此要特别注意这些情况。\n-- 错误的比较\nSELECT *\nFROM employees\nWHERE department = NULL;\n\n-- 正确的比较\nSELECT *\nFROM employees\nWHERE department IS NULL;\n\n使用合适的运算符： 选择适当的逻辑运算符取决于具体的查询需求。确保选择正确的运算符，如 AND、OR、IN、BETWEEN 等。\n注意字符集和排序规则： 在进行字符串比较时，确保了解你的数据库使用的字符集和排序规则。不同的字符集和排序规则可能会导致不同的比较结果。\n避免在索引列上使用函数： 在逻辑条件中，尽量避免在索引列上使用函数，因为这可能导致索引失效，从而降低查询性能。\n-- 不推荐\nSELECT *\nFROM products\nWHERE YEAR(sale_date) = 2023;\n\n-- 推荐\nSELECT *\nFROM products\nWHERE sale_date &gt;= '2023-01-01' AND sale_date &lt; '2024-01-01';\n\n笛卡尔积笛卡尔积（Cartesian Product）是指在没有任何条件的情况下，两个或多个表之间的所有可能的组合。当没有使用 JOIN 条件时，MySQL 将返回两个表之间的笛卡尔积。\n-- 创建两个简单的表\nCREATE TABLE table1 (\n    id INT,\n    name VARCHAR(20)\n);\n\nCREATE TABLE table2 (\n    id INT,\n    value INT\n);\n\n-- 插入一些数据\nINSERT INTO table1 (id, name) VALUES (1, 'Alice'), (2, 'Bob');\nINSERT INTO table2 (id, value) VALUES (1, 100), (2, 200);\n\n-- 查询两个表的笛卡尔积\nSELECT *\nFROM table1, table2;\n\n上述查询将返回一个包含所有可能组合的结果集，即 table1 中的每一行与 table2 中的每一行的组合：\n\n\n\nid\nname\nid\nvalue\n\n\n\n2\nBob\n1\n100\n\n\n1\nAlice\n1\n100\n\n\n2\nBob\n2\n200\n\n\n1\nAlice\n2\n200\n\n\n在实际使用中，很少需要获取两个表的笛卡尔积，因为这通常会导致结果集非常庞大。正常情况下，通过使用 JOIN 子句来根据某些条件连接两个表，以获取有意义的关联数据。例如：\n-- 使用 JOIN 条件连接两个表\nSELECT *\nFROM table1\nJOIN table2 ON table1.id = table2.id;\n\n在这个例子中，table1.id = table2.id 是连接条件，而不是返回笛卡尔积。笛卡尔积是在没有任何连接条件的情况下获取的，而正常的关联查询则通过指定连接条件来获取有关联性的结果。\nJOIN后面会讲，这里是为了笔记的完整。\n当然学校里讲了用WHERE然后通过各自表名来指定具有相同的列名\n-- 使用 WHERE 条件连接两个表\nSELECT *\nFROM table1, table2\nWHERE table1.id = table2.id;\n\n这样其实两者和JOIN获得的结果是一样的，一些 SQL 查询可能使用 WHERE 子句来表示连接条件，尤其是在较早的 SQL 版本中。\n但是后面会讲到，我们几乎从来不会用WHERE来指定两个表之间的关系，等我们后面讲到JOIN的时候会着重讲。\n注意事项这一部分的注意事项就是为了避免过大的笛卡尔积，而且牵扯到数据库的一些性能上的调优。\n结果集的大小： 笛卡尔积会返回两个或多个表之间的所有可能组合，导致结果集的大小可能会非常庞大。在实际应用中，通常需要通过合适的条件（例如 WHERE 子句或 JOIN 条件）来限制结果集，以防止返回过大的数据量。\n性能影响： 笛卡尔积的性能影响很大，尤其是在表的行数较大时。因为它需要计算和返回所有可能的组合，可能导致查询变得缓慢。在实际使用中，要特别小心避免无意义的笛卡尔积。\n避免不必要的笛卡尔积： 在实际查询中，尽量避免无意义的笛卡尔积。确保查询中有适当的条件来限制结果集，以获得有意义和有效的数据。\n使用连接条件： 在实际应用中，很少直接使用逗号（,）生成笛卡尔积，而是通过使用连接条件，例如使用 JOIN 子句，来获取有意义的关联数据。\nSELECT *\nFROM table1\nJOIN table2 ON table1.id = table2.id;\n\nININ 关键字在 MySQL 中用于判断一个值是否在一个给定的值列表中。它通常用于替代多个 OR 条件的情况，使得查询更加简洁和可读。\n基本的语法结构如下：\nSELECT column1, column2, ...\nFROM table_name\nWHERE column_name IN (value1, value2, ...);\n\n\ncolumn1, column2, ...: 要检索的列的名称，可以是一个或多个列。\ntable_name: 要检索数据的表的名称。\ncolumn_name: 要进行 IN 操作的列的名称。\nvalue1, value2, ...: 用于比较的值列表。\n\n以下是一些 IN 关键字的使用示例：\n用法1. 使用常量值列表：SELECT *\nFROM products\nWHERE category_id IN (1, 2, 3);\n\n上述查询将返回 category_id 列中值为 1、2 或 3 的所有产品。\n2. 使用子查询：SELECT *\nFROM employees\nWHERE department_id IN (SELECT department_id FROM departments WHERE location = 'New York');\n\n上述查询将返回在 ‘New York’ 地点的部门中工作的所有员工。\n子查询后面会讲到，妈的SQL的知识点怎么这么复杂。\n3. 使用字符串列表：SELECT *\nFROM customers\nWHERE country IN ('USA', 'Canada', 'Mexico');\n\n上述查询将返回位于 ‘USA’、’Canada’ 或 ‘Mexico’ 的所有客户。\n4. 使用 NULL：SELECT *\nFROM orders\nWHERE customer_id IN (1, 2, NULL);\n\nIN 运算符可以用于包含 NULL 值，但要注意 IN 运算符的行为与其他比较运算符可能不同。在 IN 中，NULL 被视为未知，因此与 IN (1, 2, NULL) 比较时，如果列的值为 NULL，它将被包括在结果中。\n5. 使用子查询限制值范围：SELECT *\nFROM products\nWHERE price IN (SELECT MAX(price) FROM products);\n\n上述查询将返回价格等于产品中最高价格的所有产品。\nEXISTSEXISTS 关键字在 MySQL 中用于检查子查询是否返回任何行。如果子查询返回至少一行，则 EXISTS 条件为真；如果子查询没有返回任何行，则 EXISTS 条件为假。EXISTS 主要用于检查子查询是否为空，而不是返回具体的值。\n基本的语法结构如下：\nSELECT column1, column2, ...\nFROM table_name\nWHERE EXISTS (SELECT * FROM another_table WHERE condition);\n\n\ncolumn1, column2, ...: 要检索的列的名称，可以是一个或多个列。\ntable_name: 要检索数据的表的名称。\nanother_table: 用于子查询的表的名称。\ncondition: 子查询中的条件，用于限制子查询返回的行。\n\n以下是一些 EXISTS 关键字的使用示例：\n用法1. 使用 EXISTS 检查是否存在相关行：SELECT *\nFROM employees e\nWHERE EXISTS (SELECT 1 FROM departments d WHERE d.department_id = e.department_id);\n\n上述查询将返回至少在 departments 表中存在的 employees 表中的所有员工。\n2. 使用 NOT EXISTS 检查是否不存在相关行：SELECT *\nFROM products p\nWHERE NOT EXISTS (SELECT 1 FROM orders o WHERE o.product_id = p.product_id);\n\n上述查询将返回在 orders 表中没有对应订单的所有产品。\n3. 使用子查询限制条件：SELECT *\nFROM customers c\nWHERE EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id AND o.order_date &gt;= '2023-01-01');\n\n上述查询将返回至少在 orders 表中存在，并且订单日期在 ‘2023-01-01’ 之后的所有客户。\n4. 使用 EXISTS 作为连接条件：SELECT *\nFROM employees e\nWHERE EXISTS (SELECT 1 FROM departments d WHERE d.department_id = e.department_id)\n  AND e.salary &gt; 50000;\n\n上述查询将返回在 departments 表中存在并且薪水大于 50000 的所有员工。\n子查询好，终于到了这个byd子查询。\n在 MySQL 中，子查询是指嵌套在其他 SQL 查询语句中的查询。子查询可以出现在 SELECT、FROM、WHERE 或 HAVING 子句中，用于执行嵌套的、独立的查询，并将其结果用于外部查询。\n也就是说，在查询过程中，可以先通过子查询返回回来的结果作为条件的一部分，然后再进行查询。\n用法1. 在 SELECT 子句中使用子查询：SELECT column1, (SELECT column2 FROM table2 WHERE condition) AS subquery_result\nFROM table1;\n\n在这个例子中，子查询 (SELECT column2 FROM table2 WHERE condition) 返回一个单一的值，并将其命名为 subquery_result。\n2. 在 FROM 子句中使用子查询：SELECT column1, column2\nFROM (SELECT column1, column2 FROM table1 WHERE condition) AS subquery_result;\n\n在这个例子中，子查询 (SELECT column1, column2 FROM table1 WHERE condition) 返回一组结果，作为一个虚拟的表被用于外部查询的 FROM 子句。\n3. 在 WHERE 子句中使用子查询：SELECT column1, column2\nFROM table1\nWHERE column1 = (SELECT column1 FROM table2 WHERE condition);\n\n在这个例子中，子查询 (SELECT column1 FROM table2 WHERE condition) 返回一个值，用于与外部查询的 WHERE 子句中的条件进行比较。\n4. 在 IN 子句中使用子查询：SELECT column1, column2\nFROM table1\nWHERE column1 IN (SELECT column1 FROM table2 WHERE condition);\n\n在这个例子中，子查询 (SELECT column1 FROM table2 WHERE condition) 返回一组值，用于与外部查询的 IN 子句中的条件进行比较。\n5. 在 EXISTS 子句中使用子查询：SELECT column1, column2\nFROM table1\nWHERE EXISTS (SELECT 1 FROM table2 WHERE condition);\n\n在这个例子中，子查询 (SELECT 1 FROM table2 WHERE condition) 返回结果集的存在性，用于与外部查询的 EXISTS 子句中的条件进行比较。\n注意事项\n子查询的性能可能受影响，特别是在处理大量数据时。在使用子查询时，要确保查询的效率，并考虑是否有更好的优化方法。\n使用适当的连接（JOIN）和索引，以提高子查询的性能。\n注意处理子查询返回的结果集的唯一性，确保子查询返回的值不会引起外部查询的错误。\n子查询可以嵌套多层，但过度嵌套可能会降低查询的可读性。在编写复杂的查询时，考虑使用表连接（JOIN）和其他联结方式。\n\n","slug":"MySQL-Review-5","date":"2023-12-06T06:26:47.000Z","categories_index":"","tags_index":"笔记,MySQL复习","author_index":"General_K1ng"},{"id":"3cf8efd46ba4d0ca921476f1afc68b5c","title":"MySQL Review-4","content":"今天来继续复习MySQL中的SELECT语句，也是以后基本上用的最多的查询操作。\nSELECT一般形式SELECT主要用于从数据库当中检索数据，这是它的一般形式。\nSELECT column1, column2, ...\nFROM table_name\nWHERE condition;\n\n\ncolumn1, column2, ...: 要检索的列的名称，可以是一个或多个列，也可以使用通配符*表示选择所有列。\ntable_name: 要检索数据的表的名称。\nWHERE condition: 可选的条件，用于过滤检索的数据。如果省略此部分，将检索表中的所有行。\n\n后面我们会讲到WHERE关键字，现在只需要知道后面跟的是需要查询的条件。\n以下是一个简单的SELECT语句的例子：\nSELECT first_name, last_name\nFROM employees\nWHERE department = 'IT';\n\n这个例子从名为”employees”的表中选择了”first_name”和”last_name”列，其中部门是”IT”的所有员工。\n注意事项\n语法规范： 确保SELECT语句的语法正确。检查列名、表名和条件是否正确拼写，并使用正确的SQL语法。\n数据类型匹配： 确保条件中使用的数据类型与数据库表中的数据类型匹配。例如，如果某列是字符串类型，条件中的值应该用单引号括起来。\n通配符的使用： 谨慎使用通配符*，因为它选择表中的所有列。这可能导致不必要的数据传输和性能问题。最好只选择需要的列。\n索引的使用： 使用索引可以加速SELECT语句的执行。确保表中经常用于检索的列上创建了适当的索引。\n避免使用SELECT *： 尽量避免使用SELECT *，而是明确列出需要检索的列。这有助于减少数据传输和提高查询性能。\n条件优化： 使用有效的条件来过滤结果集，以减少返回的数据量。这有助于提高查询性能。\n数据安全： 对于用户提供的数据，使用参数化查询或预处理语句，以防止SQL注入攻击。\n使用LIMIT： 当你只需要获取前几行结果时，使用LIMIT子句来限制结果集的大小，从而提高性能。\n\nSELECT column1, column2\nFROM table_name\nWHERE condition\nLIMIT 10;\n\n这样会通过LIMIT来限制查询出来的结果只为10条。\nDISTINCT 和 ALLDISTINCT 和 ALL 是 MySQL 中用于处理重复数据的关键字，它们通常用于配合 SELECT 语句，影响查询结果中的重复行。\nDISTINCTDISTINCT 关键字用于从结果集中去除重复的行，只返回唯一的行。以下是一些基本用法：\nSELECT DISTINCT column1, column2, ...\nFROM table_name\nWHERE condition;\n\n\ncolumn1, column2, ...: 要检索的列的名称，可以是一个或多个列，也可以使用通配符 * 表示选择所有列。\ntable_name: 要检索数据的表的名称。\nWHERE condition: 可选的条件，用于过滤检索的数据。\n\n例如：\nSELECT DISTINCT department\nFROM employees;\n\n上述查询将返回唯一的部门列表，去除了重复的部门名。\nALLALL 关键字用于保留所有的行，包括重复的行。它通常用于与聚合函数（如 COUNT()、SUM() 等）一起使用，以便在整个结果集上执行聚合操作。以下是一些基本用法：\nSELECT ALL column1, column2, ...\nFROM table_name\nWHERE condition;\n\n例如：\nSELECT ALL salary\nFROM employees\nWHERE department = 'IT';\n\n这个查询将返回部门为 ‘IT’ 的所有员工的薪水，包括重复的薪水值。\n需要注意的是，默认情况下，ALL 是隐式的，也就是说，当没有指定 DISTINCT 时，ALL 是默认的行为。因此，通常在不需要去除重复行的情况下，你可以省略 ALL。\n-- 下面两个查询等效\nSELECT column1, column2, ...\nFROM table_name\nWHERE condition;\n\nSELECT ALL column1, column2, ...\nFROM table_name\nWHERE condition;\n\nAS在MySQL中，AS 关键字用于给列或表达式指定别名（alias）。别名是一个临时的名称，使得查询结果更易读或用于标识计算列的结果。\nAS 可以省略，直接使用空格或不使用别名，但添加别名通常能够提高查询结果的可读性。\n以下是 AS 关键字的基本用法：\n1. 列别名：SELECT column_name AS alias_name\nFROM table_name;\n\n例子：\nSELECT first_name AS \"First Name\", last_name AS \"Last Name\"\nFROM employees;\n\n在上述例子中，查询结果中的 first_name 和 last_name 列被分别命名为 “First Name” 和 “Last Name”。\n2. 表别名：SELECT column1, column2, ...\nFROM table_name AS alias_name;\n\n例子：\nSELECT e.first_name, e.last_name, d.department_name\nFROM employees AS e\nJOIN departments AS d ON e.department_id = d.department_id;\n\n在上述例子中，employees 表和 departments 表被分别用 e 和 d 作为别名，以简化查询语句。\n3. 列表达式别名：SELECT column_name + 10 AS alias_name\nFROM table_name;\n\n例子：\nSELECT salary * 0.1 AS bonus\nFROM employees;\n\n在上述例子中，salary * 0.1 被命名为 bonus。\nAS 关键字在这些情境中是可选的，你可以直接使用空格：\nSELECT column_name alias_name\nFROM table_name;\n\n或者干脆省略：\nSELECT column_name\nFROM table_name;\n\n但是我的习惯一般是要把AS加上，一种代码的规范。\nWHEREWHERE 关键字在 MySQL 中用于过滤从表中检索的数据，它允许你指定一个条件，只有符合条件的行才会包含在查询的结果集中。以下是 WHERE 关键字的基本用法：\nSELECT column1, column2, ...\nFROM table_name\nWHERE condition;\n\n\ncolumn1, column2, ...: 要检索的列的名称，可以是一个或多个列，也可以使用通配符 * 表示选择所有列。\ntable_name: 要检索数据的表的名称。\ncondition: 过滤条件，用于确定哪些行应该包含在结果集中。\n\n以下是一些 WHERE 关键字的用法和示例：\n用法1. 简单条件：SELECT *\nFROM employees\nWHERE department_id = 1;\n\n上述查询将返回 department_id 等于 1 的所有员工的信息。\n2. 多个条件：SELECT *\nFROM orders\nWHERE customer_id = 1 AND order_status = 'Shipped';\n\n上述查询使用 AND 运算符结合两个条件，只返回 customer_id 为 1 且 order_status 为 ‘Shipped’ 的订单。\n这里的AND不用说也知道表示“且”，后面会单独讲，这里只作为例子。\n3. 范围条件：SELECT *\nFROM products\nWHERE price BETWEEN 50 AND 100;\n\n上述查询使用 BETWEEN 关键字，返回价格在 50 到 100 之间的产品。\n其实这里也能看出来，写SQL就跟写英语一样。。\n4. 字符串匹配：SELECT *\nFROM customers\nWHERE last_name LIKE 'S%';\n\n上述查询使用 LIKE 关键字，返回姓氏以 ‘S’ 开头的客户。\n5. 空值检查：SELECT *\nFROM employees\nWHERE manager_id IS NULL;\n\n上述查询使用 IS NULL，返回 manager_id 列为空的员工。\n6. IN 子句：SELECT *\nFROM products\nWHERE category_id IN (1, 2, 3);\n\n上述查询使用 IN 关键字，返回属于指定类别的产品。\n7. 复杂条件：SELECT *\nFROM orders\nWHERE (customer_id = 1 AND order_status = 'Shipped') OR (customer_id = 2 AND order_status = 'Processing');\n\n就。。复杂条件，只要有小学英文水平和逻辑能力，基本上都能看懂。\n注意事项这一部分对于开发来说是非常重要的，不然会出大问题。\n注意条件的顺序： WHERE中的条件顺序可能会影响查询的性能。一般来说，更有选择性的条件应该放在前面，以便尽早排除不符合条件的行。\n-- 不推荐\nSELECT *\nFROM employees\nWHERE department_id = 1 AND last_name LIKE 'S%';\n\n-- 推荐\nSELECT *\nFROM employees\nWHERE last_name LIKE 'S%' AND department_id = 1;\n\n避免在列上使用函数： 在WHERE条件中，避免在列上使用函数，因为这可能导致索引失效，从而降低查询性能。\n-- 不推荐\nSELECT *\nFROM products\nWHERE YEAR(sale_date) = 2023;\n\n-- 推荐\nSELECT *\nFROM products\nWHERE sale_date &gt;= '2023-01-01' AND sale_date &lt; '2024-01-01';\n\n使用索引： 确保涉及到WHERE条件的列上有适当的索引。索引可以加速数据检索，提高查询性能。\n谨慎使用NULL： 当使用NULL作为条件时，要小心，因为在SQL中，与NULL的比较不同于与其他值的比较。使用IS NULL或IS NOT NULL来检查NULL值。\n-- 不推荐\nSELECT *\nFROM employees\nWHERE manager_id = NULL;\n\n-- 推荐\nSELECT *\nFROM employees\nWHERE manager_id IS NULL;\n\n避免在索引列上使用函数： 如果在索引列上使用了函数，索引可能无法被有效利用，从而导致查询性能下降。\n-- 不推荐\nSELECT *\nFROM products\nWHERE YEAR(sale_date) = 2023;\n\n-- 推荐\nSELECT *\nFROM products\nWHERE sale_date &gt;= '2023-01-01' AND sale_date &lt; '2024-01-01';\n\n使用合适的比较运算符： 根据具体情况选择合适的比较运算符，如=、&lt;、&gt;、&lt;=、&gt;=等。\nSELECT *\nFROM products\nWHERE price &gt; 100;\n\n防止SQL注入： 使用参数化查询或预处理语句，以避免SQL注入攻击。不要直接将用户输入的值嵌入到SQL查询中。\n-- 避免\n$user_input = \"Robert'; DROP TABLE employees;\";\n$sql = \"SELECT * FROM users WHERE username = '$user_input'\";\n\n-- 推荐\n$user_input = \"Robert'; DROP TABLE employees;\";\n$stmt = $pdo-&gt;prepare(\"SELECT * FROM users WHERE username = ?\");\n$stmt-&gt;execute([$user_input]);\n\n这些是开发层面的注意事项，对于考试应该帮助不大。\nLIKELIKE 关键字在 MySQL 中用于模糊匹配，通常与通配符一起使用，以便在搜索中匹配模式而不是确切的值。\n这是它的一般语法\nSELECT column1, column2, ...\nFROM table_name\nWHERE column_name LIKE pattern;\n\n\ncolumn1, column2, ...: 要检索的列的名称，可以是一个或多个列，也可以使用通配符 * 表示选择所有列。\ntable_name: 要检索数据的表的名称。\ncolumn_name: 要进行模糊匹配的列的名称。\npattern: 匹配模式，可以包含通配符。\n\n以下是一些 LIKE 关键字的使用示例：\n用法1. 百分号 % 通配符：-- 以 'S' 开头的所有数据\nSELECT *\nFROM employees\nWHERE last_name LIKE 'S%';\n\n上述查询将返回姓氏以 ‘S’ 开头的所有员工的信息。\n-- 包含 'son' 的任何位置的数据\nSELECT *\nFROM products\nWHERE product_name LIKE '%son%';\n\n上述查询将返回产品名称中包含 ‘son’ 的所有产品。\n而且结合之前讲的字符串比较，可以想想这里的匹配是否区分大小写？\n2. 下划线 _ 通配符：-- 第三个字母为 'i' 的所有数据\nSELECT *\nFROM customers\nWHERE last_name LIKE '__i%';\n\n上述查询将返回姓氏中第三个字母为 ‘i’ 的所有客户的信息。\n3. NOT LIKE：-- 不以 'A' 开头的所有数据\nSELECT *\nFROM employees\nWHERE last_name NOT LIKE 'A%';\n\n上述查询将返回姓氏不以 ‘A’ 开头的所有员工的信息。\n4. 使用 ESCAPE：-- 查找包含 '%' 的数据\nSELECT *\nFROM products\nWHERE product_name LIKE '%\\%%' ESCAPE '\\';\n\n在某些情况下，如果你需要搜索包含 % 字符的实际数据，你可以使用 ESCAPE 子句来指定一个转义字符。\n5. 指定多个匹配条件：-- 以 'S' 或 'M' 开头的数据\nSELECT *\nFROM employees\nWHERE last_name LIKE 'S%' OR last_name LIKE 'M%';\n\n在某些情况下，你可能需要指定多个匹配条件。\n注意事项这些也是开发层面需要注意的事情。\n性能问题： LIKE语句可能会导致性能问题，尤其是在大型表上，因为它可能无法使用索引。当LIKE模式以通配符开头（例如，%something）时，索引无法有效使用。在这种情况下，可以考虑其他优化方法，例如全文搜索。\n通配符的位置： 通配符的位置影响查询的性能。使用通配符 % 在模式的开头（例如，%something）可能导致全表扫描，而使用通配符在模式的结尾（例如，something%）可能能够利用索引。\n大小写敏感性： 默认情况下，LIKE是大小写敏感的。如果你希望进行大小写不敏感的匹配，可以使用LOWER或UPPER函数：\nSELECT *\nFROM employees\nWHERE LOWER(last_name) LIKE 's%';\n\n\n字符集和排序规则： MySQL的LIKE操作是基于字符集和排序规则的。确保你了解你的数据表和数据库使用的字符集及排序规则，以免导致意外的匹配或不匹配。\n避免在长文本上使用：%在长文本字段上可能导致性能问题。如果只是需要检查是否包含某个子字符串，考虑使用LOCATE或INSTR等函数。\n\nSELECT *\nFROM products\nWHERE LOCATE('son', product_name) &gt; 0;\n\n注意转义字符： 如果你的模式中包含通配符字符 % 或 _，并且你确实想要匹配这些字符本身，而不是它们的通配符含义，你需要使用转义字符。在MySQL中，默认的转义字符是\\。例如，如果要匹配包含 % 字符的数据，你可以使用：\nSELECT *\nFROM products\nWHERE product_name LIKE '%\\%%' ESCAPE '\\';\n\n使用全文搜索： 对于大型文本数据，全文搜索可能是更有效的选择。MySQL提供了全文搜索的功能，例如MATCH ... AGAINST语法。\n避免在计算列上使用：%在计算列上使用可能导致索引失效。如果可能，尽量在原始列上使用LIKE。\n-- 不推荐\nSELECT *\nFROM employees\nWHERE CONCAT(first_name, last_name) LIKE 'John%';\n\n-- 推荐\nSELECT *\nFROM employees\nWHERE first_name LIKE 'John%';\n\n\n\n\n\n","slug":"MySQL-Review-4","date":"2023-12-06T05:45:33.000Z","categories_index":"","tags_index":"笔记,MySQL复习","author_index":"General_K1ng"},{"id":"6381f3e54a84ac6dc19cc4600b2aeb52","title":"MySQL Review-3","content":"今天继续复习MySQL当中比较重要的一点，但是前面也已经涉及到了，就是MySQL中的约束。\n但是其实前面的UNIQUE，PRIMARY之类的也算约束。\n约束在关系数据库中，约束是一种用于定义和强制表中数据规则的机制。约束确保了数据的完整性、一致性和可靠性。通过使用约束，数据库管理系统可以强制执行数据表中的规则，防止插入、更新或删除操作导致数据不一致或错误。\n简单来说约束就是你在建立表的时候对一些字段的约束条件，比如前面提到的主键，唯一键都是比较重要的约束条件。\n语法格式当在MySQL中添加约束时，你可以使用以下语法格式：\nALTER TABLE table_name\nADD CONSTRAINT constraint_name\nCONSTRAINT_TYPE (constraint_details);\n\n这里的 constraint_name 是你给约束指定的名称，CONSTRAINT_TYPE 是约束的类型，而 constraint_details 是约束的具体细节。下面是几个常见约束的例子：\n比方说我们之前提到的主键\n主键约束ALTER TABLE table_name\nADD CONSTRAINT pk_example PRIMARY KEY (column1, column2, ...);\n\n外键约束这个约束有一些知识点需要记忆，这里只给出语法，后面会讲\nALTER TABLE table_name2\nADD CONSTRAINT fk_example\nFOREIGN KEY (column1) REFERENCES table_name1(column1);\n\n唯一约束这个更加熟悉，前面也讲过了\nALTER TABLE table_name\nADD CONSTRAINT uk_example UNIQUE (column1, column2, ...);\n\n检查约束这个和外键一样，放到后面讲，这里只给出语法格式\nALTER TABLE table_name\nADD CONSTRAINT chk_example CHECK (condition);\n\n这里介绍了一些常用的约束条件，但是其实说回来一般还是遵循最上面的通用的语法格式。\n外键这我猜测应该是一个非常重要的考点，虽然在实际开发中一般通过后端采取逻辑外键和事务处理来保证数据的完整性质，但是毕竟考试嘛，谁猜得到呢？\n在MySQL中，外键（Foreign Key）是一种用于建立表与表之间关联的约束。外键用于定义两个表之间的引用关系，其中一个表的列值（或列组合）是另一个表的主键或唯一键的值。这样的关联关系有助于维护数据的完整性，确保相关表之间的数据一致性。\n基本概念\n引用表（Referenced Table）： 包含被引用列的表称为引用表，通常是主键或唯一键的表。\n引用列（Referenced Column）： 在引用表中的主键或唯一键列被称为引用列。\n外键表（Referencing Table）： 包含外键列的表称为外键表，它引用了引用表中的列。\n外键列（Foreign Key Column）： 在外键表中与引用列相对应的列被称为外键列。\n\n语法上面已经介绍了表已经建立后的语法，这里两种都再给出一下。\n在创建表时定义外键：\nCREATE TABLE table_name1 (\n    column1 datatype PRIMARY KEY,\n    column2 datatype,\n    ...\n);\n\nCREATE TABLE table_name2 (\n    column1 datatype,\n    column2 datatype,\n    ...\n    FOREIGN KEY (column1) REFERENCES table_name1(column1);\n);\n\n在已有表上添加外键：\nALTER TABLE table_name2\nADD FOREIGN KEY (column1) REFERENCES table_name1(column1);\n\n特点\n数据一致性： 外键确保在外键表中的每个值都有对应的引用表中的值，保持数据的一致性。\n防止孤立行： 外键防止在外键表中存在不属于引用表的孤立行，即不存在对应的引用值的行。\n级联操作： 外键可以定义级联操作，例如在引用表中更新主键值时，外键表中相关的外键列的值也会自动更新。\n\n参照选项当定义外键关系时，可以使用不同的参照选项来规定在主表（被引用表）的记录被更新或删除时，应该如何处理从表（引用表、外键表）的记录。以下是一些常见的参照选项：\nRESTRICT（限制）:\n\n如果存在关联记录，阻止对主表的相关操作。如果主表中的记录正在被引用表引用，那么主表的记录不能被删除或更新，以保持引用完整性。\n\nCREATE TABLE orders (\n    order_id INT PRIMARY KEY,\n    customer_id INT,\n    FOREIGN KEY (customer_id) REFERENCES customers(customer_id) ON DELETE RESTRICT\n);\n\nCASCADE（级联）:\n\n如果主表的记录被更新或删除，引用表中相关的记录也会被相应地更新或删除。这就是级联操作。\n\nCREATE TABLE orders (\n    order_id INT PRIMARY KEY,\n    customer_id INT,\n    FOREIGN KEY (customer_id) REFERENCES customers(customer_id) ON DELETE CASCADE\n);\n\nSET NULL（设置为空）:\n\n如果主表的记录被更新或删除，引用表中相关的外键列将被设置为NULL。\n\nCREATE TABLE orders (\n    order_id INT PRIMARY KEY,\n    customer_id INT,\n    FOREIGN KEY (customer_id) REFERENCES customers(customer_id) ON DELETE SET NULL\n);\n\nSET DEFAULT（设置为默认值）:\n\n如果主表的记录被更新或删除，引用表中相关的外键列将被设置为它们的默认值。\n\nCREATE TABLE orders (\n    order_id INT PRIMARY KEY,\n    customer_id INT DEFAULT 1,\n    FOREIGN KEY (customer_id) REFERENCES customers(customer_id) ON DELETE SET DEFAULT\n);\n\n这些选项可以应用于两种情况：ON DELETE 和 ON UPDATE。前者用于指定在主表的记录被删除时应该如何处理，而后者用于指定在主表的记录被更新时应该如何处理。\n意思就是，当主表（被引用表）发生更改的时候，从表（外键表）会怎么样，会根据你提前设计的这些进行一些默认操作。\n示例考虑一个部门（departments）和员工（employees）两个表的情况：\nCREATE TABLE departments (\n    department_id INT PRIMARY KEY,\n    department_name VARCHAR(50)\n);\n\nCREATE TABLE employees (\n    employee_id INT PRIMARY KEY,\n    first_name VARCHAR(50),\n    last_name VARCHAR(50),\n    department_id INT,\n    FOREIGN KEY (department_id) REFERENCES departments(department_id)\n);\n\n\n确保数据一致性： 外键关系确保employees表中的每个员工的department_id值都存在于departments表的department_id列中。这样，你不能在employees表中插入一个不存在的部门ID，从而确保了数据的一致性。\n防止孤立行： 外键关系防止employees表中的行变得孤立，即存在不属于departments表中任何部门的员工。每个在employees表中的department_id值都必须在departments表中有对应的部门ID。\n禁止删除被引用的行： 如果你尝试删除departments表中的某个部门（带有相关的员工），MySQL默认情况下将不允许这样的删除，以防止破坏外键约束。这防止了误删除操作，确保数据的完整性。\n级联操作： 可以通过定义外键时的级联选项来实现级联操作。例如，如果定义了级联更新，当departments表中的某个部门ID更新时，employees表中所有相关的department_id也会自动更新\n\n具体来说：\n假设我们有两张表，一张是部门表，另一张是员工表。我们想要在员工表中记录每个员工所在的部门。\n部门表 (departments)：\n\n\n\ndepartment_id\ndepartment_name\n\n\n\n1\nSales Department\n\n\n2\nIT Department\n\n\n3\nHR Department\n\n\n员工表 (employees)：\n\n\n\nemployee_id\nfirst_name\nlast_name\ndepartment_id\n\n\n\n101\nJohn\nSmith\n1\n\n\n102\nEmily\nJohnson\n2\n\n\n103\nMichael\nWang\n1\n\n\n为什么使用外键？\n关联员工和部门： 我们使用外键来确保员工表中的 department_id 值始终对应着部门表中的 department_id 值。这样，我们知道每个员工属于哪个部门。\n防止错误： 外键帮助我们防止错误的数据插入，例如，如果我们试图在员工表中插入一个不存在的部门ID，系统会阻止这样的操作。\n\n外键语法中的哪个是引用表，哪个是外键表？在这个例子中：\n\n被引用表 (Referenced Table)： 部门表 (departments) 是引用表，因为它包含了被引用的列 department_id，这是员工表中 department_id 列的来源。\n外键表 (Referencing Table)： 员工表 (employees) 是外键表，因为它包含了外键列 department_id，这是与部门表中的 department_id 列相关联的列。\n\n外键建立了两张表之间的关系，就像一种连接。它确保了员工表中的每个员工都与部门表中的一个部门相对应，而且部门表中的每个部门都可以与员工表中的多个员工相对应。这种关系有助于我们更好地组织和理解数据。\n操作被引用表（departments）：\n插入新的部门： 如果你想在departments表中插入新的部门，这是允许的，因为departments表是引用表，没有其他表直接引用它。\n更新部门ID： 如果你更新了departments表中的某个部门ID，且该部门ID在employees表的department_id列中有对应的值，系统的默认设置下可能会阻止这个更新操作。这是因为外键关系会防止引用表中的主键（或唯一键）发生变化，以维护数据的完整性。你可能需要先更新employees表中的相关外键列，然后再更新departments表。\n删除部门： 如果你尝试删除departments表中的某个部门，系统可能会阻止这个操作，因为还存在与该部门相关联的员工（在employees表中有相应的department_id）。你可能需要先删除相关的员工记录，然后才能删除部门。\n\n操作外键表（employees）：\n插入新员工： 你可以在employees表中插入新员工，但是要确保插入的department_id值存在于departments表中，否则系统会阻止这个操作。\n更新员工所在部门： 如果你更新了employees表中的某个员工的department_id，只要新的department_id值在departments表中存在，这是允许的。\n删除员工： 你可以删除employees表中的员工，不会直接影响departments表。但是，如果你删除了departments表中的某个部门，而该部门在employees表中有员工，系统可能会阻止这个操作，要求你先删除相关的员工。\n\n检查约束在MySQL中，检查约束（Check Constraint）是一种用于定义在插入或更新行时必须满足的条件的机制。它允许你指定在某个列或一组列上的数据必须满足的条件，以确保数据的有效性和一致性。如果检查约束中的条件不满足，MySQL将拒绝插入或更新操作。\n语法格式如下：\nCREATE TABLE table_name (\n    column1 datatype,\n    column2 datatype,\n    ...\n    CHECK (condition);\n);\n\n或者在已有表上添加检查约束：\nALTER TABLE table_name\nADD CHECK (condition);\n\n其中，condition 是一个逻辑表达式，表示需要满足的条件。如果 condition 为真，操作将被允许，否则将被拒绝。\n示例假设我们有一个存储订单信息的表，要求订单的总金额不能为负数：\nCREATE TABLE orders (\n    order_id INT PRIMARY KEY,\n    order_date DATE,\n    total_amount DECIMAL(10,2),\n    CHECK (total_amount &gt;= 0)\n);\n\n在这个例子中，我们使用检查约束确保 total_amount 列的值必须大于等于零。如果尝试插入或更新一条订单，使得总金额小于零，系统将拒绝这个操作。\n注意事项：\nCHECK约束条件： condition 中可以包含对一列或多列的条件，以及多个逻辑操作符（AND、OR、NOT）。\n可选性： CHECK约束是可选的，你可以选择使用或不使用它，具体取决于业务需求。\n兼容性： 需要注意的是，MySQL在早期版本中对CHECK约束的支持并不完整，因此在使用CHECK约束时需要确保使用的MySQL版本支持这一特性。\n\n这玩意也不常用，一般都靠我们的后端来进行校验，数据库层面一般很少做校验的。\n字符串比较没想到啊，这个课件真是误人子弟，说MySQL的字符串比较是不区分大小写的。。。\n其实，字符串的比较是否区分大小写，本质上，MySQL的默认字符串比较是取决于所使用的字符集和排序规则（collation）的。一般而言，对于一些常见的字符集，例如UTF-8，其默认的排序规则通常是不区分大小写的，但这并不是绝对的。\n在MySQL中，可以通过查看字符集和排序规则的默认值来了解默认的字符串比较行为。例如，对于UTF-8字符集，utf8_general_ci是一个常见的不区分大小写的排序规则，而utf8_bin是区分大小写的规则。\n这个bin就是二进制binary的简写。\n二进制比较\n基于字节比较： 二进制比较将字符串视为一系列字节，而不考虑字符的编码。每个字符都是由一个或多个字节组成的。\n区分大小写： 二进制比较是区分大小写的，即大写字母和小写字母被视为不同的值。\n不受字符集和排序规则影响： 二进制比较不考虑字符集和排序规则，直接比较字符串的字节。\n\nSELECT 'abc' = BINARY 'ABC';  -- 返回 0，因为它是区分大小写的二进制比较\n\n字符集比较\n基于字符比较： 字符集比较考虑字符的编码和排序规则。字符集规定了字符的编码方式，而排序规则定义了字符串的排序规则，包括如何处理大小写、重音符号等。\n可能不区分大小写： 根据具体的字符集和排序规则，字符集比较可能是区分大小写的，也可能是不区分大小写的。\n受字符集和排序规则影响： 字符集比较会受到所使用的字符集和排序规则的影响。\n\nSELECT 'abc' COLLATE utf8_general_ci = 'ABC' COLLATE utf8_general_ci;  -- 返回 1，因为它是不区分大小写的字符集比较\n\n选择使用的情况\n二进制比较： 适用于需要完全区分大小写、直接比较字节的场景，或者在处理二进制数据时。\n字符集比较： 适用于普通文本字符串的比较，可以根据语言、地区等要求选择合适的字符集和排序规则，确保字符串的比较和排序符合预期。\n\n好，那么其实在MySQL当中会有一些默认的情况会使用字符集比较，比如在主键和唯一键的判断当中，就会默认使用字符集比较，而且并不是二进制比较，这也是课件说MySQL的字符串比较是不区分大小写的原因。\n在MySQL中，主键和唯一键（Unique Key）的约束条件判断默认是受到字符集和排序规则的影响的。具体来说，如果使用的字符集和排序规则是区分大小写的，那么主键和唯一键的约束条件也会区分大小写；如果字符集和排序规则是不区分大小写的，那么约束条件也会不区分大小写。\n比如：\nCREATE TABLE example_table (\n    id INT PRIMARY KEY,\n    name VARCHAR(50) UNIQUE\n) COLLATE utf8_general_ci;\n\n在上述例子中，表 example_table 的字符集和排序规则被指定为 utf8_general_ci，这是一个不区分大小写的排序规则。因此，主键和唯一键 name 的约束条件在比较时将不区分大小写。\n如果你使用的字符集和排序规则是区分大小写的，你可以在创建表时显式指定，例如：\nCREATE TABLE example_table (\n    id INT PRIMARY KEY,\n    name VARCHAR(50) UNIQUE\n) COLLATE utf8_bin;\n\n在这种情况下，主键和唯一键 name 的约束条件将区分大小写。\n而二进制比较只会在你使用BINARY关键字的时候才会使用。\n\n\n\n\n\n\n\n\n\n字符集的比较在以下情况下非常重要：\n\n文本搜索和匹配： 如果你的应用需要执行基于文本的搜索、匹配或过滤操作，字符集比较就变得至关重要。例如，你可能希望在数据库中执行不区分大小写的搜索，或者处理包含重音符号的字符。\n排序和比较： 如果你需要对字符串进行排序，或者在查询中进行字符串的比较，字符集和排序规则就会影响到排序的结果和比较的行为。在不同的语言环境下，字符集和排序规则的选择可能有所不同。\n唯一性约束： 当你在数据库中定义唯一键或唯一索引时，字符集和排序规则会影响到是否区分大小写。这对于确保唯一性约束的正确性非常重要。\n国际化和多语言支持： 如果你的应用需要支持多种语言，特别是包含非拉丁字符的语言，选择正确的字符集和排序规则是确保正确处理和显示文本的关键。\n用户输入和输出： 当用户与应用交互时，字符集和排序规则会影响到用户输入的处理和在界面上显示的文本。确保使用合适的字符集可以提供更好的用户体验。\n\nALTER语句前面也看到了很多ALTER的操作，一般都是在表格创建好之后，如果对于表还有什么额外的操作，那么我们就可以使用这个关键字，来进行一些额外的操作。\n这里就进行一下关于这个语句的一些总结。\n1. 添加列：ALTER TABLE table_name\nADD COLUMN column_name datatype;\n\n这将在指定的表中添加一个新列。\n2. 修改列的数据类型：ALTER TABLE table_name\nMODIFY COLUMN column_name new_datatype;\n\n这将更改表中指定列的数据类型。\n3. 修改列的名称：ALTER TABLE table_name\nCHANGE COLUMN old_column_name new_column_name datatype;\n\n这将修改表中指定列的名称和数据类型。\n4. 删除列：ALTER TABLE table_name\nDROP COLUMN column_name;\n\n这将从表中删除指定的列。\n5. 添加主键：ALTER TABLE table_name\nADD PRIMARY KEY (column1, column2, ...);\n\n这将在表上添加主键。\n6. 移除主键：ALTER TABLE table_name\nDROP PRIMARY KEY;\n\n这将从表上移除主键。\n7. 添加外键：ALTER TABLE table_name\nADD CONSTRAINT fk_name\nFOREIGN KEY (column_name)\nREFERENCES referenced_table(referenced_column);\n\n这将在表上添加外键约束。\n8. 移除外键：ALTER TABLE table_name\nDROP FOREIGN KEY fk_name;\n\n这将从表上移除指定的外键约束。\n9. 修改表名：ALTER TABLE old_table_name\nRENAME TO new_table_name;\n\n其实之前都见过，这里只是做个总结。\n","slug":"MySQL-Review-3","date":"2023-12-05T09:19:22.000Z","categories_index":"","tags_index":"笔记,MySQL复习","author_index":"General_K1ng"},{"id":"ca462487924054497383c1abea48a162","title":"CPT101 Review-1","content":"今天复习CPT101，在我看来全是死记硬背的东西，但是不背又不行，唉\n我看课件感觉好多废话，但是我又不知道到底会不会考，我真无语了\n计算机的分类计算机主要可以分为四个主要阶段，分别是：大型计算机，超级计算机，工作站，微型计算机，个人电脑。\nMainframe Computers（大型计算机，1960年代）\n\n简单解释： 大型计算机就像是一座超级大的智能城市，可以同时处理很多任务。\n比喻： 想象一座巨大的超级电脑城市，里面有很多小工作区域，每个区域负责不同的事情，比如管理大量数据或运行复杂的程序。\n诞生时间： 大型计算机的出现可以追溯到20世纪40年代末至50年代初。这个时期就好像是计算机的“古代时代”，大概在你的爷爷奶奶年轻的时候。正是二战后，人们开始研究如何用电子设备进行更复杂的计算任务。\n\nSupercomputers（超级计算机，1970年代）\n\n简单解释： 超级计算机就像是计算能力极强的超级英雄，可以解决非常复杂的问题。\n比喻： 想象一个能够瞬间算出很多数学题答案的超级数学英雄，这就是超级计算机。\n诞生时间： 超级计算机的发展始于20世纪70年代。在这个时期，就好像是计算机的“英雄时代”，大概在你的爸爸妈妈年轻的时候。科学家们需要处理更加复杂的科学和工程计算任务，这促使了超级计算机的发展。\n\nWorkstations（工作站，1980年代）\n\n简单解释： 工作站就像是一座小型工作城市，专门用来完成一些复杂的设计和工程任务。\n比喻： 想象一座小城市里有很多专业的设计师和工程师，他们使用工作站完成一些很酷的设计和计算工作。\n诞生时间：工作站的兴起发生在20世纪80年代，就好像是计算机的“现代时代”开始，大概在你的父母小时候。这是计算机技术向专业领域渗透的时期。科学家、工程师和设计师需要更强大的计算能力来处理复杂的图形和设计任务。\n\nMicrocomputers（微型计算机，1980年代）\n\n简单解释： 微型计算机就像是一座小镇，你可以在家里使用它完成一些简单的任务。\n比喻： 想象一座小镇里的小电脑，可以用来写作业、玩游戏，还可以学一些新知识。\n诞生时间： 微型计算机在20世纪80年代逐渐普及。就好像是计算机的“小镇时代”，大概在你的爸爸妈妈小时候。个人电脑如IBM PC等的推出使得计算机变得更加亲民，个人用户可以在家里使用它们。\n\nPersonal Computers（个人电脑，1980年代）\n\n简单解释： 个人电脑就像是你自己的小房子，可以在里面做很多事情，包括学习、玩游戏和上网。\n比喻： 想象你有一个属于自己的小电脑房子，可以在里面做你喜欢的事情，就像有一个属于你的小天地。\n诞生时间： 个人电脑的兴起主要发生在20世纪80年代，这是计算机的“个人时代”，大概在你的爸爸妈妈小时候。尤其是IBM PC的推出。这是计算机走向家庭的时代，人们开始在家里使用个人电脑进行各种任务。\n\nMicrocontrollers（微控制器，1980年代）\n\n简单解释： 微控制器就像是一个小小的计算小助手，专门负责控制和管理一些小型设备。\n比喻： 想象一下微控制器就像是一位小小的机器小管家，可以控制各种小玩具、计算器，甚至汽车里的一些功能。\n诞生时间： 微控制器和嵌入式计算机的发展在20世纪80年代也变得显著，就好像是计算机的“微小时代”，大概在你的爸爸妈妈小时候。尤其是随着电子产品的普及，这些小型计算机开始被嵌入到各种设备中，从电子计算器到汽车控制系统。\n\nEmbedded or Dedicated Computers（嵌入式或专用计算机，从计算器到汽车）\n\n简单解释： 这些计算机就像是隐藏在各种设备中的小小智能大脑，让设备能够执行特定的功能。\n比喻： 想象一下这是设备里的小小大脑，让你的计算器、手机，甚至汽车都能够聪明地完成各种任务。\n诞生时间： 这是计算机的“嵌入时代”，从你的爸爸妈妈小时候一直到现在。\n\nServers（服务器，1980年代）\n\n简单解释： 服务器就像是一座大型信息中心，它们帮助连接并提供服务给很多人。\n比喻： 想象一下服务器是一座大型的服务城市，通过网络连接，可以为很多人提供信息和服务。\n诞生时间： 服务器的发展可以追溯到20世纪80年代。这是计算机的“连接时代”，从你的爸爸妈妈小时候一直到现在。随着互联网的兴起，人们需要大型的中央计算机来存储和提供互联网服务，这推动了服务器技术的发展。\n\nChip Computer (?)\n\n简单解释： 芯片计算机可能指的是一种小型计算机，内置在一个芯片中，用于执行一些简单的任务。\n比喻： 想象一下一个微小的芯片里有一个小型计算机，可以完成一些基础的计算任务。\n诞生时间： 这可能是计算机的“微芯时代”，从你的爸爸妈妈小时候一直到现在。\n\n这样大概应该可以基本上记住计算机的发展史？不知道，反正课件就这些，上网找了点资料，应该能背。\n计算机世代世代这词怎么看着这么中二。\n\n第一代计算机 (1940s-1950s) - 真空管时代：\n简单解释： 第一代计算机就像是一座大型实验室，使用大而笨重的真空管来执行计算任务。\n比喻： 想象一下这是计算机的“实验室时代”，也就是只存在于实验室当中的电老虎，科学家他们在里面做各种计算实验。\n特点： 大型、昂贵、需要大量的电力。\n代表计算机： MARK I, ENIAC, UNIVAC。\n\n\n第二代计算机 (1950s-1960s) - 晶体管时代：\n简单解释： 第二代计算机就像是一座更现代的城市，开始使用小而高效的晶体管来进行计算。\n比喻： 这是计算机的“城市时代”，就像是城市里的建筑变得更小巧，但是效率更高了，但是还是只存在于实验室当中。\n特点： 晶体管取代了真空管，使计算机更小、更可靠。\n代表计算机： IBM1401, IBM 1410，配有1402卡片读写机。\n\n\n第三代计算机 (1960s-1970s) - 集成电路时代：\n简单解释： 第三代计算机就像是一座更高效的城市，开始使用集成电路，将许多电子元件集成到一个芯片上。\n比喻： 这是计算机的“高楼大厦时代”，就像是城市里的建筑变得更紧凑，功能更强大，成本开始降低，开始走入人们日常生活。\n特点： 集成电路的使用使计算机更小、更快、更可靠。\n代表计算机： DEC PDP-1，IBM 360。\n\n\n第四代计算机 (1970s-现在) - 微处理器时代：\n简单解释： 第四代计算机就像是一座充满小而强大的计算机的城市，引入了微处理器，使计算机更加个人化。\n比喻： 这是计算机的“个性化时代”，就像是每个人都可以拥有自己的小型计算机。\n特点： 微处理器的出现使得计算机变得更小、更便携，个人电脑开始普及。\n代表计算机： LSI和VLSI技术崛起，出现了大规模集成电路。出现了Cray-1超级计算机，以及个人电脑的崭露头角，如Apple II、IBM PC、Notebook PC、Palmtop、Laptop、iPhone、iPad等。\n\n\n未来计算机（可能的第五代）：\n简单解释： 未来计算机可能像是一座充满智能的城市，使用更先进的技术，比如人工智能和量子计算。\n比喻： 这将是计算机的“智能时代”，就像是城市里充满了智能机器人和超级智慧的计算机。\n特点： 可能包括更强大的人工智能、量子计算等技术。\n\n\n\n计算机中的硬件与软件\n硬件：\n简单解释： 计算机的硬件就像是它的身体，包括所有的物理部件，如中央处理器（CPU）、内存、硬盘、显示屏等。\n比喻： 想象一下计算机的硬件就像是一台机器人的身体，有头脑（CPU）、记忆力（内存）、存储空间（硬盘），它们一起协作完成任务。\n\n\n软件：\n简单解释： 计算机的软件就像是它的思维能力，是由程序组成的，告诉硬件如何执行任务。\n比喻： 软件就像是机器人的大脑，里面有很多指令和程序，告诉机器人如何走路、说话，完成各种任务。\n\n\n硬件和软件的关系：\n简单解释： 硬件和软件关系密不可分，硬件提供了执行任务的能力，而软件告诉硬件要执行什么任务。\n比喻： 想象一下机器人，硬件是机器人的身体，软件是机器人的大脑。只有两者配合得当，机器人才能高效地完成各种任务。\n\n\n过去的情况：\n简单解释： 以前，大学的计算机课程通常分为硬件和软件两个方向，学生在其中一个方向进行专业学习。\n比喻： 就像是学生可以选择学习机器人的身体（硬件）或大脑（软件），但并没有同时学习两者的整体知识。\n\n\n问题的影响：\n简单解释： 这种专业化导致了一些问题，例如程序员可能不了解他们使用的设备，软件可能无法充分利用新硬件的性能优势。\n比喻： 就好比一个机器人专家可能不知道如何正确地使用一台新型机器人的身体，或者一个新型机器人的大脑不知道如何充分发挥身体的性能。\n\n\n\n硬件计算机硬件主要有五个类别，分别是：输入（Input）、处理（Processing）、输出（Output）、存储（Storage）和通信（Communications）。\n\n输入（Input）：\n简单解释： 输入部分涉及到将数据或信息引入计算机系统的过程。\n具体例子： 键盘、鼠标、触摸屏、摄像头等都是用于向计算机输入信息的设备。\n比喻： 就像给计算机输入命令的方式，就像你用键盘给计算机发指令，或者通过触摸屏让它明白你的动作。\n\n\n处理（Processing）：\n简单解释： 处理部分是计算机执行操作和运算的地方，这里进行了所有的计算和决策。\n具体例子： 中央处理器（CPU）是负责执行指令和运算的关键组件。\n比喻： 就像计算机的大脑，它负责思考和处理输入的信息，执行各种任务。\n\n\n输出（Output）：\n简单解释： 输出部分是计算机向外部世界传递处理结果的地方。\n具体例子： 显示屏、打印机、扬声器等设备用于向用户显示或传达计算机的结果。\n比喻： 就像计算机向你展示它的思考结果，就像你通过显示屏看到图像、通过扬声器听到声音。\n\n\n存储（Storage）：\n简单解释： 存储部分是用于保存数据和程序的地方，以便之后的使用。\n具体例子： 硬盘驱动器、固态硬盘、内存等是计算机存储数据和程序的地方。\n比喻： 就像计算机的记忆，可以保存过去的信息，以便今后的使用，就像你的大脑记住了你学过的知识一样。\n\n\n通信（Communications）：\n简单解释： 通信部分涉及计算机与其他计算机或设备之间传输信息的过程。\n具体例子： 网络接口卡、Wi-Fi模块等是用于连接计算机与网络或其他设备进行通信的部件。\n比喻： 就像计算机通过网络与其他计算机交流，就像你通过电话或信息与朋友们保持联系。\n\n\n\n软件计算机软件主要分为两个部分：系统软件（System Software）和应用软件（Applications Software）。\n系统软件（System Software）：\n通信与硬件交互（Communication with Hardware）：\n简单解释： 系统软件负责与计算机的硬件进行交流，使硬件能够有效地执行软件指令。\n功能： 系统软件确保软件和硬件之间的顺畅沟通，使得计算机的各个部分能够正确协同工作。\n比喻： 就像系统软件是翻译官，帮助软件和硬件之间更好地交流，确保它们能够理解对方。\n\n\n资源管理（Resource Management）：\n简单解释： 系统软件负责有效管理计算机的各种资源，如内存、处理器、存储等，以确保它们被充分利用。\n功能： 系统软件分配和监控计算机资源，以满足不同程序的需求，确保计算机运行顺畅。\n比喻： 就像系统软件是一个管理员，负责分配每个人的工作，确保资源得到合理利用。\n\n\n促进应用程序之间的通信（Facilitates Communication Among Application Programs）：\n简单解释： 系统软件帮助不同的应用程序之间进行有效的沟通和协同工作。\n功能： 系统软件提供了一些工具和接口，使得不同的应用程序可以互相协作，共享信息。\n比喻： 就像系统软件是一个社交平台，让不同的应用程序之间可以友好地互动和分享。\n\n\n\n应用软件（Applications Software）：\n为用户提供利益或协助用户（Benefits or Assists the User）：\n简单解释： 应用软件是用户直接与之交互的软件，为用户提供各种功能和服务。\n功能： 应用软件可以是办公套件、图形设计工具、游戏等，它们直接满足用户的需求，提供具体的服务。\n比喻： 就像应用软件是一位服务员，根据你的需求提供不同的服务，比如为你准备文件、设计图形、玩游戏等。\n\n\n\n向下兼容性（Backward or Downward Compatibility）\n简单解释： 向下兼容性是指新硬件可以运行旧硬件上编写的大多数软件。这意味着即使你有一台新的计算机，你仍然可以运行为旧计算机编写的软件。\n为何需要向下兼容性？：\n简单解释： 向下兼容性的主要目的是确保旧软件在新硬件上仍然可以运行，而不需要进行太多修改。\n原因：\n保护投资： 人们通常在软件开发上投入大量资源和金钱。通过保持向下兼容性，可以确保过去的投资仍然有价值，而不必重新开发所有软件。\n用户体验： 用户不必因为升级硬件而失去对过去软件的使用。这提供了更平滑的过渡，用户可以逐步更新硬件而不担心软件的兼容性问题。\n过渡期： 当新硬件推出时，人们可能还在使用旧硬件。通过向下兼容性，可以在过渡期内保持对过去技术的支持。\n\n\n\n\n为什么是向下兼容而不是向上兼容？：\n简单解释： 向下兼容性更为常见，因为它更容易实现。新硬件通常更强大，可以模拟或处理旧硬件的指令和功能。\n原因：\n技术演进： 随着技术的进步，新硬件通常能够模拟和处理旧硬件的功能，但反过来却不一定成立。\n资源充足： 新硬件通常具有更多的资源和功能，可以模拟和处理旧硬件的操作，因此向下兼容性更为实际。\n\n\n\n\n\n也就是说，向下兼容性保证了用户和开发者的良好体验以及对于旧软件的支持。\nVDHLVHDL（Very High Speed Integrated Circuits Hardware Description Language，非常高速集成电路硬件描述语言）是一种用于描述电子系统结构和行为的编程语言。它主要用于设计和模拟数字电路，涵盖了从高层次系统规范到低层次门级描述的各个抽象层次。\n\n目的和用途:\n硬件描述: VHDL主要用于描述数字系统的硬件组件。它允许设计人员指定电子电路的结构和功能。\n仿真: VHDL支持计算机仿真，使设计人员能够在实际实施之前验证其设计的正确性和性能。这有助于在设计过程的早期阶段识别和修复潜在问题。\n自动布局: VHDL还用于提供给自动布局工具的输入。这些工具根据VHDL中提供的高层描述生成电路的物理布局。这对于集成电路的制造和制造至关重要。\n\n\n扭转硬件与软件的分野:\n关于关注硬件的人和关注软件的人之间的分野的说法是指传统上硬件工程师和软件程序员之间的区别。\nVHDL在弥合这一差距方面发挥了重要作用。通过VHDL，设计人员可以以类似于软件开发中使用的编程语言的方式表达硬件设计。\n这使得硬件和软件团队能够更有效地进行沟通，因为VHDL为指定硬件结构及其功能提供了共同的语言。\n\n\nVHDL的特点:\n抽象层次: VHDL支持不同层次的抽象，从高层次的行为描述到低层次的结构和门级表示。\n并发性: VHDL支持并发编程，允许设计人员描述数字系统中过程和事件的并行执行。\n测试台: 设计人员可以使用VHDL创建测试台，以模拟电路在各种条件下的行为，有助于验证和调试过程。\n可配置性: VHDL具有很高的可配置性，允许设计人员以不同的上下文参数化和重用组件。\n\n\n\n简而言之，一种语言，用来描述硬件。\n一些软硬件交互开发的例子\n窗口界面 - WIMPs（窗口、图标、菜单、指针）\n想象一下你的电脑是一个办公桌，而WIMPs就是一种高级的组织工具。窗口就像是你的文件夹，图标是你的文件，菜单是你的工具箱，指针就像是你的笔。通过这些工具，你可以更有效地组织和管理你的电脑任务，就像在一个更智能的工作环境中一样。\n\n\n微处理器革命 - 快速位图图形\n想象一下微处理器就像是你电脑的引擎，而微处理器革命就是升级了这台引擎。这个升级让你的电脑可以更快速地处理图形，就像是你的屏幕变得更加细腻、清晰，使你的整个电脑体验更加流畅。\n\n\n互联网 - 连接所有网络\n想象一下互联网是一张巨大的全球蜘蛛网，将世界各地的网络连接在一起。这个全球蜘蛛网让你可以通过电脑轻松地访问到全球的信息，就像是打开了一扇通向世界的大门，让你能够与世界各地的人进行沟通和交流。\n\n\nNetscape浏览器的推出 - 推动互联网的使用\n想象一下Netscape浏览器是一辆通往互联网的新型车。当这辆车上路时，更多的人可以更轻松地进入互联网，就像是有了这款浏览器，你可以更便捷地浏览网页，发现更多有趣的内容，就像是在一辆更高级的车上畅游一样。\n\n\n\n计算机的层次结构计算机系统被视为一个层次有序的系统，这意味着它可以被划分为多个层次或级别，每个级别包含一些简单的组件部分。这个层次结构的概念有助于理解计算机系统的复杂性，并使得系统的设计和理解更为容易。\n层次结构的例子：\n\n最底层可能是硬件层，包括处理器、内存、输入输出设备等。\n在硬件之上可能是操作系统层，负责管理硬件资源、提供用户界面等。\n再上一层可能是应用软件层，包括各种应用程序和工具。\n\n好处\n模块化和可维护性：\n层次结构使系统被分解为相互独立的模块或层次。每个模块负责特定的功能，这样的设计使得系统更容易维护和理解。如果需要对系统进行修改或升级，只需关注特定层次而无需了解整个系统的复杂性。\n\n\n抽象和简化：\n通过层次结构，系统设计者可以使用抽象来隐藏底层的细节。上层的模块不需要了解底层模块的具体实现细节，从而简化了设计和编程过程。这种抽象使得不同层次的设计可以独立进行，提高了系统的灵活性。\n\n\n可移植性：\n层次结构设计有助于实现系统的可移植性。由于各个层次都是相对独立的，更容易在不同的硬件平台上重新实现或迁移整个系统。\n\n\n性能优化：\n通过在不同层次上进行优化，系统设计者可以更有效地提高整体性能。例如，在底层硬件层进行优化可能会影响整个系统的性能，而无需涉及上层的软件层次。\n\n\n分工协作：\n层次结构有助于实现分工协作。不同团队可以专注于系统中的不同层次，加快开发进度，同时确保系统整体上的一致性和稳定性。\n\n\n\n操作系统的优势1. 揭示硬件系统功能：\n\n操作系统充当了硬件和应用软件之间的中介。它可以将硬件系统的底层功能性展现给用户和应用程序。这包括处理器管理、内存管理、文件系统、网络功能等。通过操作系统，用户能够直观地利用计算机系统的各种功能，而无需了解底层硬件的复杂性。\n\n2. 用户程序与硬件系统的交互：\n\n操作系统为用户程序提供了一种与硬件系统进行交互的标准接口。用户编写的程序可以通过操作系统的API（Application Programming Interface）或系统调用与硬件进行通信。这种抽象层使得编程更加简单，程序员可以专注于应用程序的逻辑，而无需直接处理底层硬件的复杂性。\n\n3. 编程的便利性：\n\n操作系统提供了一系列高级功能和服务，使得程序员可以更轻松地开发应用程序。这包括文件管理、内存管理、进程调度等。通过使用这些操作系统提供的功能，编程变得更为方便和高效。\n\n4. 系统和用户的保护：\n\n操作系统通过实施访问控制和权限管理来保护系统和用户。只有经过授权的程序和用户才能访问特定的资源和数据。这种安全机制有助于防止恶意软件、未经授权的访问，以及对系统的滥用。\n\n5. 公平性和效率：\n\n操作系统负责管理系统资源，确保它们被公平和有效地分配给不同的用户和应用程序。调度算法、内存管理和文件系统的优化都有助于确保系统资源的公平共享和高效利用。这是为了避免某个应用程序或用户占用过多资源，影响其他程序或用户的正常运行。\n\n摩尔定律摩尔定律（Moore’s Law）是由英特尔创始人之一戈登·摩尔（Gordon Moore）在1965年提出的观察性定律。这一定律描述了集成电路上可容纳的晶体管数量随时间的推移而呈指数级增长的趋势。具体来说，摩尔定律的表述是：“集成电路上可容纳的晶体管数量每隔约18至24个月就会翻倍。”\n以下是摩尔定律的一些关键点：\n\n指数级增长： 摩尔定律指出，集成电路上的晶体管数量以指数形式增长，而不是线性增长。这就意味着在相对短的时间内，芯片上可以容纳的晶体管数量会迅速增加。\n时间尺度： 最初，摩尔估计这一趋势大约每隔18至24个月就会翻倍，这个估计后来被广泛接受。这表明了集成电路技术的快速进步，以及芯片性能和功能的迅速提升。\n成本效益： 摩尔定律的实质之一是，随着晶体管数量的增加，每个晶体管的成本相对降低。这导致了更为经济有效的电子设备制造，促使了技术的广泛应用和市场普及。\n影响产业： 摩尔定律的实现推动了计算机科学和信息技术领域的快速发展。计算机硬件的性能大幅提升，从而推动了软件和应用程序的发展，也促使了信息技术在各个领域的广泛应用。\n挑战与延续： 随着技术逐渐接近摩尔定律的物理极限，一些人开始质疑它的持续性。在过去几年中，虽然芯片的制造工艺在继续进步，但翻倍速度可能已经减缓。面临着晶体管缩小和功耗等方面的物理和工程难题，一些专业人士对摩尔定律的未来持保守态度。\n\nQ&amp;A提到计算机系统的四个架构层次：\n\n计算机系统的四个架构层次包括：\n高级语言层次： 这是诸如Java、C++或Python等编程语言操作的层次。\n汇编语言层次： 这个层次涉及对特定体系结构的机器码指令进行符号表示。\n操作系统层次： 操作系统管理硬件资源并为计算机程序提供服务。\n数字逻辑层次： 这是最低层次，涉及实际硬件组件，如逻辑门和电路。\n\n\n\nCPU和ALU分别代表什么？\n\nCPU： 中央处理单元。这是计算机的主要组件，负责执行指令。\nALU： 算术逻辑单元。它是CPU的一部分，执行算术和逻辑运算。\n\n计算机系统的组成部分有哪些？\n\n计算机系统的主要组成部分包括：\n中央处理单元（CPU）： 执行指令。\n内存（RAM）： 存储CPU快速访问的数据和指令。\n存储设备（硬盘、固态硬盘）： 用于长期存储数据。\n主板： 连接并促进各种组件之间的通信。\n输入设备（键盘、鼠标）： 允许用户输入数据。\n输出设备（显示器、打印机）： 显示或产生结果。\n\n\n\n提到四种不同类型的计算机：\n\n\n个人计算机（PC）： 为个人使用而设计。\n\n\n\n服务器： 为网络中的其他计算机提供服务。\n\n\n\n大型机： 面向组织的大规模计算。\n\n\n\n嵌入式系统： 嵌入其他设备中的专用系统（如洗衣机、汽车）。\n\n\n\n通过什么方式促使‘服务器’的使用？\n\n服务器通过网络连接和专用软件的可用性来提供服务。 它们旨在为网络中的其他计算机（客户端）提供服务、资源或数据。\n\n定义‘计算机系统’的学科领域：\n\n计算机系统涵盖各种学科领域，包括：\n计算机体系结构： 计算机系统的设计和组织。\n操作系统： 管理硬件资源的软件。\n计算机网络： 计算机之间的连接和通信。\n软件工程： 软件应用程序的开发。\n数据库： 数据的存储和检索。\n\n\n\n定义‘向下兼容性’：\n\n向下兼容性指的是软件或硬件系统能够与先前版本的相同系统的功能和数据一起使用或支持的能力。 这确保了新版本仍然可以运行由旧版本创建的应用程序或使用旧版本生成的数据。\n\n可以用于设计高速集成电路硬件的描述语言是什么？\n\nVerilog或VHDL（VHSIC硬件描述语言）可用于设计高速集成电路硬件。 这些语言允许工程师描述数字电路的行为和结构，促进复杂硬件系统的设计。\n\n采用分层方法的计算机系统的优势有哪些？\n\n分层方法的优势包括：\n模块化设计： 系统被划分为层次，每个层次都有特定的功能，使得系统更易于理解和维护。\n抽象： 各个层次提供不同程度的抽象，使得开发人员可以专注于特定层次的实现而不必关心底层细节。\n可维护性： 修改或升级系统的特定层次不会影响其他层次，从而提高了系统的可维护性。\n可替代性： 可以相对容易地替换或升级某个层次，而不影响系统的整体功能。\n\n\n\n什么是摩尔定律？\n\n摩尔定律是由英特尔公司创始人戈登·摩尔提出的观点，它指出集成电路上可容纳的晶体管数量每隔约18至24个月会翻一番。 摩尔定律反映了集成电路技术快速发展的趋势，导致芯片性能不断提升，成本不断降低。\n\n通过什么可以展现硬件系统的功能并提供给用户？\n\n硬件系统的功能可以通过软件展现并提供给用户。 软件通过与硬件交互，控制硬件执行特定任务，使用户能够利用硬件提供的功能。\n\n有‘操作系统’包围计算机硬件的优势有哪些？\n\n有操作系统包围计算机硬件的优势包括：\n资源管理： 操作系统负责有效管理计算机硬件资源，如内存、CPU等。\n用户接口： 提供了用户与计算机系统交互的接口，使用户能够方便地使用计算机。\n多任务处理： 允许同时运行多个程序，提高了系统的效率和利用率。\n安全性： 操作系统提供了对计算机系统的访问控制和安全性管理。\n\n\n\nWIMP是什么缩写？WIMP的出现是由于什么发展？\n\nWIMP是窗口（Windows）、图标（Icons）、菜单（Menus）和指针（Pointers）的缩写。 WIMP的出现是由于图形用户界面（GUI）的发展。GUI的引入使计算机操作更直观，用户通过图形元素进行交互，而不仅仅是通过命令行界面。\n\n科学计算的焦点是什么？\n\n科学计算的焦点是通过数值方法和模拟来解决科学和工程问题。 这包括对复杂的数学模型进行数值求解，以模拟自然现象或工程系统的行为。\n\n商业计算的焦点是什么？\n\n商业计算的焦点是支持和优化商业运作。 这包括数据管理、财务分析、市场营销等，旨在提高组织的效率和决策制定。\n\n个人计算的主要特点是什么？\n\n个人计算的主要特点是个人使用。 个人计算机是为个人用户设计的，通常用于个人任务、娱乐和办公，具有相对较小的规模和灵活性。\n\n","slug":"CPT101-Review-1","date":"2023-12-03T07:50:09.000Z","categories_index":"","tags_index":"CPT101复习,笔记","author_index":"General_K1ng"},{"id":"931d32a5aa688f1d603d588de90831ae","title":"MySQL Review-2","content":"今天继续复习数据库，顺序就按照学校的来，我也不知道从哪里开始讲。\n什么是SQL？SQL的全称是 “Structured Query Language”，也就是结构化查询语言，是一种用于访问和处理数据库的标准的计算机语言。\nSQL可以干什么？SQL主要分为两种，一种是DDL（Data Definition Language），另一种是DML（Data Manipulation Language）。\nDDL（数据定义语言）：\n\n解释： DDL 是用于定义和管理数据库结构的语言。\n比喻： 想象数据库是一个房子，DDL 就像是建造房子的工具和规划图。它负责定义房子的基本结构，比如房间的数量、形状，以及窗户、门等的位置。\n例子： 如果你想在数据库中创建一个新的表格来存储学生信息，你会使用DDL 来定义这个表格的结构，包括每个字段的类型和大小。\n\nCREATE TABLE 学生表 (\n    姓名 VARCHAR(50),\n    年龄 INT,\n    成绩 FLOAT\n);\n\nDML（数据操作语言）：\n\n解释： DML 是用于操作（添加、修改、删除）数据库中实际数据的语言。\n比喻： 如果 DDL 是用来规划和建造房子的工具，那么 DML 就是用来在房子里进行装修和整理的工具。\n例子： 如果你想在学生表中添加一条新的学生记录，你会使用 DML。\n\nINSERT INTO 学生表 (姓名, 年龄, 成绩) VALUES ('小明', 15, 95);\n\n建立表格当你使用MySQL建表时，可以把表想象成一个电子表格，每个表格有一些列（字段），每列代表一种数据类型，而每一行则代表一条记录。\n这就是一般建表的语法：\nCREATE TABLE 表名 (\n    列1 数据类型,\n    列2 数据类型,\n    列3 数据类型,\n    ...\n);\n\n现在，我们可以通过一个具体的例子来说明。假设我们要创建一个存储学生信息的表，包括学生ID、姓名、年龄和成绩。我们可以这样写：\nCREATE TABLE 学生表 (\n    学生ID INT,\n    姓名 VARCHAR(50),\n    年龄 INT,\n    成绩 FLOAT\n);\n\n在这个例子中，我们创建了一个名为“学生表”的表，其中包含了四个列：学生ID（整数类型）、姓名（最大长度为50的字符串类型）、年龄（整数类型）和成绩（浮点数类型）。\n\n表名： 就像给一个文件起名一样，我们给我们的表起了一个名字，这个表的名字叫做“学生表”。\n列名和数据类型： 就像填写一个表格一样，我们定义了表格的每一列。例如，学生表中有学生ID、姓名、年龄和成绩这四列。而每一列都有对应的数据类型，比如学生ID是整数类型，姓名是字符串类型，年龄也是整数类型，成绩是浮点数类型。\n\n命名对象注意规范在MySQL中，命名对象（例如表名、列名、数据库名等）时，你会经常看到使用引号（单引号或双引号）或反引号（`）来括住这些名称。它们的使用有一些区别：\n\n单引号和双引号：\n单引号（'）和双引号（\"）在MySQL中通常用于表示字符串值。例如，SELECT * FROM 表 WHERE 列 = '某个值';。\n但是，当命名数据库对象（如表名、列名）时，单引号和双引号并不是标准的用法，而通常使用反引号。\n\n\n反引号（`）：\n在MySQL中，反引号主要用于标识数据库对象的名称，如表名、列名等。它是MySQL中用于引用标识符（identifiers）的一种方式。\n使用反引号可以确保MySQL正确解释标识符，即使标识符中包含了MySQL关键字或特殊字符。\n举例说明，在使用反引号的情况下，你可以创建一个包含空格的列名：CREATE TABLE 表名 (`有空格的列` INT);\n\n\n\n举例来说明：\n-- 使用反引号命名表名和列名\nCREATE TABLE `学生表` (\n    `学生ID` INT,\n    `姓名` VARCHAR(50),\n    `年龄` INT,\n    `成绩` FLOAT\n);\n\n-- 查询数据时也要使用反引号\nSELECT `学生ID`, `姓名` FROM `学生表` WHERE `年龄` &gt; 18;\n\nMySQL中的数据类型整数类型：\nTINYINT:\n范围：-128 到 127 （有符号），0 到 255 （无符号）\n存储空间：1字节\n\n\nSMALLINT:\n范围：-32,768 到 32,767 （有符号），0 到 65,535 （无符号）\n存储空间：2字节\n\n\nMEDIUMINT:\n范围：-8,388,608 到 8,388,607 （有符号），0 到 16,777,215 （无符号）\n存储空间：3字节\n\n\nINT (INTEGER):\n范围：-2,147,483,648 到 2,147,483,647 （有符号），0 到 4,294,967,295 （无符号）\n存储空间：4字节\n\n\nBIGINT:\n范围：-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 （有符号），0 到 18,446,744,073,709,551,615 （无符号）\n存储空间：8字节\n\n\n\n注意事项：\n\n在上述范围内，有符号整数类型的范围是从负数到正数，而无符号整数类型的范围是从0到正数。\n要注意的是，选择整数类型时，应根据存储需求选择合适的类型，以避免浪费存储空间。如果知道数据永远不会为负，可以考虑使用无符号整数类型，这将扩大可表示的正数范围。\n\n浮点数和定点数类型：1. 浮点数类型:\n\nFLOAT和DOUBLE是MySQL中用于存储浮点数的数据类型。\nFLOAT存储单精度浮点数，占用4字节。\nDOUBLE存储双精度浮点数，占用8字节。\n\n注意事项：\n\n浮点数在表示小数时可能存在精度问题，因为它们是以二进制形式存储的。\n在科学计算等需要广范围和较高精度的场景中使用。\n\n例子：\nCREATE TABLE 浮点数表 (\n    列1 FLOAT,\n    列2 DOUBLE\n);\n\n2. 定点数类型:\n\nDECIMAL是MySQL中用于存储定点数的数据类型，也称为精确数值类型。\nDECIMAL用于确保小数的精确性，而不会受到浮点数精度问题的影响。\nDECIMAL存储的小数点位数是固定的，通过指定精度和小数位数来定义。\n\n注意事项：\n\n适用于需要高精度计算，如货币或其他需要精确小数位的场景。\n占用的存储空间和定义的精度和小数位数相关。\n\n例子：\nCREATE TABLE 定点数表 (\n    列1 DECIMAL(10, 2),\n    列2 DECIMAL(8, 4)\n);\n\n在这个例子中，DECIMAL(10, 2)表示总共10位数，其中包括2位小数；而DECIMAL(8, 4)表示总共8位数，其中包括4位小数。\n总体而言，选择浮点数还是定点数取决于应用的需求。如果需要高精度，特别是在与货币相关的场景中，建议使用DECIMAL。如果对精度要求相对较低，而且需要处理大量数据，可以考虑使用FLOAT或DOUBLE。\n字符串类型：在MySQL中，有几种常见的字符串类型，包括CHAR、VARCHAR、TEXT。这些类型之间有一些关键的区别，主要涉及存储方式、长度限制和性能等方面。\nCHAR:\n\nCHAR是一种固定长度的字符串类型，即使存储的字符串长度不足，也会占用指定长度的空间。\n例如，如果定义了一个CHAR(10)，那么不管实际存储的字符串是”abc”还是”abcdefghij”，都会占用10个字符的存储空间。\n\n注意事项：\n\n适用于存储长度固定的字符串，比如存储国家代码或其他长度一致的数据。\n如果存储的字符串长度变化较大，可能会浪费存储空间。\n\n例子：\nCREATE TABLE 字符表 (\n    列1 CHAR(10),\n    列2 CHAR(50)\n);\n\nVARCHAR:\n\nVARCHAR是一种可变长度的字符串类型，它只占用存储的实际数据长度加上一些额外的字节。\n例如，如果定义了一个VARCHAR(10)，实际存储的字符串是”abc”，那么只会占用4个字符的存储空间（3个字符的数据加上一个用于存储长度的字节）。\n\n注意事项：\n\n适用于存储长度变化较大的字符串，可以节省存储空间。\nVARCHAR最大长度受数据库引擎的限制。\n\n例子：\nCREATE TABLE 可变字符表 (\n    列1 VARCHAR(10),\n    列2 VARCHAR(50)\n);\n\nTEXT:\n\nTEXT用于存储大文本数据，可以存储较长的字符串。\n与VARCHAR不同，TEXT没有指定长度，可以存储非常大的文本数据。\n\n注意事项：\n\n适用于存储非常长的文本数据，如文章内容、日志等。\nTEXT类型的数据在排序和索引上的性能可能不如CHAR和VARCHAR。\n\n例子：\nCREATE TABLE 文本表 (\n    列1 TEXT,\n    列2 LONGTEXT\n);\n\n总体而言，选择哪种字符串类型取决于实际的数据需求。如果字符串长度是固定的，使用CHAR可能更为合适。如果长度变化较大，但不会超过某个限定值，使用VARCHAR。如果需要存储非常长的文本数据，使用TEXT。\n日期和时间类型：DATE:\n\nDATE用于存储日期，不包含时间部分。\n格式为’YYYY-MM-DD’。\n\n注意事项：\n\n适用于存储不需要精确到时分秒的日期信息。\n\nTIME:\n\nTIME用于存储时间，不包含日期部分。\n格式为’HH:MM:SS’。\n\n注意事项：\n\n适用于存储不需要日期信息的时间。\n\nDATETIME:\n\nDATETIME用于存储日期和时间。\n格式为’YYYY-MM-DD HH:MM:SS’。\n\n注意事项：\n\n适用于需要同时存储日期和时间的情况。\n\nTIMESTAMP:\n\nTIMESTAMP也用于存储日期和时间。\n格式为’YYYY-MM-DD HH:MM:SS’。\nTIMESTAMP还具有特殊的自动更新功能，即当记录插入或更新时，TIMESTAMP列会自动更新为当前时间戳。\n\n注意事项：\n\n适用于需要记录时间戳并且可能需要自动更新的情况。\n\n总的来说，选择日期和时间类型取决于存储需求。如果只需要日期或时间，可以选择DATE或TIME。如果需要同时存储日期和时间，可以选择DATETIME或TIMESTAMP。在选择时还需要考虑是否需要自动更新功能。\n枚举和集合类型：在MySQL中，枚举（ENUM）和集合（SET）是用于存储一组离散值的数据类型。它们允许你定义一组可能的值，然后将某一列的值限制在这个集合内。以下是它们的详细解释：\nENUM:\n\nENUM用于存储一组预定义的可能取值。\n你可以在定义列的时候列举出所有可能的取值，然后在数据表中存储这些取值中的一个。\n例如，ENUM('男', '女')表示这个列的值只能是’男’或’女’中的一个。\n\n注意事项：\n\nENUM适用于有限且固定的取值集合。\n存储的值是按照定义时的顺序来排序的。\n\n例子：\nCREATE TABLE 枚举表 (\n    列1 ENUM('小', '中', '大')\n);\n\nSET:\n\nSET也用于存储一组预定义的可能取值，但不同于ENUM，SET允许存储多个值，这些值是由逗号分隔的。\n例如，SET('篮球', '足球', '乒乓球')表示这个列的值可以是单个选项，也可以是多个选项的组合，如’篮球’、’足球’、’篮球,乒乓球’等。\n\n注意事项：\n\nSET适用于有限的且可以组合的取值集合。\n存储的值是按照插入时的顺序来排序的。\n\n例子：\nCREATE TABLE 集合表 (\n    列1 SET('苹果', '橙子', '香蕉')\n);\n\n这玩意可不常用，起码目前我还没用过。\n二进制类型：在MySQL中，二进制类型用于存储二进制数据，例如图像、音频、视频等二进制文件。以下是MySQL中常见的二进制类型：\nBINARY 和 VARBINARY:\n\nBINARY和VARBINARY用于存储二进制数据，其中BINARY是定长的，而VARBINARY是变长的。\n例如，BINARY(10)表示存储长度为10的二进制数据，而VARBINARY(255)表示可以存储最大长度为255的变长二进制数据。\n\n注意事项：\n\n适用于存储固定或变长的二进制数据。\n\n例子：\nCREATE TABLE 二进制表 (\n    列1 BINARY(10),\n    列2 VARBINARY(255)\n);\n\nBLOB:\n\nBLOB是用于存储大型二进制对象的类型，适用于存储比较大的二进制数据。\nMySQL提供了不同大小的BLOB类型，包括TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。\n\n注意事项：\n\n适用于存储大型的二进制数据，如图像、音频、视频等。\nBLOB类型的数据在排序和索引上的性能可能不如其他类型。\n\n例子：\nCREATE TABLE 二进制大对象表 (\n    列1 BLOB,\n    列2 LONGBLOB\n);\n\n这玩意更加不常用，一般我们会使用第三方提供的OSS（对象存储服务），便宜安全好用，还快，谁会往自家服务本地存东西？\n空间数据类型：在MySQL中，空间数据类型用于存储与空间（地理或几何）相关的数据。以下是几种常见的空间数据类型：\n\nGEOMETRY:\n\nGEOMETRY类型用于存储任意几何对象。\n这包括点、线、多边形等各种几何形状。\n\n注意事项：\n\n适用于存储任意几何对象，但不能进行特定类型的分析或查询。\n\n\nPOINT:\n\nPOINT类型用于存储二维平面上的点。\nPOINT类型可以用来表示地理坐标，如经纬度。\n\n注意事项：\n\n适用于存储地理坐标等点的信息。\n\n\nLINESTRING:\n\nLINESTRING类型用于存储线。\n可以用一系列的点来定义一条线。\n\n注意事项：\n\n适用于存储线的几何信息。\n\n\nPOLYGON:\n\nPOLYGON类型用于存储多边形。\n可以用一系列的点来定义一个封闭的区域。\n\n注意事项：\n\n适用于存储多边形的几何信息。\n\n\n\n这个我也没用过。。。。\n\n\n\n\n\n\n\n\n\n存储空间的单位通常有字节（Byte）、千字节（KB）、兆字节（MB）、吉字节（GB）、太字节（TB）等。它们之间的换算关系如下：\n\n字节（Byte）:\n1 Byte = 8 比特（bit）\n\n\n千字节（KB）:\n1 KB = 1024 Bytes\n\n\n兆字节（MB）:\n1 MB = 1024 KB = 1024 * 1024 Bytes\n\n\n吉字节（GB）:\n1 GB = 1024 MB = 1024 * 1024 KB = 1024 * 1024 * 1024 Bytes\n\n\n太字节（TB）:\n1 TB = 1024 GB = 1024 * 1024 MB = 1024 * 1024 * 1024 KB = 1024 * 1024 * 1024 * 1024 Bytes\n\n\n\n自个慢慢换算，感觉考试肯定有一道题考这个。\n列选项（约束）在MySQL中，当你创建表时，你可以为每个列指定一些选项，这些选项称为列选项（Column Options）。这些选项允许你进一步定制列的行为和特性。以下是一些常见的列选项：\nNOT NULL使用NOT NULL选项是为了确保某一列的值不能为空（即不允许为NULL）。这对于确保数据的完整性和有效性是非常重要的。以下是关于NOT NULL选项的一些注意事项：\n数据完整性：\n\n主要目的是确保表中的每一行都有该列的值，从而维护数据的完整性。如果某一列没有NOT NULL选项，那么在插入数据时，该列可以为空。\n\n默认值：\n\n如果没有为列指定DEFAULT选项，而且该列被设置为NOT NULL，则在插入新行时必须为该列提供一个非NULL的值，否则插入将失败。\n\nCREATE TABLE 表名 (\n    列1 INT NOT NULL DEFAULT 0,\n    列2 VARCHAR(50) NOT NULL DEFAULT '未知'\n);\n\n索引和性能：\n\nNOT NULL列上的索引通常比允许NULL值的列上的索引更有效。这是因为索引不需要考虑NULL值，因此在使用NOT NULL的列进行检索时可能更快。\n\n外键约束：\n\n如果某列被用作外键，通常会希望该列是NOT NULL的，以确保引用的完整性。外键通常引用主键，而主键列通常是NOT NULL的。\n\nCREATE TABLE 父表 (\n    列1 INT PRIMARY KEY\n);\n\nCREATE TABLE 子表 (\n    列2 INT REFERENCES 父表(列1) NOT NULL\n);\n\n查询条件：\n\n在查询数据时，NOT NULL条件可以用于过滤掉空值。例如，SELECT * FROM 表名 WHERE 列1 IS NOT NULL;\n\nDEFAULT在MySQL中，DEFAULT选项用于指定列的默认值。如果在插入数据时未提供值，列将采用默认值。以下是关于DEFAULT选项的一些注意事项：\n默认值的类型：\n\n默认值必须是与列数据类型兼容的值。例如，如果列是整数类型，那么默认值必须是整数。如果类型不匹配，MySQL可能会尝试进行自动转换，但这可能导致错误或意外行为。\n\nCREATE TABLE 表名 (\n    列1 INT DEFAULT 0,\n    列2 VARCHAR(50) DEFAULT '未知'\n);\n\nNULL与DEFAULT的区别：\n\nDEFAULT和NULL是不同的概念。如果列被定义为NOT NULL，并且没有指定DEFAULT值，那么插入数据时必须提供一个非NULL的值。如果列具有DEFAULT值，那么在插入数据时可以省略该列，而MySQL将使用默认值。\n\nCREATE TABLE 表名 (\n    列1 INT NOT NULL,\n    列2 VARCHAR(50) DEFAULT '未知'\n);\n\n多列的默认值：\n\n对于包含多个列的表，可以为每列分别指定默认值。这些默认值将在插入数据时使用。\n\nCREATE TABLE 表名 (\n    列1 INT DEFAULT 0,\n    列2 VARCHAR(50) DEFAULT '未知',\n    列3 DATE DEFAULT CURRENT_DATE\n);\n\n系统函数和表达式：\n\n可以使用系统函数或表达式作为默认值，例如CURRENT_DATE表示当前日期，NOW()表示当前日期和时间。这使得可以动态地生成默认值。\n\nCREATE TABLE 表名 (\n    列1 INT DEFAULT 0,\n    列2 VARCHAR(50) DEFAULT '未知',\n    列3 TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n注意默认值的影响：\n\n当在插入数据时未提供指定列的值时，MySQL将使用默认值。这可以确保即使没有显式提供值，表中的每一行都具有某些默认的初始值。\n\nAUTO_INCREMENTAUTO_INCREMENT是MySQL中用于创建自增长列的选项。当插入一行数据时，自增长列会自动递增，为每一行分配一个唯一的标识。以下是关于AUTO_INCREMENT选项的一些注意事项：\n仅适用于整数类型：\n\nAUTO_INCREMENT通常用于整数列，例如INT、BIGINT等。自增长列的值会从一个指定的起始值开始，然后按照指定的步长递增。\n\nCREATE TABLE 表名 (\n    列1 INT AUTO_INCREMENT,\n    列2 VARCHAR(50),\n    PRIMARY KEY (列1)\n);\n\n唯一性：\n\n自增长列通常用作主键，确保每行的唯一性。由于每行的自增长值都不同，可以方便地用作唯一标识。\n\nCREATE TABLE 表名 (\n    列1 INT AUTO_INCREMENT PRIMARY KEY,\n    列2 VARCHAR(50)\n);\n\n指定起始值：\n\n可以使用AUTO_INCREMENT选项指定自增长列的起始值。这可以通过在创建表时使用AUTO_INCREMENT = value语法来完成。\n\nCREATE TABLE 表名 (\n    列1 INT AUTO_INCREMENT PRIMARY KEY,\n    列2 VARCHAR(50)\n) AUTO_INCREMENT = 100;\n\n不跳号：\n\n自增长列保证不会跳过任何值。即使删除了表中的某些行，下一行插入时仍会使用之前未使用的最小的自增长值。\n\n事务和并发：\n\n自增长列在事务和并发环境下的行为是可控的。不同的数据库引擎可能有不同的实现方式，但通常会保证生成唯一的自增长值。\n\n不适用于复制表：\n\n在使用复制表结构的操作（如CREATE TABLE ... AS SELECT ...）时，不会保留AUTO_INCREMENT属性。需要额外的步骤来设置新表的自增长属性。\n\n不可手动插入值：\n\n通常情况下，不建议手动插入值到自增长列。MySQL会自动为该列分配一个唯一的值。如果插入时指定了自增长列的值，系统可能会忽略该值并使用自己的自增长值。\n\nPRIMARY KEYPRIMARY KEY用于定义表中的主键，主键是用来唯一标识表中每一行的一列或一组列。以下是关于PRIMARY KEY的一些注意事项：\n唯一性：\n\n主键必须保证唯一性，每一行都必须有不同的主键值。这确保了表中的每个记录都可以通过主键唯一标识。\n\nCREATE TABLE 表名 (\n    列1 INT PRIMARY KEY,\n    列2 VARCHAR(50)\n);\n\n不允许NULL：\n\n主键列不允许包含NULL值。每个主键列都必须包含一个非NULL的值。\n\nCREATE TABLE 表名 (\n    列1 INT PRIMARY KEY,\n    列2 VARCHAR(50) NOT NULL\n);\n\n唯一索引：\n\n主键在数据库中通常被实现为唯一索引。因此，通过主键进行查询或检索的速度很快。\n\n复合主键：\n\n主键可以包含多列，这称为复合主键。复合主键的组合值必须是唯一的。\n\nCREATE TABLE 表名 (\n    列1 INT,\n    列2 INT,\n    PRIMARY KEY (列1, 列2)\n);\n\n自动递增：\n\n主键列通常与AUTO_INCREMENT一起使用，确保每次插入新记录时都生成唯一的主键值。\n\nCREATE TABLE 表名 (\n    列1 INT AUTO_INCREMENT PRIMARY KEY,\n    列2 VARCHAR(50)\n);\n\n外键关系：\n\n主键通常用作与其他表的外键关系。外键可以引用另一表中的主键，以确保数据的引用完整性。\n\nCREATE TABLE 父表 (\n    列1 INT PRIMARY KEY\n);\n\nCREATE TABLE 子表 (\n    列2 INT,\n    FOREIGN KEY (列2) REFERENCES 父表(列1)\n);\n\n变更注意事项：\n\n在表已经存在的情况下，要添加主键，表中的数据必须保证唯一性。如果表中已经有重复的值，需要先处理这些冲突再添加主键。\n\nALTER TABLE 表名 ADD PRIMARY KEY (列1);\n\nUNIQUEUNIQUE是用于定义唯一约束的关键字，在MySQL中，它用于确保表中的某一列或一组列的值是唯一的。以下是关于UNIQUE的一些注意事项：\n唯一性：\n\nUNIQUE约束确保被约束的列中的所有值都是唯一的，不允许重复。\n\nCREATE TABLE 表名 (\n    列1 INT UNIQUE,\n    列2 VARCHAR(50)\n);\n\nNULL值：\n\n对于带有UNIQUE约束的列，NULL值在唯一性方面是例外的。即使有多个NULL值，它们在唯一性检查中不会相互冲突。\n\nCREATE TABLE 表名 (\n    列1 INT UNIQUE,\n    列2 VARCHAR(50) UNIQUE\n);\n\n复合唯一性：\n\nUNIQUE约束可以应用于单列，也可以应用于多列，称为复合唯一性。复合唯一性要求所有列的组合值是唯一的。\n\nCREATE TABLE 表名 (\n    列1 INT,\n    列2 VARCHAR(50),\n    UNIQUE (列1, 列2)\n);\n\n自动创建索引：\n\nUNIQUE约束通常会在底层自动创建唯一索引。因此，对带有UNIQUE约束的列进行检索或排序的性能较好。\n\n违反唯一性的操作：\n\n如果插入或更新操作违反了UNIQUE约束，MySQL将抛出唯一性冲突的错误。在进行这些操作前应该确保要插入或更新的值不会导致唯一性冲突。\n\nINSERT INTO 表名 (列1, 列2) VALUES (1, '值1'); -- 正确\nINSERT INTO 表名 (列1, 列2) VALUES (1, '值2'); -- 违反唯一性约束\n\n变更注意事项：\n\n在表已经存在的情况下，要添加UNIQUE约束，表中的数据必须保证唯一性。如果表中已经有重复的值，需要先处理这些冲突再添加UNIQUE约束。\n\nALTER TABLE 表名 ADD UNIQUE (列1);\n\n插入数据（INSERT INTO）示例想象你有一张表格，表格的每一行代表一位同学的信息，有姓名、年龄和成绩三列。\n打开表格（表）：\n\n在MySQL中，就是打开你要插入数据的表。比如，我们打开了一张叫做students的表。\n\nUSE your_database_name; -- 切换到你的数据库\n\n选择要插入的位置（表的列）：\n\n告诉MySQL你要在哪个表格的哪几列插入数据。在我们的例子中，我们要插入姓名、年龄和成绩。\n\nINSERT INTO students (name, age, score) VALUES\n\n填写信息（插入具体的数据）：\n\n在表格中填写新同学的信息。比如，小明，13岁，成绩90。\n\n('小明', 13, 90);\n\n整合成完整的插入语句：\n\n将上述两步整合在一起，形成完整的插入语句。\n\nINSERT INTO students (name, age, score) VALUES ('小明', 13, 90);\n\n注意事项列顺序和值的对应：\n\n插入数据时，要确保列名和对应的值的顺序是一致的。比如，如果你的表有列 name、age、score，那么你插入的值的顺序也应该是 name、age、score。\n\nINSERT INTO students (name, age, score) VALUES ('小明', 13, 90);\n\n数据类型匹配：\n\n插入的值的数据类型要与表中对应列的数据类型匹配。如果某一列是整数类型，那么插入时对应的值也应该是整数。\n\nINSERT INTO students (name, age, score) VALUES ('小明', '13', 90); -- 错误示例，'13' 应为整数\n\n字符串使用单引号：\n\n如果插入的值是字符串，要确保用单引号括起来。\n\nINSERT INTO students (name, age, score) VALUES ('小明', 13, 90);\n\n主键约束：\n\n如果表中有主键，确保插入的数据不会导致主键重复。主键是表中唯一标识每一行记录的列。\n\nINSERT INTO students (id, name, age, score) VALUES (1, '小明', 13, 90);\n\n当然，一般主键都是自增的，我们不需要给主键赋值。\n默认值：\n\n如果表中某一列有默认值，可以选择不插入该列的值，数据库会使用默认值。\n\nINSERT INTO students (name, age) VALUES ('小明', 13); -- score 列会使用默认值\n\n插入多行数据：\n\nINSERT INTO语句可以一次插入多行数据，只需在VALUES后面添加多组值。\n\nINSERT INTO students (name, age, score) VALUES\n('小明', 13, 90),\n('小红', 14, 95),\n('小刚', 13, 88);\n\n良好的数据准备：\n\n在执行插入操作之前，确保你的数据准备工作已经完成，例如数据已经清理、格式正确等。\n\n事务处理：\n\n在插入大量数据时，可以考虑使用事务处理，以确保数据的一致性和完整性。\n\n更新（修改）数据（UPDATE）当你想要修改数据库表中已经存在的数据时，你可以使用 MySQL 中的 UPDATE 语句。这就好像你在纸上修改错别字一样，只不过是在数据库里进行的修改。\n示例想象你有一张表格，里面记录了同学的名字、年龄和成绩。现在你发现小明的成绩写错了，他实际上是 95 分，而不是原来的 90 分。\n找到小明的那一行（定位数据）：\n\n就像在表格里找到小明的那一行一样，在 MySQL 中，我们使用 WHERE 子句来定位要修改的行。\n\nUPDATE students SET score = 95 WHERE name = '小明';\n\n修改小明的成绩：\n\n然后告诉数据库你要把小明的成绩改成 95 分。\n\nUPDATE students SET score = 95 WHERE name = '小明';\n\n提交修改（保存修改）：\n\n最后，告诉数据库你已经完成了修改，要保存这个修改。\n\n\n\n\n\n\n\n\n\n\n一般的语法格式为：\nUPDATE table_name\nSET column1 = value1, column2 = value2, ...\nWHERE condition;\n\n\ntable_name：要修改的表名称。\n**column1, column2, …**：要修改的字段名称，可以为多个字段。\n**value1, value2, …**：要修改的值，可以为多个值。\ncondition：修改条件，用于指定哪些数据要修改。\n\n注意事项使用 WHERE 子句：\n\nUPDATE 语句会更新表中所有符合条件的记录。因此，务必使用 WHERE 子句来明确指定哪些行需要被更新。如果不使用 WHERE，可能会导致意外地修改整个表的数据。\n\nUPDATE students SET score = 95 WHERE name = '小明';\n\n确保条件唯一性：\n\n如果可能的话，确保 WHERE 子句的条件足够唯一，以免误操作。确保只有目标行满足条件。\n\nUPDATE students SET score = 95 WHERE student_id = 123; -- 使用唯一的 student_id\n\n备份数据：\n\n在执行大规模更新或者重要数据的更新操作之前，最好备份数据。这可以在意外发生时提供数据的还原点。\n\n避免过度更新：\n\n谨慎使用 UPDATE 语句，特别是在生产环境中。过度更新可能导致性能问题和数据一致性问题。确保只更新必要的数据。\n\n事务处理：\n\n对于涉及多个表或需要多个步骤的复杂更新，使用事务处理确保数据的一致性。在更新操作完成之后，使用 COMMIT 提交事务。\n\nSTART TRANSACTION;\n-- 执行一系列更新操作\nCOMMIT;\n\n这一步一般不需要我们手动去操作，一般的数据库软件都能做到，点一下，或者回车之类的。\n考虑性能：\n\n在更新大量数据时，要考虑更新操作的性能。如果可能的话，避免在大表上执行没有索引支持的更新操作，以提高查询效率。\n\n数据类型匹配：\n\n确保更新的值与目标列的数据类型匹配，以避免数据转换错误。\n\nUPDATE students SET age = '15' WHERE name = '小明'; -- 错误示例，'15' 应为整数\n\n更新部分字段：\n\n可以选择仅更新需要修改的列，而不必修改整行的所有数据。\n\nUPDATE students SET score = 95 WHERE name = '小明'; -- 只更新成绩，而不修改其他信息\n\n测试更新语句：\n\n在执行更新语句之前，先使用 SELECT 语句检查 WHERE 子句，确保它选中了你希望更新的行。\n\nSELECT * FROM students WHERE name = '小明';\n\n删除（行）数据（DELETE）当你想要从数据库中删除一些信息时，就可以使用 MySQL 中的 DELETE 语句。这就好像你在擦掉一张纸上的某些文字一样。\n示例想象你有一张同学名单表格，里面记录了同学们的名字、年龄和成绩。现在你发现表里有一个错误的记录，记录了一个不存在的同学，名字叫做”小花”，你要把这个错误的记录删除。\n找到要删除的那一行（定位数据）：\n\n就像在表格里找到那个错误记录的行一样，在 MySQL 中，我们使用 WHERE 子句来定位要删除的行。\n\nSELECT * FROM students WHERE name = '小花';\n\n确认删除操作（删除数据）：\n\n然后告诉数据库你要删除这个找到的记录。\n\nDELETE FROM students WHERE name = '小花';\n\n提交删除（保存删除操作）：\n\n最后，告诉数据库你已经完成了删除操作，要保存这个删除。\n\n注意事项使用 WHERE 子句：\n\nDELETE 语句会删除表中所有符合条件的记录。因此，务必使用 WHERE 子句来明确指定哪些行需要被删除。如果不使用 WHERE，可能会导致意外地删除整个表的数据。\n\nDELETE FROM students WHERE name = '小花';\n\n确保条件唯一性：\n\n确保 WHERE 子句的条件足够唯一，以免误删除其他不需要删除的数据。确保只有目标行满足条件。\n\nDELETE FROM students WHERE student_id = 123; -- 使用唯一的 student_id\n\n备份数据：\n\n在执行大规模删除或者删除重要数据之前，最好备份数据。这可以在意外发生时提供数据的还原点。\n\n避免没有 WHERE 的删除：\n\n不要轻易执行没有 WHERE 子句的 DELETE 语句，因为这会删除整个表中的所有数据。\n\nDELETE FROM students; -- 慎用，会删除整个表中的数据\n\n事务处理：\n\n对于涉及多个表或需要多个步骤的复杂删除操作，使用事务处理确保数据的一致性。在删除操作完成之后，使用 COMMIT 提交事务。\n\nSTART TRANSACTION;\n-- 执行一系列删除操作\nCOMMIT;\n\n考虑性能：\n\n在删除大量数据时，要考虑删除操作的性能。如果可能的话，避免在大表上执行没有索引支持的删除操作，以提高查询效率。\n\n谨慎使用 DELETE：\n\n谨慎使用 DELETE，尤其是在生产环境中。过度删除可能导致数据丢失和性能问题。\n\n测试删除语句：\n\n在执行删除语句之前，先使用 SELECT 语句检查 WHERE 子句，确保它选中了你希望删除的行。\n\nSELECT * FROM students WHERE name = '小花';\n\n关于删除的补充在 MySQL 中，有几种不同的删除操作，包括 DELETE、TRUNCATE 和 DROP，它们有不同的作用和用途。以下是它们的主要区别：\nDELETE\n作用： 用于删除表中的记录。\n影响范围： 可以通过使用 WHERE 子句来指定删除的记录。可以删除满足条件的一行或多行数据。\n保留结构： 表结构不受影响，只删除数据。\n事务支持： DELETE 操作是事务安全的，可以与事务一起使用。\n\nDELETE FROM table_name WHERE condition;\n\nTRUNCATE\n作用： 用于快速删除表中的所有数据。\n影响范围： 删除整个表中的所有数据，而不考虑任何条件。没有 WHERE 子句。\n保留结构： 保留表的结构，只删除数据。\n重置计数器： 在某些数据库中，TRUNCATE 操作还可以重置自增计数器（如果有的话）。\n事务支持： TRUNCATE 操作通常比 DELETE 操作更快，但不支持回滚。\n\nTRUNCATE TABLE table_name;\n\nDROP\n作用： 用于删除整个表，包括表的结构、数据以及相关的索引、约束等。\n影响范围： 删除整个表，无法恢复。\n保留结构： 表结构也被删除，不再存在。\n事务支持： DROP 操作是 DDL（数据定义语言）命令，不能回滚。执行后表不可恢复地被删除。\n\nDROP TABLE table_name;\n\n\n\n\n\n\n\n\n\n\n这里说的事务安全是指什么呢？\n在数据库管理系统中，事务（Transaction）是一组数据库操作，被看作是一个不可分割的工作单元。事务具有以下四个特性，通常被称为 ACID 特性：\n\n原子性（Atomicity）： 事务是一个原子操作，要么全部执行成功，要么全部执行失败。如果在事务执行过程中发生错误，系统会回滚（Rollback）事务，将数据库恢复到事务开始之前的状态，保持数据的一致性。\n一致性（Consistency）： 事务执行前后，数据库从一个一致的状态转变到另一个一致的状态。事务执行过程中，数据库约束不会被破坏，确保数据的完整性。\n隔离性（Isolation）： 事务的执行是相互隔离的，一个事务的执行不应影响其他事务的执行。事务之间应该是相互独立的，就好像它们是在系统中独立运行一样。\n持久性（Durability）： 一旦事务被提交，其结果应该是永久性的，即使系统崩溃，也能够通过数据库的恢复机制将数据还原到事务提交后的状态。\n\n说白了，如果是事务安全的，删除操作如果中途出现了什么问题导致了删除失败，则会回滚到删除之前的状态。\n比方说执行了一条删除语句，需要删除表中五条数据，但是在第三条的时候不知道咋了无法删除，但是已经删了两条数据了，如果是事务安全的，则会回滚到之前的状态，等于什么都没删。如果不是事务安全的，那么结果就是永久的删掉了这两条数据。\n也就是说，要么全部成功，要么全部失败。\n剩下的几个外键，CHECK之类的后面再说，今天复习的蛮多了，结束！\n","slug":"MySQL-Review-2","date":"2023-12-02T05:52:17.000Z","categories_index":"","tags_index":"笔记,MySQL复习","author_index":"General_K1ng"},{"id":"39fbf399d55711348e77da1a1e71b32f","title":"Java_Learning(Week10&11)","content":"哥们上周发烧了，就啥也没写，这周看能不能把两周的东西全写了。\n第十周这个JavaFX快被人喷烂了，我这里也不想写，我只写有必要学的。\nJava IO首先，Java IO 指的是 Java Input/Output（输入/输出）的缩写。在编程中，输入/输出是指程序与外部世界之间的信息传递。\n就好比你在电脑上输入文字，或者程序输出一些结果。\n让我们以一个简单的例子来理解 Java IO。假设你有一个小程序，要求用户输入他们的名字，然后程序将打印出一个问候语。在这个例子中，用户输入和程序输出就是IO的一部分。\nimport java.util.Scanner;  // 导入一个用于输入的工具\n\npublic class GreetingProgram {\n    public static void main(String[] args) {\n        // 创建一个 Scanner 对象，用于接收用户的输入\n        Scanner scanner = new Scanner(System.in);\n\n        // 提示用户输入名字\n        System.out.print(\"请输入你的名字: \");\n\n        // 通过 Scanner 获取用户输入的名字\n        String userName = scanner.nextLine();\n\n        // 输出问候语\n        System.out.println(\"你好, \" + userName + \"! 欢迎使用这个程序。\");\n\n        // 关闭 Scanner 对象，释放资源\n        scanner.close();\n    }\n}\n\n\n在这个例子中，Scanner 类帮助我们从控制台（System.in）获取用户的输入。这就是 Java 中的一种输入操作。而 System.out.println 则是一种输出操作，它将问候语打印到屏幕上。\nJava 的IO包含很多类，用于处理各种输入和输出。它们可以用于文件、网络、内存等不同的地方。就像你用不同的方式和不同的工具进行不同类型的交流一样，Java IO 也提供了不同的类来满足各种需求。\nFile类在 Java 中，File 类是用来表示文件和目录路径的。就像你在电脑上有文件夹来存放文件一样，程序中也可以通过 File 类来处理文件和文件夹。\n举个例子，想象你有一个程序，需要读取或写入一些文本文件。这时候，File 类就可以帮助你指定文件的路径和名称。\nimport java.io.File;\n\npublic class FileExample {\n    public static void main(String[] args) {\n        // 创建一个 File 对象，表示一个文件\n        File myFile = new File(\"example.txt\");\n\n        // 判断文件是否存在\n        if (myFile.exists()) {\n            System.out.println(\"文件存在！\");\n        } else {\n            System.out.println(\"文件不存在！\");\n        }\n\n        // 获取文件名\n        String fileName = myFile.getName();\n        System.out.println(\"文件名：\" + fileName);\n\n        // 获取文件路径\n        String filePath = myFile.getAbsolutePath();\n        System.out.println(\"文件路径：\" + filePath);\n    }\n}\n\n\n在这个例子中，我们创建了一个 File 对象，表示一个文件的路径。然后，我们检查文件是否存在，获取文件名和文件路径。\nFile 类的作用就像是一个文件的抽象描述，你可以使用它来检查文件是否存在、获取文件信息，甚至创建、删除文件。类似于你在电脑上通过文件夹来组织文件，程序中通过 File 类来处理文件和目录。\nFile类中的常用方法file.exists()： 检查文件或目录是否存在。\nFile myFile = new File(\"C:\\\\Users\\\\YourUsername\\\\Documents\\\\example.txt\");\n\nif (myFile.exists()) {\n    System.out.println(\"文件存在！\");\n} else {\n    System.out.println(\"文件不存在！\");\n}\n\nfile.isFile()： 判断给定路径是否表示一个文件。\nFile myFile = new File(\"C:\\\\Users\\\\YourUsername\\\\Documents\\\\example.txt\");\n\nif (myFile.isFile()) {\n    System.out.println(\"这是一个文件！\");\n} else {\n    System.out.println(\"这不是一个文件！\");\n}\n\nfile.isDirectory()： 判断给定路径是否表示一个目录。\nFile myDirectory = new File(\"C:\\\\Users\\\\YourUsername\\\\Documents\");\n\nif (myDirectory.isDirectory()) {\n    System.out.println(\"这是一个目录！\");\n} else {\n    System.out.println(\"这不是一个目录！\");\n}\n\nfile.isHidden()： 判断文件是否是隐藏文件。\nFile myFile = new File(\"C:\\\\Users\\\\YourUsername\\\\Documents\\\\example.txt\");\n\nif (myFile.isHidden()) {\n    System.out.println(\"这是一个隐藏文件！\");\n} else {\n    System.out.println(\"这不是一个隐藏文件！\");\n}\n\nfile.length()： 获取文件的长度（以字节为单位）。\nFile myFile = new File(\"C:\\\\Users\\\\YourUsername\\\\Documents\\\\example.txt\");\nlong fileSize = myFile.length();\n\nSystem.out.println(\"文件大小：\" + fileSize + \" 字节\");\n\nfile.canRead()： 判断文件是否可读。\nFile myFile = new File(\"C:\\\\Users\\\\YourUsername\\\\Documents\\\\example.txt\");\n\nif (myFile.canRead()) {\n    System.out.println(\"文件可读！\");\n} else {\n    System.out.println(\"文件不可读！\");\n}\n\nfile.canWrite()： 判断文件是否可写。\nFile myFile = new File(\"C:\\\\Users\\\\YourUsername\\\\Documents\\\\example.txt\");\n\nif (myFile.canWrite()) {\n    System.out.println(\"文件可写！\");\n} else {\n    System.out.println(\"文件不可写！\");\n}\n\nfile.getAbsolutePath()： 获取文件或目录的绝对路径。\nFile myFile = new File(\"C:\\\\Users\\\\YourUsername\\\\Documents\\\\example.txt\");\nString absolutePath = myFile.getAbsolutePath();\n\nSystem.out.println(\"文件的绝对路径：\" + absolutePath);\n\n绝对路径与相对路径绝对路径想象一下你住在一个大城市中，有很多房子和街道。每个房子都有一个唯一的地址，这个地址就像文件在计算机中的绝对路径一样。绝对路径告诉计算机，文件在整个文件系统中的确切位置。\n在计算机中：\nFile myFile = new File(\"C:\\\\Users\\\\YourUsername\\\\Documents\\\\example.txt\");\n\n这里的 \"C:\\\\Users\\\\YourUsername\\\\Documents\\\\example.txt\" 就是文件的绝对路径。就像你的家庭地址告诉你的朋友你住在哪个房子一样，计算机使用绝对路径告诉程序文件在哪里。\n相对路径相对路径有点像给朋友一个指示方向的方式。想象你和朋友在一个大花园里，有很多树和小道。如果你告诉朋友：“在我们左侧的第三颗大树旁边有一个小花园”，这就是相对于你当前位置的路径描述。相对路径是相对于当前工作目录或当前文件所在的位置的路径。\n在计算机中：\nFile myFile = new File(\"Documents\\\\example.txt\");\n\n这里的 \"Documents\\\\example.txt\" 就是文件的相对路径。程序会在当前工作目录或当前文件所在的位置中寻找这个文件。\nPrintWriter类如果我们需要向文件当中写入一些内容，我们就可以用到PrintWriter类，就相当于我们用来写字的笔一样。\nimport java.io.FileWriter;\nimport java.io.PrintWriter;\nimport java.io.IOException;\n\npublic class LetterWriter {\n    public static void main(String[] args) {\n        try {\n            // 创建一个 PrintWriter 对象，用于写入文件\n            PrintWriter writer = new PrintWriter(new FileWriter(\"letter.txt\"));\n\n            // 写入信的内容\n            writer.println(\"亲爱的朋友,\");\n            writer.println(\"希望你过得很好！\");\n            writer.println(\"祝你一切顺利。\");\n\n            // 关闭 PrintWriter，确保写入完成\n            writer.close();\n            \n            System.out.println(\"信已写入文件！\");\n        } catch (IOException e) {\n            System.out.println(\"写信时出错：\" + e.getMessage());\n        }\n    }\n}\n\n\n在这个例子中，我们创建了一个 PrintWriter 对象，用于写入文件。然后，我们使用 println 方法向文件写入每一行信的内容。最后，我们关闭 PrintWriter，确保信的内容已经写入文件。\nBufferedWriter类想象一下你在写一篇文章，你可以选择是逐字逐句写，还是先在脑海中构思好，然后再一次性写入。BufferedWriter 就像是帮你提前构思好的大脑，让你能够更高效地写入文件。\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class ArticleWriter {\n    public static void main(String[] args) {\n        try {\n            // 创建一个 BufferedWriter 对象，用于写入文件\n            BufferedWriter writer = new BufferedWriter(new FileWriter(\"article.txt\"));\n\n            // 写入文章内容\n            writer.write(\"今天是个美好的一天。\\n\");\n            writer.write(\"阳光明媚，空气清新。\\n\");\n            writer.write(\"希望每个人都过得愉快！\");\n\n            // 关闭 BufferedWriter，确保写入完成\n            writer.close();\n            \n            System.out.println(\"文章已写入文件！\");\n        } catch (IOException e) {\n            System.out.println(\"写文章时出错：\" + e.getMessage());\n        }\n    }\n}\n\n\n在这个例子中，我们创建了一个 BufferedWriter 对象，它负责将数据写入文件。然后，我们使用 write 方法逐行写入文章内容。最后，我们关闭 BufferedWriter，确保文章的内容已经写入文件。\n\n\n\n\n\n\n\n\n\nBufferedWriter 和 PrintWriter 都是 Java 中用于写入文件的类，但它们有一些区别。\n1. 数据类型:\n\nBufferedWriter 主要用于写入字符数据，而且通常搭配其他的 Writer 使用。\nPrintWriter 则旨在向文本文件写入各种类型的数据，包括字符、数字等。它继承自 Writer 类，但提供了更高级别的写入操作。\n\n2. 功能:\n\nBufferedWriter 主要关注的是提高写入性能，通过在内存中创建缓冲区，将数据一次性写入文件，而不是每次都直接写入文件。\nPrintWriter 提供了方便的写入各种数据类型的方法，例如 println 可以用于写入一行文本，print 可以用于写入其他数据类型。\n\n3. 用途:\n\n如果你主要关心写入字符数据并提高写入性能，比如写入大量文本数据，那么 BufferedWriter 是个好选择。\n如果你需要更高级别的写入操作，比如写入不同类型的数据，而且希望写入更方便，那么 PrintWriter 可能更适合你。\n\nBufferedReader类如果你在阅读一本书，有时你可能会一次读一个字，但这样效率不高。BufferedReader 就像是一种阅读方式，它可以提高你读取文本的效率，一次读取一行文字。\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class BookReader {\n    public static void main(String[] args) {\n        try {\n            // 创建一个 BufferedReader 对象，用于读取文件\n            BufferedReader reader = new BufferedReader(new FileReader(\"book.txt\"));\n\n            // 读取书的内容一行一行地输出\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n\n            // 关闭 BufferedReader\n            reader.close();\n            \n            System.out.println(\"书已读完！\");\n        } catch (IOException e) {\n            System.out.println(\"读书时出错：\" + e.getMessage());\n        }\n    }\n}\n\n在这个例子中，我们创建了一个 BufferedReader 对象，它负责从文件中读取数据。然后，我们使用 readLine 方法一次读取一行书的内容，并输出到控制台。最后，我们关闭 BufferedReader，表示我们已经读完了这本书。\n以上就是学校教的了，但是！其实压根没讲全，没讲明白，所以下来我来补充。\n什么是流？想象一下水流，水从一个地方流向另一个地方，这是一个连续的过程。在计算机中，流也是一种数据的流动方式，数据可以从一个地方（比如文件、网络、键盘）流向另一个地方（比如文件、网络、屏幕）。\n在计算机中，流是一种用于处理输入和输出的概念。就像水流一样，数据可以流经不同的管道（流），从一个地方传送到另一个地方。\n\n输入流（Input Stream）： 就像是水流进入计算机，可以是文件、键盘、网络等。我们可以从输入流中读取数据。\n输出流（Output Stream）： 就像是水流离开计算机，可以是文件、屏幕、网络等。我们可以往输出流中写入数据。\n\n可以把流比作一个管道，通过这个管道可以传送数据。输入流就像是管道的一端，数据从外部流入计算机；输出流就像是管道的另一端，数据从计算机流向外部。这样，我们就可以通过这个管道实现数据的输入和输出。\n在Java中，流是一种用于在程序中读取和写入数据的机制。流可以用于处理各种输入和输出，如文件、网络连接、内存等。Java中的流按照数据类型分为字节流（Byte Stream）和字符流（Character Stream），以及按照功能分为输入流和输出流。\n字节流（Byte Stream）想象一下，你正在把一本书从图书馆搬到家里。这本书就像是你的数据，而搬运的过程就是数据在计算机中传输的过程。在Java中，字节流就好比是你用一个个小车把书本一页一页地搬运到家里的过程。\n字节流就是一种比较原始的搬运方式，就像是逐页逐页地把书本搬运到家里。Java中的字节流可以帮助我们在程序中传输和处理数据，就像你搬运书本一样。\n字符流（Character Stream）字符流和字节流有些相似，但在处理文本数据时更方便。让我们用一个类似的比喻来解释字符流。\n想象你有一张写满字的便签，这些字就是你的文本数据。你想要把这张便签上的文字复制到电脑里。这时候，你会用一个专门读取文字的笔，而不是一个一页一页地搬运。\n在Java中，字符流就像这支专门读取文字的笔。它以字符为单位进行读写，而不是字节。这样做的好处是，在处理文本文件时，字符流可以更好地处理字符编码，确保我们正确地读取和写入文本数据。\n也就是说，字符流更加适合来处理字符，或者说是文本数据。\n\n这张图说明了输入流和输出流的类层次\nFileInputStream想象一下你的电脑是一个大型文件柜，里面有很多文件夹和文件。有时候，你可能想要读取某个文件的内容，就像打开文件柜并查看文件一样。这时候，Java中的FileInputStream就像是一个专门用来帮你读取文件的小助手。\n首先，你需要告诉这个小助手你要读取哪个文件。就像告诉朋友：“嘿，我要看一下那个文件柜里的那个文件”，你需要给FileInputStream一个文件的路径，告诉它你要读取哪个文件。\n// 创建一个FileInputStream，告诉它你要读取的文件是哪个\nFileInputStream fis = new FileInputStream(\"文件的路径\");\n\n现在，它知道你要读取哪个文件了。接下来，你可以要求它帮你一个字一个字地读取文件的内容。就像你可以一个一个字母地读一封信一样。\n// 创建一个变量来存储读取到的字节\nint byteRead = fis.read();\n\n上面的代码告诉小助手：“嘿，帮我读取文件的第一个字节。”小助手会告诉你这个字节是什么，然后你可以决定做什么，比如显示在屏幕上或者做其他处理。\n读取完一个字节后，你可以继续读取下一个字节，直到整个文件都被读取完毕。\nwhile (byteRead != -1) {\n    // 处理读取到的字节，比如显示在屏幕上\n    System.out.print((char) byteRead);\n\n    // 继续读取下一个字节\n    byteRead = fis.read();\n}\n\n最后记得释放资源：\n// 关闭FileInputStream\nfis.close();\n\nFileOutputStream当你想要往文件里写入内容时，就可以使用Java中的FileOutputStream。\n想象一下，你现在想在文件柜里新建一个文件，并开始写一些东西。Java中的FileOutputStream就像是一个小秘书，专门帮你把你想写的东西一个字一个字地写进文件里。\n首先，你需要告诉这个小秘书你要写入哪个文件。就像对朋友说：“我要在文件柜里的这个文件里写点东西”，你需要给FileOutputStream一个文件的路径，告诉它你要写入哪个文件。\n// 创建一个FileOutputStream，告诉它你要写入的文件是哪个\nFileOutputStream fos = new FileOutputStream(\"文件的路径\");\n\n现在，小秘书知道你要往哪个文件写入了。接下来，你可以告诉它你要写入的内容是什么。就像告诉小秘书：“嘿，帮我写下这一句话”，你需要把要写入的内容转换成字节数组，并传给FileOutputStream。\n// 要写入的内容，这里用字符串举例\nString content = \"你好，文件！\";\n// 把字符串转换成字节数组\nbyte[] byteContent = content.getBytes();\n\n// 告诉小秘书把这个字节数组写入文件\nfos.write(byteContent);\n\n上面的代码告诉小秘书：“好的，帮我把这个字节数组写入文件。”小秘书会帮你把内容一个字一个字地写进文件。\n最后一样，记得释放资源。\n// 关闭FileOutputStream\nfos.close();\n\n集合框架（Collections Framework）这周讲了几个数据结构，但是没细讲，因为我们下学期好像有算法课，但是无所谓，讲了就先记着。\n首先，什么是集合框架呢？在Java中，集合框架是一组用于存储和操作数据的类和接口。就像你有一个盒子，可以把不同类型的东西放进去，Java的集合框架也提供了不同类型的容器，用于存储和处理数据。\n\n集合框架的种类\nList（列表）： 就像一个有序的清单，你可以按照顺序放入和取出物品。比如，一个购物清单就是一个List。\nSet（集合）： 就像一个没有重复物品的袋子，你可以往里放入各种东西，但相同的东西只会有一个。比如，一个装满不同颜色糖果的袋子就是一个Set。\nMap（映射）： 就像一本字典，你可以查找特定的词语并找到对应的解释。在Java中，Map允许你用一个值（键）来查找另一个值（值）。\nQueue（队列）： 就像排队等候的人一样，先来的先被处理。在Java中，Queue用于处理先进先出（FIFO）的数据结构。\n\n具体的集合类这些集合框架中的每一个都有具体的实现类，就像箱子的每个分区都有不同的盒子。比如，List有ArrayList、LinkedList，Set有HashSet、TreeSet，Map有HashMap、TreeMap等。\n像List、Set这些都是接口，而ArrayList是它的实现类，这里只是说明一下，毕竟我们没学接口。\n\nArrayList： 动态数组，可以动态增长和缩小。适合随机访问元素。\nLinkedList： 双向链表，对于频繁的插入和删除操作比ArrayList更高效。\nHashSet： 无序、不包含重复元素的集合。\nLinkedHashSet： 有序、不包含重复元素的集合，保留了元素的插入顺序。\nTreeSet： 有序、不包含重复元素的集合，按照元素的自然顺序或者指定的比较器进行排序。\nHashMap： 无序的键值对集合，使用哈希表实现。\nLinkedHashMap： 有序的键值对集合，保留了元素的插入顺序。\nTreeMap： 有序的键值对集合，按照键的自然顺序或者指定的比较器进行排序。\n\n为什么要用这些？byd想要自己手搓链表？手搓数据结构？\n体验过一遍你就不会想要再来了，所以Java给你提供了，直接用就行，这也是封装的体现。\n泛型当我们谈到泛型时，可以将其比喻成一种“万能容器”，就像一个可以装任何类型的盒子一样。让我们通过一个简单的例子来理解泛型：\n1. 什么是泛型？泛型是一种让你在编写代码时，不仅可以指定数据类型，还可以使代码更灵活、通用的特性。就像你可以用一个盒子来容纳各种各样的东西，泛型让你的代码可以容纳不同类型的数据。\n2. 为什么需要泛型？假设你有一个盒子类：\nclass Box {\n    private Object content;\n\n    public void setContent(Object content) {\n        this.content = content;\n    }\n\n    public Object getContent() {\n        return content;\n    }\n}\n\n这个盒子可以装任何东西，但有一个问题，当你想取出盒子里的东西时，你必须强制转换类型：\nBox myBox = new Box();\nmyBox.setContent(\"Hello, World!\");\n\n// 需要强制转换类型\nString message = (String) myBox.getContent();\n\n这样的代码看起来有些麻烦，而且容易出错。泛型的出现就是为了解决这个问题。\n3. 使用泛型的盒子：class GenericBox&lt;T&gt; {\n    private T content;\n\n    public void setContent(T content) {\n        this.content = content;\n    }\n\n    public T getContent() {\n        return content;\n    }\n}\n\n在这个泛型盒子中，&lt;T&gt;表示这是一个泛型类，T是类型的占位符，可以代表任何数据类型。现在，你可以创建一个可以装任何类型的盒子：\nGenericBox&lt;String&gt; myGenericBox = new GenericBox&lt;&gt;();\nmyGenericBox.setContent(\"Hello, World!\");\n\n// 不需要强制转换类型\nString message = myGenericBox.getContent();\n\n4. 泛型的好处：\n类型安全： 泛型提供了类型检查，防止在编译时发生类型错误。\n代码重用： 泛型可以使你编写更通用的代码，适用于多种数据类型。\n\n5. 示例：使用泛型的集合：List&lt;String&gt; myList = new ArrayList&lt;&gt;();\nmyList.add(\"苹果\");\nmyList.add(\"香蕉\");\n\n// 不需要强制转换类型\nString fruit = myList.get(0);\n\n在这个例子中，List&lt;String&gt;表示这是一个字符串类型的列表，你可以放入和取出字符串，不需要担心类型转换问题。\n说白了，就是告诉你，这个数据结构里面装的是什么类型的东西，是装什么对象的。\nList记住List是一个接口，下面的两个都是它的实现类，在实现类当中必须实现接口中的所有方法，所以，只要是List中的方法，在下面的两个实现类当中都能用。\n当我们谈到List接口时，可以把它看作是一个有序的集合，就像你的播放列表一样，你可以按照特定的顺序存储和访问元素。List接口提供了一系列方法，让我们能够方便地操作列表中的元素。以下是一些常用的List接口方法：\n常用的List接口方法：添加元素：add(E element): 将元素添加到列表的末尾。\nList&lt;String&gt; playlist = new ArrayList&lt;&gt;();\nplaylist.add(\"歌曲1\");\nplaylist.add(\"歌曲2\");\n\nadd(int index, E element): 在指定位置插入元素。\nplaylist.add(1, \"歌曲3\");\n\n获取元素：get(int index): 获取指定位置（索引）的元素。\nString song = playlist.get(0);\n\n移除元素：remove(int index): 移除指定位置的元素。\nplaylist.remove(1);\n\nremove(Object obj): 移除第一次出现的指定元素。\nplaylist.remove(\"歌曲1\");\n\n判断元素是否存在：contains(Object obj): 判断列表中是否包含指定元素。\nboolean hasSong = playlist.contains(\"歌曲2\");\n\n获取列表大小：size(): 获取列表中元素的数量。\nint numberOfSongs = playlist.size();\n\n遍历列表：使用for循环或者迭代器Iterator来遍历列表中的元素。\nfor (String song : playlist) {\n    System.out.println(song);\n}\n\n// 或者\n\nIterator&lt;String&gt; iterator = playlist.iterator();\nwhile (iterator.hasNext()) {\n    String song = iterator.next();\n    System.out.println(song);\n}\n\n\n替换元素：set(int index, E element): 替换指定位置的元素。\nplaylist.set(0, \"新歌曲\");\n\n增强For就是一种For循环，你们肯定也会见过IDEA中用黄色波浪线画出来说你这个for循环可以替换为增强for。\n增强for循环也被称为for-each循环，它提供了一种简化遍历数组或集合的语法。语法格式如下：\nfor (ElementType variable : collection) {\n    // 循环体，使用 variable 访问当前元素\n}\n\n其中，ElementType是集合中元素的类型，variable是一个新的变量，用于存储当前循环迭代的元素，collection是被遍历的集合。\nList&lt;String&gt; fruits = Arrays.asList(\"苹果\", \"香蕉\", \"橙子\");\n\n// 使用增强for循环遍历列表\nfor (String fruit : fruits) {\n    System.out.println(fruit);\n}\n\n这段代码将会输出：\n苹果\n香蕉\n橙子\n\n迭代器迭代器是一种更传统的遍历集合的方式，它是Iterator接口的实现类。通过迭代器，你可以手动控制遍历的过程，并进行一些额外的操作。迭代器提供了三个基本方法：\n\nhasNext(): 判断集合中是否还有下一个元素。\nnext(): 返回集合中的下一个元素，并将迭代器的位置移动到下一个元素。\nremove(): 从集合中移除上一个返回的元素（可选操作）。\n\nList&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);\n\n// 使用迭代器遍历列表\nIterator&lt;Integer&gt; iterator = numbers.iterator();\nwhile (iterator.hasNext()) {\n    Integer number = iterator.next();\n    System.out.println(number);\n}\n\n这段代码同样会输出：\n1\n2\n3\n4\n5\n\n选择使用哪种方式？\n增强For循环： 适用于简单的遍历操作，语法简洁，易读。\n迭代器： 提供了更多的控制权，可以在遍历的同时对集合进行操作，适用于需要更多控制的情况。\n\n实际上，肯定还是增强For用的多，但是不代表迭代器你就可以不学了。\nArrayList当我们谈到ArrayList时，可以把它比作一个可伸缩的动态数组，就像你的书包可以随时放入更多的书一样。让我们通过简单的例子来理解ArrayList：\n1. 什么是ArrayList？ArrayList是Java中的一种数据结构，它允许我们以列表的形式存储一组元素。就像你的书包可以容纳许多书籍一样，ArrayList可以容纳很多数据。\n2. 如何使用ArrayList？假设我们有一个ArrayList用来存储水果：\nimport java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建一个ArrayList来存储水果\n        ArrayList&lt;String&gt; fruits = new ArrayList&lt;&gt;();\n\n        // 添加水果\n        fruits.add(\"苹果\");\n        fruits.add(\"香蕉\");\n        fruits.add(\"橙子\");\n\n        // 打印水果\n        System.out.println(\"水果列表: \" + fruits);\n    }\n}\n\n在这个例子中，我们首先创建了一个ArrayList，然后向其中添加了一些水果（”苹果”、”香蕉”、”橙子”）。最后，我们打印整个水果列表。\n3. ArrayList的好处\n动态大小： 与普通数组不同，ArrayList的大小是动态的，你可以根据需要添加或删除元素，而不用担心数组的固定大小。\n方便操作： ArrayList提供了许多方便的方法，比如添加元素、删除元素、获取元素等，使得对数据的操作更加灵活。\n\n4. 操作ArrayList// 获取特定位置的水果\nString firstFruit = fruits.get(0);\nSystem.out.println(\"第一个水果: \" + firstFruit);\n\n// 删除水果\nfruits.remove(\"香蕉\");\nSystem.out.println(\"删除香蕉后的列表: \" + fruits);\n\n在这里，我们通过get方法获取第一个水果，然后使用remove方法删除了”香蕉”。\n对于我而言，这个玩意最好的地方在于动态，你可以回想一下自己用数组的时候的诸多不便，这里基本上都能解决了。\nLinkedList当我们谈到LinkedList时，可以将其比作一条可以在节点之间移动的链表，就像你的项链上的各种珠子可以一个接一个地连接一样。让我们通过简单的例子来理解LinkedList：\n1. 什么是LinkedList？LinkedList是Java中的一种数据结构，它使用节点（Node）的方式来存储元素，每个节点都包含一个元素和指向下一个节点的引用。就像项链上的珠子一个接一个地连接，LinkedList中的元素也是通过节点连接的。\n2. 如何使用LinkedList？假设我们有一个LinkedList用来存储颜色：\nimport java.util.LinkedList;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建一个LinkedList来存储颜色\n        LinkedList&lt;String&gt; colors = new LinkedList&lt;&gt;();\n\n        // 添加颜色\n        colors.add(\"红色\");\n        colors.add(\"绿色\");\n        colors.add(\"蓝色\");\n\n        // 打印颜色\n        System.out.println(\"颜色链表: \" + colors);\n    }\n}\n\n在这个例子中，我们首先创建了一个LinkedList，然后向其中添加了一些颜色（”红色”、”绿色”、”蓝色”）。最后，我们打印整个颜色链表。\n3. LinkedList的好处\n动态操作： 与ArrayList不同，LinkedList对于频繁的插入和删除操作更为高效，因为它只需要调整节点的引用。\n节点连接： LinkedList的元素通过节点相互连接，这意味着你可以在链表中方便地插入或删除元素。\n\n4. 操作LinkedList// 获取第一个颜色\nString firstColor = colors.getFirst();\nSystem.out.println(\"第一个颜色: \" + firstColor);\n\n// 在指定位置插入颜色\ncolors.add(1, \"黄色\");\nSystem.out.println(\"插入黄色后的链表: \" + colors);\n\n在这里，我们通过getFirst方法获取第一个颜色，然后使用add方法在指定位置插入了”黄色”。\n这个就是双向链表，具体的数据结构细节这里我就不说了，如果有时间的话以后再说，你只需要记得，频繁的删改，这个更加高效。\nSet跟List一样，Set也是一样的，也是接口。\n当我们谈到Set接口时，可以将其比作一个独特的盒子，这个盒子只能放不同的物品，不允许重复。Set是一种集合，它不保留元素的插入顺序，而且不允许包含重复元素。\n常用的Set接口方法：添加元素：add(E element): 将元素添加到集合中。\nSet&lt;String&gt; uniqueColors = new HashSet&lt;&gt;();\nuniqueColors.add(\"红色\");\nuniqueColors.add(\"绿色\");\nuniqueColors.add(\"蓝色\");\n\n移除元素：remove(Object obj): 从集合中移除指定元素。\nuniqueColors.remove(\"绿色\");\n\n判断元素是否存在：contains(Object obj): 判断集合中是否包含指定元素。\nboolean hasRed = uniqueColors.contains(\"红色\");\n\n获取集合大小：size(): 获取集合中元素的数量。\nint numberOfColors = uniqueColors.size();\n\n清空集合：clear(): 移除集合中的所有元素。\nuniqueColors.clear();\n\n遍历集合：使用增强for循环或者迭代器Iterator遍历集合中的元素。\nfor (String color : uniqueColors) {\n    System.out.println(color);\n}\n\n// 或者\n\nIterator&lt;String&gt; iterator = uniqueColors.iterator();\nwhile (iterator.hasNext()) {\n    String color = iterator.next();\n    System.out.println(color);\n}\n\nHashSetHashSet 是 Java 中的一个集合类，实现了 Set 接口，它以哈希表的形式存储元素，确保不包含重复元素。现在，让我们通过一些简单的比喻和例子来理解 HashSet。\n特性就是这玩意放东西不会重复，懂吧，就是不会重复，但是问题就是不会保证元素的顺序，就是你添加的时候和最后往外拿的时候顺序可能不一样。\n1. 使用 HashSet让我们通过一些例子来看看如何使用 HashSet：\nimport java.util.HashSet;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建一个 HashSet 来存储颜色\n        HashSet&lt;String&gt; uniqueColors = new HashSet&lt;&gt;();\n\n        // 添加颜色\n        uniqueColors.add(\"红色\");\n        uniqueColors.add(\"绿色\");\n        uniqueColors.add(\"蓝色\");\n        uniqueColors.add(\"红色\"); // 尝试添加重复的颜色，但实际上只有一个红色被保留\n\n        // 输出 HashSet 的大小\n        System.out.println(\"颜色集合大小：\" + uniqueColors.size());\n\n        // 遍历 HashSet\n        for (String color : uniqueColors) {\n            System.out.println(color);\n        }\n    }\n}\n\n2. HashSet 的特性\n不允许重复元素：无论你尝试往里放多少个相同的东西，最终只会保留一个。\n无序性： HashSet 不保证元素的顺序，元素的存储顺序可能和你添加的顺序不一样。\n\n3. HashSet 的用途HashSet 常常用于需要快速查找和去重的场景。比如，你可以使用 HashSet 存储一组唯一的用户名，以快速检查新用户名是否已存在。\n学校就讲了这一个，其实也就这个用的最多，剩下的一个LinkedHashSet和TreeSet以后看有没有时间再写。\nMap什么是Map？就是存储键值对的一种数据结构，可以将其比喻成一种关系对照表，就像字典一样，每个词都有对应的解释。Map 是 Java 中的一种集合接口，用于存储键值对，其中每个键对应一个值。让我们通过一些简单的比喻和例子来理解 Map。\n1. 字典想象一本字典，其中每个词都有一个对应的解释。在 Java 中，Map 就像这本字典一样，每个键（词）都有一个对应的值（解释）。\n2. 基本概念\n键（Key）： 就像字典中的词，用于查找对应的值。\n值（Value）： 就像字典中词的解释，与键相关联。\n\n3. 常用的 Map 接口方法添加键值对：put(K key, V value): 将键值对添加到 Map 中。\nMap&lt;String, Integer&gt; wordCount = new HashMap&lt;&gt;();\nwordCount.put(\"apple\", 3);\nwordCount.put(\"banana\", 2);\n\n获取值：get(Object key): 根据键获取对应的值。\nint count = wordCount.get(\"apple\");\n\n判断键是否存在：containsKey(Object key): 判断 Map 中是否包含指定的键。\nboolean hasApple = wordCount.containsKey(\"apple\");\n\n获取所有键或值的集合：keySet(): 返回包含所有键的 Set。\nSet&lt;String&gt; words = wordCount.keySet();\n\nvalues(): 返回包含所有值的 Collection。\nCollection&lt;Integer&gt; counts = wordCount.values();\n\n移除键值对：remove(Object key): 移除指定键的键值对。\nwordCount.remove(\"apple\");\n\n获取 Map 的大小：size(): 获取 Map 中键值对的数量。\nint size = wordCount.size();\n\n遍历键值对：使用 entrySet() 方法获取包含键值对的 Set，然后通过增强for循环或迭代器遍历。\nfor (Map.Entry&lt;String, Integer&gt; entry : wordCount.entrySet()) {\n    String word = entry.getKey();\n    int count = entry.getValue();\n    System.out.println(word + \": \" + count);\n}\n\nHashMap哈希表，听着吓人，但是嘞，没什么复杂的。\n想象一本神奇的记事本，你可以通过写上人名（键）找到对应的秘密信息（值）。这就是 HashMap 的特性，每个键都对应一个值，就像一个名字对应一个秘密。\n1. 使用 HashMap让我们通过一些例子来看看如何使用 HashMap：\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建一个 HashMap 来存储人的名字和对应的年龄\n        Map&lt;String, Integer&gt; ageMap = new HashMap&lt;&gt;();\n\n        // 添加键值对\n        ageMap.put(\"Alice\", 15);\n        ageMap.put(\"Bob\", 16);\n        ageMap.put(\"Charlie\", 14);\n\n        // 获取值\n        int aliceAge = ageMap.get(\"Alice\");\n        System.out.println(\"Alice 的年龄是：\" + aliceAge);\n\n        // 判断键是否存在\n        boolean hasBob = ageMap.containsKey(\"Bob\");\n        System.out.println(\"是否包含 Bob？\" + hasBob);\n\n        // 获取所有键的集合\n        System.out.println(\"所有人的名字：\" + ageMap.keySet());\n\n        // 获取所有值的集合\n        System.out.println(\"所有人的年龄：\" + ageMap.values());\n\n        // 移除键值对\n        ageMap.remove(\"Charlie\");\n\n        // 获取 HashMap 的大小\n        System.out.println(\"HashMap 大小：\" + ageMap.size());\n\n        // 遍历键值对\n        for (Map.Entry&lt;String, Integer&gt; entry : ageMap.entrySet()) {\n            String name = entry.getKey();\n            int age = entry.getValue();\n            System.out.println(name + \" 的年龄是：\" + age);\n        }\n    }\n}\n\n3. HashMap 的特性\n键值对存储： HashMap 存储的是键值对，每个键对应一个值。\n快速查找： 你可以通过键快速找到对应的值。\n\n4. 用途HashMap 常常用于需要快速查找和存储键值对的场景，比如存储用户名和密码、单词的词频等。\n好！爷弄完了，休息！\n","slug":"Java-Learning-Week10-11","date":"2023-11-30T08:33:11.000Z","categories_index":"","tags_index":"笔记,Java初学","author_index":"General_K1ng"},{"id":"97b03ceace2b3c315b6a7d6611736a00","title":"MySQL Review-1","content":"其实我在想要不要写一个数据库的复习，毕竟最近临近期末，各种考试又到来，数据库好像还是相对来说比较重要的一个技术，那就顺便来讲讲吧，主要以学校为主，以MySQL作为我们的讲解内容。\n数据库介绍什么是数据库？先从这个问题开始，顾名思义，数据库（Database）就是按照数据结构来存储，组织和管理数据的仓库。\n可以类比我们的图书馆，里面有很多的书架，每个书架上面放着不同的书，每本书又都有自己的书名，作者，页码等等的信息。\n在数据库中，书架就就相当于表，每本书就是表当中的一行数据，而书的名字，作者这些信息就相当于表当中的列。这样，当你想要寻找信息的时候，就可以做到快速的在数据库当中查找，而不用每个书架都找一遍。\n数据库的好处就在于可以方便的存储，查找和管理大量的信息。\n而我们今天所要谈到的数据库属于数据库当中的关系型数据库（Relational Database），还有另外一种称为非关系型数据库，这种我们以后再谈。\n那么什么是关系型数据库呢？\n关系型数据库关系型数据库是一种特定类型的数据库，它的结构就像是一个由表格组成的巨大Excel电子表格。这些表格中的每一行都代表数据库中的一个记录，而每一列则代表这个记录的不同属性或信息。\n比方说，我们可以有一个表格存储学生信息，表格的列可以包括学生的姓名、年龄、性别等信息，每一行则是一个具体的学生记录。\n关系型数据库之所以叫“关系型”，是因为不同表格之间可以建立关系。比如，我们可以有一个表格存储学生的成绩，这个表格中可能有学生的ID（在学生信息表格中也有的），成绩等信息。通过学生的ID，我们就可以在两个表格之间建立关系，将学生的信息和成绩联系起来。\n这种结构的好处在于它能够更好地组织和管理大量的数据。而且，如果需要更新或者修改数据，只需要在相应的表格中进行，而不需要修改整个数据库。\n关系型数据库的特点\n表结构： 数据以表格的形式组织，每个表格包含多个列，每列定义了特定的数据类型。表格中的每一行表示一个记录，也就是实际的数据项。\n关系： 表格之间可以建立关系。这种关系使得不同表格中的数据可以相互关联，从而提供更丰富、更全面的信息。关系通常通过主键和外键来建立。\nACID 属性： 关系型数据库遵循ACID（原子性、一致性、隔离性、持久性）属性，确保在数据库发生故障或者其他问题时，数据保持一致性和完整性。\n事务管理： 关系型数据库支持事务处理，这意味着可以将一系列数据库操作作为一个原子单元执行。如果其中任何一个操作失败，整个事务会被回滚，以保持数据库的一致性。\n数据完整性： 数据库提供了丰富的约束条件，如主键、唯一键、外键等，以确保数据的完整性。这意味着数据库中的数据符合预定义的规则，不会出现不一致或错误的数据。\nSQL 查询语言： 关系型数据库使用结构化查询语言（SQL）进行数据查询和操作。SQL提供了一种简单而强大的语法，用于从数据库中检索、更新和删除数据，以及定义和管理数据库结构。\n可伸缩性： 关系型数据库系统通常具有良好的可伸缩性，可以处理大量数据和复杂的查询。这使得它们适用于大型企业和复杂的数据管理需求。\n备份与恢复： 关系型数据库提供了备份和恢复机制，确保在系统故障或其他灾难性事件发生时，可以迅速恢复数据。\n\n数据库管理系统（Database Management System）这里我们又要引出另外一个很相关的概念，就是数据库管理系统，什么是数据库管理系统？它跟数据库有什么关系？\n数据库（Database）和数据库管理系统（Database Management System，简称DBMS）是两个密切相关但又不同的概念。\n\n数据库（Database）： 数据库是一个组织数据的集合，它可以包含各种各样的信息，并按照一定的结构存储。数据库的目的是为了方便数据的存储、检索、更新和管理。数据库中的数据以表格的形式组织，每个表格包含多个列，每列定义了特定的数据类型，而每一行则代表一个记录。\n数据库管理系统（DBMS）： 数据库管理系统是一个软件，它提供了对数据库进行管理和操作的工具和接口。DBMS充当了数据库和应用程序之间的桥梁，负责处理数据库的创建、维护、查询、更新和删除等操作。DBMS负责管理数据库的物理和逻辑结构，实施安全性控制，确保数据的一致性和完整性，以及提供对数据库的并发访问控制。\n\n简而言之，数据库是一个存储数据的仓库，而数据库管理系统是负责管理这个仓库的系统。DBMS通过提供一组功能和接口，使得用户和应用程序能够方便地与数据库交互，而不必关心底层数据库的细节。数据库管理系统还负责处理并发访问、故障恢复、安全性等方面的任务，以确保数据库的可靠性和效率。\n举例来说，关系型数据库（如MySQL、Oracle、SQL Server）是一种数据库类型，而针对这种数据库类型的管理系统（MySQL Server、Oracle Database Server、SQL Server）则是具体的数据库管理系统。不同类型的数据库可能需要不同类型的DBMS来进行管理。\n懂吧，我们所学的MySQL本质上是一种数据库管理系统，并且是关系型数据库管理系统（Relational Database Management System，简称RDBMS）。\nRDBMS当中的术语在学习MySQL也就是关系型数据库之前，我们需要了解一些必须的术语，这些也适用于其他RDBMS。\n\n数据库（Database）： 就像一个超级大文件夹，可以存储很多很多的数据。\n表（Table）： 就像一张电子表格，有很多行和列，每一行代表一条记录，每一列代表一种信息。\n记录（Record）： 表格中的一行，包含了某个人、物或事件的所有相关信息。\n字段（Field）： 表格中的一列，表示一种特定类型的信息，比如姓名、年龄或者成绩。\n主键（Primary Key）： 就像是一个独一无二的ID，确保每一条记录都有一个唯一的标识符。\n外键（Foreign Key）： 是一个特殊的字段，连接不同表格的关系，就像是表格之间的桥梁。\n查询（Query）： 就像是在数据库中提出的问题，要求获取符合条件的信息。\nSQL（Structured Query Language）： 是一种用于和数据库交流的语言，就像是和数据库对话的方式。\n插入（Insert）： 就是往表格里新增一条记录，就像是在表格中填写新的一行。\n更新（Update）： 就是修改表格中已有记录的信息，就像是更正之前填写的错误。\n删除（Delete）： 就是把表格中的某一行记录移除，就像是把一行数据擦掉。\n事务（Transaction）： 就像是进行一系列的操作，要么全部成功，要么全部失败，确保数据的一致性。\n备份（Backup）： 就像是数据库的复制，以防止意外情况导致数据丢失。\n恢复（Recovery）： 就是在出现问题后，通过备份重新获得数据库的正确状态。\n冗余（Redundancy）： 想象一下你有一份电话簿，如果同一个人的信息在不同的页面出现了很多次，这就是冗余。数据库设计时要尽量避免冗余，以免浪费空间和增加混乱。而且虽然冗余降低了性能，但提高了数据的安全性。。\n复合键（Composite Key）： 如果一个表格中的主键不止一个字段，而是由两个或更多字段组成，那么这就是复合键。就像用姓名和生日一起来唯一标识一个人，而不仅仅是一个属性。\n索引（Index）： 想象一本书的目录，索引就是数据库的目录，可以让我们更快地找到需要的信息。它是一种优化方法，提高数据检索的速度。\n参照完整性（Referential Integrity）： 假设你有两个表格，一个存储学生信息，另一个存储课程信息。参照完整性就是确保如果在课程表中有学生的信息，那么这个学生在学生表中一定存在。这样可以防止出现“无根的”数据，确保数据的关联性。\n\nMySQL介绍自己百度吧，这个没啥要讲的，而且安装我也就不说了，这个安装都不会装我的建议是当初为什么要学这个专业？\nMySQL有一下特点：\n\n开源性（Open Source）： MySQL 是一个开源的关系型数据库管理系统，这意味着任何人都可以免费使用它，并且可以查看和修改其源代码。这使得它成为许多开发者和企业的首选。\n跨平台性（Cross-Platform）： MySQL 可以在多个操作系统上运行，包括 Windows、Linux、macOS 等，这使得它非常灵活，能够满足不同用户的需求。\n高性能（High Performance）： MySQL 被设计成高性能的数据库系统，能够处理大规模的数据并支持高并发访问。它采用了一些优化技术，例如索引、缓存等，以提高查询和操作的速度。\n支持多种存储引擎（Storage Engines）： MySQL 支持多种存储引擎，例如 InnoDB、MyISAM 等。每个存储引擎都有其特定的优势和用途，可以根据应用的需求选择合适的引擎。\n事务支持（Transaction Support）： MySQL 支持事务处理，确保一系列操作要么全部成功，要么全部失败，以保持数据的一致性。\n安全性（Security）： MySQL 提供了一系列的安全性功能，包括用户认证、访问控制、加密传输等，以确保数据库的数据安全。\n备份和恢复（Backup and Recovery）： MySQL 允许用户进行定期的数据库备份，以防止数据丢失。在发生故障时，可以通过备份进行恢复。\n简单的 SQL 语法（Simple SQL Syntax）： MySQL 使用标准的 SQL 语法，这使得学习和使用 MySQL 相对简单，特别适合初学者。\n社区支持（Community Support）： 由于 MySQL 是开源的，有一个庞大的用户社区，用户可以在社区中分享经验、解决问题，获得及时的支持和帮助。\n\n","slug":"MySQL-Review-1","date":"2023-11-18T10:15:15.000Z","categories_index":"","tags_index":"笔记,MySQL复习","author_index":"General_K1ng"},{"id":"7d4841571c0abc342271e318c113c7dc","title":"Java_Learning(Week9)","content":"说实话，我看了一下这一周的课件，我感觉学校还是没有讲东西，OOP的思想我上一周应该说的比较详细了，这周需要讲的一些东西应该就是多态和异常了，说实话这会儿讲异常没有什么必要我感觉，其他更重要的东西都还没讲，什么链表，哈希表这些的。\n哦对了，顺便补一下之前拉下的一点东西，讲一下方法重载（Overload）和方法重写（Override）之间的区别。\n重载与重写上周我们简单提了一下方法的重写是什么，现在先来看一下重载吧。\n重载 （Overload）简单来说，Overload指的是在同一个类中创建多个具有相同名称但参数不同的方法。这样，可以根据不同的情况来调用这些方法。\nclass Calculator {\n    public int add(int a, int b) {\n        return a + b;\n    }\n\n    public double add(double a, double b) {\n        return a + b;\n    }\n}\n\n在这个例子中，Calculator类有两个add方法，一个用于整数相加，另一个用于浮点数相加。这两个方法都有相同的名称，但是它们的参数不同。这就是方法的重载。\n就是方法名称相同，但是参数类型或者数量不同，就是方法的重载。\n方法重载的规则\n方法名称必须相同： 重载的方法必须具有相同的名称。\n参数列表必须不同： 重载的方法必须有不同的参数列表（个数或类型不同）。\n返回类型可以相同也可以不同： 返回类型可以相同也可以不同，但仅仅通过返回类型的不同是无法进行重载的。\n可以有不同的访问修饰符： 重载的方法可以有不同的访问修饰符（比如public、private、protected等）。\n可以抛出不同的异常： 重载的方法可以抛出不同的异常，可以声明新的或者更广的异常\n\n重写（Override）上周已经讲过了，假设你有一个父类（比如动物类），而你想创建一个子类（比如狗类）。父类中可能有一个makeSound方法，用于发出声音。现在，如果你想在子类中改变狗的声音，你可以使用override。\n在Java中，override就是在子类中创建一个与父类相同的方法，但是子类中的这个方法有着自己的实现。这样，当你调用这个方法时，程序会自动调用子类的方法，而不是父类的方法。\nclass Animal {\n    public void makeSound() {\n        System.out.println(\"一般的动物发出的声音\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"汪汪汪！\");\n    }\n}\n\n重写的优势在于让子类能够根据自身需求来实现（重写）父类的方法，使得代码更加灵活和符合具体情境。但是，需要遵循一些规则，如保持方法签名不变，不能改变返回类型，也不能抛出比父类方法更宽泛的异常。\n方法重写的规则\n参数列表必须完全相同： 重写的方法的参数列表必须与被重写方法的参数列表完全相同。\n返回类型可以不同，但必须是父类返回值的派生类： 返回类型可以是被重写方法返回类型的子类，但是在Java 5及更早版本中，返回类型必须相同；而在Java 7及更高版本中，返回类型可以不同。\n访问权限不能比被重写方法更低： 重写的方法的访问权限不能比被重写方法的访问权限更低，例如，如果被重写方法在父类中声明为public，那么在子类中的重写方法不能声明为protected。\n只能重写父类的成员方法： 只能重写父类的成员方法，不能重写父类的静态方法或实例方法。\n不能重写final方法： 被声明为final的方法不能被子类重写。\n不能重写static方法，但能够被再次声明： 被声明为static的方法不能被子类重写，但可以在子类中被再次声明。\n同包中的子类可以重写父类所有方法，除了private和final的方法： 如果子类和父类在同一个包中，子类可以重写父类所有非private和非final的方法。\n不同包中的子类只能重写父类的声明为public和protected的非final方法： 如果子类和父类不在同一个包中，子类只能够重写父类的声明为public和protected的非final方法。\n重写的方法能够抛出任何非强制异常，但不能抛出新的强制异常，或者比被重写方法声明的更广泛的强制异常： 在重写时，可以抛出任何非强制异常，但不能抛出新的强制异常，也不能抛出比被重写方法声明的更广泛的强制异常。\n构造方法不能被重写： 构造方法不能被继承，因此也不能被重写。\n如果不能继承一个类，则不能重写该类的方法： 如果无法继承一个类，那么就无法重写该类的方法。\n\n很多，给爷背就完了。\n重写与重载之间的区别\n\n\n区别点\n重载方法\n重写方法\n\n\n\n参数列表\n必须修改\n一定不能修改\n\n\n返回类型\n可以修改\n一定不能修改\n\n\n异常\n可以修改\n可以减少或删除，一定不能抛出新的或者更广的异常\n\n\n访问\n可以修改\n一定不能做更严格的限制（可以降低限制）\n\n\n多态其实上面的重载和重写都是Java多态的体现，那么问题就来了，什么是多态？\n什么是多态多态是面向对象编程中的一个重要概念，它允许不同类的对象对同一个消息（方法调用）作出不同的响应。简而言之，同一种行为在不同的对象上可以表现出不同的形态。\n说白了，就是同一个行为具有多个不同的表现形式。\n比如动物会叫，狗叫就是汪汪，猫叫就是喵喵，就是这。\n多态的优点这都是教科书上面该写的东西，哪里都一样\n\n灵活性（Flexibility）： 多态使得代码更加灵活，能够处理多种不同类型的对象，而无需修改现有的代码。这使得系统更容易适应变化和扩展。\n可扩展性（Extensibility）： 添加新的类或子类变得更加容易。如果你需要引入新的类型，只需确保它符合已有的接口或继承关系，而不需要修改现有的代码。\n简化代码（Simplified Code）： 多态性使得代码更简洁，因为相同的操作可以适用于不同类型的对象。这减少了代码的复杂性和冗余性。\n提高代码的可读性和可维护性（Readability and Maintainability）： 通过使用多态，代码更容易理解和维护，因为它强调了对象的行为而不是具体的实现细节。\n降低耦合度（Reduced Coupling）： 多态性降低了对象之间的耦合度。通过将操作定义在接口或抽象类上，而不是具体的实现类上，减少了类之间的直接依赖，使得系统更容易修改和维护。\n可替代性（Substitutability）： 多态性使得可以在不影响代码其他部分的情况下替换对象。这对于在系统中替换部分功能或优化代码是非常有用的。\n\n多态存在的必要条件\n继承（Inheritance）： 多态性通常基于继承关系。子类必须继承自父类或实现相同的接口或抽象类，以便能够通过父类或接口类型的引用来引用子类对象。\n方法重写（Method Overriding）： 多态性要求子类必须重写（Override）父类中的方法。重写的方法在子类中具有相同的签名（方法名、参数列表和返回类型），这样在运行时可以根据对象的实际类型调用正确的方法。\n父类引用指向子类对象（Upcasting）： 多态性的关键是使用父类类型的引用指向子类对象。这种类型的引用可以容纳任何符合父类或接口的子类对象。\n运行时绑定（Runtime Binding）： 多态性的实现是在运行时确定的，而不是在编译时。这意味着系统在程序运行时能够动态地选择调用哪个方法，而不是在编译时就确定。\n一致的接口（Consistent Interface）： 多态性要求所有相关类都要有一致的接口，即它们应该共享相同的方法签名。这可以通过接口、抽象类或共同的基类来实现。\n\n第五点看不懂没关系，目前还没学到。\n为了理解这么几个必要条件，我们来举个例子。\n假设有一个动物（Animal）类和两个子类：狗（Dog）和猫（Cat）。这里使用了继承、方法重写、父类引用指向子类对象和运行时绑定这些多态性的概念。\n// 动物类\nclass Animal {\n    public void makeSound() {\n        System.out.println(\"一般的动物发出声音\");\n    }\n}\n\n这个是动物类，当中有一个makeSound()方法\n// 狗类\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"汪汪汪！\");\n    }\n\n    public void fetch() {\n        System.out.println(\"狗在接飞盘！\");\n    }\n}\n\n这是狗类，继承了动物类，然后重写了其中的叫声方法，并且拥有自己的一个成员方法是接飞盘。\n// 猫类\nclass Cat extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"喵喵喵！\");\n    }\n\n    public void scratch() {\n        System.out.println(\"猫在抓抓！\");\n    }\n}\n\n这个是猫类，同样的，重写了叫声方法，滨区给拥有自己的成员方法\n那么我们写一个测试类\n// 父类引用指向子类对象\nAnimal myDog = new Dog();\nAnimal myCat = new Cat();\n\n注意这里，开头我们使用的是Animal声明的，然后new的后面是狗对象，这就是父类引用指向子类对象。\n// 调用各自的makeSound方法，运行时绑定确定调用哪个方法\nmyDog.makeSound();  // 运行时调用Dog类的makeSound方法\nmyCat.makeSound();  // 运行时调用Cat类的makeSound方法\n\n然后我们分别调用他们各自的makeSound()，你会发现输出的是他们各自的叫声，因为我们重写了他们各自的方法。\n汪汪汪！\n喵喵喵！\n\n然后我们继续尝试调用他们各自的子类中的成员方法\n// 父类引用无法调用子类特有的方法（fetch和scratch）\n myDog.fetch();  // 编译错误，Animal类没有fetch方法\n myCat.scratch(); // 编译错误，Animal类没有scratch方法\n\n你会发现编译器已经开始报错了\nCannot resolve method 'fetch' in 'Animal'\nCannot resolve method 'scratch' in 'Animal'\n\n因为父类当中并没有这几个方法，那么此时我们可以对我们的对象进行强转。\n// 如果我们将引用类型更改为子类类型，就可以调用子类特有的方法\nDog myRealDog = (Dog) myDog;\nmyRealDog.fetch();  // 正常调用fetch方法\n\nCat myRealCat = (Cat) myCat;\nmyRealCat.scratch(); // 正常调用scratch方法\n\n此时就可以继续调用子类当中的方法了\n狗在接飞盘！\n猫在抓抓！\n\n好！\n这部分就到这里先结束。\n异常这会儿讲这个感觉还是有点怪哈，因为我们目前好像没遇到什么异常，最有名的异常应该就是数组越界异常，其他的其实还蛮少的。\n那就先讲什么是异常。\n什么是异常？异常就是程序当中的错误，就是报错，就是IDE给你标成红色的时候，那就是出异常了。\n但是并不是所有的错误都是异常，甚至有的错误是可以避免的\n比方说零不能作除数，数组访问不能越界，这些都是一些常见的异常。\n异常的分类在Java中，异常分为两个主要类别：已检查异常（Checked Exceptions）和未检查异常（Unchecked Exceptions）。这两者都是 Throwable 类的子类。\n\n已检查异常（Checked Exceptions）：\n已检查异常是在编译时被检测到的异常，程序必须显式地处理它们，否则编译器会报错。\n通常是由外部因素引起的，例如输入/输出错误、文件不存在等。\n例如：IOException、ClassNotFoundException。\n\n\n未检查异常（Unchecked Exceptions）：\n也称为运行时异常（Runtime Exceptions），是在运行时由Java虚拟机检测到的异常。\n不要求显式地捕获或声明，程序员可以选择处理或者不处理这些异常。\n通常是由程序错误引起的，例如空指针引用、数组越界等。\n例如：NullPointerException、ArrayIndexOutOfBoundsException。\n\n\n\n除了这两个主要的分类之外，还有一种特殊情况：\n那就是错误（Errors）：\n\n错误通常指示了一些严重的问题，程序可能无法恢复。与异常不同，错误通常由于系统级问题（例如内存耗尽）引起。\n例如：OutOfMemoryError、StackOverflowError。\n\n一般出现了Errors，那就一般不归我们管了，我们也管不了这些。\n这些异常和错误类的层次结构如下：\nThrowable\n|-- Error\n|-- Exception\n    |-- Checked Exceptions\n    |-- Unchecked Exceptions (Runtime Exceptions)\n\n这个层次结构也就是Java当中的类的继承结构。\nException 类的层次\n这就是这些类的继承结构，里面是类中含有的一些方法，不用管，看不懂没关系。\n在Java中，异常类都是派生自 Throwable 类。Throwable 类是所有可以作为异常抛出的类和错误的根类。异常类的层次结构主要分为两大类：Error 和 Exception，而 Exception 又分为已检查异常（Checked Exceptions）和未检查异常（Unchecked Exceptions）。\n\nThrowable 类：\nThrowable 是 Java 异常体系的根类。它有两个主要的子类：Error 和 Exception。\n任何可以作为异常抛出的类都是 Throwable 的子类。\n\n\nError 类：\nError 类用于表示严重的系统问题，通常无法通过程序来恢复。程序一般不会捕获 Error 类的实例。\n一些常见的 Error 类包括 OutOfMemoryError、StackOverflowError 等。\n\n\nException 类：\nException 类是所有异常类的父类，它表示程序运行过程中可能遇到的问题。\nException 类又分为已检查异常和未检查异常。\n\n\n已检查异常（Checked Exceptions）：\n已检查异常是在编译时被检测到的异常，程序必须显式地处理它们，否则编译器会报错。\n一些常见的已检查异常包括 IOException、ClassNotFoundException 等。\n\n\n未检查异常（Unchecked Exceptions，Runtime Exceptions）：\n未检查异常是在运行时由 Java 虚拟机检测到的异常，不要求显式地捕获或声明，程序员可以选择处理或者不处理这些异常。\n一些常见的未检查异常包括 NullPointerException、ArrayIndexOutOfBoundsException 等。\n\n\n\n捕获异常那么讲了什么是异常，那我们怎么去处理这个异常呢？\n想象一下你正在读一本书，突然有人拿走了这本书。你可以选择哭泣和放弃，或者你可以找到一本相似的书继续阅读。在编程中，当程序遇到问题时，我们可以选择放弃并让程序崩溃，或者我们可以处理这个问题，使程序继续执行。\n在Java中，我们使用try和catch来处理异常。这就像在代码中放置一个安全网，当有问题时，我们可以抓住它并执行一些特殊的代码，而不是让程序崩溃。\n以下是一个简单的例子，假设我们想要读取一个文件中的内容：\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\npublic class ReadFileExample {\n    public static void main(String[] args) {\n        try {\n            readFile();\n        } catch (FileNotFoundException e) {\n            System.out.println(\"文件找不到啦！请检查文件是否存在。\");\n        }\n    }\n\n    public static void readFile() throws FileNotFoundException {\n        File file = new File(\"example.txt\");\n        Scanner scanner = new Scanner(file);\n        // 这里是读取文件内容的代码\n        System.out.println(\"成功读取文件！\");\n    }\n}\n\n这里面涉及了Java当中的I/O，看不懂无所谓，只是举个例子，里面还有throws这个关键字，下面会讲到，这里先看。在这个例子中，我们尝试调用readFile方法，这个方法有可能抛出FileNotFoundException异常。我们用try和catch来捕获这个异常。如果文件不存在，我们就会进入catch块，并输出一条消息告诉用户文件找不到。\n此外，我们还可以多重捕获异常，怎么说呢，就是在一个try块后面跟随多个catch块的情况。这样做的目的是为不同类型的异常提供不同的处理逻辑。在Java中，catch块按照它们出现的顺序进行匹配，只有第一个匹配的catch块会执行。\n举个例子：\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\npublic class MultiCatchExample {\n    public static void main(String[] args) {\n        try {\n            readFile();\n        } catch (FileNotFoundException e) {\n            System.out.println(\"文件找不到啦！请检查文件是否存在。\");\n        } catch (NullPointerException e) {\n            System.out.println(\"空指针异常！请检查代码中的空引用。\");\n        } catch (Exception e) {\n            System.out.println(\"发生了其他异常：\" + e.getMessage());\n        }\n    }\n\n    public static void readFile() throws FileNotFoundException {\n        File file = null; // 故意设置为null，模拟空指针异常\n        Scanner scanner = new Scanner(file);\n        // 这里是读取文件内容的代码\n        System.out.println(\"成功读取文件！\");\n    }\n}\n\n在这个例子中，readFile方法有可能抛出两种异常：FileNotFoundException和NullPointerException。\n在main方法中的try块后面有两个catch块，第一个捕获FileNotFoundException，第二个捕获NullPointerException。\n如果发生了FileNotFoundException，第一个catch块会执行，如果发生了NullPointerException，则第二个catch块会执行。\n请注意，catch块的顺序很重要。如果把第二个catch块放在第一个之前，那么即使发生了NullPointerException，也会被第一个catch块捕获，因为Exception是NullPointerException的父类。\n有点像if条件语句，但是不太像。\nfinally关键字想象一下你正在玩积木，突然有人叫你去吃饭。无论你是否玩得高兴，你都应该把积木收拾好，对吧？finally 就像是你要完成的最后一步，无论怎样，都会执行的一段代码。\n在编程中，finally 关键字用于确保一段代码（通常是清理代码）无论发生什么都会被执行。\npublic class FinallyExample {\n\n    public static void main(String[] args) {\n        try {\n            divide(10, 0);\n        } catch (ArithmeticException e) {\n            System.out.println(\"除数不能为零！\");\n        } finally {\n            System.out.println(\"这里的代码总是会执行，无论有没有异常发生。\");\n        }\n    }\n\n    public static void divide(int num1, int num2) {\n        if (num2 == 0) {\n            throw new ArithmeticException(\"除数不能为零！\");\n        } else {\n            int result = num1 / num2;\n            System.out.println(\"结果是：\" + result);\n        }\n    }\n}\n\n\n在这个例子中，我们有一个 divide 方法，它可能会抛出 ArithmeticException 异常，因为我们不能将一个数除以零。在 main 方法中，我们使用 try-catch 块来捕获这个异常，然后使用 finally 关键字来确保无论是否发生异常，都会执行 finally 块内的代码。\n所以，finally 就是那个一定会执行的“清理代码”块，确保在程序执行的最后阶段，无论是否有异常，都能完成一些必要的操作。\nthrows/throw 关键字那么这就是第二种处理异常的方式，在Java中，throw 关键字用于在代码中抛出异常，而 throws 关键字用于在方法声明中指定可能会抛出的异常类型。\nthrows 关键字：想象一下你在一个游戏中扔飞盘。有时候飞盘可能会飞得太高，而你不想被砸到头。所以，你在扔飞盘之前说：“我可能会扔得很高，小心头顶！”这就是 throws 的作用。\n在编程中，throws 关键字用于告诉其他人（或其他代码）：“嘿，我这里可能会有异常发生，你需要注意一下！”。具体来说，在方法的声明中使用 throws，你在方法名后面列出可能抛出的异常类型。\n继续上面的例子：\npublic class ThrowsExample {\n\n    public static void main(String[] args) {\n        try {\n            doSomething();\n        } catch (FileNotFoundException e) {\n            System.out.println(\"文件找不到啦！请检查文件是否存在。\");\n        }\n    }\n\n    public static void doSomething() throws FileNotFoundException {\n        // 在这里做一些可能抛出 FileNotFoundException 的操作\n        throw new FileNotFoundException(\"这是一个模拟的文件未找到异常\");\n    }\n}\n\n在这个例子中，doSomething 方法可能会抛出 FileNotFoundException 异常，所以我们在方法声明中使用了 throws FileNotFoundException。\nthrow 关键字：现在，想象一下你在捡到了一个石头，然后你发现其实是一个屎蛋，然后你突然想把它扔给别人。这就是 throw 关键字的作用。\n在编程中，throw 关键字用于手动抛出异常。有时候，我们在代码中发现了一些问题，而不是等到程序崩溃，我们可以使用 throw 主动地抛出一个异常。\npublic class ThrowExample {\n\n    public static void main(String[] args) {\n        try {\n            checkAge(12);\n        } catch (IllegalArgumentException e) {\n            System.out.println(\"年龄不合法：\" + e.getMessage());\n        }\n    }\n\n    public static void checkAge(int age) {\n        if (age &lt; 18) {\n            throw new IllegalArgumentException(\"年龄必须大于等于18岁\");\n        } else {\n            System.out.println(\"年龄合法，可以继续操作\");\n        }\n    }\n}\n\n在这个例子中，checkAge 方法检查年龄是否合法，如果年龄小于18岁，就会使用 throw 抛出一个 IllegalArgumentException 异常。\n一些注意事项\n注意下面事项：\n\ncatch 不能独立于 try 存在。\n在 try/catch 后面添加 finally 块并非强制性要求的。\ntry 代码后不能既没 catch 块也没 finally块。\ntry, catch, finally 块之间不能添加任何代码。\n\n声明自定义异常那么，上面讲了这么多，这些异常其实都是Java给我们提供好的异常，但是现实开发中遇到的异常可多了去了，Java的异常不可能覆盖我们可能遇到的异常，这时候自定义异常就显得非常重要了。\n假设我们正在设计一个游戏，玩家的年龄不能小于 18 岁。如果小于 18 岁，我们就会抛出一个自定义的异常，告诉玩家不能玩这个游戏。\n我们可以通过创建一个继承自 Exception 的新类来声明自定义异常\n// 自定义异常类\nclass AgeTooYoungException extends Exception {\n    public AgeTooYoungException(String message) {\n        super(message);\n    }\n}\n\n然后我们再在测试类当中试一下：\npublic class CustomExceptionExample {\n\n    public static void main(String[] args) {\n        try {\n            checkPlayerAge(15); // 尝试使用 checkPlayerAge 方法\n        } catch (AgeTooYoungException e) {\n            System.out.println(\"抱歉，你太小了，不能玩这个游戏！\");\n            System.out.println(\"异常信息：\" + e.getMessage());\n        }\n    }\n\n    public static void checkPlayerAge(int age) throws AgeTooYoungException {\n        if (age &lt; 18) {\n            throw new AgeTooYoungException(\"年龄太小，不能玩游戏！\");\n        } else {\n            System.out.println(\"年龄合适，可以开始游戏！\");\n        }\n    }\n}\n\n其实还有更炫的，你可以把我们经常用的System.out.println中的out换成err，这样控制台打印的文字就是红色警告，非常的炫酷。\n抱歉，你太小了，不能玩这个游戏！\n异常信息：年龄太小，不能玩游戏！\n\n在这个例子中，AgeTooYoungException 是我们自定义的异常类，它继承自 Exception。我们使用 checkPlayerAge 方法来检查玩家的年龄，如果年龄小于 5 岁，就抛出 AgeTooYoungException 异常。\n在 main 方法中，我们使用 try-catch 块捕获这个异常，并输出一条友好的消息告诉玩家不能玩这个游戏。\n好了，所以也就讲了这么些东西。\n","slug":"Java-Learning-Week9","date":"2023-11-14T07:22:21.000Z","categories_index":"","tags_index":"笔记,Java初学","author_index":"General_K1ng"},{"id":"0d78bd92a017cfff181854aa3e1bedda","title":"Java_Learning(Week8)","content":"因为最近太忙了，所以直接空了三周的笔记没有写，后面看有没有时间再补上吧，这节课，我们直接开始Java编程当中的重头戏——面向对象。\n面向对象（OOP）什么是对象？首先先明确一点，对象不是找男女朋友！\n这里我想先引用我很喜欢的一本Java书（Java编程思想，非常好的工具书）当中面向对象导论中的第一句话\n\n\n\n\n\n\n\n\n\n“我们之所以将自然界分解，组织成各种概念，并按其含义分类，主要是因为我们是整个口语交流社会共同遵守的协议的参与者，这个协定以语言的形式固定下来……除非赞成这个协定中规定的有关语言信息的组织和分类，否则我们根本无法交谈”\n——Benjamin Lee Whorf (1897 - 1941)\n所以对于我们的Java这门完全面向对象的语言来说，对象就是对物体的抽象。\n当然不仅限于Java，任何支持面向对象变成的语言，我们都可以这么说，因为面向对象和语言的关系并不大，而是一种编程思想。\n现在我们来想想什么是对物体的抽象。\n比方说有一个人，我们就可以想想它具有什么特点？\n\n性别，是男是女？\n年龄，几岁了？\n姓名，我们怎么称呼？\n性格\n。。。\n\n这样我们就逐步将一个人进行了分解，这个分解的过程就是抽象的过程。\n而这些东西体现在代码上面就是我们要写的一个类（class），什么是类呢？\n什么是类？什么是类？也就是我们经常见到的class，我们每次写代码的时候都会见到它，我们必须把代码写到类里面，每次新建也都是要新建一个类，方法也必须用类包裹。\n所以，有具体想过什么是类吗？\n我用最简单的话来说，类就是一个模板，我们通过这个模板来构建对象。\n什么意思？我第一次接触也是晕头转向。但是没关系，\n比方说用上面那个例子，我们构建一个类，名字叫做Person\n那么，我们就把一个人进行抽象然后写出一个类来\npublic class Person {\n    String name;   //姓名\n    int age;\t   //年龄\n    String gender; //性别\n}\n\n对吧，这就我们最基本的对这个人进行的抽象，他肯定有名字，年龄，性别。\n接下来最终要的一句话就是，对象要根据类来创建，类是构造对象的模板。\n比如说我是一个人，我叫张三，年龄是20，性别是男。对吧，那么此处的张三就是一个“人”对象，或者说是一个Person对象，但是Person这是一个类，他是张三的模板。\n或者再来一个人，姓名是李四，年龄30，性别是女，那么我们说李四也是一个Person对象。\n所以就能发现李四和张三都是人，都是Person，我们可以通过Person这个类去构造很多对象。\n类和对象的关系\n类定义了对象的结构，包括两个大部分，属性和方法，这两点我们后面说。\n对象是类的实例，对象们具体化了类的定义，拥有类的属性和方法。\n一个类可以创建多个对象，每个对象之间是相互独立的，它们之间可以有不同的属性值。\n\n所以记住我的这句话\n类是对象的模板，对象是类的实例\n目前为止，只需要知道这些应该就够了。\n为什么需要面向对象？要搞懂这个问题我们就要讲到面向对象的对立面——面向过程。\n面向过程，顾名思义，就是面向过程，hhhhhh\n好吧，为了方便理解，我来举一个例子，比方说我们现在有一个飞机，让你用程序去控制它，我们怎么控制？\n面向过程在面向过程编程中，我们会将问题分解为一系列的步骤，然后按照顺序执行这些步骤来模拟飞机的飞行。\n\n初始化飞机参数（速度、高度、燃料等）。\n启动引擎。\n增加速度。\n升高飞机。\n检查燃料。\n如果燃料足够，继续飞行；否则，降落。\n定期检查飞机的状态。\n如果到达目的地，降落。\n\n对吧，如果是面向过程，我们就必须依次写这些过程的函数，并且必须提前将运行的时序排列好。\n而且飞机还有很多的全局变量，我们该怎么保存和管理和操作呢？比方说高度？速度？燃料量？甚至这只能描述一架飞机，如果飞机更多该怎么办呢？\n所以发现了吗？\n这种方式将问题分解为一系列步骤，每个步骤都是一个函数或方法。这些函数按照顺序执行，但问题是，我们需要管理大量的全局变量来存储飞机的状态，以及一系列函数来操作这些状态。\n面向对象那么面向对象，我们就先对飞机这个物体进行抽象，先来构建一个飞机的类，也就是飞机的class\nclass Airplane {\n    double speed;\n    double altitude;\n    double fuel;\n\n  \tvoid startEngine() {\n        // 启动引擎\n        // 实现细节\n    }\n\n    void increaseSpeed() {\n        // 增加速度\n        // 实现细节\n    }\n\n    void ascend() {\n        // 升高飞机\n        // 实现细节\n    }\n\n    void checkFuel() {\n        // 检查燃料\n        // 实现细节\n    }\n\n    // 更多方法...\n\n    void land() {\n        // 降落\n        // 实现细节\n    }\n}\n\n这里我们就简单构造了一个飞机的类，这个类里面拥有一架飞机应该有的一些参数和一些方法，或者说属性和方法，这里方法指的就是飞机可以实现的一些方法，而且每个飞机都具有自己的状态，而且不需要全局变量。不同的飞机（对象）之间是可以独立操作的，当我需要操作的时候，只需要用不同的对象调用需要的方法就行了，而且代码更加的清晰和可维护。\n当然，面向过程肯定也不是就像这么说的这么差劲了，面向过程也有节省资源，对于小规模问题更有操作性这些优点。\n总之，OOP 适用于模拟复杂的现实世界问题，提供了更有组织的代码结构和更好的可维护性。但有时，对于简单问题或需要高度的资源效率的情况，面向过程编程可能更合适。在实际编程中，我们可以根据问题的复杂性和要求来选择适当的编程方法。有时候，甚至可以将两种方法结合使用，以获得最佳的结果。\n封装思想继续上面飞机的例子，我们可以这个类里面有各种各样飞机所具备的方法，我们在需要用的时候只需要构建一个飞机对象，然后让这个对象去调用它的方法就行了，我们就不需要关心这个方法内部是怎么实现的，这让方法更具有复用性和方便别人来使用，并且更加的安全，我们不能随便去改变方法的内部，我们只能调用这个方法。\n或者再举个例子，我们目前学习的很多方法其实都是封装后的结果，比方说Math这个工具类当中的很多方法max()，pow()还记的吗？我们只需要去调用，或者传递参数，他就会返回一个结果，我们并不知道Java底层是怎么实现的，只知道我们把数字放进去，他就给我最大值，我把数字传进去，他就吐给我幂。\n所以和面向对象类似的，\n封装 是一种面向对象编程的概念，它就像是一个飞机机舱一样，将飞机内部的复杂部分隐藏在外部看不见的地方。\n比方说飞机内部的电子设备和引擎。在飞机上，有许多复杂的机械和电子零部件，例如引擎、仪表板、油箱等等。这些零部件对于让飞机正常运行非常重要，但乘客通常不需要知道所有这些细节。所以，这些零部件被封装在飞机的外部之下，乘客只能看到和使用一些简单的控制界面，如按钮、手柄和屏幕。\n封装的好处就是：\n\n隐藏细节：乘客不需要知道飞机内部的复杂性，他们只需要使用控制界面来与飞机交互。\n安全性：乘客不能随意触摸飞机内部的复杂零部件，这可以防止不必要的干预和错误操作。\n简化使用：乘客只需使用简单的控制界面，而不需要了解复杂的内部工作。\n\n所以，封装就像是将复杂性和细节隐藏在一个容器中，对外部提供了一个简化的界面，这使得事物更容易理解和使用，就像乘客使用飞机的控制面板一样。\n懂了吗？如懂，无所谓，看不懂多看几遍，或者问我。\n构造方法构造方法是 Java 编程中的一个特殊方法，它有点像一个蓝图，用来创建对象。\n你可以把构造方法比作一家工厂，用来制造不同种类的产品，而这些产品就是对象。\n为什么需要构造方法？你想想嘛，刚刚的类是什么？是对象的模板，对吧，就相当于一个蓝图，但是只有蓝图那不行的呀，我们怎么才能把这个对象构造出来呢？\n——构造方法。\n构造方法的特点\n构造方法与类名相同。\n构造方法没有返回类型（不像其他方法有int、String等返回类型）。\n构造方法可以有参数，这些参数可以帮助你设置对象的特性。\n\n我们来举一个例子，就用刚刚的飞机的例子，我们给它加上构造方法。\npublic class Airplane {\n    double speed;    // 飞机的速度\n    double altitude; // 飞机的高度\n    double fuel;     // 飞机的燃料量\n\n    // 空参构造方法，用于创建一个默认的飞机对象\n    public Airplane() {\n        this.speed = 0;\n        this.altitude = 0;\n        this.fuel = 0;\n    }\n\n    // 有参构造方法，用于创建具有特定特性的飞机对象\n    public Airplane(double speed, double altitude, double fuel) {\n        this.speed = speed;\n        this.altitude = altitude;\n        this.fuel = fuel;\n    }\n}\n\n这里要讲的东西比较多哈，先从我们有点陌生的这个this关键字开始，这里的this是什么？有什么用呢？\nthis关键字我一句话解决，为了区分类的属性变量和方法的参数。\n有时候需要在类的方法中区分类的实例变量（类的属性）和方法的参数，以避免混淆。这时候就可以使用关键字 this。\n想象一栋大楼（类），每层楼都有一扇窗户（属性），然后有人站在某一层的窗前，这个人需要知道他所在的楼层有多少窗户，也就是说，他需要引用自己所在楼层的窗户。这时，this 就像是告诉他，”这里是你所在的楼层的窗户”。\n具体来说，this 是一个特殊的关键字，它在类的方法中表示当前对象的引用。通过 this，你可以访问或修改当前对象的属性。这有助于区分属性和方法参数，因为它告诉编译器你想要访问的是对象的属性而不是方法参数。\n懂了吧，就是你在构建类之前的那些飞机的速度，高度，燃油量都是要靠this来区分滴\n空参构造好，我们再来看一下空参构造的那个方法：\n// 空参构造方法，用于创建一个默认的飞机对象\npublic Airplane() {\n    this.speed = 0;\n    this.altitude = 0;\n    this.fuel = 0;\n}\n\n这就是我们那个模板的空参构造，那么在对象构建的时候所对应的那个语句长什么样子呢？\n// 使用空参构造方法创建默认飞机\n      Airplane defaultPlane = new Airplane();\n\n熟悉吧，就长这个样子，可以看见我们在new Airplane()这个括号当中并没有传递任何参数，然后在构造方法当中我们也可以发现，我们为每个属性值都配上了默认的值，都是0。\n有参构造// 有参构造方法，用于创建具有特定特性的飞机对象\npublic Airplane(double speed, double altitude, double fuel) {\n    this.speed = speed;\n    this.altitude = altitude;\n    this.fuel = fuel;\n}\n\n这就是有参构造，可以发现这个构造方法需要接收三个参数才可以，然后就把这些参数传递给了用this声明的属性参数，那么我们在构造这个对象的时候就要这么写：\n// 使用有参构造方法创建具有特定特性的飞机\nAirplane customPlane = new Airplane(600, 10000, 500);\n\n可以发现我们向里面分别传递了三个参数，依次对应速度，高度，燃油量这几个属性，传递进去以后就创建了两个对象。\n然后我们就可以看一下这两个方法构造出来的飞机对象有什么区别吧。\npublic static void main(String[] args) {\n\n        // 使用空参构造方法创建默认飞机\n        Airplane defaultPlane = new Airplane();\n\n        // 使用有参构造方法创建具有特定特性的飞机\n        Airplane customPlane = new Airplane(600, 10000, 500);\n\n        System.out.println(\"默认飞机的速度：\" + defaultPlane.speed);\n        System.out.println(\"默认飞机的高度：\" + defaultPlane.altitude);\n        System.out.println(\"默认飞机的燃料量：\" + defaultPlane.fuel);\n\n        System.out.println(\"定制飞机的速度：\" + customPlane.speed);\n        System.out.println(\"定制飞机的高度：\" + customPlane.altitude);\n        System.out.println(\"定制飞机的燃料量：\" + customPlane.fuel);\n    }\n\n输出如下：\n默认飞机的速度：0.0\n默认飞机的高度：0.0\n默认飞机的燃料量：0.0\n定制飞机的速度：600.0\n定制飞机的高度：10000.0\n定制飞机的燃料量：500.0\n\n空参构造出来的默认飞机各个属性都是0，没问题，因为我们什么都没传递。\n定制出来的飞机因为我们传递了参数，所以各个属性也就赋上了相应的值。\n继承这里涉及继承只是简单的讲一下，因为后面需要讲到重写toString()方法，这里需要涉及一些继承的知识，只是简单过一下，方便我待会来讲重写方法。\n什么是继承？当谈到继承时，我们可以将其想象成一种关系，就像家庭关系一样，其中有父母和子女。\n在Java中，继承是一种对象之间的关系，其中一个类可以继承另一个类的属性和行为。这就像家庭中的关系，父母把一些特征和技能传给他们的孩子。\n举个例子，假设有一个基本的类叫做”人”，这个类有一些属性和方法，比如”姓名”和”走路”。现在，我们想创建一个新的类，叫做”学生”，”学生”就可以继承”人”的属性和方法。\n这意味着”学生”类可以拥有”姓名”这个属性，而且可以调用”走路”这个方法，就像”人”类一样。但同时，”学生”类还可以有自己的属性和方法，比如”学习”和”考试”。\n通过继承，我们不需要重复定义”姓名”和”走路”，因为这些已经在”人”类中定义了。而”学生”类可以专注于定义与学生相关的属性和方法，如”学习”和”考试”。\n所以，继承允许我们建立一个类之间的父子关系，使子类可以继承父类的特性，同时可以添加自己的特性。这就像家庭中的关系一样，孩子可以继承父母的一些特点，但也可以拥有自己独特的特点。\n谁是爹？所以继承你就会发现了一个问题——谁是爹？或者谁是谁的爷爷？\n爸爸的爸爸是爷爷，爷爷的爷爷是？\n是祖先，祖先的祖先是？\n发现了吗，就是终归要有个头对吧？\n所以，在Java当中就给我提供了一个类名叫做Object，我们把它称为超类，任何一个类都继承了这个类当中的方法和属性。\n你可以把Object类想象成所有类的祖先，就像一个超级爷爷或超级奶奶。这个超级爷爷或超级奶奶传下来了一些共同的特征和方法，而每个类都可以继承这些特征和方法。\n例如，Object类有一些通用的方法，比如toString()，equals()和hashCode()。这些方法可以在任何类中使用，因为每个类都继承了Object的这些方法。\n如果你的类没有显式地继承自其他类，它就会默认继承自Object类。所以，Object类就像是所有类的最远祖先，它为所有类提供了一些共同的功能。\n当你创建自己的类时，你可以使用Object类中的这些通用方法，或者你可以重写这些方法以适应你的类的需求。就像在家庭中，你可以继承一些祖先的特点，但也可以发展出自己的特点。\n方法的重写好了终于到这里了，什么是方法的重写？\n简单来说，是在面向对象当中的一种编程概念，它允许你在子类中重新创建一个已经存在的方法，但是你可以改变这个方法的行为，以适应子类的需求。\n让我们通过一个简单的例子来解释方法的重写。假设你有一个基类叫做”动物”，它有一个方法叫做”发出声音”，这个方法可以让动物发出不同的声音。然后，你有两个子类，一个是”狗”，另一个是”猫”。\n现在，你想让狗和猫分别发出它们自己的声音，而不是使用基类”动物”的声音（比如说“Siu~~”）。这就是方法的重写的地方。\n在子类中，你可以创建一个与基类中”发出声音”方法名称相同的方法，但是你可以给它不同的声音。例如，在”狗”类中，你可以创建一个”发出声音”的方法，让它返回”汪汪”声音。而在”猫”类中，你可以创建一个相同名称的方法，让它返回”喵喵”声音。\n这样，当你调用狗的”发出声音”方法时，它会返回”汪汪”声音，而调用猫的”发出声音”方法时，它会返回”喵喵”声音。\n这就是方法的重写的基本概念。你可以在子类中重新定义一个方法，以覆盖基类中的相同方法，以适应子类的需求。\n重写toString()方法好了前面铺垫了这么多，就是为了让我可以来讲为什么我们需要在类当中重写toString()方法。\n我们先把那个飞机的例子拿下来：\npublic class Airplane {\n    double speed;    // 飞机的速度\n    double altitude; // 飞机的高度\n    double fuel;     // 飞机的燃料量\n\n    // 空参构造方法，用于创建一个默认的飞机对象\n    public Airplane() {\n        this.speed = 0;\n        this.altitude = 0;\n        this.fuel = 0;\n    }\n\n    // 有参构造方法，用于创建具有特定特性的飞机对象\n    public Airplane(double speed, double altitude, double fuel) {\n        this.speed = speed;\n        this.altitude = altitude;\n        this.fuel = fuel;\n    }\n}\n\n这是那个飞机类\n// 使用空参构造方法创建默认飞机\nAirplane defaultPlane = new Airplane();\n\n// 使用有参构造方法创建具有特定特性的飞机\nAirplane customPlane = new Airplane(600, 10000, 500);\n\nSystem.out.println(defaultPlane);\nSystem.out.println(customPlane);\n\n刚刚我们是通过对象去调用其中的属性值来获得里面的这些速度啊，高度之类的，有些太麻烦了，我想直接通过打印这个对象的方式来实现打印我对应对象的属性值，可不可以？\n然后我们就会发现控制台输出了这一行：\nCPT111.week8.Airplane@7ef20235\nCPT111.week8.Airplane@27d6c5e0\n\n你就会发现输出了这么个奇怪的东西，这是什么呢？\nCPT111.week8.说明是这个类目前在这个包下面，也就是这个文件夹下面，这个类的名字叫Airplane，然后@后面跟上了一堆乱码。\n那这个其实就是这个对象的地址值，当我们有new关键字的时候，就会生成一个新的对象，然后就会产生相应的地址值，当然这一部分的数据结构我是不想讲的，要讲的话放到后面吧，这里讲不完。\n总之，这个地址值指向了内存当中的一个部分，那个部分就存放着我们的地址值，在我们执行输出语句的时候，其实JVM底层就调用我们这个对象的toString()方法，然后进行输出。\n那你就会问，我们的方法当中明明没有这个方法啊。\n那到这里应该就很显而易见了，在我们的超类Object当中就有一个toString()方法，我们可以去Java的源码当中看一下：\n/**\n * Returns a string representation of the object.\n * @apiNote\n * In general, the\n * {@code toString} method returns a string that\n * \"textually represents\" this object. The result should\n * be a concise but informative representation that is easy for a\n * person to read.\n * It is recommended that all subclasses override this method.\n * The string output is not necessarily stable over time or across\n * JVM invocations.\n * @implSpec\n * The {@code toString} method for class {@code Object}\n * returns a string consisting of the name of the class of which the\n * object is an instance, the at-sign character `{@code @}', and\n * the unsigned hexadecimal representation of the hash code of the\n * object. In other words, this method returns a string equal to the\n * value of:\n * &lt;blockquote&gt;\n * &lt;pre&gt;\n * getClass().getName() + '@' + Integer.toHexString(hashCode())\n * &lt;/pre&gt;&lt;/blockquote&gt;\n *\n * @return  a string representation of the object.\n */\npublic String toString() {\n    return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n}\n\n看见啦，上面那一大段读不懂无所谓，我们就看下面这个返回值，不要管这些方法内部是怎么实现的，我们都学了封装了，就直接看\n先通过getClass()获得这个类，然后再调用getName() 方法获得这个类名字（对应Airplane），然后字符串拼接上一个@，最后通过Integer包装类下的一个方法将这个类的hashCode转换成了十六进制的整数，然后再返回。\n对吧，这就是封装的魅力，可能不懂，但是懂了。。。\n所以我们就知道了，那一串乱码不是随便打出来的，而是超父类Object中的一个方法，而我们的飞机类在底层默认继承了这个类罢了。\n所以我们就要重写这个方法，怎么重写，其实就跟新建方法一样，不过方法名要相同\npublic String toString() {\n    return \"Airplane{speed = \" + speed + \", altitude = \" + altitude + \", fuel = \" + fuel + \"}\";\n}\n\n这就重写完成了，其实按照规范我们还要加上一个@Override注解，告诉别的开发者和JVM这个方法是重写的，但是其实没有必要，底层JVM也都知道这个方法是重写的，在调用的时候，会调用这个重写后覆盖的方法。\n当然，我的习惯还是加上。\n@Override\npublic String toString() {\n    return \"Airplane{speed = \" + speed + \", altitude = \" + altitude + \", fuel = \" + fuel + \"}\";\n}\n\nOK，现在我们再来看看直接打印这个对象会有什么结果\nAirplane{speed = 0.0, altitude = 0.0, fuel = 0.0}\nAirplane{speed = 600.0, altitude = 10000.0, fuel = 500.0}\n\n结束！！！\n到这里后，应该就可以对着课件把老师上课搞得东西自己研究出来了，我就不对着搞了，太累了。\n最近事情还是蛮多的，不一定会定时更新。\nT T\n","slug":"Java-Learning-Week8","date":"2023-11-06T10:20:06.000Z","categories_index":"","tags_index":"笔记,Java初学","author_index":"General_K1ng"},{"id":"19b17cf70fbf7b80415d6c3b17a3d380","title":"Java_Exercise(Week4)","content":"说实话在我昨天晚上做玩这周的Exercise和CW之后，我对于这周是否要写这个笔记产生了很大的怀疑，难度确实有，但是不大，问题在于，想要把我昨天做题时候的思路讲清楚，呈现明白，是一个非常浪费时间和精力的事。。\n想了想，还是写出来吧。\nExercise #4.1 Copy Even Indices编写一个 Java 方法 int[] copyEven(int[] nums)，将偶数索引处的元素复制到一个新数组中。\n该方法必须返回长度正确的新数组，并在数组中包含这些元素。\nTest cases :\ncopyEven([1, 2, 3]) → [1, 3]\ncopyEven([1, 2, 3, 4]) → [1, 3]\n\n题目解析第一题还是比较简单的，就相当于热身了，我们首先要明白我们要干什么。\n\n编写一个方法，这个方法接收一个数组，然后返回一个新数组\n判断偶数索引，并且将偶数索引的元素放到这个新数组当中\n\n那就先写呗，方法先定义出来\npublic static int[] copyEven(int[] nums){\n    //方法体\n}\n\n然后怎么去想，我们是不是要返回一个新的数组，那么数组这个我们是知道的，它必须指定长度，所以问题就来到了我们新的数组是多长的问题。\n那么，长度是多少呢？\n这里我们可以这样想，原数组的长度我们知道是nums.length对吧，那么我们还知道我们需要返回的是偶数索引处的元素，那么偶数元素有多少个？\n根据之前我们学过的计数器，我们应该可以写出以下代码。\nint count = 0;\nfor (int i = 0; i &lt; nums.length; i += 2) {\n    count++;\n}\n\n这里注意，第三个循环条件不再是i++了，因为我们需要的是偶数索引有多少个，所以我们的循环条件变成了i += 2。\n好了现在我们知道了新数组的长度了，我们就先把这个需要返回的数组创建出来。\nint[] result = new int[count];\n\n接下来我们只需要把偶数索引处的元素填进去就好了，对吧，其实上面的那个循环条件刚好就是获取偶数索引元素的，所以我们再写一个一样的，只不过循环内部改为新数组的赋值即可。\nint index = 0;\nfor (int i = 0; i &lt; nums.length; i += 2) {\n    result[index] = nums[i];\n    index++;\n}\n\n最后返回我们的result数组即可，其实并不是很难。\n完整代码\nClick to see more\n方法\npublic static int[] copyEven(int[] nums) {\n    int count = 0;\n    for (int i = 0; i &lt; nums.length; i += 2) {\n        count++;\n    }\n\n    int[] result = new int[count];\n    int index = 0;\n    for (int i = 0; i &lt; nums.length; i += 2) {\n        result[index] = nums[i];\n        index++;\n    }\n\n    return result;\n}\n\n测试数组\nint[] test1 = {1, 2, 3};\nint[] test2 = {1, 2, 3, 4};\nint[] test3 = {8, 5, 4, 9, 6, 7, 7, 6};\n\n测试结果如下\n[1, 3]\n[1, 3]\n[8, 4, 6, 7]\n\n\n\nExercise #4.2 A Diamond is FORever这题开始就稍微有那么一丢丢需要脑子了。\n编写一个 Java 方法 void diamond(int n)，该方法接收奇数整数参数 n，并打印出类似下面测试用例的 n-by-n 图案，每个组成菱形的元素用星号（*）表示，每个不组成菱形的元素用点（.）表示，每个 * 或 .之间用一个空格隔开。\nTest cases :\ndiamond(5)\n\n. . * . .\n\n. * * * .\n\n* * * * *\n\n. * * * .\n\n. . * . .\n\ndiamond(9)\n\n. . . . * . . . .\n\n. . . * * * . . .\n\n. . * * * * * . .\n\n. * * * * * * * .\n\n* * * * * * * * *\n\n. * * * * * * * .\n\n. . * * * * * . .\n\n. . . * * * . . .\n\n. . . . * . . . .\n\n题目解析这个怎么才能讲的清楚呢。。。\n还是一样，先明确一下我们需要干什么\n\n写一个方法void diamond(int n)返回值为空，接收一个整数，要求可以输出一个菱形图案\n这个接收的整数n必须为奇数\n然后就是图案的创建，我们需要打印出来一个菱形\n\n前两个应该都很简单，我们只需要创建一个方法，然后判断一下传入的是不是奇数，如果是奇数就继续，如果不是奇数就直接结束方法\npublic static void diamond(int n) {\n    if (n % 2 == 0) {\n        System.out.println(\"不是奇数\");\n        return;\n    }\n\n最难的地方就是，我们该如何打印出这个菱形图案呢？\n好我们先一步一步来哈，我想了好久才想明白该怎么讲最好。\n首先，我在这里先介绍一个数学概念——曼哈顿距离\n曼哈顿距离曼哈顿距离（Manhattan distance），也称为城市街区距离或L1距离，是计算两个点在规则网格上的距离的度量方式。它得名于纽约曼哈顿的城市街区规划，其中街道呈直角交叉。\n曼哈顿距离是通过将两个点的横向和纵向距离相加来计算的，而不考虑对角线距离。在二维平面上，曼哈顿距离是两个点在水平和垂直方向上的绝对距离之和。\n假设有两个点和，它们之间的曼哈顿距离可以用以下公式表示：其中，表示的绝对值。\n其实，说白了就是东西加南北的距离就是曼哈顿距离。\n好了，然后我们再看我们需要输出的到底是什么形状，如果没有*的话，其实就是一个n*n的正方形矩阵，而且就算如果有*的话，也能发现其实就是把一个正方形旋转了45°罢了，那么其实我们需要打印的菱形其实就是一个放倒了的正方形。\n毕竟正方形也是特殊的菱形。。。\n那这就简单啦，先说结论，从正方形正中心到边上的各个点的曼哈顿距离和相等，或者说，曼哈顿距离和相等的点的集合是一个正方形，也就是说，我们需要画出来的正方形，或者说是菱形，只需要知道他的曼哈顿距离就好。\n我画个图在这里好了。\n\n鼠标画的比较丑哈，我们需要输出的完整图案就相当于最外面这个橙色的正方形，而星号需要表示的其实就是中间的这个黑色的正方形ABCD，然后我们会发现以O为原点出发，E和F点的曼哈顿距离，也就是和其实是相等的，正方形的几何性质我就不多说了，什么全等啊之类的证明自己喜欢证可以去证一下，但是这里我们也就发现了我们需要输出的这个图形其实就是一个放倒了的正方形，并且他的曼哈顿距离就相当于最外面这个橙色正方形的一半，也就是。\n那么我们回到我们的题目，我们拿到的n其实是什么？\n是橙色正方形的边长，比如如果n=5，那就相当于五个单位长度\n那么我们怎么表示中间的这个菱形呢？\n利用我们刚刚说的曼哈顿距离，我们就能通过双层循环嵌套写出来。\nint mid = n / 2;\nfor (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; n; j++) {\n        if (Math.abs(j - mid) + Math.abs(i - mid) &lt;= mid)\n            System.out.print(\"* \");\n        else\n            System.out.print(\". \");\n    }\n    System.out.println();\n}\n\n我先解释一下这个循环，首先我们在外部定义一个变量mid用来记录我们的曼哈顿距离，因为我们说过了其实就是最外侧大正方形的一半。\n然后通过循环嵌套进行输出一个平面的n*n的矩阵，但是这个矩阵内部我们需要输出一个菱形，这个菱形满足曼哈顿距离和小于等于我们的mid，\n于是就写出来了循环内的if条件，满足条件的我们输出*，反之输出.即可\n完整代码\nClick to see more\n方法\npublic static void diamond(int n) {\n    if (n % 2 == 0) {\n        System.out.println(\"不是奇数\");\n        return;\n    }\n\n    int mid = n / 2;\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            if (Math.abs(j - mid) + Math.abs(i - mid) &lt;= mid)\n                System.out.print(\"* \");\n            else\n                System.out.print(\". \");\n        }\n        System.out.println();\n    }\n}\n\n测试数字\ndiamond(30);\nSystem.out.println(\"====================================================================\");\ndiamond(5);\nSystem.out.println(\"====================================================================\");\ndiamond(9);\n\n测试结果如下\n不是奇数\n====================================================================\n. . * . . \n. * * * . \n* * * * * \n. * * * . \n. . * . . \n====================================================================\n. . . . * . . . . \n. . . * * * . . . \n. . * * * * * . . \n. * * * * * * * . \n* * * * * * * * * \n. * * * * * * * . \n. . * * * * * . . \n. . . * * * . . . \n. . . . * . . . . \n\n\n\nExercise #4.3 Arithmetic Series编写一个 Java 方法 int[] arithSeries(int n)，在输入一个大于等于 0 的整数 n 时，输出一个具有 [1, 1, 2, 1, 2, 3, ....., 1, 2, 3, ..., n] 模式的数组。\n注意，数组的长度将是 ，高斯的著名推导恰好是 。\nTest cases :\narithSeries(2) → [1, 1, 2]\narithSeries(3) → [1, 1, 2, 1, 2, 3]\narithSeries(4) → [1, 1, 2, 1, 2, 3, 1, 2, 3, 4]\n\n题目解析这道题感觉还是在考察循环的嵌套，虽然感觉并不是很难，并且题目里面也说出来了数组的长度应该为多长，所以说大的难点几乎是没有。\n那么还是一样，明确一下目的。\n\n写一个方法，接收一个整数n，然后返回一个数组\n这个数组是一个有规律的数列 [1, 1, 2, 1, 2, 3, ....., 1, 2, 3, ..., n] \n长度已知是 \n\n那那，基本上就完了吧，外层循环用来控制有多少组，内部循环就是保证1；1,2；1,2,3。。。这样子就好。\npublic static int[] arithSeries(int n) {\n    int length = (n(n + 1))/2;\n    int[] series = new int[length];\n    int index = 0;\n\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= i; j++) {\n            series[index] = j;\n            index++;\n        }\n    }\n\n    return series;\n}\n\n然后就好了。。。感觉没什么需要特别强调的，就是注意一下索引别越界就好。\n好像以上就是完整代码hhh。\nExercise #4.4 Band Matrix编写一个 Java 方法 void bandMatrix(int n, int width)，该方法接收两个整数参数 n 和 width，并打印出类似下面的 n-by-n 图案，其中每个元素与主对角线的距离严格大于宽度的为 0，不大于宽度的为星号(*)，每个 0 或 * 之间有两个空格。请注意，这里的距离是指你向上/下/左/右移动到任何对角线条目的最少次数\n\nTest cases :\nbandMatrix(4, 0)\n\n*  0  0  0\n\n0  *  0  0\n\n0  0  *  0\n\n0  0  0  *\n\nbandMatrix(4, 1)\n\n*  *  0  0\n\n*  *  *  0\n\n0  *  *  *\n\n0  0  *  *\n\nbandMatrix(4, 2)\n\n*  *  *  0\n\n*  *  *  *\n\n*  *  *  *\n\n0  *  *  *\n\n题目解析还是一样的先明确我们需要什么\n\n写一个方法，接收两个整数，一个是n，另一个是width，分别代表维度和宽度，没有返回值\n要求输出一个矩阵\n矩阵内部要满足一定要求：每个元素与主对角线的距离严格大于宽度的为 0，不大于宽度的为星号(*)，每个 0 或 * 之间有两个空格。\n\n这个跟上面那个菱形的还挺像的，但是我个人感觉是没上面的难。\n首先我们先构建方法\n  public static void bandMatrix(int n, int width) {\n//方法体\n  }\n\n然后一想，还是矩阵，那就一样的循环嵌套\npublic static void bandMatrix(int n, int width) {\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            //该怎么输出？\n        }\n        System.out.println();\n    }\n}\n\n然后就是里面该怎么进行输出呢？\n题目已经说的很清楚了，用if写出来呗\nif (Math.abs(i - j) &lt;= width) {\n    System.out.print(\"*  \");\n} else {\n    System.out.print(\"0  \");\n}\n\n对吧。。。\n然后就，就，就结束了。\n完整代码\nClick to see more\n方法\npublic static void bandMatrix(int n, int width) {\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            if (Math.abs(i - j) &lt;= width) {\n                System.out.print(\"*  \");\n            } else {\n                System.out.print(\"0  \");\n            }\n        }\n        System.out.println();\n    }\n}\n\n测试\nbandMatrix(4,0);\nSystem.out.println(\"========================================\");\nbandMatrix(4,1);\nSystem.out.println(\"========================================\");\nbandMatrix(5,3);\n\n测试结果\n*  0  0  0  \n0  *  0  0  \n0  0  *  0  \n0  0  0  *  \n========================================\n*  *  0  0  \n*  *  *  0  \n0  *  *  *  \n0  0  *  *  \n========================================\n*  *  *  *  0  \n*  *  *  *  *  \n*  *  *  *  *  \n*  *  *  *  *  \n0  *  *  *  *  \n\n\n\nExercise #4.5 Even Odd Swap编写一个 Java 方法 int[] evenOddSwap(int[]nums)，给定一个包含相同数目偶数和奇数的整数数组、按出现的顺序交换所有偶数和奇数对。\nTest cases :\nevenOddSwap([1, 2, 3, 4]) → [2, 1, 4, 3]\n\nevenOddSwap([100, 25]) → [25, 100]\n\nevenOddSwap([]) → []\n\nevenOddSwap([11, 55, 100, 200, 300, 7]) → [100, 200, 11, 55, 7, 300]\n\n题目解析噔噔咚。。。\n这个应该是今天最难的一道了，昨天开始做到这里让我有点惊讶怎么会这么难。。。\n但是最后还是做出来了，也有可能是我的思路过于抽象？\n算了，我就按照我的思路来讲解了。\n但是我现在好累，我实在不想再敲代码了。\n简单来说，分别找到奇数元素和偶数元素所对应的索引，然后交换，然后返回新数组。\n说着比较简单，但是基本上提示到位了。\n下周再把这个更出来。\n","slug":"Java-Exercise-Week4","date":"2023-10-14T04:44:30.000Z","categories_index":"","tags_index":"笔记,Java初学","author_index":"General_K1ng"},{"id":"a8c731e8e4e06940923b6b0b44a5b222","title":"Java_Learning(Week4)","content":"有一说一，咱们学校这个课的进度是真的赶啊，这才几节课就到数组和方法了。。\n循环补充什么？原来上周没有讲什么是For循环，那我上周笔记不就多写了！\n怪不得感觉上周写的这么多。。。算了无所谓了，那么这里就来补充一些上周没有提到的东西。\nbreak关键字break 关键字用于立即退出当前所在的循环，不再执行剩余的循环迭代。它的主要用途是在满足某个条件时，提前跳出循环，以节省计算资源或处理特殊情况。\n使用情况：\n\nbreak 可以用在 for、while、和 do-while 循环中，以及 switch 语句中。\n\nfor (int i = 1; i &lt;= 10; i++) {\n    if (i == 5) {\n        break; // 当 i 等于 5 时，退出循环\n    }\n    System.out.println(i);\n}\n\n上述代码就只会输出数字 1 到 4，然后退出循环，也就是说，循环后面的就不会执行了，就会直接跳出。\ncontinue 关键字continue 关键字用于跳过当前迭代，并继续下一次迭代。它的主要用途是在某些条件下，跳过某些循环迭代，但不会退出整个循环。\n简单来说就是跳过一次循环，继续执行下面的循环操作。\n使用情况：\n\ncontinue 可以用在 for、while、和 do-while 循环中。\n\nfor (int i = 1; i &lt;= 5; i++) {\n    if (i == 3) {\n        continue; // 当 i 等于 3 时，跳过当前迭代\n    }\n    System.out.println(i);\n}\n\n上述代码将输出数字 1、2、4、5，跳过了数字 3。\n循环结构嵌套跟if一样，循环结构也是可以进行嵌套操作的，无论是while循环还是For循环，或者两者杂交，都可以。\n基本的嵌套循环结构最常见的循环嵌套是使用for循环。下面是一个简单的例子，演示如何使用嵌套的for循环打印一个矩形图案：\nfor (int i = 1; i &lt;= 5; i++) {\n    for (int j = 1; j &lt;= 5; j++) {\n        System.out.print(\"* \");\n    }\n    System.out.println(); // 换行\n}\n\n上述代码将输出一个5x5的矩形，如下所示：\n* * * * * \n* * * * * \n* * * * * \n* * * * * \n* * * * * \n\n外部循环和内部循环在嵌套循环中，通常有外部循环和内部循环的概念。外部循环的迭代次数决定了内部循环的执行次数。下面的示例展示了如何使用嵌套循环生成一个数字三角形：\nfor (int i = 1; i &lt;= 5; i++) {\n    for (int j = 1; j &lt;= i; j++) {\n        System.out.print(j + \" \");\n    }\n    System.out.println();\n}\n\n这将输出以下数字三角形：\n1 \n1 2 \n1 2 3 \n1 2 3 4 \n1 2 3 4 5 \n\n控制循环的流程然后我们就可以通过学到的continue和break关键字进行循环的控制了。break用于退出循环，而continue用于跳过当前迭代并进入下一次迭代。\nfor (int i = 1; i &lt;= 5; i++) {\n    if (i == 3) {\n        continue; // 跳过i等于3的迭代\n    }\n    for (int j = 1; j &lt;= 5; j++) {\n        if (j == 4) {\n            break; // 退出内部循环\n        }\n        System.out.print(i + \"-\" + j + \" \");\n    }\n    System.out.println();\n}\n\n这就会输出：\n1-1 1-2 1-3 \n2-1 2-2 2-3 \n4-1 4-2 4-3 \n5-1 5-2 5-3 \n\n可以发现，当进行最外层循环并没有进行第三次操作，直接进行到了第四次，然后内部循环在第四次直接跳出了，所以也并没有打印3之后的数字。\n那么这里就要强调一个重点：\nbreak和continue的注意事项\nbreak 只会退出包含它的最内层循环。\n在多层嵌套循环中，可以使用带标签的 break 来退出指定的外部循环。\n\nouterloop:\nfor (int i = 1; i &lt;= 3; i++) {\n    for (int j = 1; j &lt;= 3; j++) {\n        if (i * j == 6) {\n            break outerloop; // 通过标签退出外部循环\n        }\n        System.out.println(i * j);\n    }\n}\n\n\ncontinue 只会影响包含它的当前循环迭代。\n在多层嵌套循环中，continue 只会影响包含它的最内层循环迭代。\n\nfor (int i = 1; i &lt;= 3; i++) {\n    for (int j = 1; j &lt;= 3; j++) {\n        if (i * j == 6) {\n            continue; // 跳过当前内部循环的迭代\n        }\n        System.out.println(i * j);\n    }\n}\n\n循环嵌套的性能说实话，这周看了很多人写的代码，让我大为震惊，最高的循环嵌套次数打到了五六个for循环嵌套，这个不是说不行，但是循环嵌套的性能是很低的，专业一点是时间复杂度是很高的，嵌套循环的时间复杂度是外部循环次数与内部循环次数的乘积。如果循环次数很大，可能会导致程序运行时间过长。\n所以，尽量避免不必要的嵌套循环。\n记住！\n一定要记住！\n用循环实现多个骰子呃，其实没啥写的，既然课件上面有，我就写在这里吧，我不会去用Math.random()那个方法，过于复杂，这里我是直接创建Random的对象来进行随机数的产生。\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class DiceSimulator {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);// 创建键盘录入的对象\n\n        System.out.print(\"请输入要投掷的骰子次数: \");// 一个提示\n        int numberOfThrows = scanner.nextInt();// 接收需要投掷的次数，或者说有几个骰子\n\n        if (numberOfThrows &lt;= 0) {// 无效判断，如果是负数或者0就直接停止\n            System.out.println(\"无效的次数。请输入一个正整数。\");\n            return;\n        }\n\n        Random random = new Random(); // 创建Random随机类\n\n        System.out.println(\"投掷结果：\");\n        for (int i = 0; i &lt; numberOfThrows; i++) {// 用for循环实现，只要小于录入的投掷次数就持续循环\n            int diceRoll = random.nextInt(6) + 1; // 生成1到6之间的随机整数\n            System.out.println(\"第 \" + (i + 1) + \" 次投掷: \" + diceRoll);// 输出\n        }\n\n    }\n}\n\n应该没有什么需要我特别强调的吧，看注释应该都能看懂。\n数组说实话讲到这里还是有些惊讶的，没想到这周能涉及到数组，按理说应该会在循环和条件语句那里停一段时间做做算法题什么的，没想到进度这么猛。所以我感觉其实对大部分人来说还是比较困难的。\n但是那能怎么办呢？\n什么是数组？数组是一种数据结构，用于存储相同类型的数据元素的集合。在Java中，数组具有以下特点：\n\n固定大小： 数组一旦创建，其大小通常是固定的，不能随意增加或减少。这意味着在创建数组时必须指定其大小，而且不可更改。\n索引访问： 数组中的每个元素都有一个唯一的索引值，用于访问该元素。索引通常从0开始，然后递增，最大索引是数组大小减1。\n相同数据类型： 数组中的所有元素必须是相同的数据类型，例如整数、浮点数、字符等。\n\n记住，数组是一种数据结构，在内存当中用来存储数据，不仅是Java当中，C和C++当中，包括任何语言当中你都能见到数组身影。\n为什么需要数组？记住，数组是一种数据结构，跟什么语言关系不大，我还是要强调一遍。\n为什么需要数组呢，主要有以下几点：\n\n组织数据： 数组提供了一种有效的方式来组织和存储大量数据，这些数据可以按顺序排列，并且可以通过索引快速访问。\n快速访问： 数组的查询是非常快速的，如果我们知道索引的话，数组就允许我们以常量时间（O(1)）访问特定索引位置的元素，这使得查找、插入和删除操作变得非常高效。\n内存管理： 数组在内存中是连续存储的，这有助于减少内存访问的开销，提高数据的读取速度。\n数学和算法： 数组是许多数学和算法问题的基本工具，例如排序、搜索、统计等。\n\n总之，数组是一种数据结构，为我们实际应用有很大帮助，有以下几点作用：\n\n存储和访问数据： 数组用于存储和访问大量数据元素，如存储学生成绩、员工信息、图像像素等。\n迭代和遍历： 数组使得我们可以轻松遍历数据集，执行各种操作，例如打印所有元素、查找特定元素等。\n排序和搜索： 数组是许多排序和搜索算法的基础，如冒泡排序、快速排序、二分查找等。\n实现其他数据结构： 数组可以用来实现其他高级数据结构，如栈、队列、堆等。\n多维数组： 数组可以扩展到多维，用于表示矩阵、图形等复杂结构。\n缓存性能优化： 数组的连续内存存储有助于提高缓存性能，因为数据通常在内存中连续存储，这降低了内存访问的开销。\n\n如何声明和创建数组？我们必须要先声明数组这个变量，才能在程序中使用数组。下面是声明数组变量的语法：\ndataType[] arrayName;   // 首选的方法\n \n或者\n \ndataType arrayName[];  // 效果相同，但不是首选方法\n\n注意: 建议使用 **dataType[] arrayName** 的声明风格声明数组变量。 dataType arrayName[] 风格是来自 C/C++ 语言 ，在Java中采用是为了让 C/C++ 程序员能够快速理解Java语言。\n然后接下来就是创建数组：\narrayName = new dataType[arraySize]; // 创建数组\n\n其中：\n\ndataType 表示数组中元素的数据类型，例如 int、double、String 等。\narrayName 是数组的名称，可以根据需要自定义。\narraySize 是数组的大小，即数组可以容纳的元素数量。\n\n上面的语法语句做了两件事：\n\n使用 dataType[arraySize] 创建了一个数组。\n把新创建的数组的引用赋值给变量 arrayName。\n\n当然我们一般直接写一行，直接声明并创建：\ndataType[] arrayName = new dataType[arraySize]\n\n当然我们如果知道数组当中需要存放的值，我们也可以这样直接创建：\ndataType[] arrayName = {value0, value1, ..., valuek};\n\n然后最值得注意的就是数组的索引是从0开始的，为什么呢？我也不知道，记住就行。\n那么最后举个例子创建一个用来存放整型的长度为5的数组吧！\nint[] numbers; // 声明一个整数数组\nnumbers = new int[5]; // 创建一个包含5个整数的数组\n\n数组的赋值与访问可以使用数组的索引来访问和赋值数组元素。数组的索引从0开始，最大索引是数组长度减1。\nint[] numbers = new int[5];\nnumbers[0] = 10; // 给第一个元素赋值\nnumbers[1] = 20; // 给第二个元素赋值\n\nint firstNumber = numbers[0]; // 访问第一个元素\nint secondNumber = numbers[1]; // 访问第二个元素\n\n那么如果我们此时去访问除了第一和第二索引之外的值会发生什么？\n因为我们没有赋值，所以其实返回的就是默认值，默认值是0。\npublic class ArrayExample {\n    public static void main(String[] args) {\n        int[] numbers = new int[5];\n        \n        // 给索引0和1赋值\n        numbers[0] = 10;\n        numbers[1] = 20;\n        \n        // 访问索引2、3、4\n        System.out.println(numbers[2]); // 默认为0\n        System.out.println(numbers[3]); // 默认为0\n        System.out.println(numbers[4]); // 默认为0\n    }\n}\n\n输出如下：\n0\n0\n0\n\n那如果我访问比这个数组长度更长的索引会发生什么嘞？\npublic class ArrayExample {\n    public static void main(String[] args) {\n        int[] numbers = new int[5];\n        \n        // 给索引0和1赋值\n        numbers[0] = 10;\n        numbers[1] = 20;\n        \n        // 访问索引5\n        System.out.println(numbers[5]);\n    }\n}\n\n会直接报出异常，哈哈：\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length 5\n\tat CPT111.DiceSimulator.main(DiceSimulator.java:15)\n\n这里我们触发了数组索引越界异常（ArrayIndexOutOfBoundsException），这是一个运行时异常。在Java中，数组的索引从0开始，所以有效索引范围是0到数组长度减1。\n不清楚运行时异常是什么没关系，你就把它当做你的程序的一个bug就好，在非常后面我们就会了解到。\n数组的遍历遍历数组是访问数组中所有元素的常见操作。可以使用循环来遍历数组，常见的是for循环遍历，当然在之后也有增强for，现阶段我们就先用普通for进行遍历吧。\nint[] numbers = {1, 2, 3, 4, 5};\nfor (int i = 0; i &lt; numbers.length; i++) {\n    System.out.println(numbers[i]);\n}\n\n这里我们遍历并且输出了这个数组当中存储的数据，然后就是讲一下这个number.length这个就是会返回对应数组的长度。\n求数组当中的平均值，最大值，最小值，总和那就按照课件我们继续使用上面那个我们扔骰子的代码，把它继续更改一下，无非就是把每次随机的值存储到一个数组里面进行输出。\n我就直接把代码丢到这里了：\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class DiceSimulator {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        System.out.print(\"请输入要投掷的骰子次数: \");\n        int numberOfThrows = scanner.nextInt();\n\n        if (numberOfThrows &lt;= 0) {\n            System.out.println(\"无效的次数。请输入一个正整数。\");\n            return;\n        }\n\n        Random random = new Random();\n        \n        int[] diceValues = new int[numberOfThrows]; // 创建一个数组来存储每次投掷的值\n\n        System.out.println(\"投掷结果：\");\n\n        for (int i = 0; i &lt; numberOfThrows; i++) {\n            int diceRoll = random.nextInt(6) + 1;\n            diceValues[i] = diceRoll; // 将投掷结果存储到数组中\n            System.out.println(\"第 \" + (i + 1) + \" 次投掷: \" + diceRoll);\n        }\n        \n        int max = diceValues[0]; // 初始化最大值\n        int min = diceValues[0]; // 初始化最小值\n\n        //计算总和\n        int sum = 0;\n        for (int i = 0; i &lt; diceValues.length; i++) {\n            sum += diceValues[i];\n        }\n        \n        // 计算平均值\n        double average = (double) sum / numberOfThrows;\n\n        // 计算最大值\n        for (int i = 0; i &lt; diceValues.length; i++) {\n            if (diceValues[i] &gt; max){\n                max = diceValues[i];\n            }\n        }\n\n        //计算最小值\n        for (int i = 0; i &lt; diceValues.length; i++) {\n            if (diceValues[i] &lt; min){\n                min = diceValues[i];\n            }\n        }\n\n        System.out.println(\"总和: \" + sum);\n        System.out.println(\"最大值: \" + max);\n        System.out.println(\"最小值: \" + min);\n        System.out.println(\"平均值: \" + average);\n    }\n}\n\n本来有更好的写法，但是为了帮助大家理解遍历计算这些值的方法，就先这样写了，这里也要强调一件事情，那就是一个循环只干一件事情。\n比如计算总和，那么这个循环就只计算总和，不要想着一个循环里面我们既计算总和，又把最大值一算，这个习惯很不好，如果各位后续开发一些项目出了bug，想要进行排查的时候你就知道如果你写一个非常臃肿的循环有多么头疼了。\n不要以为一个循环解决了很多事情就觉得自己很聪明，其实hhh。。。\n那么数组就先到这里，后面有补充的我会继续补充，毕竟课件就讲了这些，这还是我补充过的。\n方法这个我是更没想到，我们居然讲到方法了，这可真的有点太快了。。。\n课件的引入我就不想说了，就是让我们看我们的代码，wow，我们的main方法为什么写的这么长，有没有什么办法让他简单易读又不影响正常逻辑呢？\n什么是方法？Java方法是一种编程结构，它们是一组有序的语句，用于执行特定的功能或任务。这些功能可以解决各种问题。\n\n问题解决步骤的组合： 方法实际上是问题解决步骤的组合。它们让你将一个大问题分解为更小、可管理的部分，然后以特定的方式组合这些部分，以实现所需的功能。\n方法存在于类或对象中： 方法通常与类或对象相关联。它们可以被定义在类的内部，以便与类的其他成员（如属性和其他方法）共享数据和行为。此外，一些方法也可以与对象相关联，使其成为对象的行为。\n方法的创建和引用： 在编写Java程序时，你可以创建方法并在程序中使用它们。创建方法意味着定义方法的名称、参数和执行的操作。一旦定义，你可以在程序的其他部分引用这些方法，以便重复使用它们，而不必每次都重新编写相同的代码。\n\n说白了，目的就是为了更加简洁，减少代码量，重复使用。\n刚好这些就是方法的优点。\n方法的命名规则当然，这个上课没说，但是这里我要提一下。\n\n方法名应该有意义： 方法名应该反映方法的功能和目的。使用清晰、有意义的词汇来描述方法的操作，这有助于其他开发人员理解代码的含义。\n采用驼峰命名法（Camel Case）： Java通常使用驼峰命名法来命名方法，这意味着方法名的首字母小写，后续的单词首字母大写，并且不使用下划线或连字符。例如：calculateTotalAmount()。\n遵循Java标识符规则： 方法名必须遵守Java标识符的规则。合法的方法名可以包含字母、数字和下划线，但必须以字母（a-z或A-Z）或下划线（_）开头。不能使用Java的关键字作为方法名。\n使用动词或动词短语： 方法名通常以动词或动词短语开头，以表示方法正在执行的操作。例如，calculateTotal() 或 validateInput()。\n选择恰当的名字长度： 方法名应该足够长以清楚地描述其功能，但不要过于冗长。避免使用过长的方法名，因为这可能会降低代码的可读性。\n根据约定选择命名： Java社区有一些广泛接受的命名约定，例如：\nget 开头的方法通常用于获取对象的属性值，例如 getName()\nset 开头的方法通常用于设置对象的属性值，例如 setName(String name)\nis 开头的方法通常用于布尔属性的getter方法，例如 isActive()\n\n\n命名一致性： 在整个代码库中保持方法命名的一致性非常重要。如果一个方法执行类似的操作，应该使用类似的命名约定。\n避免使用缩写： 尽量避免使用缩写，除非缩写是广泛理解的，不会导致歧义。使用完整的单词可以提高代码的可读性。\n根据领域专业知识选择命名： 如果您的代码与特定领域相关，尽量使用该领域的专业术语来命名方法，以提高代码的可理解性。\n使用Java命名约定： 遵循Java编码规范和约定，这有助于保持代码的一致性，并让其他人更容易理解你的代码。\n\n好！那就继续！\n方法的定义一般来说，定义一个方法，语法如下：\n修饰符 返回类型 方法名(参数列表) throws 异常列表 {\n    // 方法体\n}\n\n\n有点看不懂无所谓，我放一张图（来自菜鸟教程）。\n\n这个异常抛出可以不用管，目前先不写也无所谓，主要以这张图为主。\n\n修饰符（Modifiers）： 修饰符用于控制方法的访问权限和行为。修饰符可以是以下之一：\npublic：方法可以被任何类访问。\nprivate：方法只能被定义它的类访问。\nprotected：方法可以被同一包内的类和继承该类的子类访问。\n没有修饰符（默认情况下）：方法在同一包内可见，但不对其他包可见。\n\n\n返回类型（Return Type）： 返回类型指定了方法执行后返回的数据类型。它可以是任何Java数据类型，包括原始数据类型（如int、double）和引用数据类型（如对象、数组）。如果方法不返回任何值，可以使用关键字 void 表示。\n方法名（Method Name）： 方法名是方法的标识符，用于在程序中引用该方法。方法名必须遵守Java标识符的规则，如字母、数字和下划线的组合，但不能以数字开头。\n参数列表（Parameter List）： 参数列表包含方法接受的输入参数。参数是方法执行所需的数据，它们由括号括起来，多个参数之间用逗号分隔。每个参数由参数类型和参数名称组成。例如：int x, String name。\nthrows 异常列表（Throws Exception List）： 异常列表指定了方法可能会抛出的异常。异常是程序运行时可能出现的问题的表示。在方法声明中使用 throws 关键字，后跟一个异常类的列表，以通知调用方需要处理这些异常。\n方法体（Method Body）： 方法体是包含在花括号 {} 中的代码块，它定义了方法的实际操作。方法体包含了方法的执行逻辑，可以访问方法参数和局部变量，并执行各种操作。\n\n调用方法这。。。目前学的就是静态方法，也就是static修饰的方法，如果要在main方法中调用，那就直接调用好了，调用，然后传递需要的参数即可。\n应该没什么需要特别强调的，待会的例子应该就能看懂了。\n示例我们继续用上面的代码，把生成数组，计算最大值最小值平均值和总和的这些循环，都给他封装成方法。\n生成数组\n// 模拟骰子投掷并返回结果数组\npublic static int[] simulateDiceRolls(int numberOfThrows) {\n    Random random = new Random();\n    int[] diceValues = new int[numberOfThrows];\n\n    for (int i = 0; i &lt; numberOfThrows; i++) {\n        diceValues[i] = random.nextInt(6) + 1;\n    }\n\n    return diceValues;\n}\n\n计算总和\n// 计算数组的总和\npublic static int calculateSum(int[] array) {\n    int sum = 0;\n    for (int value : array) {\n        sum += value;\n    }\n    return sum;\n}\n\n计算最大值\n// 计算数组的最大值\npublic static int calculateMax(int[] array) {\n    int max = array[0];\n    for (int value : array) {\n        if (value &gt; max) {\n            max = value;\n        }\n    }\n    return max;\n}\n\n计算最小值\n// 计算数组的最小值\npublic static int calculateMin(int[] array) {\n    int min = array[0];\n    for (int value : array) {\n        if (value &lt; min) {\n            min = value;\n        }\n    }\n    return min;\n}\n\n计算平均值\n    // 计算数组的平均值\n    public static double calculateAverage(int[] array) {\n        int sum = calculateSum(array);\n        return (double) sum / array.length;\n    }\n}\n\n好了，这就是我们把那些循环啊，生成数组之类的语句全都写成了方法，那么最后再来看看我们的main方法变成什么样子了吧！\npublic static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n\n    System.out.print(\"请输入要投掷的骰子次数: \");\n    int numberOfThrows = scanner.nextInt();\n\n    if (numberOfThrows &lt;= 0) {\n        System.out.println(\"无效的次数。请输入一个正整数。\");\n        return;\n    }\n\n    int[] diceValues = simulateDiceRolls(numberOfThrows);// 调用方法生成数组\n\n    System.out.println(\"投掷结果：\");\n    for (int i = 0; i &lt; numberOfThrows; i++) {\n        System.out.println(\"第 \" + (i + 1) + \" 次投掷: \" + diceValues[i]);\n    }\n\n    int sum = calculateSum(diceValues);// 调用方法计算和\n    int max = calculateMax(diceValues);// 调用方法计算最大值\n    int min = calculateMin(diceValues);// 调用方法计算最小值\n    double average = calculateAverage(diceValues);// 调用方法计算平均值\n\n    System.out.println(\"总和: \" + sum);\n    System.out.println(\"最大值: \" + max);\n    System.out.println(\"最小值: \" + min);\n    System.out.println(\"平均值: \" + average);\n}\n\n然后这次的内容就到这里了吧，感觉真的进度有些太快了，不知道这周的lab又是什么样子。。。\n","slug":"Java-Learning-Week4","date":"2023-10-09T10:37:13.000Z","categories_index":"","tags_index":"笔记,Java初学","author_index":"General_K1ng"},{"id":"db575aff8a359d17ed235c7bc3cb6733","title":"Java_Exercise(Week3)","content":"这周开始就进入到了条件语句和循环语句了，那么随之而来的就是一些简单的算法题目了，当然对于刚开始接触的人来说还是有些困难的，但是不急，只要把每一步想明白，其实没什么难的，重点在于思路，为什么要用if，为什么要用循环，为什么这个循环是for循环，那个要用while循环，怎么说呢，一定要自己去真真切切的把代码打一遍你才能真的懂，自己不敲代码那真的是不可能学会的。\nExercise #3.1 Pandemic Spread编写 Java 程序 PandemicSpread，模拟大流行病的传播速度，输入如下内容：\n\ninit：第 1 天的初始感染人数\nnumInfect：一名感染者每天新感染的健康人的平均数量\npopulation：该地区的总人数返回全部人口受感染的日期。\n\n\n测试用例：\nTest case 1 :\nInput:\n1\n2\n10\nOutput:\n4\n(Explanation: Total Infected Day 1 = 1; Day 2 = 3; Day 3 = 9; Day 4 = 27)\n\nTest case 2:\nInput:\n5\n3\n1000\nOutput:\n5\n\n题目分析我们先把这个题目进行分析，首先告诉我们需求是要模拟疫情的传播速度，然后定义了三个变量，分别是：\n\ninit：第一天的初始感染人数。它代表在大流行病开始时已经有多少人被感染了。\nnumInfect：一名感染者每天新感染的健康人的平均数量。它表示每个已感染者每天平均能传染给多少个健康人。\npopulation：该地区的总人数。它代表了整个地区内的人口数量。\n\n然后其实意图就很明显了，举个例子，假设在某个地区，第一天的初始感染人数是 1，一名感染者每天平均感染 2 个健康人，而该地区的总人口是 10。我们的目标就是找出在这种情况下，需要多少天才能使整个人口都被感染。\n对吧？这种题就跟小学生的应用题一样，可能手算都会但是让你写一个程序呢？不急，我们就先按小学生的思路走。\n根据题目要求，我们可以逐天模拟传播的过程。\n\n第一天，只有一个人被感染，并且他每天平均感染 2 个健康人。\n第二天，已感染人数将变为 1 + 1 * 2 = 3。\n第三天，已感染人数将变为 3 + 3 * 2 = 9。\n第四天，已感染人数将变为 9 + 9 * 2 = 27。\n\n然而，根据题目要求，我们只需要知道全部人口被感染的日期，所以我们可以直接返回第四天作为答案。\n所以其实我们该怎么写代码呢？\n如果不知道那就先把变量初始化了呗，反之一定是要用的，对吧？\nint init = sc.nextInt(); // 第一天有多少人被感染了\nint numInfect = sc.nextInt(); // 每个感染者平均能传染给多少人\nint population = sc.nextInt(); // 总人口\n\n当然你要在此之前记得导入Scanner的包，这里我就不写了，后面完整代码可以看到。。。\n然后就能发现一个问题，其实我们无法确定需要多少天才能使整个人口都被感染。每天新增感染人数取决于已感染人数和每个感染者平均每天感染的健康人数。因此，我们需要通过逐天迭代的方式来模拟传播过程，直到已感染人数达到或超过总人口数量。\n那么不就是我们所说的循环了吗？那么用哪个循环？while还是for？\n我在这周最开始的教程里面其实讲过了，当知道具体循环次数的时候一般用for循环，当不确定的时候就用while循环。显然，此刻我们不知道要循环多少次。\n然后我们来想循环应该怎么来写，看看上面我们的模拟传播过程，有没有发现一些规律？\n我觉得都大学生了，这个规律应该还是能看出来的。。。吧？\n第一天，只有一个人被感染，对吧？然后，每个被感染的人每天平均再感染2个健康人。所以，第二天，已感染的人数是1（初始感染）加上1（初始感染者）乘以2（每个感染者每天平均感染的人数），等于3人。\n接下来，第三天，已感染的人数是3（第二天的感染人数）加上3（第二天的感染人数）乘以2（每个感染者每天平均感染的人数），等于9人。\n再往后，第四天，已感染的人数是9（第三天的感染人数）加上9（第三天的感染人数）乘以2（每个感染者每天平均感染的人数），等于27人。\n这个规律就是每一天的感染人数都是前一天的感染人数乘以2再加上前一天的感染人数。\n所以这部分代码我想，还是非常简单的，首先，我们初始化一个变量叫做day，它表示当前是第几天，我们从第一天开始。\n还有一个变量叫做infected，它表示已经感染的人数，我们从初始感染人数开始。\n然后，我们使用一个while循环，它会一直运行直到所有人都被感染。在循环里，我们计算每一天新感染的人数，用newInfections表示，它等于infected * numInfect，也就是前一天的感染人数乘以2。\n接下来，我们将新感染的人数加到已感染的人数上，这样我们就更新了每一天的感染情况。\n最后，我们将day加1，表示进入下一天。然后，循环会继续运行，计算下一天的感染情况，直到所有人都被感染。\nint day = 1; // 定义天数，我们从第一天开始\nint infected = init; // 用infected这个变量表示已感染的人数，第一天感染的人数就是init变量所记录的值\n\nwhile (infected &lt; population) { // 循环结束条件，只要已感染人数小于总人数就一直继续循环\n    int newInfections = infected * numInfect; // 用已感染的人数乘以平均传染的速率并且用一个变量来接收，表示每日新增感染人数\n    infected += newInfections;// 然后更新已感染人数\n    day++; // 天数加一\n}\n\n整个代码逻辑其实还是非常简单清晰的吧，如果还不懂的欢迎留言。\n最后很简单了，我们只需要把day进行输出就行了。\nSystem.out.println(day);\n\n完整代码\nClick to see more\nimport java.util.Scanner;\n\npublic class PandemicSpread {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int init = sc.nextInt(); // 第一天有多少人被感染了\n        int numInfect = sc.nextInt(); // 每个感染者平均能传染给多少人\n        int population = sc.nextInt(); // 总人口\n\n        int day = 1; // 定义天数，我们从第一天开始\n        int infected = init; // 用infected这个变量表示已感染的人数，第一天感染的人数就是init变量所记录的值\n\n        while (infected &lt; population) { // 循环结束条件，只要已感染人数小于总人数就一直继续循环\n            int newInfections = infected * numInfect; // 用已感染的人数乘以平均传染的速率并且用一个变量来接收，表示每日新增感染人数\n            infected += newInfections;// 然后更新已感染人数\n            day++; // 天数加一\n        }\n\n        System.out.println(day);// 输出\n    }\n}\n\n\n\nExercise #3.2 Right Triangle编写一个 Java 程序 RightTriangle，接收三个整数输入数，并判断它们是否构成直角三角形的边长。\n\n当且仅当以下两个条件为真时，您的程序必须打印输出为真：\n\n三个整数均为正数（大于零）。\n您可以找到两个整数，这两个整数的平方和等于第三个整数的平方。\n\n测试用例：\nTest cases 1:\nInput:\n5\n12\n13\nOutput:\ntrue\n(since they are all positive and 52  + 122 == 132)\nTest cases 2:\nInput:\n5\n4\n3\nOutput:\ntrue\n(since they are all positive and 42 + 32  == 52)\nTest cases 3:\nInput:\n-3\n-4\n5\nOutput:\nfalse\n(since -3 and -4 are not positive)\n\n题目分析说实话，这种题是不是拿到手感觉非常简单，然后一到了写代码的时候就头疼，我去，要考虑的东西好多啊。。。\n但是，无所谓，一步一步跟着思路走。\n说穿了，这不就是勾股定理嘛。勾股定理需要什么？三个边长，对吧？那就写咯。\nint side1 = sc.nextInt();\n   int side2 = sc.nextInt();\n   int side3 = sc.nextInt();\n\n为什么不用a,b,c来当做变量名称呢？因为牵扯到下面的条件判断，因为我们熟悉的勾股定理的判定是对吧？但其实也是直角三角形，所以为了避免到时候条件的书写上出现一些混乱，还是用边长来当作变量名吧，当然这是我的习惯，你们可以用什么都行。\n然后我们该怎么判断？想想勾股定理\n\n所有三个整数必须为正数（大于零）。\n其中两个整数的平方和等于第三个整数的平方。\n\n所以我们先满足最基本的都要是正整数嘛，这还不简单？\nif (side1 &gt; 0 &amp;&amp; side2 &gt; 0 &amp;&amp;side3 &gt; 0 ){\n    // 布拉布拉\n}\n\n我只要写个if不就行啦，确实，然后我们想想接下来我们已经保证了三个都是正整数，然后就是怎么保证任意两边长的平方和等于第三边平方呢？\n毕竟老师上课讲到了if语句的嵌套是合法的对吧，那我继续嵌套就好啦！\nif (side1 &gt; 0 &amp;&amp; side2 &gt; 0 &amp;&amp;side3 &gt; 0 ){\n    if (Math.pow(side1,2) + Math.pow(side2,2) == Math.pow(side3,2)){\n        System.out.println(true)\n    }\n}\n\n我还用到了Math.pow()这个函数，真强\n对吧？然后呢？这只是一种情况对吧？\n一共应该有三种情况，我们都加上。\nif (side1 &gt; 0 &amp;&amp; side2 &gt; 0 &amp;&amp;side3 &gt; 0 ){\n    if (Math.pow(side1,2) + Math.pow(side2,2) == Math.pow(side3,2)){\n        System.out.println(true)\n    }\n    if (Math.pow(side1,2) + Math.pow(side3,2) == Math.pow(side2,2)){\n        System.out.println(true)\n    }\n    if (Math.pow(side2,2) + Math.pow(side3,2) == Math.pow(side1,2)){\n        System.out.println(true)\n    }\n}\n\n真简单！但是有没有发现一个问题，就是当我们输入负数的时候，程序无法做出反应，这个代码只能输出满足条件的true却不能输出不满足条件的false，怎么办呢？\n简单，我们只需要在外部定义一个布尔变量，初始化为false，只要这些条件都不满足，我在条件语句最后就直接输出它不就好了，然后我们if条件内也需要改一下，因为如果是这样的话，满足条件时就会输出一行true和一行false。\n怎么改呢？\nboolean isRight = false;\nif (side1 &gt; 0 &amp;&amp; side2 &gt; 0 &amp;&amp;side3 &gt; 0 ){\n    if (Math.pow(side1,2) + Math.pow(side2,2) == Math.pow(side3,2)){\n        isRight = true;\n    }\n    if (Math.pow(side1,2) + Math.pow(side3,2) == Math.pow(side2,2)){\n        isRight = true;\n    }\n    if (Math.pow(side2,2) + Math.pow(side3,2) == Math.pow(side1,2)){\n        isRight = true;\n    }\n}\nSystem.out.println(isRight);\n\n我们只需要改一下就能满足题意了。但是，其实这个代码是还可以简化一下的。\n第一点就是精度问题，我们用到了Math.pow()这个函数，但是其实这个函数的底层接受的是double变量，如果我们传递int进去，Java会自动帮我们转换成double（还记得吗？隐式转换！）类型的浮点数再进行运算，但是浮点数由于二进制的原因精度上可能会有所欠缺，所以我建议最好写成乘号相乘，避免一些精度上的失误。\n然后就是语句的一些简化，这里我们用了太多的if语句，其实内部可以简写为一句，运用我们之前刚学的逻辑或（||）符号即可。\n更改完代码如下：\nboolean isRight = false;\nif (side1 &gt; 0 &amp;&amp; side2 &gt; 0 &amp;&amp; side3 &gt; 0) {\n    if (side1 * side1 + side2 * side2 == side3 * side3 ||\n        side1 * side1 + side3 * side3 == side2 * side2 ||\n        side2 * side2 + side3 * side3 == side1 * side1) {\n        isRight = true;\n    }\n}\nSystem.out.println(isRight);\n\n\n可读性和简洁性一下子就上来了，对吧。\n完整代码\nClick to see more\nimport java.util.Scanner;\n\npublic class RightTriangle {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        // 输入的三个整数作为边长\n        int side1 = sc.nextInt();\n        int side2 = sc.nextInt();\n        int side3 = sc.nextInt();\n\n        // 判断所有边是否为正整数\n        boolean isPositive = side1 &gt; 0 &amp;&amp; side2 &gt; 0 &amp;&amp; side3 &gt; 0;\n\t\t\n        boolean isRight = false;// 定义变量\n        if (isPositive) {\n            if (side1 * side1 + side2 * side2 == side3 * side3 || \n                side1 * side1 + side3 * side3 == side2 * side2 ||\n                side2 * side2 + side3 * side3 == side1 * side1) {\n                isRight = true;\n            }\n        }\n        System.out.println(isRight);\n    }\n}\n\n\n\n你们知道我最开始写出来的代码长什么样子吗？我都不敢给你看。。。\n算了还是放在这里吧，看不懂也没关系，毕竟我们还没有学方法，但是这个逻辑写得我都想抽自己，上面的是我后来优化的时候写出来的，以上面为准。\n\nClick to see more\nimport java.util.Scanner;\n\npublic class RightTriangle {\n    \n    public static boolean isPositive(int a, int b, int c) {// 判断是否为正整数\n        return a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; c &gt; 0;\n    }\n\n    public static int calculateSumOfSquares(int a, int b, int c, int maxSide) {// 分情况计算平方和\n        if (maxSide == a) {\n            return (b * b) + (c * c);\n        } else if (maxSide == b) {\n            return (a * a) + (c * c);\n        } else {\n            return (a * a) + (b * b);\n        }\n    }\n\n    public static boolean isRightTriangle(int a, int b, int c) {// 判断是否满足勾股定理\n        if (!isPositive(a, b, c)) {// 方法复用，先判断是否为正整数\n            return false; \n        }\n\n        int maxSide = Math.max(Math.max(a, b), c);// 寻找三边最大值，最长的一边就是斜边\n        int sumOfSquares = calculateSumOfSquares(a, b, c, maxSide);// 调用方法，计算平方和\n        int squareOfMaxSide = maxSide * maxSide;// 计算斜边平方\n\n        return sumOfSquares == squareOfMaxSide; // 判断平方和是否等于斜边平方\n    }\n\n    public static void main(String[] args) {// 主程序入口\n        Scanner sc = new Scanner(System.in);\n\n        int side1 = sc.nextInt();\n        int side2 = sc.nextInt();\n        int side3 = sc.nextInt();// 接收三个变量\n\n        boolean isRight = isRightTriangle(side1, side2, side3);// 判断\n        System.out.println(isRight);// 输出\n    }\n}\n\n\n\nExercise #3.3 Hailstone Sequence好累啊，今天还是中秋节，写这篇文章之前我刚下飞机，现在是第二天凌晨两点半了，撑不住了，先睡觉，明天继续把剩下来的肝完。\n海尔斯通序列的计算方法如下：\n\n从一个整数 n 开始\n如果 n 是偶数，则序列中的下一个数字是 \n如果 n 是奇数，则下一个数字是 \n继续计算，直到到达 1\n\n例如\n 时，序列为 3、10、5、16、8、4、2、1 时，序列为 12, 6, 3, 10, 5, 16, 8, 4, 2, 1\n编写一个 Java 程序 HailStone，在输入正整数 n 时，打印从 n 开始的 Hailstone 序列的长度。\n测试用例：\nTest case 1:\nInput:\n3\nOutput:\n8\n\nTest case 2:\nInput:\n12\nOutput:\n10\n\n题目分析这个题属于是前面两个练习的结合，但是是属于非常简单，非常直观的结合，感觉不需要很费劲的去写这道题的思路分析，我就简单写一下，明确我们需要什么就好了。\n目标：\n\n我们需要编写一个 Java 程序，接受输入的正整数 n。\n根据规则计算从 n 开始的海尔斯通序列，直到序列中的数字变为 1。\n在计算过程中，我们需要追踪序列的长度。\n最终，我们需要打印出这个序列的长度。\n\n对吧，那就很明显了，其中牵扯到奇数和偶数的判断，这就涉及到了if条件语句，然后又需要不断的迭代去寻找数列并且要记录长度，这就牵扯到了循环，这都是一目了然的事情。\n所以，怎么解决呢？\n首先，我们需要一个变量来表示序列的长度，初始化为1。\nint sequenceLength = 1;\n\n然后，我们可以使用一个循环来计算序列，直到 n 变为 1。\nwhile (n != 1) {\n    // 布拉布拉\n}\n\n在循环中，我们需要根据奇偶性分别执行不同的操作：\n\n如果 n 是偶数，将 n 除以 2。\n如果 n 是奇数，将 n 乘以 3 并加 1。\n在每一步中，将序列长度加 1。\n\n当 n 变为 1 时，循环结束。\nwhile (n != 1) {\n    // 如果 n 是偶数\n    if (n % 2 == 0) {\n        n = n / 2;\n    } else {  // 如果 n 是奇数\n        n = 3 * n + 1;\n    }\n    sequenceLength++;  // 每次操作后，序列长度加 1\n}\n\n最后，我们打印出序列的长度。\nSystem.out.println(sequenceLength);\n\n整体非常的简单，可以说是一目了然。\n完整代码我的代码牵扯到一些方法的知识，可以先尝试看看能不能读懂，其实没有想的那么高大上，只不过最开始写的时候习惯了。。。\n当然你可以按照上面的来写，也是很简单的。\n\nClick to see more\nimport java.util.Scanner;\n\npublic class HailStone {\n    \n    public static int hailstoneLength(int n) {\n            int sequenceLength = 1; // 初始化序列长度为 1\n\n            while (n != 1) {\n                if (n % 2 == 0) {\n                    n = n / 2; // 如果 n 是偶数，下一个数是 n/2\n                } else {\n                    n = (3 * n) + 1; // 如果 n 是奇数，下一个数是 3n+1\n                }\n\n                sequenceLength++; // 序列长度加 1\n            }\n\n            return sequenceLength;\n        }\n\n        public static void main(String[] args) {\n            Scanner sc = new Scanner(System.in);\n\n            int n = sc.nextInt();\n\n            int sequenceLength = hailstoneLength(n);\n            System.out.println(sequenceLength);\n        }\n}\n\n\n\nCW1 #3.1 Armstrong Numbers这可是重头戏，我都有点不想一步一步讲了，算了先看题吧。 \n阿姆斯特朗数是一个 n 位数，等于其 n 次幂的总和。例如\n\n153 是一个三位数，个位数的立方之和等于 153\n1634 是一个四位数，个位数的 4 次方之和等于 1634\n\n\n编写一个 Java 程序 Armstrong，输入两个正整数 a 和 k、打印前 k 个大于或等于 a 的阿姆斯特朗数。\n测试用例：\nTest case 1:\nInput:\n100\n2\nOutput:\n153\n370\n\nTest case 2:\nInput:\n1500\n1\nOutput:\n1634\n\n题目分析呃一时不知道该怎么起手，先看这个数字，这个数字要求它的每一位数的某个次方之和等于它自己。\n举个例子就是，如果输入 a = 1 和 k = 5，那么程序应该输出前五个大于或等于 1 的阿姆斯特朗数。输出如下：\n1\n2\n3\n4\n5\n\n这里的输出是前五个大于或等于 1 的阿姆斯特朗数。\n这里我们就直接跳过变量初始化，然后Scanner之类的了，过于麻烦，而且我不相信还有人不会。\nok，接下来就是分块来思考，我们需要哪些功能。\n位数获取首先我们需要知道给出的数字的位数是多少对吧，也就是说这个数字的长度是多少。\n其实可以直接使用一个方法，可能没学过，但是无所谓，现在教给你，那就是String.valueOf()，然后我们再使用length()方法即可，那么，什么意思？\nString.valueOf()会将传入的int转换成String类型的字符串再返回，然后再通过length()方法就可以知道这个字符串的长度了。\nint a = 10;\nint digit = String.valueOf(a).length();\nSystem.out.println(digit);\n\n就会输出\n2\n\n当然还有一种更难的方法，牵扯到了一点递归的知识，看不懂没关系，可以体会一下，我先把代码放在这里，然后再简单讲解一下，如果看不懂也无所谓，本来我也想用while循环的，但是最后写出来的代码时间复杂度略高。。。\npublic static int countDigits(int number) {\n        if (number == 0) {\n            return 0;\n        }\n        return 1 + countDigits(number / 10);\n    }\n\n当我们遇到一个大问题时，递归就像是把它变成了一堆相同或类似的小问题。我们通过解决这些小问题来解决整个大问题。\n想象一下，你有一个大盒子里面有很多小盒子，每个小盒子里又有更小的盒子，以此类推，直到最小的盒子里没有其他盒子为止。\n递归就是一种类似的思想。\n在编程中，我们可以写一个函数，这个函数可以调用自己。当我们调用这个函数时，它会解决一个小问题，然后再调用自己来解决更小的问题。这个过程会一直持续下去，直到我们解决了最小的问题，然后逐层返回结果，最终得到整个问题的解。\n举个例子，假设我们要计算一个数的位数。我们可以把这个问题分解为计算这个数除以 10 的结果的位数，然后再加上 1。这个过程会一直重复，直到我们的数变成 0，这时我们就知道它的位数是多少了。\n递归就像是一个问题的拆解过程，将大问题变成了一系列更小的问题，然后通过递归调用来解决这些小问题，最终得到整个问题的解答。\n一般递归的形式就是让方法自己调用自己，但是要设定跳出的条件，不然就会无限递归，导致爆栈。。\n接着我们再简单看一下这个代码：\n这段代码是一个递归函数\npublic static int countDigits(int number) {\n\n这是静态方法，它接受一个整数参数 number，并返回一个整数作为结果。函数名为 countDigits。\nif (number == 0) {\n    return 0;\n}\n\n这是递归函数的终止条件。如果输入的 number 等于 0，说明已经处理完所有位数，直接返回 0。\nreturn 1 + countDigits(number / 10);\n\n这是递归调用的部分。如果输入的 number 不等于 0，将 number 除以 10，可以得到去掉最右边一位的结果。然后将这个结果传递给 countDigits 函数，继续递归计算剩余位数的数量。最后，将递归结果加上 1，表示当前位数，并返回。\n递归函数的基本思想是将一个大问题分解为一个或多个相同的小问题，并通过递归调用来解决这些小问题，最终得到整个问题的解。在这个例子中，通过每次除以 10 来逐渐缩小数字的范围，直到数字变为 0，从而计算出整数的位数。\n好吧，反正无所谓，感觉第一种更好用。\n获取每一位上的数字然后下一步就是我们如何获得这个数字每一位上的数字，因为我们需要分别拿每一位上的数字进行平方和相加，对吧，这一部分我来想想怎么获取每一位上的数字。\n这个其实在lab上有一个部分已经涉及了，就是怎么将数字反转。\n用到的方法其实就是我们的取模操作（%）\nint digit = num % 10;\n\n只要我们每一次对这个数字进行取模操作，每次模于10，就会发现每次的余数刚好是她的个位数字，然后我们在把这个数字除以10，因为是 int 类型，所以就相当于直接删去了个位数字，然后再加入循环就可以做到取出每一位上的数字了。\nwhile (num != 0){\n          int digit = num % 10;\n          num /= 10;\n      }\n\n这样就拿到了每一个位上的数字，应该不是很难，但是估计有人能发现这个循环有个问题就是还没有进行平方和操作，那么我们就在里面加上一句就行了。\nint numDigits = String.valueOf(num).length();\nint sum = 0;\nwhile (num != 0){\n          int digit = num % 10;\n          sum += Math.pow(digit,numDigits);\n          num /= 10;\n      }\n\n这样我们先通过Math.pow()这个方法计算平方，digit就是每一个位子上的数字，numDigits就是我们上一部分获得的一共有多少位，也就是我们计算的幂，然后再在循环外部先初始化一个sum变量等于0，然后通过赋值操作计算这个数字的平方和即可。\n判断是否是Armstrong数字这一步很简单，就在上面的代码基础上就能完成，非常简单，无非就是判断这个数字是不是和计算出来的平方和相等就行了，对吧？\n我们先定义一个变量，用来记录最开始传入的数字，为什么要定义这个变量，因为后续的那个while循环操作会把原来的数字进行操作，如果不记录到时候比较的时候就会出错。\nint originalNum = num;\n\n这里其实我想稍微的涉及一些方法相关的知识，如果看不懂也无所谓，后面我会给出一个不用方法的版本。\n首先我简短的提一下什么是方法，方法就是我们在代码当中有很多功能性的一些代码，我们需要重复用到，我们就会把他单独封装出来，为了更方便的使用，比如我们这里就可以定义一个方法叫做isArmstrong，用来判断传入的数字是不是 Armstrong 数字。\npublic static boolean isArmstrong(int num){ // 定义方法，返回Boolean变量\n      int originalNum = num;// 定义变量记录最初传入的数字\n      int numDigits = String.valueOf(num).length();// 计算传入数字的位数（长度），也就是幂\n      int sum = 0;// 定义一个平方和变量，初始化为0\n\n      while (num != 0){// 循环操作，计算平方和\n          int digit = num % 10;\n          sum += Math.pow(digit,numDigits);\n          num /= 10;\n      }\n      return sum == originalNum; // 比较 平方和 和 最初的数字是否相等，如果相等就返回true，不等就返回false\n  }\n\n如果不懂就看注释吧，如果是 true 就说明这个数字是 Armstrong 数字，反之就不是。\n通过循环不断的寻找接下来就是不断的寻找符合要求的数字了呗，那这一步我放到main方法当中好了。\npublic static void main(String[] args) { // 主入口\n      Scanner sc = new Scanner(System.in);\n\n      int a = sc.nextInt();\n      int k = sc.nextInt(); // 老生常谈，不想说了，看一下a和k分别代表啥\n\n      int count = 0; // 计数器，作为循环的跳出条件\n      int number = a; // 记录数字，a是初始数字，number用来记录后续更新的数字\n\n      while (count &lt; k) { //循环\n          if(isArmstrong(number)){ // 判断是否是Armstrong数字，调用方法，传入number进行判断\n              System.out.println(number);// 打印满足条件的数字\n              count++;//然后计数器加一\n          }\n          number++;// 不管条件是否满足都一直向后更新number的值，用于一直向后遍历寻找\n      }\n  }\n\n这一部分注释已经写得很完整了，应该不需要再多说了。\n完整代码带方法版：\n\nClick to see more\nimport java.util.Scanner;\n\npublic class Armstrong {\n    public static boolean isArmstrong(int num){\n        int originalNum = num;\n        int numDigits = String.valueOf(num).length();\n        int sum = 0;\n\n        while (num != 0){\n            int digit = num % 10;\n            sum += Math.pow(digit,numDigits);\n            num /= 10;\n        }\n        return sum == originalNum;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int a = sc.nextInt();\n        int k = sc.nextInt();\n\n        int count = 0;\n        int number = a;\n\n        while (count &lt; k) {\n            if(isArmstrong(number)){\n                System.out.println(number);\n                count++;\n            }\n            number++;\n        }\n    }\n}\n\n\n\n不带方法版：\n\nClick to see more\nimport java.util.Scanner;\n\npublic class Armstrong {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int a = sc.nextInt(); // 输入起始数值\n        int k = sc.nextInt(); // 输入要找到的阿姆斯特朗数的个数\n\n        int count = 0; // 计数器，记录已找到的阿姆斯特朗数的个数\n        int number = a; // 当前要检查的数值\n\n        while (count &lt; k) {\n            int originalNum = number; // 保存当前数值，用于后面的比较\n            int numDigits = String.valueOf(number).length(); // 计算当前数值的位数\n            int sum = 0; // 保存每个位上数字的幂和\n\n            int num = number;\n            while (num != 0) {\n                int digit = num % 10; // 取出当前数值的个位数字\n                sum += Math.pow(digit, numDigits); // 计算幂和\n                num /= 10; // 去掉个位数字\n            }\n\n            if (sum == originalNum) { // 如果幂和等于原始数值，说明是阿姆斯特朗数\n                System.out.println(number); // 输出阿姆斯特朗数\n                count++; // 计数器加1\n            }\n            number++; // 继续检查下一个数值\n        }\n    }\n}\n\n\n\n\n终于结束啦！！！累死了。。。\n","slug":"Java-Exercise-Week3","date":"2023-09-29T16:54:42.000Z","categories_index":"","tags_index":"笔记,Java初学","author_index":"General_K1ng"},{"id":"40a5a3eda9f47ccd7f66db869eb2a067","title":"Java_Learning(Week 3)","content":"什么是布尔类型？呃其实上周笔记应该都讲了，这周不知道为什么又提到了，那就再稍微过一下，什么是布尔类型呢？\nboolean：\n\nboolean数据类型表示一位的信息；\n只有两个取值：true 和 false；\n这种类型只作为一种标志来记录 true/false 情况；\n默认值是 false；\n例子：boolean a = true。\n\n就这么些，就是一个可以记录是和否的数据类型，只需要记住默认值是false就行，这个还慢重要的。\nJava当中的运算符逻辑运算符所以说讲布尔其实是为了引出几个逻辑运算符号，那方便复习和讲一些东西，我就把Java当中所有的运算符都放到这里一讲就好，刚好上面是布尔，那就先从逻辑运算开始，在此之前我们先想清楚几个逻辑运算的本质。\n分别是与，或，非，其实很简单，高中应该都学过基本的逻辑\n\n与就是两个都真，条件才真；\n或就是两个其中一个为真，条件就真；\n非就是将得到的真和假反转\n\n操作符也很简单，假如例子是A = true, B = false\n\n\n\n操作符\n描述\n例子\n\n\n\n&amp;&amp;\n两个都真，条件才真\n(A &amp;&amp; B) = false\n\n\n||\n两个其中一个为真，条件就真\n(A || B) = true\n\n\n!\n将得到的真和假反转\n!A = false\n\n\n然后就是课上提到了一个“XOR”操作，其实就是我们常说的逻辑异或，其实意思就是如果两个值不同，那么异或结果就是1（真），如果两个值相同，异或结果就是0（假）。\n那么我们如何只用与或非来进行异或的操作呢？\n这个其实不太好想，所以我们一步一步来，跟上我的思路。\n\n思考定义： 逻辑异或操作返回的结果是当两个输入值不相同时为真，相同时为假，对吧？也就是说，只有一个输入为真时，结果为真。反过来说，只有一个输入为假时，结果为真。\n\n分析真值表： 我们把逻辑异或的真值表列出来，这有一些小麻烦，但是很值得这么干\n\n\n\nA\nB\nA XOR B\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\n\n这里其实就比较直观了，我们已经知道了返回条件是只有一个为真的时候结果真，所以我们可以使用逻辑与运算符 &amp;&amp; 来检查两个输入是否不同时为真。例如， (A &amp;&amp; !B) 表示 A 为真且 B 不为真。\n\n然后，我们再考虑另一个条件： (B &amp;&amp; !A) 表示 B 为真且 A 不为真，这也符合逻辑异或的条件之一。\n\n最后，我们可以使用逻辑或运算符 || 来将这两个条件组合起来：(A &amp;&amp; !B) || (B &amp;&amp; !A)。\n\n\npublic class xor {\n    public static void main(String[] args) {\n        boolean a = false;\n        boolean b = true;\n\n        System.out.println((!a &amp;&amp; b) || ( a &amp;&amp; !b));\n    }\n}\n\n其实我们也可以按照检查只有一个输入为假时，结果为真来实现，本质上是一样的。\n关系运算符Java当中的关系运算符，这个更简单，说白了就是小学学的大于小于号，这些来实现一些条件判断，直接把表格列在这里，自己看看：\n\n\n\n运算符\n描述\n示例\n\n\n\n==\n等于（相等）\n5 == 5 结果为 true\n\n\n!=\n不等于\n5 != 3 结果为 true\n\n\n&gt;\n大于\n7 &gt; 4 结果为 true\n\n\n&lt;\n小于\n3 &lt; 6 结果为 true\n\n\n&gt;=\n大于等于\n4 &gt;= 4 结果为 true\n\n\n&lt;=\n小于等于\n2 &lt;= 5 结果为 true\n\n\n对吧，自己打开IDE自己输着玩，玩着玩着就知道这些是什么了。\n算术运算符这个过于简单，但是为了笔记完整性，我也只是列出表格\n\n\n\n运算符\n描述\n示例\n\n\n\n+\n加法\n5 + 3 结果为 8\n\n\n-\n减法\n7 - 4 结果为 3\n\n\n*\n乘法\n2 * 6 结果为 12\n\n\n/\n除法\n10 / 2 结果为 5\n\n\n%\n取模（取余数）\n10 % 3 结果为 1\n\n\n提一嘴，整型的除法和浮点数的除法还是有细微区别的，注意一下。\n然后就是还有自增和自减的操作，这里也列出来\n\n\n\n运算符\n描述\n示例\n\n\n\n++\n自增，相当于a = a + 1\n见下文\n\n\n–\n自减，相当于a = a - 1\n见下文\n\n\n这里牵扯到了一个前缀自增自减和后缀自增自减的区别，那么有什么区别呢？\n\n前缀自增和前缀自减：前缀自增和前缀自减在变量之前执行增加或减少操作，然后返回变量的新值。在前缀运算中，操作先执行，然后返回值。\n\n后缀自增和后缀自减：后缀自增和后缀自减在变量之后执行增加或减少操作，然后返回变量的旧值。在后缀运算中，先返回值，然后再执行操作。\n\n\n说实话大部分情况下两者好像没什么区别，但是其实还是有一些细微的区别的，那就是谁先赋值，谁先自增自减，我写一个例子代码：\npublic class PrefixPostfixExample {\n    public static void main(String[] args) {\n        int x = 5;\n        int y = 5; //定义变量\n\n        // 前缀自增示例\n        System.out.println(\"前缀自增示例:\");\n        System.out.println(\"x 的初始值：\" + x); // 输出 5\n        int prefixIncrementResultX = ++x; // 前缀自增\n        System.out.println(\"前缀自增后 x 的值：\" + x); // 输出 6\n        System.out.println(\"前缀自增的结果：\" + prefixIncrementResultX); // 输出 6\n\n        // 后缀自增示例\n        System.out.println(\"\\n后缀自增示例:\");\n        System.out.println(\"y 的初始值：\" + y); // 输出 5\n        int postfixIncrementResultY = y++; // 后缀自增\n        System.out.println(\"后缀自增后 y 的值：\" + y); // 输出 6\n        System.out.println(\"后缀自增的结果：\" + postfixIncrementResultY); // 输出 5\n    }\n}\n\n最后输出如下：\n前缀自增示例:\nx 的初始值：5\n前缀自增后 x 的值：6\n前缀自增的结果：6\n\n后缀自增示例:\ny 的初始值：5\n后缀自增后 y 的值：6\n后缀自增的结果：5\n\n发现区别了吗，前缀自增返回的结果是6，而后缀自增的结果返回的却是5。\n\n原因就是前缀自增是先进行自增操作，然后再返回值给prefixIncrementResultX这个变量，最后输出就是已经自增过的值。\n然而后缀自增是先进行赋值，也就是先把y = 5这个值赋值给了prefixIncrementResultY，也就是说此时这个变量记录的是5，然后y在此时才进行了自增操作，所以输出结果y = 6但是prefixIncrementResultY还等于5，因为实际上y在自增后还没有赋值。\n\n有点绕，但是建议仔细思考，因为我已经用的是最简单的话把这个点讲清楚辣。\n位运算符这个就更抽象了，但是其实就是二进制层面的一些运算操作，后面除非是考试或者一些比较特殊的算法题目和性能优化问题，不然其实一般很少会涉及到这里，我就列出来：\n\n\n\n运算符\n描述\n示例\n\n\n\n&amp;\n按位与（AND）\n5 &amp; 3 结果为 1\n\n\n|\n按位或（OR）\n5 | 3 结果为 7\n\n\n^\n按位异或（XOR）\n5 ^ 3 结果为 6\n\n\n~\n按位取反（NOT）\n~5 结果为 -6\n\n\n&lt;&lt;\n左移位\n5 &lt;&lt; 2 结果为 20\n\n\n&gt;&gt;\n右移位（带符号）\n10 &gt;&gt; 1 结果为 5\n\n\n&gt;&gt;&gt;\n无符号右移位\n-10 &gt;&gt;&gt; 1 结果为 2147483643\n\n\n为了方便说明，我还是写个代码来举例子\npublic class bitwiseOperator {\n    public static void main(String[] args) {\n        int a = 5;   // 二进制表示为 0101\n        int b = 3;   // 二进制表示为 0011\n\n        int bitwiseAnd = a &amp; b;      // 按位与，结果为 1 (0001)\n        int bitwiseOr = a | b;       // 按位或，结果为 7 (0111)\n        int bitwiseXor = a ^ b;      // 按位异或，结果为 6 (0110)\n        int bitwiseNot = ~a;         // 按位取反，结果为 -6 (11111111111111111111111111111010)\n        int leftShift = a &lt;&lt; 2;      // 左移位，结果为 20 (10100)\n        int rightShift = 10 &gt;&gt; 1;    // 右移位，结果为 5 (0000 0101)\n        int unsignedRightShift = -10 &gt;&gt;&gt; 1; // 无符号右移位，结果为 2147483643 (0111 1111 1111 1111 1111 1111 1111 1011)\n\n\n        System.out.println(bitwiseAnd);\n        System.out.println(bitwiseOr);\n        System.out.println(bitwiseXor);\n        System.out.println(bitwiseNot);\n        System.out.println(leftShift);\n        System.out.println(rightShift);\n        System.out.println(unsignedRightShift);\n    }\n}\n\n怎么说呢，你看第一个位与运算a &amp; b，就是在二进制层面对5和3每一位进行与运算，只有都是1才能返回1，反之返回的都是0，所以运算后得到的结果是0001也就是十进制的1，懂了吧，下面的位或啊，位异或啊都是这个道理。\n然后就是取反(~)，”取反” 是一种位运算操作，也称为按位取反或位取反。它用于翻转二进制数的每个位，将0变为1，将1变为0。具体来说，如果一个二进制位的值为0，那么在取反操作后，它的值将变为1；如果一个二进制位的值为1，那么在取反操作后，它的值将变为0。所以说你就可以看见5取反后得到了-6，那么为什么是-6捏，其实因为二进制表达数字最外面的一个0和1是表达正负号的，hh，底层的一些知识其实不用知道也行。\n移位顾名思义就是二进制数向左/右移动指定数量的位，同时在低位补零。左移n位相当于将原始数乘以2的n次方。例如，将整数5左移2位就得到了20。\n然后无符号右移位就是无符号右移不保留符号位，总是在高位补零。没有无符号左移位，但是可以通过一些方式达到类似的效果，但是没必要知道，起码现在没必要。\n这一块没搞懂无所谓，感觉考试也应该不会闲着没事考这里。。。\n赋值运算符写到这里我快累死了，赋值运算符，就是先运算，然后再赋值，先列表我再看看有没有什么需要强调的：\n\n\n\n运算符\n描述\n示例\n\n\n\n=\n赋值\nint x = 5;\n\n\n+=\n加后赋值（加法赋值）\nx += 3; // 相当于 x = x + 3;\n\n\n-=\n减后赋值（减法赋值）\nx -= 2; // 相当于 x = x - 2;\n\n\n*=\n乘后赋值（乘法赋值）\nx *= 4; // 相当于 x = x * 4;\n\n\n/=\n除后赋值（除法赋值）\nx /= 2; // 相当于 x = x / 2;\n\n\n%=\n取模后赋值（取余数赋值）\nx %= 3; // 相当于 x = x % 3;\n\n\n&lt;&lt;=\n左移位后赋值\nx &lt;&lt;= 2; // 相当于 x = x &lt;&lt; 2;\n\n\n&gt;&gt;=\n右移位后赋值（带符号）\nx &gt;&gt;= 1; // 相当于 x = x &gt;&gt; 1;\n\n\n&gt;&gt;&gt;=\n无符号右移位后赋值\nx &gt;&gt;&gt;= 1; // 相当于 x = x &gt;&gt;&gt; 1;\n\n\n&amp;=\n按位与后赋值\nx &amp;= 3; // 相当于 x = x &amp; 3;\n\n\n|=\n按位或后赋值\nx |= 6; // 相当于 x = x | 6;\n\n\n^=\n按位异或后赋值\nx ^= 5; // 相当于 x = x ^ 5;\n\n\n好像真没什么说的吧，比如x += 3就相当于x = x + 3，其他的同理，自己慢慢看，实在不行最好自己打开IDE自己打一遍就回了。\n条件运算符（三元运算符）这个有点意思，但是也很简单，和if-else语句有点像，我先写出来，这个表达方式如下：\ncondition ? expression1 : expression2\n\n其中，condition 是一个布尔表达式，如果为true，则表达式的值为 expression1，否则为 expression2。这种运算符允许你根据条件的真假选择不同的值。\n举个例子吧！\nint age = 20;\nString status = (age &gt;= 18) ? \"成年人\" : \"未成年人\";\n\nSystem.out.println(\"年龄状态：\" + status); // 输出 \"成年人\"\n\n\n就像代码说的，我先定义我20岁，然后三元运算符开始，判断是否大于18岁，如果大于就返回成年人，小于就返回未成年人。\n但是这一般只用于简单的条件判断，后面会讲它和if语句的一些区别。\n后面其实还有instanceof运算符，但是这里我不准备写，因为这在后面才会涉及，而且我们还没有认识什么是对象，什么是类，现在写了只会让人更晕。\n条件语句这一部分很符合直观，而且很易于理解，并且课上讲的也很明白步骤很清楚。所以我就来稍微写一下。\n执行逻辑非常的清晰易懂，执行顺序是从上到下，一旦满足条件，就执行相应的代码块，并且在执行完一个代码块后，程序会继续执行条件语句之后的代码。在使用条件语句时，要特别注意条件的逻辑和顺序，以确保程序按照预期方式执行。\n然后就是条件语句是顺序结构。\nif语句if语句用于在条件满足时执行一段代码块。\n\n语法格式：\nif (条件表达式) {\n    // 在条件为真时执行的代码块\n}\n\n示例：\nint x = 10;\nif (x &gt; 2) {\n    System.out.println(\"x大于5\");\n}\n\nelse-if语句else if语句用于在多个条件之间进行选择，只有一个条件满足时会执行相应的代码块。\n\n语法格式：\nif (条件表达式1) {\n    // 在条件1为真时执行的代码块\n} else if (条件表达式2) {\n    // 在条件2为真时执行的代码块\n} else {\n    // 所有条件都不满足时执行的代码块\n}\n\n示例：\nint x = 10;\nif (x &gt; 10) {\n    System.out.println(\"x大于10\");\n} else if (x == 10) {\n    System.out.println(\"x等于10\");\n} else {\n    System.out.println(\"x小于10\");\n}\n\n这里有几个注意的点，使用 if，else if，else 语句的时候：\n\nif 最多只能有 1 个 else ，else 必须在所有的 else if 之后。\nif 可以有很多个 else if，它们必须在 else 之前。\n一旦其中有一个 else if 为 true，其他的 else if 以及 else 都将跳过执行。\n\nelse语句else语句用于在前面的条件都不满足时执行一段默认的代码块。\n语法格式：\nif (条件表达式) {\n    // 在条件为真时执行的代码块\n} else {\n    // 在条件为假时执行的代码块\n}\n\n示例：\nint x = 5;\nif (x &gt; 10) {\n    System.out.println(\"x大于10\");\n} else {\n    System.out.println(\"x不大于10\");\n}\n\n嵌套然后就是注意一下条件语句的嵌套在Java当中是合法的，这意味着你可以在一个条件语句的代码块内包含另一个条件语句，以实现更复杂的条件逻辑。嵌套条件语句允许你根据多个条件的组合来进行更精细的控制程序流程。\n以下是一个示例，展示了如何嵌套条件语句：\nint x = 10;\nint y = 5;\n\nif (x &gt; 5) {\n    System.out.println(\"x大于5\");\n    \n    if (y &gt; 3) {\n        System.out.println(\"y大于3\");\n    } else {\n        System.out.println(\"y不大于3\");\n    }\n} else {\n    System.out.println(\"x不大于5\");\n}\n\n可以试着画一下这个的流程图，感受一下条件语句的嵌套。\n三元运算符和if-else语句的区别还记的三元运算符吧，不记得就往上翻，然后再下来。\n区别就是：\n\n三元运算符通常用于简单的条件判断，当条件为真时返回一个值，否则返回另一个值。它适用于将条件表达式的结果分配给一个变量，或者在一个表达式中根据条件返回不同的值。\nif-else语句用于更复杂的条件逻辑，它可以包含多个条件分支，并且可以执行多个不同的代码块，每个代码块可以包含多个语句。if-else语句通常用于根据不同的条件执行不同的操作。\n\n当然这么说可能不太能理解，就是三元运算符适合在简单情况下使用，处理的都是一些非常简单的判断，if可以实现更加负责的代码块，而且在实际开发中肯定是if语句用的更多，因为代码可读性更强，更容易理解，更方便维护。\n循环结构写到这里我快吐了，东西真的多我去，下午才上的课，我现在正在敲笔记O(∩_∩)O呵呵~。\n程序语句的执行可以分为不同的结构，其中之一是顺序结构，它表示代码会按照书写的顺序一次执行一次。\n然而，有时候我们需要让一组操作重复执行多次，这就需要用到循环结构了。\n在Java中，有三种主要的循环结构可供选择，每种都在不同的情况下有其优势和用途：\n\nwhile 循环：这是一种最基本的循环结构，它在开始执行之前检查一个条件，只有条件为真时才会执行循环体。这使得它非常适合处理需要反复执行，但不确定执行次数的情况。\ndo…while 循环：与while循环类似，但不同之处在于它首先执行循环体，然后再检查条件。这确保循环体至少会被执行一次，即使条件一开始就为假。\nfor 循环：这是一种更为复杂但强大的循环结构，通常用于需要在已知次数的情况下执行一组语句。它具有明确的初始化、条件和迭代部分，使得循环的控制非常精确。\n\n当然，在Java 5中引入了一种增强型for循环，这个目前我们还不需要了解，因为这个主要是用来遍历数组和集合元素。简化了循环过程，不再需要显式控制循环索引，而是直接迭代数组或集合的元素。\nwhile循环while 循环是Java中最基本的循环结构之一。它允许重复执行一组语句，只要指定的条件为真（true）时，循环会一直执行。当条件不再为真时，循环停止执行，程序继续执行下一个语句。\n语法：\nwhile (条件) {\n    // 循环体\n}\n\n\n条件：这是一个布尔表达式（boolean expression），当条件为true时，循环体会被执行。如果条件一开始就为false，循环体将不会被执行，而是直接跳过循环。\n循环体：这是需要重复执行的一组Java语句。它们位于大括号 {} 内，可以包含一个或多个语句。循环体中的语句会重复执行，直到条件为false。\n\n执行流程：\n\n首先，计算条件的值。\n如果条件为真，执行循环体内的代码。\n执行完循环体后，再次计算条件的值。\n如果条件仍然为真，继续执行循环体。\n这个过程将一直重复，直到条件为假为止。\n一旦条件为假，程序将继续执行while循环后面的语句或代码块。\n\n示例：\nint i = 1;\nwhile (i &lt;= 5) {\n    System.out.println(\"当前数字是：\" + i);\n    i++; // 注意这里要更新条件，不然就会形成无限循环\n}\n\n上述示例中，循环会从1一直执行到5。首先，条件 i &lt;= 5 被检查，因为1小于等于5，所以循环体内的代码会被执行。然后，i 的值递增，条件再次检查，这个过程一直重复，直到 i 的值变成6时，条件变为false，循环停止。\n注意事项：\n\n在while循环中，一定要确保在某个点上条件会变为false，否则可能导致无限循环。\n为了避免无限循环，通常在循环体内需要更新循环条件，确保最终条件变为false。\n如果条件一开始就为false，循环体将不会被执行，这可能会导致循环完全被跳过。\n\ndo…while循环万恶之源，我的建议是千万别碰这个玩意，我到现在都没搞清楚这个的执行逻辑，并且这玩意是真的难用，开发当中除非找事一般没人会用这个玩意，但是毕竟是学校，要考试的辣，而且谁知道会不会考一些八股文知识，所以笔记还是要有的。\ndo…while 循环 是Java中的另一种循环结构，和while循环很像，但有一个重要的区别：它首先执行循环体，然后再检查条件。这意味着无论条件是否为真，循环体至少会被执行一次。懂了吗，反正我没懂o(￣︶￣)o。\n语法：\ndo {\n    // 循环体\n} while (条件);\n\n执行流程：\n\n首先，执行循环体内的代码。\n执行完循环体后，计算条件的值。\n如果条件为真，继续执行循环体。\n这个过程将一直重复，直到条件为false。\n一旦条件为假，程序将继续执行do…while循环后面的语句或代码块。\n\n示例：\nint i = 1;\ndo {\n    System.out.println(\"当前数字是：\" + i);\n    i++; \n} while (i &lt;= 5);\n\n\n上述示例中，无论如何，循环体都会执行一次。然后，条件 i &lt;= 5 被检查，如果条件为真，循环体将再次执行，这个过程将一直重复，直到 i 的值变成6时，条件变为false，循环停止。\n注意事项：\n\n与while循环不同，do…while循环保证循环体至少会执行一次。\n为了避免无限循环，通常在循环体内需要更新循环条件，确保最终条件变为false。\n如果条件一开始就为false，循环体将至少被执行一次，然后停止执行。\n\n我还是要强调，没事我的建议是别用！\nfor循环基本上可以说是大伙最爱的循环结构了，后面也是大伙用得基本上最多的循环体了。\nfor 循环 是Java中一种非常强大的循环结构，通常用于需要在已知次数下执行一组语句的情况。for循环具有严格的控制结构，包括初始化、条件和迭代部分，使得它非常适合对循环进行精确控制。\n语法：\nfor (初始化; 条件; 迭代) {\n    // 循环体\n}\n\n\n初始化：这是一个在循环开始之前执行的表达式。通常用于初始化循环控制变量，它只会在循环开始时执行一次。\n条件：这是一个布尔表达式（boolean expression），它在每次循环迭代之前都会被检查。只有在条件为true时，循环体才会被执行。如果条件一开始就为false，循循环体将不会被执行。\n迭代：这是在每次循环迭代之后执行的表达式。通常用于更新循环控制变量的值。\n循环体：这是需要重复执行的一组Java语句，位于花括号 {} 内，可以包含一个或多个语句。\n\n执行流程：\n\n首先，执行初始化部分，通常用于初始化循环计数器。\n然后，计算条件的值。如果条件为true，继续执行循环体。\n执行循环体内的代码。\n执行完循环体后，执行迭代部分，通常用于更新循环计数器。\n再次计算条件的值。\n如果条件仍然为true，继续执行循环体，然后重复以上步骤，直到条件为false。\n一旦条件为假，程序将继续执行for循环后面的语句或代码块。\n\n示例：\nfor (int i = 1; i &lt;= 5; i++) {\n    System.out.println(\"当前数字是：\" + i);\n}\n\n在上述示例中，初始化部分初始化了一个计数器变量 i，条件部分检查 i 是否小于等于5，迭代部分每次增加 i 的值。循环体内的代码会重复执行，直到 i 的值变成6，条件变为false，循环停止。\n注意事项：\n\nfor循环通常用于已知循环次数的情况，因为它提供了精确的控制。\n循环变量（例如，上述示例中的 i）通常在循环内部定义，这意味着它的作用范围仅限于循环体内。\n初始化、条件和迭代部分都可以包含多个表达式，它们以逗号分隔。\nfor循环可以嵌套，即在一个for循环内包含另一个for循环。\n\n虽然说它很好用，非常的方便，条件也很严格，但是我要说的是，当年听从一位前辈说的，本质上所有的循环都是while循环，所以for循环完全可以写成while循环的格式，并且更加的简洁，方便看，他建议我养成习惯以后只写while循环，当然了，这个看个人习惯。\nfor循环和while循环的区别不得不提到一个老生常谈的话题了，for循环和while训话有什么区别，用最简单的话来说\n\nfor循环更适合在已知循环次数的情况下使用\nwhile循环则更适合在循环次数不确定的情况下使用\n\n这里这例子我一时半会儿还真举不出来，但是，嘿嘿学到循环和条件了这题还会少吗？等Exercise出来的时候再讲吧。\n","slug":"Java-Learning-Week-3","date":"2023-09-25T08:09:43.000Z","categories_index":"","tags_index":"笔记,Java初学","author_index":"General_K1ng"},{"id":"359c9a1a9e0f8b70b5c766d3c5f40981","title":"Java_Exercise(Week 2)","content":"Exercise #2.1 What day is it?编写一个 Java 程序，将日期作为输入，并打印出该日期所在星期的哪一天。\n程序应使用三个整数：y（年）、m（月）和 d（日）。对于 m，1 月用 1，2 月用 2，以此类推。对于输出，周日打印 0，周一打印 1，周二打印 2，以此类推。\n使用以下公式：\n\n\n\n\n测试用例：\nTest case 1:\nInput:\n2018\n12\n24\nOutput: \nIt's day 1 !\n\n解决给出来的一些程序问题，毕竟我们不牵扯算法的问题，公式和算法都已经给你呈现了，我们要做的只是把公式翻译成Java语言就行了，只要看好输入输出的测试用例，然后注意一下公式的表达，基本上不会出什么问题。\n代码如下：\n\nClick to see more\nimport java.util.Scanner; //牵扯到输入，所以必须导入Scanner包\n\npublic class DateToDay {\n    public static void main(String[] args) { //main方法入口\n        Scanner sc = new Scanner(System.in); // 创建Scanner的对象\n        int y = sc.nextInt(); \n        int m = sc.nextInt();\n        int d = sc.nextInt(); //调用方法分别记录输入的y,m,d的值\n\n        int a = y - (14 - m) / 12; \n        int b = a + a/4 - a/100 + a/400;\n        int c = m + 12 * ((14 - m) /12) - 2; //分别将录入的值用a,b,c来记录，便于公式的表达\n\n        int day = (d + b + (31 * c) / 12) % 7; //带入公式\n\n        System.out.println(\"It's day \" + day + \" !\"); //控制台输出，注意输出时的空格\n    }\n}\n\n\n\nExercise #2.2 CMYK to RGB有几种不同的格式用于表示颜色。您可能知道 RGB 格式，它在 0 到 255 的整数范围内指定红色 (R)、绿色 (G) 和蓝色 (B) 的级别。还有一种格式叫 CMYK 格式，它规定了青色 (C)、洋红色 (M)、黄色 (Y) 和黑色 (K) 在 0.0 到 1.0 的实数范围内的级别。\n\n编写一个 Java 程序，使用以下公式将 CMYK 格式转换为 RGB 格式：白 = 1 - 黑红色 = 255 × 白色 × (1 - 青色)绿 = 255 × 白 × (1 - 洋红)蓝 = 255 × 白 × (1 - 黄)\n您的程序必须输入青色、洋红色、黄色和黑色这四个数字；计算相应的 RGB 值，每个值都四舍五入为最接近的整数；并按下面的测试用例打印 RGB 值：\nTest case 1:\nInput:  \n0.0\n0.0\n1.0\n0.0\nOutput: \nred = 255\ngreen = 255\nblue = 0\n\nTest case 2:\nInput:\n0.0\n1.0\n0.75\n0.50\nOutput:\nred = 128\ngreen = 0\nblue = 32\n\n\n\n这道题比上一道提升了一点难度，但是难度不大，还是重点在于搞清楚变量之间的关系，并且有一些小坑注意避免，所以这道题的代码分开写便于理解。\n\nClick to see more\n首先我们先分析题目吧，说白了，让你按照公式把几个值进行转换，然后打印输出，公式都给你了，那就直接照着公式打吧：\n首先我们先要键盘录入，然后再来接受键盘录入的值，分别是青色，洋红色，黄色和黑色。\nScanner sc = new Scanner(System.in); //创建Scanner的对象\ndouble cyan = sc.nextDouble();\ndouble magenta = sc.nextDouble();\ndouble yellow = sc.nextDouble();\ndouble black = sc.nextDouble(); //用double来接受录入的值\n\n然后我们再开始按照公式进行转换\ndouble white = 1 - black;\ndouble red = 255 * white * (1 - cyan);\ndouble green = 255 * white * (1 - magenta);\ndouble blue = 255 * white * (1 - yellow);\n\n照着公式打应该是不会打错的，比较容易出错的一步就是要打印输出，我们先写一下吧\nSystem.out.println(\"red = \" +  red);\nSystem.out.println(\"green = \" + green);\nSystem.out.println(\"blue = \" + blue);\n\n看上去好像没问题啊，那我们先拿第一个测试用例试一下\n输出如下：\nred = 255.0\ngreen = 255.0\nblue = 0.0\n\n看上去好像没问题对不对？但是其实是错的，其实看一下预期发现应该是整数类型而不是double，那这不简单嘛，那前两天刚学了基本数据类型的强转，那我们来强转一下一定行，hh\nSystem.out.println(\"red = \" +  (int)red);\nSystem.out.println(\"green = \" + (int)green);\nSystem.out.println(\"blue = \" + (int)blue);\n\n这样一定行了吧，第一个测试用例确实通过了，但是第二个呢？\n输出如下：\nred = 127\ngreen = 0\nblue = 31\n\n发现了吗，blue的要求应该是32，而这里却输出了31，为什么？因为基本数据类型的强转当中，double转int是向下取整，而测试用例需要我们向上取整，这下发现了吧，我们应该使用的是Math.round()方法。\n完整的代码应该是这样：\nimport java.util.Scanner;\n\npublic class CMYKtoRGB {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        double cyan = sc.nextDouble();\n        double magenta = sc.nextDouble();\n        double yellow = sc.nextDouble();\n        double black = sc.nextDouble();\n\n        double white = 1 - black;\n        double red = 255 * white * (1 - cyan);\n        double green = 255 * white * (1 - magenta);\n        double blue = 255 * white * (1 - yellow);\n\n        System.out.println(\"red = \" +  Math.round(red));\n        System.out.println(\"green = \" +  Math.round(green));\n        System.out.println(\"blue = \" +  Math.round(blue));\n\n\n    }\n}\n\n所以一定要看清测试用例，和明白问题关键在哪，学会自己分析问题。\n\n\nExercise #2.3 Great Circle Distance大圆距离是球面上两点和（x2,y2）之间最短路径的长度。\n计算公式如下。\n\n编写一个 Java 程序，输入四个复数 x1、y1、x2、y2，它们是地球表面两点的经度和纬度（以度为单位）；使用地球的平均半径 r = 6,371.0 千米；并打印出两点之间的大圆距离 dist（单位：千米）。\n请注意，输入的数字是以度为单位的，但 Java 的三角函数使用的是弧度。使用 Math.toRadians() 将度转换为弧度。\n测试用例如下：\nTest case 1:\nInput:\n80.0\n25.0\n155.0\n102.5\nOutput: \n7509.440708014122 kilometres\n\nTest case 2:\nInput:\n10.55\n39.33\n21.47\n-7.88\nOutput:\n5169.256612492542 kilometres\n\n这个题看着很吓人，但是其实还是最开始那句话，不要被题吓到，算法和公式不是我们需要考虑的问题，我们并不需要知道怎么才能用经纬度算出两点之间的距离，根本不需要数学和物理知识，你只需要如何把公式翻译成代码就好，程序员最最重要的一点就是要明白需求，而不是想别的。\n首先看到题目，肯定我们需要有键盘录入，其次接收的变量类型应该是double，再然后就是一个非常长的公式，仔细的打出来就好。\n\nClick to see more\n首先我们还是要先创建变量来接收键盘录入的值，分别有四个x1、y1、x2、y2，必须用double。\nScanner sc = new Scanner(System.in);\n\ndouble x1 = sc.nextDouble();\ndouble y1 = sc.nextDouble();\ndouble x2 = sc.nextDouble();\ndouble y2 = sc.nextDouble();\n\n然后必须要注意题目里面已经给你提醒了，我们Java程序用的是弧度制，我们的输入都是角度，必须用 Math.toRadians() 来进行转换，为了我的代码更加的简洁，优雅（如何写优雅的代码可以看上一章）我们可以这样写：\ndouble x1 = Math.toRadians(sc.nextDouble());\ndouble y1 = Math.toRadians(sc.nextDouble());\ndouble x2 = Math.toRadians(sc.nextDouble());\ndouble y2 = Math.toRadians(sc.nextDouble());\n\n我们把键盘录入的值直接传递给 Math.toRadians() 这个函数，然后这个函数返回的值直接赋值给我们的这四个变量，简洁，优雅。\n接着我们再定义一个变量r用来表示地球的半径\ndouble r = 6371.0\n\n然后就是枯燥又考验细心的公式环节，这个公式很长很长，注意不要输错了，括号要保持清楚，所以我建议是在每个运算符之间要进行空格，便于查看和debug。\ndouble dist = 2 * r * Math.asin(Math.sqrt(Math.sin((x2 - x1)/2) * Math.sin((x2 - x1)/2) + Math.cos(x1) * Math.cos(x2) * Math.sin((y2 - y1)/2) * Math.sin((y2 - y1)/2)));\n\n然后我们输出即可，完整代码如下：\nimport java.util.Scanner; //导包\n\npublic class GreatCircleDistance {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in); //新建对象\n\n        double x1 = Math.toRadians(sc.nextDouble());\n        double y1 = Math.toRadians(sc.nextDouble());\n        double x2 = Math.toRadians(sc.nextDouble());\n        double y2 = Math.toRadians(sc.nextDouble());//用变量接收转换为弧度的键盘录入的值\n\n        double r = 6371.0;//定义地球半径\n\n        double dist = 2 * r * Math.asin(Math.sqrt(Math.sin((x2 - x1)/2) * Math.sin((x2 - x1)/2) + Math.cos(x1) * Math.cos(x2) * Math.sin((y2 - y1)/2) * Math.sin((y2 - y1)/2))); //痛苦的公式\n\n        System.out.println(dist + \" kilometres\");//输出\n    }\n}\n\n不是很难。\n\n\nCW1 #2.1 Area of a Pentagon给定 r = 五角形中心到顶点的长度（实数），编写一个 Java 程序，计算五边形的面积。\n\n五边形面积的计算公式是其中，s 是边长，计算公式为测试用例：\nTest case 1:\nInput:\n2.5\nOutput: \nArea = 14.86025806711178\n\nTest case 2:\nInput:\n1.0\nOutput:\nArea = 2.377641290737884\n\n相比前面的这个感觉其实根本没什么难度，还是强调那句话，公式都有了，翻译就好。\n代码如下：\n\nClick to see more\nimport java.util.Scanner; //导包\n\npublic class AreaOfAPentagon {\n    public static void main(String[] args) { //主入口\n        Scanner sc = new Scanner(System.in); //新建对象\n\n        double r = sc.nextDouble(); //接收键盘录入\n        double s = 2 * r * Math.sin(Math.PI / 5); //带入公式\n\n        double area = (5 * s * s) / (4 * Math.tan(Math.PI / 5)); //带入公式\n\n        System.out.println(\"Area = \" + area); //输出\n    }\n}\n\n\n\n这次的作业感觉就是lab的一次强化练习吧。\n","slug":"Java-Exercise-Week2","date":"2023-09-22T08:43:31.000Z","categories_index":"","tags_index":"笔记,Java初学","author_index":"General_K1ng"},{"id":"4b98df5a945ea20ec148c80f048ac74c","title":"Java_Learning(Week2)","content":"变量是什么？变量是计算机编程中的一个基本概念，用于存储和表示数据。变量是程序中用来保存数据的一种标识符，它可以是数字、文本、对象或任何其他数据类型的值。通过给变量赋值，程序可以在运行过程中存储、操作和使用数据。\n数据类型在Java中，变量可以分为以下几种主要类型：\n\n原始数据类型（Primitive Data Types）： 用于存储单一的数值，例如整数、浮点数、字符和布尔值。Java的原始数据类型包括int、double、char、boolean等。\n引用数据类型（Reference Data Types）： 用于存储对象的引用。这些变量不直接存储对象的数据，而是存储对象在内存中的地址。Java的引用数据类型包括类（Class）、接口（Interface）、数组（Array）等。\n\n原始数据类型（Primitive Data Types）：\nbyte（字节）：\n大小：8位（1字节）\n范围：-128 到 127\n用途：通常用于节省内存，存储小整数值。\n\n\nshort（短整数）：\n大小：16位（2字节）\n范围：-32,768 到 32,767\n用途：存储中等范围的整数。\n\n\nint（整数）：\n大小：32位（4字节）\n范围：-2^31 到 2^31-1\n用途：存储整数值，是最常用的整数数据类型。\n\n\nlong（长整数）：\n大小：64位（8字节）\n范围：-2^63 到 2^63-1\n用途：用于存储大整数值，通常用于需要大范围整数的情况。\n\n\nfloat（浮点数）：\n大小：32位（4字节）\n用途：存储小数值，具有单精度，通常用于科学计算和工程计算中。\n\n\ndouble（双精度浮点数）：\n大小：64位（8字节）\n用途：存储小数值，具有双精度，通常用于大多数浮点数计算。\n\n\nchar（字符）：\n大小：16位（2字节）\n范围：0 到 65,535\n用途：存储单个字符，例如字母、数字或符号。\n\n\nboolean（布尔值）：\n大小：取决于实现\n只有两个值：true 和 false\n用途：表示真假值，通常用于条件判断。\n\n\n\n引用数据类型（Reference Data Types）：引用数据类型是指对象类型，它们不直接存储数据，而是存储对对象的引用。常见的引用数据类型包括类（Class）、接口（Interface）、数组（Array）等。这些类型的变量存储的是对象的引用地址，而不是对象的实际数据。\n变量的声明与初始化为什么要声明变量？为什么要声明变量呢？声明变量是为了告诉编译器变量的名称、类型和内存分配。在Java中，声明变量有以下重要原因：\n\n类型检查： 声明变量可以让编译器检查代码中的类型错误。如果你尝试将不兼容的数据类型赋给一个已声明的变量，编译器会直接报错。\n内存分配： 声明变量让编译器知道需要为该变量分配多少内存空间。这是因为不同数据类型需要不同大小的内存来存储。\n代码可读性： 变量声明可以提高代码的可读性。通过看变量名和类型，其他开发人员可以更容易地理解代码的用途和意图。\n作用域控制： 变量的声明还确定了变量的作用域，即在哪些部分的代码中可以访问该变量。作用域规则有助于防止变量被误用或滥用。\n\n在Java中，变量的声明通常包括变量名和类型，例如：\nint age; // 声明一个整数变量\ndouble salary; // 声明一个双精度浮点数变量\nString name; // 声明一个字符串变量\n\n在声明后，可以使用赋值语句将值分配给变量，这一步称为变量的初始化，例如：\nage = 30; // 将值30赋给age变量\nsalary = 50000.0; // 将值50000.0赋给salary变量\nname = \"Jin\"; // 将字符串\"Jin\"赋给name变量\n\n什么是变量的初始化？变量的初始化是指在声明变量的同时给它一个初始值。在Java中，可以选择性地在声明时初始化变量，也可以在稍后的代码中初始化。如果不初始化变量，它们将具有默认值，这取决于变量的数据类型。例如，int类型的变量默认初始化为0，boolean类型的变量默认初始化为false，Object类型的变量默认初始化为null。\n声明变量的要求\n变量名称规则： 变量的名称必须遵循一定的命名规则。变量名称可以包含字母、数字、下划线（_）和美元符号（$），但必须以字母、下划线或美元符号开头，不能以数字开头。变量名称区分大小写，即myVariable和myvariable是不同的变量名。\n关键字冲突： 变量名称不能与Java的关键字（保留字）相同。例如，不能使用关键字int作为变量名。\n合法标识符： 变量名称必须是合法的标识符。这意味着变量名称不能包含空格、特殊字符（如@、#、%等），也不能是Java中已经定义的类名、方法名等标识符。\n类型声明： 变量的声明必须包括其数据类型。数据类型确定了变量可以存储的数据种类和范围。例如，int、double、String等都是合法的数据类型。\n唯一性： 在同一个作用域内，变量名必须是唯一的。不能在同一作用域内声明两个同名的变量。\n声明语法： 变量的声明语法为：数据类型 变量名;。例如，int age;声明了一个整数类型的变量名为age。\n\n什么是包装类？课件当中还提到了一个难以理解的概念，就是包装类（Wrapper Class），如果目前无法理解其实无所谓，在后续的泛型部分应该会详细讲，这里我就提一下。\n在Java中，每种原始数据类型都有对应的包装类（Wrapper Class），用于将原始数据类型封装成对象。这些包装类提供了一些额外的功能，例如在集合类中存储原始数据类型的值，以及执行一些与对象相关的操作。以下是原始数据类型和其对应的包装类：\n\n\n\n\n\n\n\n\n\n对象的概念很重要，但是要理解也非常的抽象，需要长时间的感觉，所以我会在后面的笔记中渗透一些面向对象的内容，理解什么是对象，什么是面向对象。\n\n\n\n原始数据类型\n对应的包装类\n\n\n\nbyte\nByte\n\n\nshort\nShort\n\n\nint\nInteger\n\n\nlong\nLong\n\n\nfloat\nFloat\n\n\ndouble\nDouble\n\n\nchar\nCharacter\n\n\nboolean\nBoolean\n\n\n包装类的用处这一段我去找的资料，看个乐就行，反正现在看不懂非常正常。\n\n将原始数据类型转换为对象： 原始数据类型是基本的数据类型，不能直接用于面向对象编程（OOP）。包装类允许将原始数据类型封装成对象，从而可以在对象上执行各种操作。\n在集合中存储原始数据类型： Java集合（如ArrayList、HashMap等）只能存储对象，而不能存储原始数据类型。包装类使得可以将原始数据类型的值存储在集合中，因为它们都是对象。\n提供额外的功能和方法： 包装类提供了许多有用的方法，这些方法可以用于执行各种操作，如转换为字符串、比较、数学运算等。这些方法使得在处理数据时更加灵活和方便。\n处理空值（null）： 包装类可以存储null值，这在某些情况下非常有用，例如表示缺失数据或处理可能为null的情况。\n支持泛型（Generics）： 在泛型代码中，只能使用对象类型，而不是原始数据类型。包装类允许您在泛型类中使用原始数据类型的值。\n与其他API的兼容性： 某些Java API和库只接受对象作为参数，这时您需要使用包装类将原始数据类型封装成对象以便与这些API进行交互。\nJava反射： 反射是一种机制，可以在运行时检查和操作类的属性和方法。包装类使得可以通过反射机制来访问原始数据类型的信息和值。\n\n再强调一遍，看不懂无所谓的！\n如果让我用大白话来说，包装类无非是为了让Java当中的一些操作更加灵活和方便。\n类型转换在Java中，数据类型转换是将一个数据类型的值转换为另一个数据类型的过程。数据类型转换通常涉及到原始数据类型之间的转换以及对象之间的转换。Java中的数据类型转换可以分为两种类型：隐式转换（Implicit Conversion）和显式转换（Explicit Conversion）。\n隐式转换（Implicit Conversion）：隐式转换是自动进行的类型转换，不需要显式指定，通常发生在以下情况：\n\n小类型到大类型： 当将一个小范围的数据类型转换为一个大范围的数据类型时，会发生隐式转换。例如，将一个int赋值给long，或将一个float赋值给double。\n整数到浮点数： 当将整数类型转换为浮点数类型时，会发生隐式转换。例如，将int赋值给float。\n字面量常量转换： 在赋值常量字面量时，会进行隐式转换。例如，将整数字面量42赋值给long类型的变量。\n表达式中的类型提升： 在表达式中，如果包含多个操作数，它们的数据类型会自动提升到更大的数据类型，以便执行操作。这种提升也是隐式转换的一部分。\n\n隐式转换是安全的，因为它不会导致数据丢失。例如，将int转换为long不会导致数据精度损失。\n显式转换（Explicit Conversion）：显式转换需要通过强制类型转换操作符（cast）来明确指定。它通常用于以下情况：\n大类型到小类型： 当将一个大范围的数据类型转换为一个小范围的数据类型时，需要进行显式转换。这可能导致数据精度损失，因此需要程序员明确表示他们知道潜在的风险。例如，将double强制转换为int。\ndouble d = 3.14;\nint i = (int) d; // 显式转换，将double转换为int，会损失小数部分\n\n对象之间的转换： 当需要将一个对象从一种类转换为另一种类时，需要进行显式转换。这需要使用强制类型转换操作符，并确保类型之间存在继承关系或实现关系。\n// 显式将父类引用转换为子类引用\nParentClass parent = new ChildClass();\nChildClass child = (ChildClass) parent; // 显式转换\n\n字符到整数的转换： 当需要将字符类型（char）的字符表示为其对应的Unicode码点时，需要进行显式转换。\nchar c = 'A';\nint unicode = (int) c; // 显式转换，将字符'A'转换为Unicode码点65\n\n总结一下就是，显式转换别乱用，比较容易出错的，隐式转换JVM都帮你完成了，你只需要操点心就行。\n什么是转义符？看了看我们的课件，第一周的Lab和后面的一些练习当中就出现了转义符的相关知识，那就来了解一下好了。\n在计算机编程中，转义符是一种特殊字符，通常用来表示一些特殊的字符或控制字符序列。转义符以反斜杠符号（\\）开头，后跟一个或多个字符，用于表示不容易直接输入或显示的字符。转义符的主要目的是允许你在字符串或字符常量中插入特殊字符，或者执行某些控制操作。\n以下是一些常见的转义符及其用途：\n\n\\n： 表示换行符，用于在文本中创建新的一行。\n\\t： 表示制表符，用于在文本中创建水平制表符（通常用于缩进文本）。\n\\r： 表示回车符，用于将光标移到行的开头。\n\\b： 表示退格符，用于删除光标前的字符。\n\\f： 表示换页符，通常在控制打印机输出时使用。\n\\： 表示反斜杠自身，用于在字符串中插入反斜杠字符。\n‘： 表示单引号字符，用于在字符常量中插入单引号。\n“： 表示双引号字符，用于在字符串中插入双引号。\n\\uXXXX： 表示Unicode转义序列，其中XXXX是一个四位十六进制数，用于表示特定的Unicode字符。例如，\\u0041表示字符’A’。\n\n使用转义符可以在字符串中插入特殊字符，从而实现格式化文本、创建多行文本、处理特殊字符等目的。例如，要创建一个包含换行的多行字符串，可以使用\\n转义符，如下所示：\nString multiLineString = \"This is the first line.\\nThis is the second line.\";\nSystem.out.println(multiLineString);\n\n或者你要是想要在打印输出的时候输出双引号本身，你就可以在需要输出的双引号前加上\\。\npublic static void main(String[] args) {\n\t\tSystem.out.println(\"Hello world!\");\n        System.out.println(\"\\\"Hello world!\\\"\");\n    }\n\n最后就会输出\nHello world!\n\"Hello world!\"\n\n所以其实没啥重要的知识，忘了自己上网查就好。\n良好的编程习惯！这一部分非常的重要，好的习惯养成就是在最开始学习编程的时候养成的，不然后续很多的坏习惯可能会导致团队协作，项目开发，版本维护等等等问题，所以这一部分还是挺重要的。\n我们的最终的目的是可以编写优雅的代码，什么样子的代码可以称得上优雅？\n\n有意义的变量名： 变量名应该能清晰地表达变量的用途和含义。避免使用单个字母或无意义的缩写。例如，使用totalAmount而不是amt，使用customerName而不是cn。尤其是很多国人，千万不要用拼音来，其实拼音还好，最怕的是用拼音缩写，真的逆天，记住一定要让别人和你自己都能看懂，为什么说你自己呢？因为在编程当中有一句话：“刚写完的代码只有我和上帝看得懂，一周后，只有上帝看得懂。。。”如果养成了良好习惯，就能极大程度的避免这一点，并且后期工作一般是很多人来维护同一个项目，如果你的变量名很抽象，很容易导致团队合作的脱节。\n注释： 使用注释来解释代码的意图和关键部分，但不要过度注释。注释应该是清晰、简洁、易于理解的。及时更新注释以反映代码的变化。我平时最讨厌两种人，一种是让我加注释的，另一种是不让我加注释的XD。\n缩进和格式化： 使用一致的缩进和代码格式化规范，以增加代码的可读性。使用空格或制表符进行缩进，选择一种风格并保持一致。一定要缩进，一定要换行！不然问别人问题别人都不想给你看。\n函数和方法： 函数和方法应该短小而专注于单一任务。遵循单一职责原则（SRP）。使用有意义的函数名，并确保函数的命名与其功能一致。记住，一个函数或者方法只干一件事，实现功能的时候一定是越细化越好，现在可能看不出来，但是一旦到了大型项目，这样的好处就体现出来了，可以快速定位bug，快速针对功能进行更新，修改，删除。\n避免魔法数值： 避免在代码中直接使用未经解释的魔法数值。使用常量或枚举类型来表示这些数值，并为其命名以提高代码的可维护性。魔法数值就是直接把一个数字写到代码里面，这会非常的致命。\n异常处理： 始终处理可能引发异常的情况。不要忽略异常或简单地将其抛出。使用try-catch块或throws声明来处理异常。等我们学到异常之后就能理解了，现在可以先不用管。\n代码复用： 遵循”不要重复自己”（DRY）原则，将常用的代码块提取到函数、方法或类中以便复用。\n代码测试： 编写单元测试来验证代码的正确性。自动化测试可以帮助及早发现和修复问题。每次写完一个部分，或者一个小功能时候养成一个习惯针对这一部分写几个测试用例来验证一下，可以有效降低bug率。\n版本控制： 使用版本控制系统（如Git）来跟踪代码的历史记录和更改。提交代码前进行代码审查。\n命名约定： 遵循命名约定，例如Java中的驼峰命名法（camelCase），以及类名以大写字母开头等。\n文档化： 编写文档来描述项目、模块、函数和方法的用法和API。这有助于其他开发人员理解和使用你的代码。\n性能考虑： 在编写代码时考虑性能问题，但不要过度优化。只有在有明确性能问题时才进行优化。采访过一位大佬，代码的易读性&gt;代码的性能。\n安全性： 注意代码的安全性，避免常见的安全漏洞，如SQL注入、跨站脚本（XSS）等。\n错误处理： 考虑错误处理策略，包括日志记录和向用户提供有用的错误信息。\n持续学习： 不断学习新的编程技术和最佳实践，保持对编程世界的好奇心和进取心。\n\n","slug":"Java-Learning-week2","date":"2023-09-18T13:14:43.000Z","categories_index":"","tags_index":"笔记,Java初学","author_index":"General_K1ng"},{"id":"b6ddc4ee88d4afe7e2e1051d594b4d83","title":"Java_Learning(Week 1)","content":"整理CPT111这门课程（Java Programming）的一些笔记，从最简单的开始，不是简单的翻译，但是还是会以学校进程和教材为主。\n选择一个趁手的IDE在我们选择IDE前，容我先简单介绍一下什么是IDE，为什么我们需要IDE。\n什么是IDE？IDE是集成开发环境（Integrated Development Environment）的缩写。是一种软件应用程序，旨在帮助程序员编写、调试和管理他们的代码项目。IDE为开发者提供了一套工具和功能，使他们更轻松地进行软件开发工作。以下是IDE的一些主要特点和功能：\n\n代码编辑器：IDE包含一个文本编辑器，用于编写源代码。这个编辑器通常会提供语法高亮显示、自动完成、代码格式化等功能，以帮助程序员编写更高效和规范的代码。\n编译器和解释器：IDE集成了编译器（对于编译型语言）或解释器（对于解释型语言），可以将源代码转换为可执行的程序或直接执行代码。这使得程序员可以更轻松地检查代码的语法错误和逻辑错误。\n调试器：IDE通常包含一个强大的调试器，用于帮助程序员识别和修复代码中的错误。调试器允许程序员逐步执行代码、查看变量的值，并在运行时检测问题。\n项目管理工具：IDE允许程序员创建和管理代码项目。这包括创建、打开、保存和组织文件和文件夹，以及管理依赖项和库。\n版本控制集成：许多IDE集成了版本控制工具，如Git，以便程序员能够更轻松地跟踪和管理代码的版本历史。\n自动化构建工具：IDE通常包含自动构建工具，可以自动构建和部署代码项目，减少了手动操作的需求。\n代码分析工具：IDE可以提供代码分析和性能分析工具，帮助程序员识别潜在的性能瓶颈和代码质量问题。\n集成开发环境：IDE将上述所有功能整合在一个统一的界面中，使程序员能够在一个环境中进行所有开发活动，提高了工作效率。\n\n我们为什么需要IDE？总结两个字，方便！方便就完事了，理论上你完全可以用电脑自带的笔记本进行代码的书写，但是我相信没有人会这么干，趁手的IDE可以大幅度提升你的开发效率和开发质量，并且可以帮助你更好的后期维护和debug(虽然这往往和IDE没有多大关系)。\n安装IDEAIntelliJ IDEA（通常称为IDEA）是一款由JetBrains开发的强大集成开发环境（IDE），主要用于Java、Kotlin和其他编程语言的开发。它具有许多优点，如智能代码编辑、强大的代码导航、集成的构建工具、版本控制、调试器和丰富的插件生态系统等。下面是安装IntelliJ IDEA的详细步骤：\n安装IntelliJ IDEA：\n\n下载IntelliJ IDEA： 前往JetBrains官方网站（ https://www.jetbrains.com/idea/download/ ），  选择适用于您操作系统的版本（Windows、macOS、Linux）并下载Community Edition（免费版本）或Ultimate Edition（付费版本）。初学者完全使用社区版本完全就够用了，虽然我们学校提供了教育免费版，如果不嫌麻烦的话也可以。\n安装JDK： IntelliJ IDEA需要Java Development Kit (JDK) 才能运行。虽然目前我知道好像IDEA可以自己给你装JDK，并且有很完备的版本管理，非常方便。\n安装IntelliJ IDEA：\n在Windows上，运行下载的安装程序（.exe文件）并按照提示进行安装。\n在macOS上，将下载的IntelliJ IDEA文件拖到“应用程序”文件夹中。\n在Linux上，解压下载的文件并运行idea.sh脚本。\n\n\n启动IntelliJ IDEA： 打开安装好的IntelliJ IDEA应用程序。\n激活或注册：\n如果你选择Ultimate Edition，并且有有效的许可证，可以直接输入许可证信息激活。\n如果你选择Community Edition，它是免费的，无需激活。\n\n\n配置首选项： 在首次运行IDEA时，您可以根据您的偏好配置IDEA的外观、主题、插件等设置。\n\n一些基本的设置自己上网搜索，比如字体，主题之类的，这里不作详细介绍。\n为什么不用学校推荐的NetBeans?我觉得难用，就是这么简单，难用，而且后续很多的企业开发当中基本上公司配备的Java用的IDE都是IDEA，你也不想特立独行吧？（\n打出你的第一句Hello Word！为什么要打出Hello World？别问，问就是传统。\n创建新项目\n打开IntelliJ IDEA。\n在欢迎屏幕上，选择 “Create New Project”（创建新项目）。\n\n\n\n配置项目\n在 “Project name”（项目名称）字段中输入您的项目名称，例如 “CPT111”。\n在 “Project location”（项目位置）字段中选择您要保存项目的文件夹位置。\n选择JDK，没有JDK就用IDEA给你装一个，免去了复杂的环境配置。\n点击 “Finish”（完成）。\n\n创建后的界面如下：\n\n运行其实这个默认的Main方法就是最普通的HelloWorld了，对着这个代码直接右键运行就好。\n\n简单解释一下代码与非常简单的Python不同，Java的 Hello World 令人有些费解，但是不急，逐行分析一下\npublic class Main {\n    public static void main(String[] args) {\n\n        System.out.println(\"Hello world!\");\n    }\n}\n\n\npublic：这是一个访问修饰符，表示这个类是公共的，可以从其他类中访问。在Java中，类通常会被声明为public、private或protected，以控制其可见性。\nclass：这个关键词用于定义一个类。在Java中，所有的代码都必须位于类中，这是面向对象编程的基本概念。\nHelloWorld：这是类的名称，通常类名的第一个字母大写。类名必须与文件名相匹配，并且在Java中，每个程序都必须包含至少一个类，其中一个类必须包含一个main方法，作为程序的入口点。\n{ 和 }：这些大括号用于定义类的开始和结束，以及方法的开始和结束。在Java中，大括号用于组织代码块。\npublic static void main(String[] args)：这是一个特殊的方法，叫做main方法。它是Java程序的入口点，当程序运行时，会从main方法开始执行。让我们来解释main方法的各个部分：\npublic：同样是访问修饰符，表示main方法是公共的，可以从其他类中访问。\nstatic：这是一个关键词，表示main方法是静态的，可以在不创建类的实例的情况下调用。\nvoid：这是返回类型，表示main方法不返回任何值。\nmain：这是方法的名称，Java程序会从这里开始执行。\n(String[] args)：这是方法的参数列表。在这里，main方法接受一个字符串数组作为参数，通常用来接收命令行参数。\n\n\nSystem.out.println(\"Hello, World!\");：这是main方法中的一行代码，用于在控制台上打印文本消息。让我们分解这行代码：\nSystem：这是一个类，代表了Java的系统资源和标准输入/输出。\nout：这是System类的一个静态成员，代表标准输出流。\nprintln：这是一个方法，用于将文本输出到标准输出流，并在最后自动添加一个换行符。\n\"Hello, World!\"：这是要打印的文本消息，包含在双引号中。\n\n\n\n如果这上面的你都不能理解，也别急，你只要知道System.out.println(\"Hello world!\")这一句是输出就好，也就是打印。\n","slug":"Java-Learning","date":"2023-09-18T08:56:41.000Z","categories_index":"","tags_index":"笔记,Java初学","author_index":"General_K1ng"},{"id":"f742bd6c1e232d7ef58dbc0bfbd5e353","title":"核方法","content":"核方法（Kernel Methods）“Kernel methods”（核方法）是机器学习领域中一类重要的算法和技术，它们主要用于处理非线性问题和高维数据。核方法在分类、回归和聚类等任务中具有广泛的应用，并在支持向量机（Support Vector Machines，SVM）等算法中发挥着关键作用。\n线性可分 vs. 线性不可分在介绍核方法之前，让我们先了解一下线性可分和线性不可分的概念：\n\n线性可分：在一个二分类问题中，如果可以通过一条直线（在二维空间中）或一个超平面（在高维空间中）将两类样本完美地分开，那么我们称该问题是线性可分的。\n线性不可分：如果两类样本在特征空间中不能被一条直线或一个超平面完美地分开，那么我们称该问题是线性不可分的。\n\n在传统的机器学习中，对于线性可分的问题，我们可以使用线性分类器（如感知机、逻辑回归、线性SVM等）来解决，它们在处理线性问题上表现良好。但对于线性不可分的问题，传统的线性分类器就会遇到困难，因为它们无法在原始的特征空间中找到合适的线性边界。\n核方法的核心思想是通过一个数学技巧，将原始的特征空间映射到一个更高维度的特征空间，使得在新的高维空间中，数据在某种意义上变得线性可分。这个数学技巧就是所谓的“核函数”。\n核函数是一种特殊的函数，它可以计算在高维特征空间中两个样本之间的相似度。通过核函数，我们可以在不显式计算高维特征空间中的数据点的情况下，直接在原始的低维特征空间中进行计算，从而大大节省了计算资源。\n一旦我们得到了在高维特征空间中的相似度，我们可以使用线性分类器（如线性SVM）来找到一个超平面，将样本分开。在原始的低维特征空间中，这个超平面对应于一个非线性边界，从而实现了对线性不可分问题的有效处理。\n常用的核函数包括线性核、多项式核、高斯核（径向基核函数），它们分别对应着不同的映射函数。通过选择适当的核函数，我们可以将核方法应用于不同类型的数据，并取得良好的分类性能。\n特征图（Feature Maps）在机器学习和核方法的上下文中，**”特征地图”（Feature Map）**是一个重要的概念，它与核函数密切相关。\n在介绍特征地图之前，我们先回顾一下核方法的基本思想：核方法通过使用核函数将原始的低维特征空间映射到一个高维特征空间，使得数据在高维空间中可能是线性可分的，然后在高维空间中使用线性分类器来处理原始的非线性问题。\n特征地图是与核函数对应的映射函数。具体地说，核函数  可以计算原始特征空间中两个样本  和  在高维特征空间中的内积（或称为相似度），即 ，其中  是特征地图函数。\n换句话说，给定一个核函数 ，我们可以找到一个特征地图函数 ，使得 。这样，我们就可以通过核函数的计算结果来隐式地得到样本在高维特征空间中的内积，而无需直接计算映射后的高维特征。\n举例来说，如果我们使用高斯核函数（径向基核函数），其形式为 ，那么相应的特征地图函数就是 。在这里，样本在高维特征空间中的内积  可以通过计算核函数  得到，而无需直接计算  和 。\n特征地图的引入使得核方法具有高效处理高维特征空间的能力，因为我们无需显式地计算映射后的高维特征，而只需计算核函数的结果。这在处理复杂的非线性问题时非常有用，因为在高维空间中，数据可能更容易线性可分，从而提高了分类和回归等任务的性能。\n举例回顾我们关于线性回归的讨论，我们考虑了从房屋的居住面积（用表示）预测房屋价格（用表示）的问题，并且将一个的线性函数拟合到训练数据。但是，如果价格可以更准确地表示为的非线性函数呢？在这种情况下，我们需要比线性模型更具表现力的模型族。\n我们开始考虑拟合三次函数 。实际上，我们可以将这个三次函数视为另一组特征变量的线性函数（如下所定义）。具体地说，令函数  定义为：这个函数将输入  映射成一个包含四个新的数字的向量。我们可以看到，这些数字分别是  和 。所以，当我们把房屋面积  输入到函数  中，我们得到一个新的向量，比如对于某个具体的房屋面积 ，我们会得到 。\n现在让我们来理解为什么这组数字又把房屋面积问题转换成了线性问题。原始问题是要预测房屋价格 ，它与房屋面积  之间的关系可能是一个复杂的三次函数。但是，当我们使用特殊的函数  将房屋面积  映射成新的特征向量  时，我们得到了一个新的问题。\n新问题是：如何用参数向量  中的四个数字  来表示房屋价格与新特征向量  之间的关系？换句话说，我们想找到一个线性模型来拟合这组新的特征。\n这个新的问题是线性的，因为我们的目标是找到四个数字 ，使得房屋价格  可以通过  来近似表示。这里的  表示参数向量  的转置， 是特征向量。所以这就变成了一个线性模型：我们只需要找到合适的  来使得  与房屋价格  尽可能接近即可。\n让 表示包含  的向量。那么我们可以将  的三次函数重写为：其中  是新的特征变量。因此， 的三次函数可以视为基于  的线性函数。为了区分这两组变量，在核方法的背景下，我们将“原始”输入值称为问题的输入属性（在本例中是 ，即房屋面积）。当原始输入映射到一组新的量  时，我们将称这些新的量为特征变量。（不幸的是，不同的作者在不同的上下文中使用不同的术语来描述这两个概念。）我们称  为特征图，它将属性映射为特征。\n通过这样的方式，我们把原始的非线性问题转化成了一个线性问题，使得我们可以用线性模型来处理这个新的特征空间。线性问题比非线性问题更容易解决，我们可以使用已知的数学方法来找到最佳的 ，从而得到一个在新特征空间中表现良好的模型。\n这就是特征地图的精妙之处：通过将原始特征映射到一个新的高维特征空间，我们可以使用线性模型来处理复杂的非线性关系，从而提高了模型的表现能力。核方法通过隐式计算高维特征空间中的内积，进一步简化了计算过程，使得在高维空间中处理问题变得高效。\n带有特征的最小均方（LMS with features）什么是带有特征的最小均方？“LMS” 是 “最小均方误差”（Least Mean Squares）的缩写。它是一种经典的优化算法，通常用于机器学习中的参数估计和模型训练。在这个算法中，我们尝试通过最小化均方误差来调整模型的参数，从而使得模型在训练数据上更好地拟合。\n“LMS with features” 指的是在 LMS 算法中使用特征来进行参数估计和模型拟合的版本。特征是用来表示数据的属性或变量，在机器学习中，我们通常会用特征来描述样本的特点，从而帮助模型理解和预测数据。\n在 “LMS with features” 中，我们假设模型的输出（或目标值）是由一组特征和模型的参数进行线性组合得到的。例如，如果我们用  表示样本的特征， 表示模型的参数，那么模型的输出可以表示为 。而 “LMS with features” 的目标就是通过最小化预测值与真实值之间的均方误差，来找到最优的参数 ，从而使得模型在训练数据上拟合得更好。\n“LMS with features” 算法通常是迭代的，它会根据预测结果和真实结果之间的误差来更新模型的参数。在每一次迭代中，模型会根据当前参数预测输出，并计算预测值与真实值之间的差距。然后，根据这个差距，算法会通过一定的学习率来调整参数的值，使得预测结果逐渐趋近于真实结果。\n这种算法被广泛用于线性回归和神经网络等机器学习模型的训练过程中。通过使用特征来表示数据，LMS 可以根据数据的特点来调整模型的参数，从而更好地适应不同的问题和数据集。\n推导我们将推导出用于拟合模型 的梯度下降算法。首先回忆一下，对于普通的最小二乘问题，我们要拟合 ，批量梯度下降的更新公式为（参见第一节课笔记以获取其推导）：在这里，每个变量的含义如下：\n\n 是我们要优化的参数向量，它用来拟合模型 。\n 是第  个训练样本的特征向量。\n 是第  个训练样本的真实标签或目标值。\n 是模型的预测值，即 。\n\n接下来，我们引入一个特征映射 ，它将属性 （在  中）映射到特征 （在  中）。这样，我们的目标就是拟合函数 ，其中  是  中的向量，而不是 。\n为了在特征映射下进行参数更新，我们将算法中所有出现的  替换为 ，得到新的参数更新公式：在这个公式中，每个变量的含义如下：\n\n 是我们要优化的参数向量，它用来拟合模型 。\n 是第  个训练样本在特征映射下的特征向量。\n 是第  个训练样本的真实标签或目标值。\n 是模型的预测值。\n\n这个新的更新公式可以用于梯度下降算法中的每一步迭代，以更新参数 ，从而逐渐使模型在训练数据上拟合得更好。特别地，如果我们使用随机梯度下降算法，即每次只用一个样本进行更新，更新规则变为：这样我们就得到了用于拟合模型  的梯度下降算法。这个算法在机器学习中非常常用，特别是在支持向量机（SVM）等模型中，它们使用了核方法和特征映射来处理非线性问题。\n举例当我们想预测房价时，最初使用了简单的线性模型 ，其中  是房屋的居住面积， 是房价， 和  是需要学习的参数。但有时候，房价可能不仅仅与面积成线性关系，可能是一种曲线或弯曲的关系，比如更大的房屋不仅仅是线性地增长更贵，可能有更多的因素在影响房价。所以我们需要更灵活的模型来适应这种复杂的关系。\n这时候，我们可以考虑使用一个三次函数来预测房价，就像  这样的函数。但是，我们仍然希望能够使用梯度下降这样的优化算法来找到最优的参数 。\n现在问题是，我们之前的梯度下降算法是针对线性模型设计的，而现在我们的模型是三次函数。这时，我们可以通过一个特殊的函数 ，将原来的房屋面积  映射成一个新的向量 ，我们把这个向量当做新的特征来处理。这样，我们的模型变成了 ，这就是一个线性模型！\n通过这个巧妙的映射，我们把原本的非线性问题转换成了线性问题。现在我们可以使用梯度下降算法来学习参数 ，使得预测的房价  尽可能接近真实的房价 。\n更新参数的公式为：在这里， 是我们需要学习的参数向量， 是一个房屋的面积特征， 是这个房屋的真实价格。 是学习率，它控制我们在每次更新中改变参数的步长。\n通过反复迭代这个更新过程，我们的模型会逐渐学到最优的参数 ，从而能够更好地拟合房价数据。这就是梯度下降算法的一个简单应用，通过特征映射的方式，我们可以在复杂的问题中使用线性模型来得到更好的预测结果。\n","slug":"Kernel-methods","date":"2023-07-29T07:55:10.000Z","categories_index":"","tags_index":"笔记,Machine Learning","author_index":"General_K1ng"},{"id":"8dcfbd65ba007c0c6564bd13d62b9cd1","title":"文本分类的事件模型","content":"文本分类的多项式事件模型在文本分类中，我们有一个专门的模型叫做多项式事件模型，它在处理文本分类问题时表现较好。这个模型与我们之前介绍的朴素贝叶斯有些相似，但也有一些不同之处。\n问题描述我们要解决的问题是对电子邮件进行分类，判断其是垃圾邮件还是正常邮件。对于一封电子邮件，我们可以将其表示为由单词组成的向量 ，其中  是第  个单词在词汇表中的标识， 是邮件中的单词总数。\n伯努利事件模型 vs. 多项式事件模型在文本分类的特定情境中，朴素贝叶斯的形式使用了所谓的伯努利事件模型（有时称为多变量伯努利事件模型）。在这个模型中，我们假设生成一封电子邮件的方式是：首先根据类先验概率  随机确定下一封邮件是垃圾邮件还是正常邮件。然后，发送电子邮件的人遍历字典，独立地根据概率  决定是否在邮件中包含每个单词 。因此，一封邮件的概率由  给出。\n这里介绍了另一种模型，称为多项式事件模型（Multinomial event model）。为了描述这个模型，我们将使用不同的符号和特征来表示电子邮件。我们用  表示邮件中第  个单词的标识。因此， 现在是一个取值范围为  的整数，其中  是我们词汇表（字典）的大小。一封由  个单词组成的电子邮件现在用长度为  的向量  来表示；请注意，不同文档的  可以不同。例如，如果一封电子邮件以 “A NeurIPS…” 开头，则 （“a”是字典中的第一个单词），（如果“neurips”是字典中的第35000个单词）。\n多项式事件模型的生成过程在多项式事件模型中，生成一封邮件的过程是这样的：\n\n根据类别先验概率  随机确定邮件是垃圾邮件还是正常邮件。\n通过从多项式分布  生成第一个单词 。\n然后，第二个单词  独立于 ，但仍从相同的多项式分布中生成。\n依此类推，直到生成所有  个单词的邮件。\n\n详细来说，首先根据  决定是否为垃圾邮件或非垃圾邮件，与之前相同。然后，邮件的发送者通过从某个多项式分布（）生成  来撰写邮件。接下来，第二个单词  独立于  但是从相同的多项式分布中选择，对于 、 等等，都是相同的过程，直到生成邮件的所有  个单词。因此，整体的邮件概率由  给出。请注意，这个公式看起来类似于之前在伯努利事件模型下给出的邮件概率公式，但公式中的术语现在具有非常不同的含义。特别地， 现在是一个多项式分布，而不是伯努利分布。\n我们新模型的参数与之前一样：、（对于任意 ）和。请注意，我们假设对于所有  的值，是相同的（即生成一个单词的分布不依赖于其在邮件中的位置 ）。\n参数估计我们的目标是通过训练集  来估计模型的参数。对于多项式事件模型，参数包括先验概率  和条件概率 。\n为了估计这些参数，我们最大化似然函数 。其中， 是类别先验概率， 和  分别是给定类别的条件概率。使用拉普拉斯平滑来获得更好的性能，参数估计公式如下：\n类别先验概率：垃圾邮件样本数总样本数\n条件概率：在垃圾邮件中出现的第个单词的样本数垃圾邮件中的单词总数在正常邮件中出现的第个单词的样本数正常邮件中的单词总数\n如果我们有一个训练集 ，其中  （这里， 是第  个训练样本中的单词数），数据的似然函数可以表示为：通过最大化这个似然函数，我们可以得到参数的最大似然估计：如果我们在估计和时应用拉普拉斯平滑（在实践中需要以获得良好的性能），我们将在分子中加1，在分母中加上，从而得到：\n朴素贝叶斯分类器尽管朴素贝叶斯分类器不一定是最优的分类算法，但由于其简单性和易于实现，通常在文本分类问题中表现出令人惊讶的良好效果。因此，它经常作为首选尝试的算法之一。\n通过以上的多项式事件模型和参数估计，我们可以构建一个朴素贝叶斯分类器，用于文本分类任务。希望这样的改写能够让您更好地理解文本分类问题及其相关模型。如果还有其他问题或需要进一步解释，请随时问我！\n","slug":"Event-models-for-text-classification","date":"2023-07-29T06:54:26.000Z","categories_index":"","tags_index":"笔记,Machine Learning","author_index":"General_K1ng"},{"id":"8b18e271b14b3d6ddbc293dffc4eb5b3","title":"拉普拉斯平滑","content":"解决稀疏数据问题：拉普拉斯平滑当我们用机器学习构建垃圾邮件过滤器时，朴素贝叶斯算法是一个强大的工具。然而，在实践中应用该算法时，我们可能会遇到一个小问题，那就是稀疏数据问题。\n稀疏数据问题是什么？稀疏数据问题出现在我们有大量特征，但某些特征在训练集中很少出现，甚至有些特征在某类邮件中根本没有出现。这就像探险家在茫茫大草原上追踪狼群，但是草原上的脚印却非常零散，有些地方甚至一点踪迹都没有。\n解决方案：拉普拉斯平滑为了解决这个问题，我们引入了拉普拉斯平滑（Laplace Smoothing）。这就像是在草原上找到了一种神奇的踪迹增强剂，让我们能够更好地跟踪狼群一样！\n在朴素贝叶斯算法中，我们需要估计特征在某个类别下的条件概率。在稀疏数据情况下，有些特征在训练集中可能没有出现，导致概率估计为零。为了避免这种情况，我们采用拉普拉斯平滑来平滑概率估计。\n改进朴素贝叶斯算法尽管朴素贝叶斯算法在许多问题上表现不错，但在某些特定情况下，特别是在文本分类任务中，它可能面临一些问题。让我们简要讨论当前形式下算法存在的问题，并探讨如何通过一种简单的改进来提高其性能。\n问题：稀疏数据假设我们在进行垃圾邮件/电子邮件分类问题，并且要使用朴素贝叶斯算法来进行分类。在假设情景中，你完成了CS229课程并在项目中取得优秀成绩，决定在20xx年5月20日前将你的工作提交给NeurIPS学术会议进行发表。由于你在邮件中讨论了该学术会议，你开始收到带有“neurips”一词的消息。但这是你的第一篇NeurIPS论文，直到此时为止，你之前没有收到过包含“neurips”一词的邮件；尤其是“neurips”一词从未出现在你的垃圾邮件/非垃圾邮件训练集中。假设“neurips”是词典中的第35000个单词，那么你的朴素贝叶斯垃圾邮件过滤器因此选择了参数φ_{35000|y}的最大似然估计为：这意味着因为在垃圾邮件或非垃圾邮件的训练示例中从未见过“neurips”，它认为在任何一类邮件中看到该单词的概率都是零。因此，当尝试判断一个包含“neurips”的消息是否为垃圾邮件时，它计算了类别的后验概率，并得到：这是因为每个术语“”都包含一个的项，这个项被乘到其中。因此，我们的算法得到了的结果，并且无法进行预测。\n更广泛地说，因为在有限的训练集中没有见过某个事件，将其概率估计为零是一个统计上不好的做法。考虑对取值在的多项式随机变量的均值进行估计的问题。我们可以用来参数化我们的多项式分布。给定一组独立的观测值，最大似然估计为：\n解决方案：拉普拉斯平滑如上所述，如果我们使用这些最大似然估计，一些的值可能为零，这是个问题。为了避免这种情况，我们可以采用拉普拉斯平滑，用以下估计代替：在这里，是特征可能的取值个数，是训练样本总数。\n在这里，我们在分子上加了，在分母上加了。请注意，仍然成立（请自行验证！），这是一个希望得到的性质，因为是我们知道必须总和为的概率的估计值。而且，对于所有的值，不等于，解决了概率被估计为零的问题。在某些（可以说相当强的）条件下，可以证明拉普拉斯平滑实际上给出了的最优估计器。\n拉普拉斯平滑的优点是对所有特征都给予了一个非零的概率估计，避免了概率为零的问题。这样，即使某个特征在训练集中没有出现，它仍然有一个较小但非零的概率估计，不会影响到后续的概率计算。\n考虑回到我们的朴素贝叶斯分类器，并应用拉普拉斯平滑，我们可以得到以下参数的估计值：请注意，对于是否应用拉普拉斯平滑通常并不重要，因为我们通常会有相当数量的垃圾邮件和非垃圾邮件，所以将是的一个合理估计值，并且通常会远离0。\n通过拉普拉斯平滑，我们能够更好地解决稀疏数据问题，并使得朴素贝叶斯算法在文本分类等任务中表现得更加优秀。\n","slug":"Laplace-smoothing","date":"2023-07-29T06:21:21.000Z","categories_index":"","tags_index":"笔记,Machine Learning","author_index":"General_K1ng"},{"id":"060cf84ea8728915ecf4c659557a0907","title":"朴素贝叶斯","content":"机器学习中的文本分类在GDA中，特征向量是连续的实值向量。现在我们来讨论另一种学习算法，其中是离散值。\n在机器学习中，我们经常遇到特征是离散值的情况，这里我们来讨论这种情况。举个例子，我们打算用机器学习构建一个电子邮件垃圾邮件过滤器。这个过滤器的任务是判断一封电子邮件是否是垃圾邮件，然后自动将其过滤到专门的垃圾邮件文件夹里。这个问题属于文本分类的范畴，而文本分类又是一个更大问题集的一部分。\n特征表示方式我们假设我们有一个训练集（一组被标记为垃圾邮件或非垃圾邮件的电子邮件）。我们将通过指定用于表示邮件的特征  来构建我们的垃圾邮件过滤器。\n我们将通过一个特征向量来表示一封电子邮件，其长度等于字典中的单词数。具体地，如果一封电子邮件包含字典中的第  个单词，则我们将设置 ；否则，我们设置 。例如，向量表示的一封电子邮件可能如下所示：该特征向量用于表示包含单词“a”和“buy”，但不包含“aardvark”，“aardwolf”或“zygmurgy”的电子邮件。所编码到特征向量的单词集合称为词汇表，因此特征向量 x 的维度等于词汇表的大小。例如，如果词汇表包含1000个单词，那么特征向量  的维度将是1000。在这种表示下，我们可以通过特征向量来表示每封电子邮件中包含哪些特定的单词。\n\n\n\n\n\n\n\n\n\n在实际应用中，我们通常不会查阅完整的英语字典来获取所有可能的单词列表。而是根据训练集来确定特征向量中的单词。通常只将在训练集中至少出现一次的单词加入特征向量。这样可以减少建模所需的单词数量，降低计算和空间需求。此外，一些高频的“内容无关”单词（如 “the”, “of”, *”and”*）也会被排除，因为它们对判断电子邮件是否是垃圾邮件没有太大帮助。这些高频单词被称为停用词（stop words）。\n朴素贝叶斯分类器现在我们需要构建一个生成模型来对条件概率  建模。但如果我们的词汇表有50000个单词，那么特征向量 ，也就是一个由0和1组成的50000维向量。如果我们想用多项式分布来显式建模 ，那么可能的结果有个，参数数量将非常庞大。\n为了简化建模，我们做出了一个非常强的假设，称为朴素贝叶斯（Naive Bayes）假设。假设在给定  的条件下，所有的  是条件独立的。这样，我们得到了朴素贝叶斯分类器。举个例子，如果  表示垃圾邮件；”buy” 对应单词编号2087，而”price” 对应单词编号39831。那么我们假设在已知 （某封电子邮件是垃圾邮件）的情况下，是否知道 （是否包含”buy”）对于判断 （是否包含”price”）是无关的。更形式化地，我们可以写成 。（注意，这不是说  和  是独立的，而是说在给定  的条件下， 和  是条件独立的。）\n我们现在有：第一个等式是概率的一般性质，而第二个等式就是由朴素贝叶斯假设得到的结果。尽管朴素贝叶斯假设非常强，但由此产生的算法在很多问题上表现良好。\n参数化和最大似然估计在朴素贝叶斯算法中，我们使用一些参数来表示模型。这些参数是 ， 和 。它们的解释非常简单： 表示在垃圾邮件（）中，包含单词  的比例。\n通过给定的训练集 ，我们可以写出数据的联合似然：为了估计参数 ， 和 ，我们使用最大似然估计。也就是找到使得联合似然函数最大化的参数值。\n具体地，我们可以通过如下公式来计算参数的最大似然估计值：在上面的方程中，符号“∧”表示“与”。这些参数有一个非常自然的解释。例如，只是垃圾邮件（）中包含单词的比例。\n预测新样本的类别在拟合好这些参数后，我们可以用来预测新样本的类别。假设我们有一个新样本的特征表示 ，我们希望判断它是垃圾邮件还是非垃圾邮件（还是）。\n我们可以简单地计算后验概率来进行预测：然后，我们选择具有较高后验概率的类别作为预测结果。\n处理更多离散值的情况最后，我们指出，虽然我们主要针对特征是二元值的问题开发了朴素贝叶斯算法，但对可以在，，，中取值的情况，其推广是简单的。在这种情况下，我们只需将建模为多项式而不是伯努利分布。实际上，即使某些原始输入属性（例如我们之前的例子中的房屋生活面积）是连续值的，将其离散化（即将其转换为一组小的离散值）并应用朴素贝叶斯也是相当常见的。例如，如果我们使用某个特征来表示生活面积，我们可以将连续值离散化如下：\n\n\n\nLiving area (sq. feet)\n&lt; 400\n400-800\n800-1200\n1200-1600\n&gt;1600\n\n\n\n\n1\n2\n3\n4\n5\n\n\n因此，对于一所生活面积为890平方英尺的房屋，我们将相应特征的值设置为3。然后，我们可以应用朴素贝叶斯算法，用多项式分布来建模，就像之前所描述的那样。当原始的连续值属性不适合用多元正态分布建模时，将特征进行离散化并使用朴素贝叶斯（而不是GDA）通常会得到更好的分类器。\n","slug":"Naive-bayes","date":"2023-07-24T07:28:32.000Z","categories_index":"","tags_index":"笔记,Machine Learning","author_index":"General_K1ng"},{"id":"68643f4a3340f18395afd7c596807d57","title":"高斯判别分析","content":"高斯判别分析（GDA）让我们来讨论生成学习算法中的一个重要模型——高斯判别分析（Gaussian Discriminant Analysis，简称 GDA）。在这个模型中，我们假设数据的条件概率  符合多元正态分布。在深入探讨 GDA 模型之前，我们先简要介绍一下多元正态分布的性质。\n多元正态分布在  维空间中的多元正态分布，也被称为多元高斯分布，由均值向量  和协方差矩阵  参数化，其中  是对称且半正定的。我们用  来表示这个分布，其概率密度函数如下所示：在上面的方程中，“”表示矩阵的行列式。\n对于服从  分布的随机变量 ，其均值是 ，这并不令人意外：对于一个向量值随机变量 ，协方差定义为 ，这推广了实值随机变量的方差概念。协方差也可以定义为 。（你应该能够自行证明这两个定义是等价的。）如果 ，那么：以下是一些高斯分布密度函数的示例：\n\n\n最左边的图显示的是均值为零（即2x1的零向量）且协方差矩阵（2x2的单位矩阵）的高斯分布。这个分布也被称为标准正态分布。\n中间的图显示的是均值为零且的高斯分布。\n最右边的图显示的是均值为零且的高斯分布。我们可以观察到，随着变得更大，高斯分布变得更加“扩展”，而随着变得更小，分布则变得更“压缩”。\n\n让我们看更多的例子：\n\n上面的图显示了均值为0的高斯分布，并分别显示了它们的协方差矩阵：左侧的图显示了熟悉的标准正态分布，我们可以看到随着协方差矩阵中的非对角元素增加，密度趋向于线（由给出）。当我们查看同样三个密度的等高线图时，这一点更加清晰：\n\n以下是通过变化生成的另一组示例：\n\n上面使用的图分别是:从左边和中间的图中，我们可以看到通过减小协方差矩阵的非对角元素，密度再次变得“压缩”，但是方向相反。最后，当我们更一般地改变参数时，等高线将形成椭圆（右边的图显示了一个例子）。\n作为我们最后的一组例子，我们固定，通过改变，我们可以将密度的均值移动到不同的位置。\n\n上面的数字是使用生成的，分别是\n高斯判别分析模型当我们面对一个分类问题，其中输入特征是连续值随机变量时，我们可以使用高斯判别分析（Gaussian Discriminant Analysis，GDA）模型，它使用多元正态分布来建模。该模型为：写出分布，这是：在这里，我们的模型参数是、、和。（请注意，尽管有两个不同的均值向量和，但通常使用一个协方差矩阵来应用该模型。）数据的对数似然是由以下公式给出：通过对参数最大化，我们可以找到参数的最大似然估计：从图示上看，该算法的过程如下所示：\n\n在图中显示了训练集，以及对每个类别中的数据进行拟合的两个高斯分布的等高线。注意，这两个高斯分布的等高线具有相同的形状和方向，因为它们共享协方差矩阵，但它们具有不同的均值和。图中还显示了给出决策边界的直线，该边界使得。在边界的一侧，我们将预测是最可能的结果，而在另一侧，我们将预测。\n讨论：GDA和逻辑回归GDA模型与逻辑回归之间有着有趣的关系。事实上，如果我们将  看作是  的函数，我们会发现它可以写成以下形式：\n在这里， 是 、、 和  的一些合适函数。这恰好是逻辑回归——一个判别算法——用来建模  的形式。\n\n\n\n\n\n\n\n\n\n这里使用了重新定义右侧的  的约定，通过添加额外的坐标 ，将它们变成  维向量\n那么我们什么时候更喜欢一种模型而不是另一种模型呢？一般来说，当在同一数据集上训练时，GDA和逻辑回归会给出不同的决策边界。那么哪个模型更好呢？\n我们刚刚证明了如果  是多元高斯分布（具有共享的 ），那么  必定遵循一个逻辑函数。然而，反过来并不成立；即  是一个逻辑函数并不意味着  是多元高斯分布。这表明GDA对数据做出了比逻辑回归更强的建模假设。事实上，当这些建模假设正确时，GDA将对数据拟合得更好，是一个更优的模型。特别地，当  确实是高斯分布（具有共享的 ）时，GDA是渐近有效的。简单来说，这意味着在非常大的训练集（大 n）的极限情况下，没有比GDA更好的算法（例如在准确估计  方面）。特别地，可以证明在这种情况下，GDA将优于逻辑回归；而更一般地说，即使对于较小的训练集大小，我们通常也会预期GDA更优。\n相比之下，逻辑回归通过做出明显较弱的假设，更加健壮且对错误的建模假设不太敏感。有许多不同的假设集会导致  采取逻辑函数的形式。例如，如果 ，并且 ，那么  将是逻辑函数。在这样的泊松分布数据上，逻辑回归也会表现良好。但是，如果我们在这样的数据上使用GDA，并将高斯分布拟合到这样的非高斯分布数据上，结果将变得不那么可预测，GDA可能（或者可能不会）表现良好。\n总结起来：GDA做出了更强的建模假设，在建模假设正确或近似正确的情况下更具数据效率（即需要较少的训练数据来学习得更好）。逻辑回归做出了较弱的假设，对于与建模假设的偏差更具有鲁棒性。具体而言，当数据确实是非高斯分布时，在大规模数据集的极限情况下，逻辑回归几乎总是比GDA表现更好。因此，在实践中，逻辑回归比GDA更常用。（我们接下来讨论的朴素贝叶斯算法也涉及有关判别模型与生成模型的类似考虑，但朴素贝叶斯算法仍被认为是一种非常优秀且广受欢迎的分类算法。）\n","slug":"Gaussian-discriminant-analysis","date":"2023-07-22T06:04:23.000Z","categories_index":"","tags_index":"笔记,Machine Learning","author_index":"General_K1ng"},{"id":"6e9ecff97c79fc9b7ee5419e3db98187","title":"生成式学习算法","content":"生成式学习算法：从动物外貌特征到分类预测到目前为止，我们已经讨论了一些学习算法，这些算法主要关注于建模条件分布 ，也就是在给定输入  的情况下输出  的概率分布。例如，逻辑回归使用  来建模 ，其中  是 sigmoid 函数。在这次笔记中，我们将探讨一种不同类型的学习算法。\n判别式学习算法在考虑一个分类问题时，我们希望根据动物的一些特征来学习如何区分大象 (y = 1) 和狗 (y = 0)。判别式学习算法，例如逻辑回归或感知机算法，试图找到一条直线，即决策边界，来将大象和狗分开。然后，为了对新的动物进行分类，算法会检查它在决策边界的哪一侧，并根据结果进行预测。\n生成式学习算法：全新的方法现在，我们来探讨一种全新的学习方法。首先，我们可以构建一个描述大象外貌特征的模型。然后，我们可以构建一个独立的描述狗外貌特征的模型。最后，当我们需要对一个新的动物进行分类时，我们可以将其与大象模型进行匹配，并将其与狗模型进行匹配，从而确定新动物更像我们在训练集中见过的大象还是更像狗。\n生成式学习算法 vs. 判别式学习算法刚才我们提到的直接学习  的算法（例如逻辑回归）或者直接学习从输入空间  到标签 {0, 1} 的映射（例如感知机算法），都属于判别式学习算法。而在这里，我们将讨论一类试图对条件概率 （以及类先验 ）进行建模的算法，这些算法被称为生成式学习算法。例如，对于一个表示示例是狗（0）还是大象（1）的问题， 建模了狗的特征分布，而  建模了大象的特征分布。\n从条件概率到后验概率在建模了  （称为类先验）和条件概率  之后，我们的算法可以使用贝叶斯规则来推导给定  的后验概率 ：这里，分母  由  给出（您应该能够从概率的标准性质验证这一点），因此也可以用我们已经学到的  和  的数量来表示。实际上，如果我们正在计算  以进行预测，那么我们实际上不需要计算分母，因为分母  只是用于归一化 ，以确保其概率总和为1。但由于我们只关心预测的类别，而不是具体的概率值，我们可以忽略归一化项，直接计算分子部分来得到预测的类别。\n","slug":"Generative-learning-algorithms","date":"2023-07-22T05:45:25.000Z","categories_index":"","tags_index":"笔记,Machine Learning","author_index":"General_K1ng"},{"id":"944f20daa7bfde2d1440fd8c10bf6bf0","title":"（实战）鸢尾花数据集的三分类","content":"上一章的难度相比各位估计应该也是云里雾里吧，那么这一章就来实战一下如何运用softmax回归来进行多分类吧！刚好顺便来弥补一下之前我们在对鸢尾花进行分类的时候只运用了二分类的遗憾，今天，我们就直接开始，三分类！\nSoftmax回归概念回顾首先我们先回顾一下什么是Softmax回归，它是一种用于多分类问题的分类算法，也称为多类别逻辑回归或多项逻辑回归。Softmax回归广泛用于机器学习和深度学习中，尤其在图像识别、自然语言处理和语音识别等任务上。\n简单来说，softmax回归将输入的样本通过线性变换和一个softmax函数映射为类别的概率分布。它主要包含两个步骤：\n\n线性变换：对于给定的输入样本，首先通过一个线性变换计算每个类别的得分。这个得分可以看作是输入样本属于每个类别的权重。\nSoftmax函数：然后，将得分通过softmax函数转换为概率分布。Softmax函数可以将原始得分转换为非负且和为1的概率值，这样可以表示每个类别的概率。\n\n假设我们有n个类别，对于第i个类别，它的得分为。那么Softmax函数的计算如下：其中，是指数函数，是求和函数。\n最终，输入样本属于第i个类别的概率为。可以选择概率最高的类别作为预测结果。\n在训练过程中，通常使用交叉熵损失函数来衡量预测结果和真实标签之间的差异，并通过梯度下降等优化算法来更新模型的参数，使得预测结果更接近真实情况。\n好像还是有些难懂，那再用人话来说一遍吧。\n人话版本1. 什么是分类问题？\n首先，什么是分类问题。在机器学习中，分类问题是指将事物分为不同的类别。比如，我们可以将动物分为猫、狗和鸟三个类别，或者将邮件分为垃圾邮件和非垃圾邮件两个类别。\n2. 什么是Softmax回归？\n它是一种机器学习算法，用于解决分类问题。假设我们有很多特征，比如动物的体重、体长和年龄，我们想要根据这些特征把动物分成不同的类别，比如猫、狗和鸟。Softmax回归可以帮助我们做这件事。\n3. 如何工作？\nSoftmax回归的工作方式有两个关键步骤：\n步骤一：计算得分\n对于给定的一个动物，我们会用一些数学计算得到它属于每个类别的得分。这个得分可以理解为，每个类别有多大的可能性与这个动物匹配。\n步骤二：转换为概率\n有了得分后，我们需要将它们转换成概率。概率是一个介于0到1之间的数值，表示某个动物属于某个类别的可能性有多大。Softmax回归使用一个特殊的函数，称为softmax函数，来做这个转换。它会把得分转换成概率，确保所有类别的概率加起来等于1。\n4. 如何做预测？\n在训练阶段，我们会用一堆已知类别的动物数据来让机器学习算法学习。它会通过调整一些参数来找到最佳的方式来预测动物的类别。\n然后，在预测阶段，当我们有一个新的动物数据时，我们会用训练好的模型，通过同样的计算和转换过程，得到动物属于每个类别的概率。最后，我们会选择概率最高的类别作为预测结果，就像猫、狗和鸟中选择概率最高的那个类别。\n怎么计算得分假设我们有一个分类问题，有个类别需要进行分类。对于给定的输入样本，我们会为每个类别分配一个得分（也称为logit），表示输入样本属于该类别的可能性大小。\n对于第个类别，得分的计算是通过将输入样本的特征与相应的权重进行线性组合得到的。假设输入样本有个特征（即特征向量的长度为），则该类别的得分可以表示为：其中， 是与每个特征相关联的权重， 是输入样本的特征值， 是偏置项（也称为截距项）。\n对于输入样本，我们需要为每个类别计算一个得分。\n怎么转换成概率得到每个类别的得分后，我们需要将它们转换为概率，以便进行分类。\n我们使用softmax函数来执行这个转换。对于第个类别的得分，它在Softmax函数中的概率表示为：其中，是指数函数，它会将得分转换为非负数。是求和函数，对所有类别的得分进行求和。\n通过这个计算，我们可以获得每个类别的概率。这些概率的和总是等于1，因为softmax函数的特性保证了这一点。\n最后，在预测阶段，我们选择具有最高概率的类别作为预测结果。例如，如果softmax函数给出了猫的概率为0.8，狗的概率为0.15，鸟的概率为0.05，那么我们将预测这个输入样本属于”猫”类别。\n实战开始选取模块与库那么还是老样子，选择我们应该用那些库，其实跟上次的都差不多。\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n首先，我们导入了所需的库，包括 pandas 用于数据处理，numpy 用于数值计算，matplotlib.pyplot 用于绘图，以及一些用于机器学习的模块如 train_test_split 用于数据集划分，StandardScaler 用于特征缩放，accuracy_score、confusion_matrix 和 classification_report 用于评估分类模型的性能。\n读取文件# 读取数据\ndata = pd.read_csv('iris.csv') # 你的文件路径！\n\n然后，我们使用 pandas 读取了一个名为 “iris.csv” 的数据集，该数据集包含了鸢尾花（Iris）的一些测量数据以及其所属的物种标签。\n跟上次一样的数据预处理过程，不过这一次我们还需要干一个事情就是将Species列转换成数值，使用One-hot编码。那么什么是One-hot编码呢？\nOne-hot编码在softmax回归中，我们需要将类别标签转换成一种称为One-hot编码的形式。One-hot编码是一种向量表示方法，将一个类别表示为一个向量，其中只有一个元素是1，其他元素都是0。例如，山鸢尾类别可以表示为[1, 0, 0]，变色鸢尾类别可以表示为[0, 1, 0]，维吉尼亚鸢尾类别可以表示为[0, 0, 1]。\n# 将Species列转换成数值，使用One-hot编码\ndata = pd.get_dummies(data, columns=['Species'])\n\n我们将数据集中的 “Species” 列进行了转换，并使用 One-hot 编码将其转换成了数值形式，这是因为机器学习算法通常只接受数值输入。\n数据预处理其实这一步真的跟之前二分类那一次都差不多了，无非是分离标签，分离特征，划分训练集和预测集，最后再把特征缩放一下。\n# 将特征和标签进行分离\nX = data.drop(['Species_setosa', 'Species_versicolor', 'Species_virginica'], axis=1).values\ny = data[['Species_setosa', 'Species_versicolor', 'Species_virginica']].values\n\n我们将数据集中的特征和标签进行了分离。在这个数据集中，特征是花的测量数据，而标签是表示鸢尾花所属物种的 One-hot 编码形式。\n# 将数据集划分为训练集和测试集\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n我们使用 train_test_split 函数将数据集划分为训练集和测试集。训练集用于模型的训练，测试集用于评估模型的性能。这里将数据集划分成 80% 的训练集和 20% 的测试集，并且使用 random_state 参数设置了随机种子，以确保每次划分的结果都是相同的，便于我们复现结果。\n# 特征缩放\nscaler = StandardScaler()\nX_train_scaled = scaler.fit_transform(X_train)\nX_test_scaled = scaler.transform(X_test)\n\n接着，我们对特征进行了缩放处理，这是为了确保不同特征的数值范围一致，从而避免某些特征对模型训练的影响过大。这里使用了 StandardScaler 类进行标准化处理，将特征缩放到均值为 0、方差为 1 的标准正态分布。\nSoftmax函数就是我们上面所说的那个，我在这里再放一下：我们翻译成代码就是\n# 定义Softmax函数\ndef softmax(scores):\n    exp_scores = np.exp(scores - np.max(scores, axis=1, keepdims=True))\n    return exp_scores / np.sum(exp_scores, axis=1, keepdims=True)\n\n定义 Softmax 函数，这是一个常用的激活函数，用于将模型输出转换为类别概率。它将原始的线性输出（也称为 “scores“）转换为一个概率分布，确保所有概率值在 0 到 1 之间，并且它们的和等于 1。这里的实现避免了数值不稳定性问题，通过减去每个样本的最大分数，可以使指数运算更稳定。\n损失函数：交叉熵这里我们需要再定义一个函数，我们称之为交叉熵函数，为了训练模型，我们需要定义一个损失函数来衡量预测结果和真实标签之间的差异。在softmax回归中，我们使用交叉熵损失函数来衡量预测概率和真实标签之间的距离。我们的目标是最小化交叉熵损失函数，使得模型的预测尽可能接近真实情况。\n# 定义交叉熵损失函数\ndef cross_entropy_loss(y_true, y_pred):\n    num_samples = y_true.shape[0]\n    log_likelihood = -np.log(y_pred[range(num_samples), np.argmax(y_true, axis=1)])\n    loss = np.sum(log_likelihood) / num_samples\n    return loss\n\n交叉熵是常用的分类问题损失函数，它通过计算模型输出概率与真实标签之间的差异来评估模型性能。这里的实现使用了 NumPy 数组运算，避免了显式的循环操作，提高了计算效率。\n训练函数这一步，我们需要使用我们的老朋友梯度下降算法来优化模型参数（权重和偏置）。梯度下降算法会根据损失函数的梯度方向，逐步更新模型的参数，以使损失函数逐渐减小。\n通过迭代训练过程，我们的模型将学习如何将输入样本映射到合适的类别，并且我们可以使用训练好的模型进行预测。\n# 定义训练函数\ndef train_softmax_regression(X, y, learning_rate, epochs):\n    num_samples, num_features = X.shape\n    num_classes = y.shape[1]\n\n    # 初始化权重和偏置\n    W = np.random.randn(num_features, num_classes)\n    b = np.zeros((1, num_classes))\n\n    # 记录每个epoch的损失\n    losses = []\n\n    for epoch in range(epochs):\n        # 前向传播\n        scores = np.dot(X, W) + b\n        probabilities = softmax(scores)\n\n        # 计算损失\n        loss = cross_entropy_loss(y, probabilities)\n        losses.append(loss)\n\n        # 反向传播\n        error = probabilities - y\n        dW = np.dot(X.T, error) / num_samples\n        db = np.sum(error, axis=0, keepdims=True) / num_samples\n\n        # 参数更新\n        W -= learning_rate * dW\n        b -= learning_rate * db\n\n    return W, b, losses\n\n我们定义了训练函数 train_softmax_regression。该函数使用批量梯度下降法来训练 Softmax 回归模型。在训练过程中，我们根据损失函数的梯度更新模型的权重和偏置，不断优化模型以使其更好地拟合训练数据。同时，我们还记录了每个 epoch 的损失值，以便后续的可视化和分析。\n开始调用设置学习率和迭代次数这一步跟之前也非常像，无非是梯度下降嘛\n# 设置学习率和迭代次数\nlearning_rate = 0.01\nepochs = 1000\n\n# 调用训练函数，训练Softmax回归模型\nW, b, losses = train_softmax_regression(X_train_scaled, y_train, learning_rate, epochs)\n\n在这里，我们设置了学习率和迭代次数，并调用训练函数 train_softmax_regression 对模型进行训练。通过不断地迭代优化权重和偏置，模型将逐渐适应训练数据。\n模型预测# 使用训练好的模型进行预测\nscores_test = np.dot(X_test_scaled, W) + b\nprobabilities_test = softmax(scores_test)\ny_pred = np.argmax(probabilities_test, axis=1)\n\n现在，我们使用训练好的模型对测试集进行预测。首先，我们计算测试集的模型输出分数（即未经过 Softmax 函数处理的值），然后将其转换为概率分布，最后根据概率值选择最可能的类别作为预测结果。\n模型评估设置这里我们需要写一些代码，方便我们后期对模型进行评估\n准确率# 计算准确率\naccuracy = accuracy_score(np.argmax(y_test, axis=1), y_pred)\nprint(\"准确率：\", accuracy)\n\n接下来，我们计算模型的准确率，即模型在测试集上的分类正确率。这里使用了 accuracy_score 函数，它将预测结果与真实标签进行比较，并输出分类的准确率。\n分类报告与混淆矩阵# 输出分类报告和混淆矩阵\nprint(\"\\n分类报告：\")\nprint(classification_report(np.argmax(y_test, axis=1), y_pred))\n\nprint(\"\\n混淆矩阵：\")\nprint(confusion_matrix(np.argmax(y_test, axis=1), y_pred))\n\n最后，我们输出分类报告和混淆矩阵，用于详细评估模型在各个类别上的分类性能。分类报告提供了精确率、召回率和 F1 分数等指标，而混淆矩阵展示了模型预测结果与真实标签之间的对应关系。\n\n\n\n\n\n\n\n\n\n混淆矩阵是分类器在测试集上的分类结果的矩阵表示。矩阵的行表示真实类别，列表示预测类别。对角线上的元素表示正确分类的样本数，非对角线上的元素表示错误分类的样本数。\n可视化处理这一步我们就需要进行可视化处理，因为程序写一大堆，不如图像来的直观，便捷。\n损失函数# 可视化损失值随着迭代次数的变化\nplt.plot(range(epochs), losses)\nplt.xlabel('Epochs')\nplt.ylabel('Loss')\nplt.title('Training Loss')\nplt.show()\n\n我们使用 matplotlib 库绘制了损失值随着迭代次数的变化曲线图，用于可视化模型训练的过程和损失值的收敛情况。这个图可以帮助我们判断模型是否在训练中得到了有效的优化。\n结果散点图我们需要绘制分类结果的散点图和预测结果的散点图。散点图将数据集中的样本点可视化为不同颜色和符号的点，以显示不同类别的分布和模型的分类结果。\n# 准备绘制子图的布局\nfig, axes = plt.subplots(2, 2, figsize=(15, 10))\naxes = axes.ravel()\n\n首先，我们创建了一个 2x2 的子图布局，即总共有 4 个子图。plt.subplots(2, 2) 返回一个包含 2 行 2 列的 Figure 对象和一个 Axes 对象数组。然后，通过 axes.ravel() 将该数组转换为一维数组，以便更方便地对每个子图进行操作。\n# 绘制每个子图\nfor i in range(3):\n    # 绘制分类结果的散点图\n    axes[i].scatter(X_train[y_train[:, 0] == 1, i], X_train[y_train[:, 0] == 1, i + 1], label='Class 1 (Train)', marker='o', c='blue')\n    axes[i].scatter(X_train[y_train[:, 1] == 1, i], X_train[y_train[:, 1] == 1, i + 1], label='Class 2 (Train)', marker='s', c='green')\n    axes[i].scatter(X_train[y_train[:, 2] == 1, i], X_train[y_train[:, 2] == 1, i + 1], label='Class 3 (Train)', marker='^', c='red')\n\n    # 绘制预测结果的散点图，使用不同的颜色和符号\n    axes[i].scatter(X_test[y_pred == 0, i], X_test[y_pred == 0, i + 1], label='Class 1 (Test)', marker='x', c='blue', alpha=0.5)\n    axes[i].scatter(X_test[y_pred == 1, i], X_test[y_pred == 1, i + 1], label='Class 2 (Test)', marker='x', c='green', alpha=0.5)\n    axes[i].scatter(X_test[y_pred == 2, i], X_test[y_pred == 2, i + 1], label='Class 3 (Test)', marker='x', c='red', alpha=0.5)\n\n    axes[i].set_xlabel(data.columns[i])\n    axes[i].set_ylabel(data.columns[i + 1])\n    axes[i].legend()\n\n\n接着，我们使用循环遍历每个子图，并在每个子图中绘制两个类别的散点图：一个是分类结果的散点图，另一个是预测结果的散点图。我们使用 scatter 函数绘制散点图，其中包含了训练集和测试集中不同类别的样本点。\n对于分类结果的散点图，我们分别使用不同的颜色和符号来表示每个类别。蓝色圆点表示 “Class 1”，绿色正方形表示 “Class 2”，红色三角形表示 “Class 3”。我们从训练集 X_train 和标签 y_train 中选择相应的样本点，根据标签的 One-hot 编码来确定样本的类别。\n对于预测结果的散点图，我们使用虚线的 X 符号来表示。同样，我们根据预测结果 y_pred 来选择测试集 X_test 中的样本点，并根据预测的类别来确定样本所属的类别。\n在每个子图中，我们设置了 x 轴和 y 轴的标签，分别为数据集的不同特征列，用以标识每个散点图中数据点的位置。同时，我们添加了图例来说明不同类别的符号和颜色含义。\n\n# 设置整体图的标题和坐标轴\nplt.suptitle('Classification and Prediction Results')\nplt.tight_layout()\nplt.show()\n\n最后，我们为整体图设置了标题 “Classification and Prediction Results”，使用 suptitle 函数来实现。同时，我们通过 tight_layout() 函数调整子图之间的布局，使得图像更美观。最后，使用 plt.show() 来显示绘制的图像。\n完整代码如下\n\nClick to see more\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n\n# 读取数据\ndata = pd.read_csv('iris.csv') # 记得改自己文件的路径\n\n# 将Species列转换成数值，使用One-hot编码\ndata = pd.get_dummies(data, columns=['Species'])\n\n# 将特征和标签进行分离\nX = data.drop(['Species_setosa', 'Species_versicolor', 'Species_virginica'], axis=1).values\ny = data[['Species_setosa', 'Species_versicolor', 'Species_virginica']].values\n\n# 将数据集划分为训练集和测试集\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# 特征缩放\nscaler = StandardScaler()\nX_train_scaled = scaler.fit_transform(X_train)\nX_test_scaled = scaler.transform(X_test)\n\ndef softmax(scores):\n    exp_scores = np.exp(scores - np.max(scores, axis=1, keepdims=True))\n    return exp_scores / np.sum(exp_scores, axis=1, keepdims=True)\n\ndef cross_entropy_loss(y_true, y_pred):\n    num_samples = y_true.shape[0]\n    log_likelihood = -np.log(y_pred[range(num_samples), np.argmax(y_true, axis=1)])\n    loss = np.sum(log_likelihood) / num_samples\n    return loss\n\ndef train_softmax_regression(X, y, learning_rate, epochs):\n    num_samples, num_features = X.shape\n    num_classes = y.shape[1]\n\n    # 初始化权重和偏置\n    W = np.random.randn(num_features, num_classes)\n    b = np.zeros((1, num_classes))\n\n    # 记录每个epoch的损失\n    losses = []\n\n    for epoch in range(epochs):\n        # 前向传播\n        scores = np.dot(X, W) + b\n        probabilities = softmax(scores)\n\n        # 计算损失\n        loss = cross_entropy_loss(y, probabilities)\n        losses.append(loss)\n\n        # 反向传播\n        error = probabilities - y\n        dW = np.dot(X.T, error) / num_samples\n        db = np.sum(error, axis=0, keepdims=True) / num_samples\n\n        # 参数更新\n        W -= learning_rate * dW\n        b -= learning_rate * db\n\n    return W, b, losses\n\nlearning_rate = 0.01\nepochs = 1000\n\nW, b, losses = train_softmax_regression(X_train_scaled, y_train, learning_rate, epochs)\n\n# 预测\nscores_test = np.dot(X_test_scaled, W) + b\nprobabilities_test = softmax(scores_test)\ny_pred = np.argmax(probabilities_test, axis=1)\n\n# 准确率\naccuracy = accuracy_score(np.argmax(y_test, axis=1), y_pred)\nprint(\"准确率：\", accuracy)\n\n# 分类报告和混淆矩阵\nprint(\"\\n分类报告：\")\nprint(classification_report(np.argmax(y_test, axis=1), y_pred))\n\nprint(\"\\n混淆矩阵：\")\nprint(confusion_matrix(np.argmax(y_test, axis=1), y_pred))\n\n# 可视化损失\nplt.plot(range(epochs), losses)\nplt.xlabel('Epochs')\nplt.ylabel('Loss')\nplt.title('Training Loss')\nplt.show()\n\n# 准备绘制子图的布局\nfig, axes = plt.subplots(2, 2, figsize=(15, 10))\naxes = axes.ravel()\n# 绘制每个子图\nfor i in range(3):\n    # 绘制分类结果的散点图\n    axes[i].scatter(X_train[y_train[:, 0] == 1, i], X_train[y_train[:, 0] == 1, i + 1], label='Class 1 (Train)', marker='o', c='blue')\n    axes[i].scatter(X_train[y_train[:, 1] == 1, i], X_train[y_train[:, 1] == 1, i + 1], label='Class 2 (Train)', marker='s', c='green')\n    axes[i].scatter(X_train[y_train[:, 2] == 1, i], X_train[y_train[:, 2] == 1, i + 1], label='Class 3 (Train)', marker='^', c='red')\n\n    # 绘制预测结果的散点图，使用不同的颜色和符号\n    axes[i].scatter(X_test[y_pred == 0, i], X_test[y_pred == 0, i + 1], label='Class 1 (Test)', marker='x', c='blue', alpha=0.5)\n    axes[i].scatter(X_test[y_pred == 1, i], X_test[y_pred == 1, i + 1], label='Class 2 (Test)', marker='x', c='green', alpha=0.5)\n    axes[i].scatter(X_test[y_pred == 2, i], X_test[y_pred == 2, i + 1], label='Class 3 (Test)', marker='x', c='red', alpha=0.5)\n\n    axes[i].set_xlabel(data.columns[i])\n    axes[i].set_ylabel(data.columns[i + 1])\n    axes[i].legend()\n\n# 设置整体图的标题和坐标轴\nplt.suptitle('Classification and Prediction Results')\nplt.tight_layout()\nplt.show()\n\n\n\n结果评估图像评估先来看我们第一张损失函数图像\n\n可以看得出，随着我们迭代次数的增加，模型的损失在不断的减小，符合我们的预期，可以说是一个很好的模型。那么我们接着往下看。\n\n这张图当中可以看得出来，训练集的数据已经用不同颜色和形状分布在各个地方，我们也能发现我们的预测集的x也合理的分布在他们所在的区域。\n当然最开始我是只画了一张图像的，就是第一张，我只对比了Sepal.Width和Sepal.Length两个维度下，三个品种之间的关系，你可以发现绿色和红色纠缠在一起，并不能很好的区分。是因为我们只画两个维度，但是实际模型考虑了四个维度，限于二维图像的表示限度，所以我就多画了几个图，尽可能多的考虑每个维度之间不同的结果，其实就可以发现分类其实是成功了的。\n当然我也画了三维图像，那个更加明显，不过，给各位留作思考吧！\n嘿嘿以后再说吧，其实目前我们已经可以很明显的看出来三者是可以区分的。\n控制台评估我们也生成了一份报告，如果图像并不能很好的分析的话，我们可以看实际的数据报告是什么样的。\n准确率： 0.9333333333333333\n\n分类报告：\n              precision    recall  f1-score   support\n\n           0       1.00      1.00      1.00        10\n           1       0.89      0.89      0.89         9\n           2       0.91      0.91      0.91        11\n\n    accuracy                           0.93        30\n   macro avg       0.93      0.93      0.93        30\nweighted avg       0.93      0.93      0.93        30\n\n\n混淆矩阵：\n[[10  0  0]\n [ 0  8  1]\n [ 0  1 10]]\n\n\n准确率： 准确率是分类器预测正确的样本数占总样本数的比例。在这个例子中，准确率为0.9333333333333333，即约为93.33%。\n\n分类报告： 分类报告提供了关于每个类别的精确率（precision）、召回率（recall）和F1-score的信息。精确率是分类器预测为某一类别的样本中真实属于该类别的比例，召回率是真实属于某一类别的样本中被分类器预测为该类别的比例，F1-score是精确率和召回率的调和平均值。macro avg表示各类别的平均值，weighted avg表示按样本数加权的平均值。\n在这个例子中，对于类别0，精确率和召回率都为1.00，F1-score也为1.00；对于类别1，精确率和召回率都为0.89，F1-score为0.89；对于类别2，精确率和召回率都为0.91，F1-score为0.91。整体的macro avg和weighted avg的准确率、召回率和F1-score都在0.93左右。\n\n混淆矩阵： 混淆矩阵是分类器在测试集上的分类结果的矩阵表示。矩阵的行表示真实类别，列表示预测类别。对角线上的元素表示正确分类的样本数，非对角线上的元素表示错误分类的样本数。\n在这个例子中，对于类别0，有10个样本被正确分类；对于类别1，有8个样本被正确分类，1个样本被错误分类为类别2；对于类别2，有10个样本被正确分类，1个样本被错误分类为类别1。可以看到，大部分样本被正确分类，但仍有一些样本被错误分类。\n\n\n综合来看，这个分类器在测试集上的表现还是不错的，准确率达到了约93.33%。各类别的精确率、召回率和F1-score也都较为接近，说明模型对于不同类别的预测表现都较为稳定。但仍然有少数样本被错误分类，可能需要进一步优化模型，调整参数或特征，以进一步提高分类器的性能。\n其实大家可以多跑几次，会发现每次都会有些小差距，但是准确率一般都在91%~97%附近，还是蛮不错的模型了噢！\n任务留个小任务吧。\n思考：在多维度数据下，有什么方法可以更好的数据可视化？在这次分类中我们就可以发现一张二维图像可能很难看出三者之间的分类情况，何况我画了三张，对比了每两个维度三者之间的关系才可以勉强分析，那么有什么好方法呢？\n","slug":"irisSoftmax","date":"2023-07-21T10:46:33.000Z","categories_index":"","tags_index":"笔记,Machine Learning","author_index":"General_K1ng"},{"id":"6d0e0a76d24875617f81e74389647d3a","title":"构建GLM","content":"这节我们就要开始构造GLM了。\n假设您想建立一个模型，根据一些特征x（比如商店促销活动、最近的广告、天气、星期几等）来估计在任何给定的小时内到达您的商店（或您的网站上的页面浏览次数）的顾客数量y。我们知道泊松分布通常是用于描述访问者数量的好模型。有了这个信息，我们该如何为我们的问题构建一个模型呢？幸运的是，泊松分布是指数分布族的一种，因此我们可以应用广义线性模型（GLM）。在本节中，我们将描述一种构建GLM模型来解决这类问题的方法。\n问题背景首先，让我们考虑一个分类或回归问题，我们希望根据特征 x 预测随机变量 y 的值。为了推导适用于这个问题的GLM，我们做出以下三个假设：\n\n假设一： 在给定 x 和参数 θ 的情况下，y | x; θ 的分布服从某个指数族分布，其参数为 η。\n假设二： 在给定 x 的情况下，我们的目标是预测 T(y) 的期望值，即 *E[y | x]*。在我们的大多数示例中，我们有 T(y) = y，这意味着我们希望我们学习的假设 h 所输出的预测 h(x) 满足 *h(x) = E[y | x]*。（需要注意的是，这个假设对于逻辑回归和线性回归中的  的选择是成立的。例如，在逻辑回归中，我们有 。）\n假设三： 自然参数 η 和输入 x 之间是线性相关的：。（或者，如果 η 是向量值的，则 。）\n\n值得注意的是，第三个假设可能看起来较不充分，并且更应该被视为设计GLM的“选择”，而不是严格的假设。这三个假设/设计选择使我们能够推导出一类非常优雅的学习算法，即GLMs，具有许多理想的特性，如易于学习。此外，由此产生的模型通常非常有效，适用于对 y 的不同类型分布进行建模；例如，我们很快将展示逻辑回归和普通最小二乘法都可以作为GLMs的特定实例推导出来。\n普通最小二乘法（Ordinary Least Squares）为了证明普通最小二乘法是GLM模型族的一个特例，我们首先考虑目标变量 y（在GLM术语中也称为响应变量）为连续型的情况。我们将 y 给定 x 的条件分布建模为高斯分布 ，，其中 μ 可能依赖于 x。这样，我们就选择了上面提到的指数族分布中的分布作为高斯分布。\n正如之前提到的，将高斯分布表示为指数族分布时，我们有 。所以我们有：\n1. 首先，根据假设2，我们有:这表示我们的目标是预测 y 的条件期望值。\n2. 其次，由于我们选择的指数族分布是高斯分布，所以根据高斯分布的性质，其期望值 μ 就等于 η，即:3. 接下来，根据假设3，我们有:这表示 η 和输入 x 之间是线性相关的。\n将这些信息结合起来，我们得到：这就证明了普通最小二乘法是GLM模型族的一个特例。在普通最小二乘法中，我们的目标是最小化预测值与真实值之间的平方差，从而得到拟合效果最优的线性模型。普通最小二乘法是线性回归问题中最常见和经典的解决方法。在下一节，我们将继续探讨GLM模型族的其他实例，例如逻辑回归。\n逻辑回归（Logistic regression）接下来，我们将探讨逻辑回归。在这种情况下，我们对二元分类感兴趣，因此 y 只能取 0 或 1。考虑到 y 是二值的，选择伯努利分布族来建模给定 x 条件下 y 的条件分布是很自然的。将伯努利分布表示为指数族分布时，我们得到 。此外，注意到如果 ，则 。按照与普通最小二乘法相似的推导，我们得到：\n1. 首先，根据假设2，我们有：这表示我们的目标是预测 y 的条件期望值。\n2. 其次，由于我们选择的指数族分布是伯努利分布，所以根据伯努利分布的性质，其期望值 φ 就等于  函数的规范响应函数，即：3. 接下来，根据假设3，我们有：这表示 η 和输入 x 之间是线性相关的。\n将这些信息结合起来，我们得到：这就给出了逻辑回归的假设函数形式 。如果您曾经好奇我们是如何得到逻辑函数  的形式的，现在这就是答案：一旦我们假设 y 在给定 x 的条件下服从伯努利分布，逻辑函数的形式就是GLMs和指数族分布所定义的结果。\n此外，为了引入一些更多的术语，将分布的均值表示为自然参数的函数的函数 g（）称为规范响应函数。它的逆函数  被称为规范链接函数。因此，对于高斯族，规范响应函数是恒等函数；而对于伯努利分布，规范响应函数是逻辑函数。\n\n\n\n\n\n\n\n\n\n很多文献使用g来表示链接函数，而来表示响应函数；但是，我们在这里使用的符号，继承自早期的机器学习文献，将更符合本课程其他部分使用的符号。\nSoftmax回归（Softmax regression）让我们再来看一个GLM的例子，即Softmax回归。这个模型适用于多类别分类问题，其中响应变量 y 可以取 k 个值中的任意一个，即 y ∈ {1, 2, . . . , k}。例如，我们不再只将电子邮件分类为垃圾邮件或非垃圾邮件（二元分类问题），而是希望将其分类为三类，比如垃圾邮件、个人邮件和工作邮件。虽然响应变量仍然是离散的，但现在可以取多于两个值。因此，我们将其建模为多项式分布。\n参数化多项式分布为了参数化包含 k 个可能结果的多项式分布，我们可以使用 k 个参数  来指定每个结果的概率。但是，这些参数是冗余的，即不独立的（因为知道任意 k-1 个  将唯一确定最后一个，因为它们必须满足 ）。因此，我们只使用 k-1 个参数  来参数化多项式分布，其中 ，而 。为了方便起见，我们还可以让 ，但是我们应该记住这不是一个参数，并且完全由  确定。\n表示为指数族分布为了将多项式分布表示为指数族分布，我们定义  如下：，，，，，与之前的例子不同，这里我们不再有 ；而且， 现在是一个 k - 1 维向量，而不是一个实数。我们用  来表示向量  的第 i 个元素。\n指示函数我们再引入一个非常有用的符号。指示函数 1{·} 在其参数为真时取值为 1，在其参数为假时取值为 0（1{True} = 1，1{False} = 0）。例如，1{2 = 3} = 0，1{3 = 5 - 2} = 1。因此，我们还可以将  与  之间的关系表示为 (。（在继续阅读之前，请确保你理解了这是为什么！）此外，我们有 。\n多项式分布是指数族的成员现在，我们准备展示多项式分布是指数族的成员。我们有以下推导：\n\n其中：\n\n\n这样，我们完成了将多项式分布表述为指数族分布的过程。\n链接函数和响应函数我们得到了链接函数的定义（对于 i = 1, . . . , k）为：为方便起见，我们还定义了 。为了求反函数并得到响应函数，我们有：这意味着 ，将其代回公式得到响应函数为：这个从 η 到 φ 的函数被称为Softmax函数，它是一个非常有用的函数，常用于多类别分类问题中，用于将线性输出转换为类别概率。\n完成 Softmax 回归为了完成我们的模型，我们使用之前给出的第三个假设，即  与  呈线性关系。因此，我们有 （对于 ），其中 是我们模型的参数。为了方便起见，我们还可以定义 ，这样 ，如之前所述。因此，我们的模型假设给定  时  的条件分布为：这个适用于 y ∈ {1, . . . , k} 的分类问题的模型被称为 softmax 回归。它是逻辑回归的一种推广。\n模型输出我们的假设将输出：换句话说，我们的假设输出对于每个值 i = 1, . . . , k 的估计概率 。（尽管上面定义的  只有 k − 1 维，很显然  可以通过计算  获得。）\n参数拟合最后，我们讨论参数拟合。与我们之前推导普通最小二乘法和逻辑回归时类似，如果我们有一个包含 n 个示例的训练集 {}，并希望学习该模型的参数 ，我们首先将写出对数似然函数：得到上面第二行的式子，我们使用了之前给出的  的定义。现在，我们可以通过最大化  关于  来获得参数的最大似然估计，使用梯度上升或牛顿法等方法进行优化。\n\n\n\n\n\n\n\n\n\n这个部分主要讲解了Softmax回归模型的建立过程和数学推导。如果不懂，没有关系。\n深入了解数学推导对于机器学习的初学者并非必须，但它有助于加深对机器学习算法和模型的理解。对于初学者，重点应该放在理解基本概念和算法的直觉上，而不是过于深入的数学推导。\n理解数学推导可以帮助你更好地理解算法是如何工作的、为什么选择特定的方法以及它们的局限性。这对于在实际问题中选择合适的模型、调整超参数以及解决算法的性能问题非常有帮助。此外，深入了解数学推导还可以帮助你更好地理解机器学习文献和研究论文，从而保持对新进展的敏感性。\n然而，对于初学者来说，过度关注数学细节可能会让学习过程变得繁琐，甚至让人望而却步。如果你对数学不是特别熟悉，你可以先掌握机器学习的基本概念、常用算法和实践技巧。一旦你对机器学习有了较好的理解，再逐步深入学习数学推导也是一种不错的学习路径。\n最重要的是保持学习的兴趣和动力。你可以根据自己的兴趣和学习目标来决定学习深入数学推导的程度。有时候，实际动手实践和解决实际问题可能比过多纠结于数学推导更加有意义。不断实践和尝试在真实数据上应用机器学习算法将有助于你更快地掌握这门领域。\n","slug":"ConstructingGLMs","date":"2023-07-20T08:10:30.000Z","categories_index":"","tags_index":"笔记,Machine Learning","author_index":"General_K1ng"},{"id":"9397670a03548da92beb1eda8943120b","title":"指数族","content":"为了逐步理解广义线性模型（GLM），我们从定义指数族分布开始！指数族分布是一类神奇的分布，它具有以下形式：其中：\n\ny 是随机变量的取值；\nη 是参数向量（也称为典范参数）；\nT(y) 是充分统计量（sufficient statistic）的向量（对于我们考虑的分布，通常有T(y) = y）；\na(η) 是对数分区函数（log partition function）；\nb(y) 是规范化因子（normalizing factor）。\n\n不要被公式吓到，让我们看看它们的可爱之处！\n 就像一枚魔法徽章，它确保分布  在所有 y 上的和或积等于 1，这样我们就能有一个完美的概率分布。\n这个指数族分布包含许多我们耳熟能详的朋友，比如正态分布、伯努利分布、泊松分布等。而在广义线性模型中，我们将利用指数族分布的特性来构建适用于回归和分类问题的模型。\n探索不同的分布族在 GLM 世界中，固定 T、a 和 b 的选择定义了一个由 η 参数化的分布族（或集合）。当我们改变 η 时，我们会得到这个族中的不同分布。每个族族中的成员都有自己的个性和特点，让我们带着好奇心探索一番！\n伯努利分布和高斯分布是指数族分布的宠儿！让我们看看伯努利分布和高斯分布是指数族分布的两个魔法示例。\n伯努利分布：它是二分类问题中的常客！伯努利分布的均值为 ，写作 Bernoulli()。它规定了  上的分布，使得  和 。随着  的变化，我们会得到具有不同均值的伯努利分布。我们将展示通过改变  获得的这类伯努利分布恰好是指数家族分布。\n我们将Bernoulli分布写成：因此，自然参数由给出。有趣的是，如果我们通过将表示为的函数来反演这个定义，我们会得到。这就是熟悉的sigmoid函数！这在我们将逻辑回归推导为GLM时再次出现。\n将伯努利分布表达成指数家族分布为了将伯努利分布完整地表述为指数家族分布，我们还有以下参数：这表明伯努利分布可以使用适当的T、a和b的选择来写成以上公式的形式。\n高斯分布（正态分布）让我们来研究一下高斯分布。咦，还记得我们推导线性回归时提到的那个方差  吗？其实它对最终的  和  是没有影响的，所以我们可以大胆地选择  的任意值，而不改变任何结果。为了简化接下来的推导，我们就设定  吧！\n\n\n\n\n\n\n\n\n\n嗯，其实如果我们保留  作为一个变量，高斯分布也可以归入指数分布族。在这种情况下， 是一个依赖于  和  的二维向量。然而，在广义线性模型（GLM）中，我们可以通过考虑指数分布族的更一般定义来处理  参数：。这里的  被称为离散参数，对于高斯分布，。但是，为了简便起见，我们在这里只考虑了我们之前假定的情况。\n\n好的，现在让我们来看看高斯分布的奇妙之处：接下来，让我们来看看高斯分布在指数族中的参数表示：指数分布族中还有许多其他分布：多项式分布（稍后我们会看到），泊松分布（用于建模计数数据；也请参阅问题集）；伽马分布和指数分布（用于建模连续、非负的随机变量，比如时间间隔）；贝塔分布和狄利克雷分布（用于概率分布）等等。\n在下一节中，我们将向你展示一个通用的“方法”，用于构建模型，其中 （在给定  和  的情况下）来自上述任意分布之一。\n","slug":"The-exponential-family","date":"2023-07-20T07:17:04.000Z","categories_index":"","tags_index":"笔记,Machine Learning","author_index":"General_K1ng"},{"id":"005491f74262b9b4c835e159a3d618ac","title":"一些题外话","content":"这章节的在课程的笔记里面就是叫题外话，因为和下一节都比较短，所以我就放到一起来记录。\n题外话：感知机学习算法咱们现在稍微偏离一下主题，来简单探讨一种历史上颇具趣味的算法，同时在后面学习理论的时候也会再次回到它。这个算法是从逻辑回归方法修改而来，以强制其输出值为 0 或 1。为了实现这个目标，我们自然而然地改变了函数 g 的定义，将其设定为阈值函数：如果我们继续使用之前定义的 ，但使用这个修改过的 g 函数定义，并采用更新规则：那么我们得到了感知机学习算法。\n感知机学习算法是机器学习中的一个简单算法，用于解决二分类问题。它的灵感来源于神经科学中的感知神经元概念，由 Frank Rosenblatt 于 1957 年提出。\n算法的目标是找到一个超平面，将数据分为两个类别。假设输入样本是一个  维特征向量 ，超平面的表达式为 ，其中  是需要学习的参数向量。对于任意输入 ，如果 ，则预测为正类；如果 ，则预测为负类。\n算法的更新规则如下：\n\n初始化  为一个随机向量或零向量。\n\n对于每个训练样本 ，其中  是标签（1 或 -1）：\na. 计算预测值：。\nb. 如果  和  异号，则更新 ：，其中  是学习率。\n\n\n算法将持续迭代以上步骤，直到所有样本被正确分类或达到预定的迭代次数。需要注意的是，感知机算法只能解决线性可分问题，如果数据线性不可分，则无法收敛。\n在 1960 年代，这个”感知机”被认为是描述大脑中个体神经元工作的一个简略模型。虽然感知机在外观上可能与之前讨论过的其他算法相似，但它实际上与逻辑回归和最小二乘线性回归有很大的不同；特别是，为感知机的预测赋予有意义的概率解释，或将其推导为最大似然估计算法都是非常困难的。不过，它作为学习理论的一个出发点，将为我们的分析提供有趣的帮助。\n另一种最大化的算法现在我们回到使用sigmoid函数作为  的逻辑回归，并讨论一种不同的最大化  的算法。\n让我们首先考虑用牛顿法来寻找函数的零点。假设我们有一个函数 ，我们希望找到一个值 ，使得 。这里， 是一个实数。牛顿法的更新公式如下：这个方法有一个直观的解释，我们可以将其看作是通过一个与当前猜测  处的  相切的线性函数来近似函数 ，然后求解该线性函数为零的位置，并将下一个猜测  设为该位置。\n下面是牛顿法的示意图：\n\n在最左边的图中，我们看到函数  的曲线以及直线 。我们试图找到 ，使得 ；在该例子中， 的值约为 1.3。假设我们将算法的初始值设为 。牛顿法接着拟合了一个与  处的  相切的直线，并求解该直线的零点。（中间的图）这给出了下一个猜测的 ，约为 2.8。最右边的图显示了再进行一次迭代的结果，将  更新为约 1.8。经过几次迭代后，我们迅速接近 。\n牛顿法提供了一种找到  的方法。那么，如果我们想要用它来最大化某个  函数呢？ 函数的极大值对应于其一阶导数  等于零的点。因此，我们可以令 ，然后使用相同的算法来最大化 ，得到更新规则：（思考一下：如果我们想要用牛顿法来最小化而不是最大化一个函数，这将如何改变？）\n最后，在逻辑回归的设置中， 是一个向量，因此我们需要将牛顿法推广到这种多维情况（也称为牛顿-拉夫逊方法）。推广到多维的公式如下：其中， 通常表示  对于  的偏导数的向量； 是一个  的矩阵（实际上是 ，假设我们包括截距项），称为Hessian 矩阵，其元素由以下公式给出：通常情况下，牛顿法 比（批量）梯度下降收敛得更快，并且需要较少的迭代次数来接近最小值。然而，一次牛顿法的迭代可能比一次梯度下降的迭代更昂贵，因为它需要找到和求逆一个  的 Hessian 矩阵；但只要  不是太大，整体上牛顿法通常更加高效。当牛顿法应用于最大化逻辑回归的对数似然函数  时，得到的方法也称为 Fisher scoring 方法。\n广义线性模型下一章节我们就要学习到广义线性模型，到目前为止，我们已经看到了一个回归示例和一个分类示例。在回归示例中，我们有，而在分类示例中，，其中和是和的合适定义函数。在下一节当中，我们将展示这两种方法都是更广泛的模型家族——广义线性模型（Generalized Linear Models，GLMs）的特例。我们还将展示如何导出和应用GLM家族中的其他模型来解决其他分类和回归问题。\n","slug":"Some-Digression","date":"2023-07-20T06:30:32.000Z","categories_index":"","tags_index":"笔记,Machine Learning","author_index":"General_K1ng"},{"id":"6ad60e40b1cfbe85f1c534ea3d1910e1","title":"（实战）鸢尾花数据集的二分类","content":"所以说第一行打不了字是吧，莫名其妙。（不用管这一行，刚刚发现我的编辑器第一行莫名其妙打不了字，所以你看到的这是第二行，很烦）\n昨天我学习了逻辑回归，今天就要实战一下啦！因为光看纸上的知识总感觉有点枯燥，咱们动手试试，把学到的知识化为力量吧！今天我们要玩的游戏是逻辑回归，而游戏场地就是鸢尾花的数据集。\n数据集：鸢尾花大冒险咱们先打开Excel，看看我们要玩的鸢尾花数据集是什么样子滴！第一列是索引，我们直接删掉啦！（记得一定要删掉哦！不然程序会迷失方向，不信你试试！不过别问我为什么知道… T T）\n\n可以发现，第一行是表头数据，分别有Sepal.Length（萼片长度），Sepal.Width（萼片宽度），Petal.Length（花瓣长度），Petal.Width（花瓣宽度），Species（种类），这几个，而Species中分为三个种类，分别是“setosa”，“versicolor”和“virginica”，分别是“小山鸢尾”、“变色鸢尾”和“维吉尼亚鸢尾”。\n准备阶段：选取我们的“法宝”首先，咱们得明确自己的任务和目标哦：我们要用逻辑回归算法解决一个二分类问题，把这个法宝应用于鸢尾花数据集。目标是训练逻辑回归模型，并查看它在测试集上的“施法”效果。\n这里咱们可要动用一些神奇的“法宝”呢！数据处理用强大的Pandas，数值计算可凭借老生常谈的numpy库，train_test_split可用来把数据分为训练集和测试集，LogisticRegression则是我们要打造的逻辑回归模型，还有accuracy_score、precision_score和recall_score这三把尺子，它们能帮我们测量评估指标的准确度哦！最后，还有matplotlib.pyplot可将数据可视化，让我们一起瞧瞧吧！\n所以准备工作差不多就这些，先把所需要的模块导入。\nimport pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score\nimport matplotlib.pyplot as plt\n\n魔法准备：定义一些有趣的“法术”现在，我们要定义一些有趣的“法术”来玩逻辑回归啦！这些“法术”都是数学公式变身的，让Python来帮我们算算就好啦！\ndef sigmoid(z):\n    return 1 / (1 + np.exp(-z))\n\ndef log_likelihood(features, target, weights):\n    scores = np.dot(features, weights)\n    ll = np.sum(target * scores - np.log(1 + np.exp(scores)))\n    return ll\n\ndef logistic_regression(features, target, num_steps, learning_rate):\n    intercept = np.ones((features.shape[0], 1))\n    features = np.hstack((intercept, features))\n    weights = np.zeros(features.shape[1])\n\n    for step in range(num_steps):\n        scores = np.dot(features, weights)\n        predictions = sigmoid(scores)\n\n        output_error_signal = target - predictions\n        gradient = np.dot(features.T, output_error_signal)\n        weights += learning_rate * gradient\n\n        # Print log-likelihood every 100 steps\n        if step % 100 == 0:\n            print(f\"Step {step}, Log-Likelihood: {log_likelihood(features, target, weights)}\")\n\n    return weights\n\n第一个“法术”叫做sigmoid，它是逻辑回归中的魔法函数，负责把输入的数值变成0到1之间的可爱小数哦！\n接下来是log_likelihood，“法术”嘛，它能算出对数似然性，看起来有点高深，其实是帮我们衡量预测结果的好坏程度！\n最后一个“法术”是logistic_regression，这个可厉害了！它用梯度上升算法，一步步地训练逻辑回归模型，就像咱们在山上慢慢攀登一样！它还会在每爬100步的时候，打印出对数似然性，让我们知道自己的成长进度哦！\n大冒险准备：数据预处理怎么个处理法，其实好像没什么需要处理的，无非就是读取，存储，几个简单的转换？差不多吧。\n# 加载数据集并分成训练集和测试集\ndata_path = 'iris.csv' # 你的路径！\ndata = pd.read_csv(data_path)\n\n# 将'setosa'标记为1，其他两种花标记为0，实现二分类问题\ndata['Species'] = data['Species'].map({'setosa': 1, 'versicolor': 0, 'virginica': 0})\n\n# 提取特征和标签\nfeatures = data.drop('Species', axis=1)\ntarget = data['Species']\n\n# 分割数据集\ntrain_features, test_features, train_target, test_target = train_test_split(features, target, test_size=0.2, random_state=42)\n\n首先，我们要加载数据集，它就像我们的宝藏地图一样，指引着我们前进的方向。我们用pd.read_csv()将数据从csv文件中读取出来，并把花的种类标记为1和0，就像宝藏上的标记一样，让我们可以区分哪些是我们要找的，哪些是普通的岩石。瞧，鸢尾花的种类有点像三个魔法宝石，我们要把其中一个宝石标记为1，其他两个标记为0，这样它们就变成了我们要寻找的目标。\n接下来，我们得把宝藏中的特征和目标提取出来。特征就像地图上的路线，目标就像我们要找的宝藏。咱们把特征放进features变量，把目标放进target变量，这样咱们就能对它们进行后续的处理啦。\n鸢尾花大冒险的第一步就是分割数据集，将宝藏地图分成训练集和测试集，这样我们才能在训练中不断成长，最后测试一下自己的探险成果。通过train_test_split，我们将数据集分成了两部分，80%的数据用来训练，20%的数据留作测试，而随机种子random_state=42则确保我们在不同的时候玩同样的游戏。\n参数：选个好武器，准备战斗# 使用训练集来训练逻辑回归模型\nnum_steps = 1000\nlearning_rate = 0.01\nweights = logistic_regression(train_features, train_target, num_steps, learning_rate)\n\n接下来，我们要选择适合鸢尾花大冒险的武器了。先把自己的装备整理一下，我们需要设定一些超级厉害的“法宝”：迭代次数num_steps和学习率learning_rate，这些会决定我们在冒险中的表现。好了，现在我们就准备好了，可以正式进入鸢尾花的世界了！\n“法宝”已经准备齐全，现在我们需要通过logistic_regression函数，调用那些魔法“法术”来进行模型的训练。这个过程就像在修炼魔法一样，每一步都在增强我们的力量。训练过程中，我们会在每爬100步的时候，打印出当前的对数似然性，这样我们就能看到自己的成长历程。\n你也可以在这部分通过调整迭代次数和学习率来观察不同情况下的模型表现。\n探索成果，评估表现！test_intercept = np.ones((test_features.shape[0], 1))\ntest_features = np.hstack((test_intercept, test_features))\ntest_predictions = sigmoid(np.dot(test_features, weights))\ntest_predictions = np.round(test_predictions)\n\naccuracy = accuracy_score(test_target, test_predictions)\nprecision = precision_score(test_target, test_predictions)\nrecall = recall_score(test_target, test_predictions)\n\nprint(f\"Accuracy: {accuracy}, Precision: {precision}, Recall: {recall}\")\n\n这一部分代码使用训练后的模型权重对测试集进行预测，并计算评估指标。首先，将测试集的特征矩阵添加一列全为1的列作为截距，然后通过逻辑函数sigmoid和权重矩阵计算预测结果。为了得到最终的分类结果，将预测概率四舍五入为0或1。\n最后，计算预测结果与测试集真实标签之间的准确率、精确率和召回率，并将结果打印输出。\n\n\n\n\n\n\nTIP\n这里我再来贴一下什么是准确率，精确率和召回率。\n\n准确率（Accuracy）： 准确率是最常用的模型性能指标之一，它表示模型正确预测的样本数与总样本数之间的比例。即：(预测正确的样本数) / (总样本数)。准确率越高，表示模型的整体性能越好。\n精确率（Precision）： 精确率是针对预测为正例的样本而言的，它表示在所有预测为正例的样本中，模型正确预测为正例的比例。即：(真正例数) / (真正例数 + 假正例数)。精确率高表示模型对正例的预测较准确。\n召回率（Recall）： 召回率是针对实际为正例的样本而言的，它表示在所有实际为正例的样本中，模型正确预测为正例的比例。即：(真正例数) / (真正例数 + 假负例数)。召回率高表示模型对正例的识别能力较强。\n\n\n\n数据可视化由于鸢尾花数据集有四个特征，我们可以选择任意两个特征来进行可视化处理。\nfeature_names = ['Sepal.Length', 'Sepal.Width', 'Petal.Length', 'Petal.Width']\ntarget_names = ['setosa', 'versicolor/virginica']\n\nfig, axes = plt.subplots(nrows=3, ncols=2, figsize=(12, 15))\n\nfor idx, ax in enumerate(axes.flat):\n    i, j = idx // 2, idx % 2\n    ax.scatter(data[data['Species'] == 1][feature_names[i]], data[data['Species'] == 1][feature_names[j]], label='setosa')\n    ax.scatter(data[data['Species'] == 0][feature_names[i]], data[data['Species'] == 0][feature_names[j]], label='versicolor/virginica')\n    ax.scatter(test_features[test_target == 1][:, i+1], test_features[test_target == 1][:, j+1], marker='o', edgecolors='red', facecolors='none', label='setosa (predicted)')\n    ax.scatter(test_features[test_target == 0][:, i+1], test_features[test_target == 0][:, j+1], marker='x', color='red', label='versicolor/virginica (predicted)')\n    ax.set_xlabel(feature_names[i])\n    ax.set_ylabel(feature_names[j])\n    ax.legend()\n\nplt.tight_layout()\nplt.show()\n\n最后这一部分代码进行了数据可视化处理，使用散点图展示了不同特征组合下的分类结果。这部分代码使用了matplotlib.pyplot库，创建了6个子图，并在每个子图中绘制了鸢尾花数据集中的两个特征。蓝色的点代表’Setosa’类别，橙色的点代表’Versicolor’和’Virginica’类别。预测集的结果用红色的圆圈（’o’）表示’Setosa’类别，用红色的叉（’x’）表示’Versicolor’和’Virginica’类别。\n完整代码如下\n\nClick to see more\nimport pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score\nimport matplotlib.pyplot as plt\n\n# 1. 逻辑回归算法的代码实现\ndef sigmoid(z):\n    return 1 / (1 + np.exp(-z))\n\ndef log_likelihood(features, target, weights):\n    scores = np.dot(features, weights)\n    ll = np.sum(target * scores - np.log(1 + np.exp(scores)))\n    return ll\n\ndef logistic_regression(features, target, num_steps, learning_rate):\n    intercept = np.ones((features.shape[0], 1))\n    features = np.hstack((intercept, features))\n    weights = np.zeros(features.shape[1])\n\n    for step in range(num_steps):\n        scores = np.dot(features, weights)\n        predictions = sigmoid(scores)\n\n        output_error_signal = target - predictions\n        gradient = np.dot(features.T, output_error_signal)\n        weights += learning_rate * gradient\n\n        # Print log-likelihood every 100 steps\n        if step % 100 == 0:\n            print(f\"Step {step}, Log-Likelihood: {log_likelihood(features, target, weights)}\")\n\n    return weights\n\n# 2. 选择一个适合的二分类数据集\n# 在此示例中，我们将使用鸢尾花数据集\n\n# 3. 加载数据集并分成训练集和测试集\ndata_path = 'iris.csv' # 你的路径！！！\ndata = pd.read_csv(data_path)\n\n# 将'setosa'标记为1，其他两种花标记为0，实现二分类问题\ndata['Species'] = data['Species'].map({'setosa': 1, 'versicolor': 0, 'virginica': 0})\n\n# 提取特征和标签\nfeatures = data.drop('Species', axis=1)\ntarget = data['Species']\n\n# 分割数据集\ntrain_features, test_features, train_target, test_target = train_test_split(features, target, test_size=0.2, random_state=465)\n\n# 4. 使用训练集来训练逻辑回归模型\nnum_steps = 1000\nlearning_rate = 0.01\nweights = logistic_regression(train_features, train_target, num_steps, learning_rate)\n\n# 5. 在测试集上评估模型性能\ntest_intercept = np.ones((test_features.shape[0], 1))\ntest_features = np.hstack((test_intercept, test_features))\ntest_predictions = sigmoid(np.dot(test_features, weights))\ntest_predictions = np.round(test_predictions)\n\naccuracy = accuracy_score(test_target, test_predictions)\nprecision = precision_score(test_target, test_predictions)\nrecall = recall_score(test_target, test_predictions)\n\nprint(f\"Accuracy: {accuracy}, Precision: {precision}, Recall: {recall}\")\n\n# 6. 数据可视化处理（放到同一张图里的子图中）\n# 由于鸢尾花数据集有四个特征，我们可以选择任意两个特征来进行可视化处理。\n\nfeature_names = ['Sepal.Length', 'Sepal.Width', 'Petal.Length', 'Petal.Width']\ntarget_names = ['setosa', 'versicolor/virginica']\n\nfig, axes = plt.subplots(nrows=3, ncols=2, figsize=(12, 15))\n\nfor idx, ax in enumerate(axes.flat):\n    i, j = idx // 2, idx % 2\n    ax.scatter(data[data['Species'] == 1][feature_names[i]], data[data['Species'] == 1][feature_names[j]], label='setosa')\n    ax.scatter(data[data['Species'] == 0][feature_names[i]], data[data['Species'] == 0][feature_names[j]], label='versicolor/virginica')\n    ax.scatter(test_features[test_target == 1][:, i+1], test_features[test_target == 1][:, j+1], marker='o', edgecolors='red', facecolors='none', label='setosa (predicted)')\n    ax.scatter(test_features[test_target == 0][:, i+1], test_features[test_target == 0][:, j+1], marker='x', color='red', label='versicolor/virginica (predicted)')\n    ax.set_xlabel(feature_names[i])\n    ax.set_ylabel(feature_names[j])\n    ax.legend()\n\nplt.tight_layout()\nplt.show()\n\n# 7. 尝试调整学习率、迭代次数等参数，观察对模型性能的影响\n# 你可以尝试不同的学习率和迭代次数，观察模型在测试集上的性能变化。\n\n\n\n结论\n\n于是我们就能得到如上的图片，并且控制台打印如下：\nStep 0, Log-Likelihood: -466.2106144434709\nStep 100, Log-Likelihood: -0.36586843732581664\nStep 200, Log-Likelihood: -0.261779308423121\nStep 300, Log-Likelihood: -0.2055975355203343\nStep 400, Log-Likelihood: -0.17016379364395556\nStep 500, Log-Likelihood: -0.14565669423300498\nStep 600, Log-Likelihood: -0.12763643409226652\nStep 700, Log-Likelihood: -0.11379421631281457\nStep 800, Log-Likelihood: -0.1028071299788049\nStep 900, Log-Likelihood: -0.09386101997678553\nAccuracy: 1.0, Precision: 1.0, Recall: 1.0\n\n图片分析\n图片中的子图：在图片中的每个子图中，横轴和纵轴分别表示两个特征，点的分布代表鸢尾花数据集中的样本分布。蓝色点表示’Setosa’类别，橙色点表示’Versicolor’和’Virginica’类别。红色圆圈（’o’）表示模型预测为’Setosa’类别的样本，红色叉（’x’）表示模型预测为’Versicolor’和’Virginica’类别的样本。\n分析子图的区分度：观察每个子图中的蓝色点和橙色点的分布情况，可以看出这两类样本在这两个特征上的区分度。如果两类样本在某个特征上有明显的分离，说明该特征对分类有较强的区分能力。\n分析预测结果：观察红色圆圈和红色叉的分布情况，它们代表了模型在测试集上的预测结果。如果模型分类准确，预测为’Setosa’类别的样本应该位于蓝色点的附近，预测为’Versicolor’和’Virginica’类别的样本应该位于橙色点的附近。如果红色圆圈和红色叉分布与蓝色点和橙色点重叠较少，说明模型的预测效果较好。\n\n控制台分析从控制台打印的日志可以看出模型在训练过程中的对数似然性（Log-Likelihood）逐步增大，并在迭代次数较少时就收敛到一个较小的负值。最后，模型在测试集上的评估结果显示准确率（Accuracy）、精确率（Precision）和召回率（Recall）均为1.0，即100%。\n对于对数似然性的变化：\n\n在训练初始阶段（Step 0到Step 100），对数似然性从一个较大的负值逐渐减小，说明模型的拟合效果在改进，损失逐渐减小。\n在训练中期（Step 100到Step 500），对数似然性下降幅度较大，模型在这个阶段学习到了较多的特征权重，开始更好地拟合训练集。\n在训练后期（Step 500到Step 900），对数似然性下降速度减缓，模型接近收敛。这时候模型已经较好地拟合训练集，但仍然可能存在一些小的误差。\n\n对于评估结果：\n\n准确率、精确率和召回率均为1.0，表示模型在测试集上的分类结果完美地匹配了真实标签。准确率表示模型正确分类样本的比例，精确率表示模型预测为正类的样本中真正为正类的比例，召回率表示模型正确识别正类样本的比例。这些指标都为1.0表明模型对于’Setosa’类别的预测完全正确，没有产生误分类。\n\n综合来看，这个结果可能存在一些问题：\n\n数据集可能过于简单：鸢尾花数据集相对简单，可能存在较强的线性关系，使得逻辑回归模型能够在这个数据集上表现得很好。\n过拟合：虽然在测试集上表现良好，但模型可能在训练集上过拟合，过度拟合了训练集的特点，导致在测试集上泛化能力较差。\n\n为了更好地评估模型性能，你可以进行交叉验证和尝试使用其他复杂度较高的数据集。交叉验证能够更全面地评估模型的泛化能力，复杂度较高的数据集能够更好地反映模型在现实场景中的表现。同时，尝试调整学习率、迭代次数等超参数，观察对模型性能的影响。这样可以更全面地评估模型的性能，并找到合适的模型和参数组合。\n","slug":"Secondary-classification-of-Iris","date":"2023-07-19T10:14:24.000Z","categories_index":"","tags_index":"笔记,Machine Learning","author_index":"General_K1ng"},{"id":"4c5f4ebe8f68ff24ce30098465671f7c","title":"分类与逻辑回归","content":"在机器学习的广袤领域中，分类问题犹如一片神秘的森林，吸引着众多探险家的目光。我们可以将自己想象成一位勇敢的森林导游，带领着各种生物来到分类问题的奇妙世界。\n什么是分类问题？在这片森林中，我们将聚焦于探讨分类问题。这与我们之前遇到的回归问题有些相似，但又有所不同。在分类问题中，我们要预测的目标值只有少数几种离散取值。我们现在先专注于二分类问题，也就是只能是0或者1。就像在森林中，我们要将每个生物划分为两类，比如“可爱的小动物”和“奇怪的怪兽”。0通常被称为负类，而1被称为正类，有时也用符号“-”和“+”来表示。在训练样本中，对于每个输入，我们都有相应的标签，也被称为标签。\n分类问题是机器学习中最常见的任务之一，我们的目标是构建一个模型，能够将新的未知数据准确地分类到正确的类别中。\n这个森林中的探险涉及以下关键要素：\n\n特征（Features）：每个生物都有一组特征，描述了它们的某些属性。这些特征可以是数字、文字、图像等形式，用于描述样本的特点。\n类别（Classes）：我们的目标是将每个生物分到预先定义的类别中。这些类别可以是二元的（例如，可爱的/奇怪的、是/否）或多元的（例如，红色/蓝色/绿色、动物种类）。\n训练数据（Training Data）：我们拥有一批标记好的样本，这些样本是已知类别的数据。我们将用这些数据来训练我们的模型，让它能够学习如何进行正确的分类。\n分类器（Classifier）：作为森林导游，我们需要一个特殊的工具，帮助我们将新生物正确地分类。这个工具就是分类器，它会根据生物的特征来做出分类决策，并将其划分到最有可能的类别中。一些常见的分类器包括逻辑回归、决策树、支持向量机等。\n\n我们可以使用分类问题的技术来构建垃圾邮件过滤器、图像识别器、情感分析器等各种实用的应用。\n了解了分类问题的本质和关键要素，我们就可以自信地踏入这片神奇的森林。接下来，让我们深入研究森林中一种重要的工具——逻辑回归，帮助我们更好地了解并解决分类问题。在这次奇妙的探险中，我们将发现更多的惊喜和乐趣！:deciduous_tree:\n逻辑回归：智慧护卫的二分类大师在机器学习的世界中，逻辑回归是一位智慧而灵活的护卫，专门擅长解决二分类问题。想象一下，他是我们探险中的得力助手，帮助我们在数据的海洋中，区分出两个不同的类别。无论是判断邮件是否为垃圾邮件，预测疾病是否会发生，还是决定客户是否会购买某个产品，逻辑回归都能忠实地指引我们找到正确答案。\n逻辑回归与线性回归的区别在分类问题中，我们通常会遇到一个挑战：目标值只能取0或者1，而线性回归的模型可能会给出超过这个范围的预测结果。为了解决这个问题，逻辑回归改变了我们的模型假设，引入了一个新的假设函数。这个函数使用了一个特殊的函数，也称为逻辑函数或Sigmoid函数，来确保预测结果总是在0和1之间。\n逻辑函数（Sigmoid函数）我们可以忽略是离散值的事实，使用我们之前的线性回归算法来尝试预测给定的。然而，很容易构造出在这种方法表现非常糟糕的例子。直观地讲，当我们知道时，的取值大于1或小于0是没有意义的。\n为了解决这个问题，让我们改变我们假设的形式。我们将选择：当这被称为逻辑函数或Sigmoid函数。以下是的绘图：\n\n\n我们可以看到，当趋近于正无穷时，趋近于1，而当趋近于负无穷时，趋近于0。这样的性质让我们的预测结果总是在合理的范围内，非常适合处理分类问题。此外，，因此也包括，始终保持在0和1之间。与之前一样，我们保持了的约定，使得。\n逻辑回归的拟合在逻辑回归中，我们需要拟合参数。与线性回归一样，我们使用了最大似然估计的方法来拟合参数。这意味着我们为分类模型赋予一组概率假设，然后通过最大似然估计来找到最合适的参数，使得我们的模型能够尽可能地拟合训练数据。 :detective:\n逻辑回归的参数拟合与最大似然估计在逻辑回归中，我们已经选择了逻辑函数作为我们的激活函数，它有助于将预测结果限制在0和1之间。同时，逻辑函数的导数具有一个非常有用的性质，这对我们进行参数拟合非常重要。\n我们将其写为：\n似然性与最大似然估计为了拟合逻辑回归模型的参数，我们需要定义一个衡量拟合程度的度量，这就是似然性（Likelihood）。对于逻辑回归而言，我们可以通过最大似然估计来找到最合适的参数。\n假设我们有个训练样本，每个样本的特征为，对应的标签为，其中。我们假设这些样本是独立生成的，即每个样本的生成与其他样本无关。然后，我们就可以写出参数的似然性。\n让我们假设：请注意，这可以更紧凑地写成假设这个训练示例是独立生成的，我们可以写出参数的似然性：\n为了计算方便，我们通常取似然性的对数，得到对数似然性（Log-Likelihood）：我们的目标是最大化对数似然性，即找到能够使得训练样本出现概率最大的参数。\n梯度上升算法我们如何最大化似然性？类似于我们在线性回归的推导中所做的，我们可以使用梯度上升算法。类似于线性回归中的梯度下降算法，梯度上升算法通过迭代更新参数来逐步寻找似然性的最大值。\n在向量表示法中，我们的更新将由 给出。（请注意更新公式中的正号而不是负号，因为现在我们要最大化函数而不是最小化。）\n\n\n\n\n\n\n\n\n\n这个更新公式表示在梯度上升算法中如何更新参数。在梯度上升算法中，我们希望最大化对数似然性，因为这是参数在训练数据上的似然性。梯度表示对数似然性关于参数的梯度向量，它告诉我们在当前参数的取值下，如何调整参数的方向，才能更好地拟合训练数据。\n具体来说，是学习率，表示每次更新参数的步长。在每一次迭代中，我们将当前的参数与学习率乘以梯度相加，得到新的参数。这样，我们逐步地沿着梯度的方向更新参数，直到达到一个满意的似然性最大值或者收敛。\n让我们从只有一个训练示例开始，我们可以计算对数似然性关于参数的偏导数，得到梯度：然后，我们使用以下更新规则来更新参数：其中，是学习率，用于控制每次更新的步长。\n可能有人看不懂，就用更易懂的表达来详细讲一下：\n\nClick to see more\n假设我们只有一个训练示例，其中是输入特征，是对应的标签。我们希望通过更新参数来使得我们的模型能够更好地拟合这个示例。\n首先，我们计算对数似然性关于参数的偏导数。这里需要用到逻辑函数的导数公式。\n推导过程如下：\n\n首先，我们计算对数似然性关于的偏导数：其中，表示通过逻辑函数将映射到0和1之间的预测结果。\n\n我们可以将上述偏导数的计算过程进行解释：\n\n首先，表示实际标签与预测值之间的差异。当预测值与实际标签一致时，差异为0，表示预测准确；当预测值与实际标签不一致时，差异为非零值，表示预测错误。\n其次，是预测错误的差异的方向，表示我们需要调整参数的方向，使得预测更加准确。\n最后，表示输入特征的第个分量，表示该特征对参数的影响程度。\n\n\n根据这个偏导数的计算结果，我们可以得到随机梯度上升法则的更新公式：其中，是学习率，用于控制每次参数更新的步长。这个公式告诉我们，在每一次更新中，我们将根据预测结果与实际标签的差异，乘以输入特征的对应分量，再乘以学习率，来更新参数。\n通过这样的参数更新过程，我们逐步调整参数的取值，使得我们的模型能够更好地拟合训练示例。这样，我们就可以使用逻辑回归来解决分类问题，并取得优秀的结果。\n\n\n\n\n如果将其与LMS更新规则进行比较，我们会发现它们看起来完全一样；但这并不是同一个算法，因为现在被定义为的非线性函数。尽管如此，令人惊讶的是，对于一个相当不同的算法和学习问题，我们最终得到了相同的更新规则。这是巧合吗，还是背后有更深层次的原因？我们将在讨论广义线性模型（GLM）时回答这个问题。\n任务任务，确实，只看不练可能什么都学不会，那么问题就来了，依旧是我让GPT生成的。\n作业任务一：逻辑回归代码实现与应用任务描述：学生需要使用Python或其他编程语言实现逻辑回归算法，并应用该算法来解决一个二分类问题。\n任务步骤：\n\n编写逻辑回归算法的代码实现，包括计算逻辑函数、计算对数似然性、梯度上升算法等关键部分。\n选择一个适合的二分类数据集，可以使用公开数据集或者自己构造一个数据集。\n将数据集分成训练集和测试集。\n使用训练集来训练你实现的逻辑回归模型。\n在测试集上评估你的模型性能，计算准确率、精确率、召回率等指标。\n最好进行数据可视化处理，让结果更直观。\n可选：尝试调整学习率、迭代次数等参数，观察对模型性能的影响。\n\n\n\n\n\n\n\nTIP\n\n准确率（Accuracy）： 准确率是最常用的模型性能指标之一，它表示模型正确预测的样本数与总样本数之间的比例。即：(预测正确的样本数) / (总样本数)。准确率越高，表示模型的整体性能越好。\n精确率（Precision）： 精确率是针对预测为正例的样本而言的，它表示在所有预测为正例的样本中，模型正确预测为正例的比例。即：(真正例数) / (真正例数 + 假正例数)。精确率高表示模型对正例的预测较准确。\n召回率（Recall）： 召回率是针对实际为正例的样本而言的，它表示在所有实际为正例的样本中，模型正确预测为正例的比例。即：(真正例数) / (真正例数 + 假负例数)。召回率高表示模型对正例的识别能力较强。\n\n\n\n我们这里可以使用一些著名的数据集，比如鸢尾花数据集\n作业任务二：逻辑回归性能优化任务描述：学生需要探索不同方法来优化逻辑回归算法的性能，并比较它们的效果。\n任务步骤：\n\n研究逻辑回归算法的原理和应用场景，了解逻辑回归的优缺点。\n选择一个适合的二分类数据集，可以使用公开数据集或者自己构造一个数据集。\n将数据集分成训练集和测试集。\n使用标准的逻辑回归算法来训练模型，并在测试集上评估模型性能，计算准确率、精确率、召回率等指标。\n尝试以下优化方法，并比较它们对模型性能的影响：\n特征缩放：尝试对特征进行缩放，例如使用标准化或归一化处理。\n多项式特征：尝试使用多项式特征来增加模型的复杂度。\n正则化：尝试使用L1或L2正则化来减少过拟合问题。\n不同的损失函数：尝试使用其他损失函数，如交叉熵损失函数。\n学习率调整：尝试使用不同的学习率，并观察其对模型训练的影响。\n\n\n分析不同优化方法对模型性能的影响，讨论哪些方法对提高模型性能效果更明显。\n\n","slug":"Classification-and-logistic-regression","date":"2023-07-18T09:41:28.000Z","categories_index":"","tags_index":"笔记,Machine Learning","author_index":"General_K1ng"},{"id":"465c62620dad1684532695600a6cd19f","title":"局部加权线性回归*","content":"引言回顾最小二乘法的概率解释，我们曾深入研究过如何通过最小化误差的平方和，寻找最佳的模型参数。这个方法的确非常强大，但有时候我们需要更加灵活和精确的工具来解决特定的问题。\n于是，引入局部加权线性回归（Locally Weighted Linear Regression）。这个方法可以被视为我们探险旅程中的一把望远镜，帮助我们看到更加微妙的模式和趋势。它以一种非常独特的方式，通过为每个数据点赋予一定的权重，使得我们的模型更加关注那些在当前预测点附近的样本。\n这里的”局部加权”，就好像是一把神奇的放大镜，它能够放大我们感兴趣的那些数据点，并且根据它们的特点，为我们提供一种个性化的预测模型。无论是在金融领域，医疗研究，还是天气预测，局部加权线性回归都能够以其独特的魅力，帮助我们更好地理解和解决问题。\n这就像是在一片茂密的丛林中，我们只专注于离我们最近的树木和植被，而忽略了远处的景象。局部加权线性回归带给我们的是一种局部敏感性，使我们能够更加准确地预测和理解数据的变化。\n局部加权线性回归（LWS）欠拟合与过拟合考虑一个让我们一起探索的有趣问题：如何从输入预测输出呢？这就是我们今天要聊的局部加权线性回归（LWR）算法啦！想象一下，我们置身于一个神奇的数据世界中，我们希望找到一种方法，能够让我们的模型更好地适应这些数据点。\n嘿，看看这张魔法般的图片吧！最左边的图展示了我们试图通过一条直线去拟合这些数据点的情况。可是，你有没有发现，这些点并不完全落在这条线上呢？是不是感觉有些不太对劲？没错，这就是我们所谓的欠拟合。这位可爱的小模型童鞋似乎没有完全抓住数据中的结构，留下了一些没被捕捉到的东西。\n\n\n于是，我们心生了一个奇妙的想法：如果我们再加上一个特征，试试拟合这样的模型，会发生什么呢？嗯嗯，看中间的图，你会发现拟合效果好像稍微好了一些。看起来添加更多的特征会让拟合效果变得更好，是不是有些开心呢？但是，小心别太过头哦！右边的图就展示了一个过拟合的例子，我们使用了一个5阶多项式去拟合这些数据。看起来，尽管拟合曲线完全通过了数据点，但它在对不同房屋面积预测房价方面的表现可能并不好。所以，记住了，过于贪心可不是好事哦！\n权重好啦，让我们稍微放慢脚步，先来简单介绍一下局部加权线性回归（LWR）算法吧！想象一下，当我们拥有足够多的训练数据时，特征的选择变得不那么重要了。这里，LWR算法就是我们的小助手，帮助我们更好地拟合数据。虽然我们只是稍微提一下，但是不要担心，在后面的作业中，你将有机会深入探索LWR算法的一些特性。\n在传统的线性回归算法中，要在查询点处进行预测（也就是评估），我们会按照以下步骤进行：\n\n通过最小化来拟合参数。\n将作为我们的预测结果输出。\n\n然而，在局部加权线性回归算法中，我们将迈出一小步，踏入了一个可爱而神奇的世界。请跟紧我，我们一起看看LWR算法的魔法步骤：\n\n通过最小化来拟合参数。\n将作为我们的预测结果输出。\n\n在这里，是非负权重值。直观地说，如果对于特定的，很大，那么在选择时，我们会努力使尽可能小。如果很小，那么在拟合中，的误差项将被忽略。\n那么，如何确定这些神奇的权重呢？一个非常常见的权重选择方式是：\n\n\n\n\n\n\n\n\n\n如果x是向量值的，这个公式可以推广为或者，其中或的选择适当。\n请注意，权重值取决于我们希望预测的特定点。而且，如果很小，那么会接近1；如果很大，那么就会很小。所以，我们可以说，对于与查询点相近的训练样本，我们赋予它们更高的“权重”，而离查询点更远的样本则具有较低的“权重”。真是一种魔法般的思想！\n还要注意的是，虽然权重公式在形式上类似于高斯分布的密度函数，但与高斯分布并没有直接的关联，特别是不是一个随机变量，无论它是否服从正态分布或其他分布。（这是一种可爱的小魔法，不是吗？）\n带宽参数控制着训练样本权重随其与查询点之间距离的衰减速度。你知道吗？这个就是我们所说的带宽参数，它也是你在后面任务中将要实验的内容之一。它决定了魔法的强弱程度！\n现在，我们已经见识了第一个非参数算法的例子，它就是局部加权线性回归。相比之下，之前我们接触的（无权重的）线性回归算法被称为参数学习算法，因为它具有一组固定的有限参数（），这些参数与数据进行拟合。一旦我们拟合了参数并将它们存储起来，我们就不再需要保留训练数据来进行未来的预测。\n但是，和LWR不同哦！为了使用局部加权线性回归进行预测，我们需要保留整个训练集。这就是所谓的非参数，因为为了表示假设，我们需要存储与训练集规模成线性增长的信息量。\n特点LWR算法的魔力之一在于它的灵活性和适应性。它不仅仅是一个固定的模型，而是根据数据的特点和查询点的需求，为每个预测问题个性化地构建模型。这就像我们有一位聪明的小精灵，他根据数据的不同部分，以及与查询点的距离，灵活地调整预测模型，以获得最佳的结果。\n嗯，你或许会问，为什么要引入这种灵活性呢？这是因为在现实世界中，我们经常面对各种各样的数据模式和问题。有时，数据可能在某个区域内呈现出线性关系，而在另一个区域则呈现出非线性关系。有时，我们对于某些区域的预测更加关注，希望能够更准确地捕捉到那些重要的点。这时，LWR算法就展现出了它的独特优势。\n让我们回到我们的探险之旅。在LWR算法中，带宽参数起着至关重要的作用。这个参数控制着样本权重随其与查询点之间距离的衰减速度。想象一下，如果我们选择一个较小的，那么只有离查询点非常近的训练样本才会受到较高的权重，而离查询点较远的样本则会受到较低的权重。这就好像我们的小精灵更注重那些距离查询点更近的样本，认为它们对于预测更加重要。\n另一方面，如果我们选择一个较大的，那么样本的权重衰减速度将变得较慢，离查询点较远的样本仍然会有较高的权重。这就好像我们的小精灵更加关注整体的数据趋势，不过仍然保留了远离查询点的样本的影响。\n嘿，还记得我们之前提到的权重选择公式吗？，这是一个非常常见的选择。但也请注意，这只是一个示例，实际上还有其他的权重选择方式，可以根据具体问题进行调整和探索。\n我知道你一定迫不及待地想要实践一下LWR算法了。在接下来的作业中，你将有机会亲自尝试不同的带宽参数，并观察它对预测结果的影响。这将帮助你更好地理解LWR算法的运作原理和特性。\nLWR算法步骤LWR算法的执行包括以下步骤：\n\n拟合参数θ：通过最小化加权误差来拟合参数。这里，是一个非负的权重值，用于调整每个训练样本在拟合过程中的重要性。\n预测：使用得到的参数对新的查询点进行预测。计算，将其作为我们的预测结果输出。\n\n在这里，我们将通过逐步展开这些步骤，深入了解每个步骤的细节和原理。\n拟合参数在LWR算法中，拟合参数的关键在于最小化加权误差。这里的权重决定了每个训练样本的重要性，进而影响参数的拟合过程。\n要拟合参数，我们需要选择合适的权重。在LWR中，一个常见的权重选择方式是使用高斯核函数，就是刚刚我们见到的：复习一下，在这个公式中，是第个训练样本的特征值，是查询点的特征值，是带宽参数。这个公式的作用是根据查询点与训练样本之间的距离，赋予每个训练样本一个权重值。距离越近的样本将具有较高的权重，对参数的拟合起到更大的影响；而距离较远的样本则具有较低的权重，对参数的拟合影响较小。\n这里，带宽参数起着关键的作用。它决定了权重随着距离的衰减速度。较小的会导致权重衰减较快，只有距离查询点较近的样本会对参数拟合产生较大的影响；而较大的会导致权重衰减较慢，距离查询点较远的样本仍然具有较高的权重。\n为了拟合参数，我们可以使用各种数值优化方法，如梯度下降或正规方程法。在优化过程中，我们使用加权误差作为目标函数，并根据权重对样本进行加权。\n预测一旦我们拟合了参数，我们就可以使用它来对新的查询点进行预测。预测的过程非常简单，我们只需计算，并将其作为我们的预测结果输出。\n这个预测过程可以看作是使用已经拟合好的参数对新的输入进行线性组合的过程。通过将参数与特征值进行线性组合，我们得到了我们对于新查询点的预测结果。\n通过拟合参数和预测过程，LWR算法为我们提供了一种灵活而强大的方式来适应不同的数据模式和预测需求。它允许我们个性化地构建模型，并根据查询点的特征和数据的分布情况进行个性化的预测。\n任务这个任务是我让GPT给出来的，因为毕竟在斯坦福原有的课程当中，这节课选修课，我也没找到作业在哪（其实是我懒）。。。TT\n任务1：调整带宽参数在这个作业中，你将尝试调整带宽参数，并观察其对LWR算法的影响。你可以选择一些不同的值，比如0.1、1、10，并进行如下实验：\n\n对于每个值，使用LWR算法进行参数拟合，并得到相应的参数。\n使用得到的参数对测试集中的样本进行预测，并计算预测结果的均方误差（Mean Squared Error）。\n观察不同值下的预测结果和均方误差之间的关系。\n\n通过这个作业，你将能够理解带宽参数对LWR算法的影响。较小的值会导致模型更关注查询点附近的训练样本，可能会出现过拟合的情况；而较大的值则会使模型更加关注整体的数据趋势，可能会出现欠拟合的情况。你可以通过观察均方误差来评估不同值下模型的性能。\n这个任务我写了个小程序，有python环境的可以尝试一下：\n\nClick to see more\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.datasets import make_regression\nfrom sklearn.model_selection import train_test_split\n\ndef compute_weights(X_train, x, tau):\n    # 计算权重值\n    weights = np.exp(-(np.linalg.norm(X_train - x, axis=1) ** 2) / (2 * tau ** 2))\n    return weights\n\ndef fit_lwr(X_train, y_train, x, tau):\n    # 拟合参数θ\n    X = np.hstack((np.ones((X_train.shape[0], 1)), X_train))  # 添加常数项\n    weights = compute_weights(X_train, x, tau)\n    W = np.diag(weights)\n    theta = np.linalg.inv(X.T @ W @ X) @ X.T @ W @ y_train\n    return theta\n\ndef predict_lwr(X_train, y_train, X_test, tau):\n    predictions = []\n    for x in X_test:\n        theta = fit_lwr(X_train, y_train, x, tau)\n        x = np.hstack(([1], x))  # 添加常数项\n        y_pred = theta.T @ x\n        predictions.append(y_pred)\n    return np.array(predictions)\n\n# 生成示例数据集\nX, y = make_regression(n_samples=100, n_features=1, noise=10, random_state=42)\n\n# 划分数据集\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# 设置不同的带宽参数\ntau_values = [0.1, 1, 10]\n\n# 绘制数据集和拟合结果的图像\nplt.figure(figsize=(12, 8))\n\nfor i, tau in enumerate(tau_values):\n    plt.subplot(2, 2, i+1)\n\n    # 绘制训练数据集\n    plt.scatter(X_train, y_train, color='b', label='Training Data')\n\n    # 拟合参数θ\n    theta = fit_lwr(X_train, y_train, X_train, tau)\n    print(f\"带宽参数τ = {tau}，拟合得到的参数θ：{theta}\")\n\n    # 预测并计算均方误差\n    y_pred = predict_lwr(X_train, y_train, X_test, tau)\n    mse = np.mean((y_pred - y_test) ** 2)\n    print(f\"带宽参数τ = {tau}，测试集上的均方误差：{mse}\\n\")\n\n    # 绘制拟合曲线\n    x_plot = np.linspace(np.min(X_train), np.max(X_train), 100)\n    X_plot = np.hstack((np.ones((x_plot.shape[0], 1)), x_plot.reshape(-1, 1)))\n    y_plot = X_plot @ theta\n    plt.plot(x_plot, y_plot, label=f\"τ = {tau}\")\n\n    plt.xlabel('X')\n    plt.ylabel('y')\n    plt.legend()\n    plt.title(f'Local Weighted Linear Regression (τ = {tau})')\n\nplt.tight_layout()\nplt.show()\n\n\n这段代码首先使用make_regression函数生成一个示例数据集，（运用了种子来进行随机数据集，便于复现），然后使用train_test_split将数据集划分为训练集和测试集。\n然后，compute_weights函数用于计算权重值，fit_lwr函数用于拟合参数，predict_lwr函数用于进行预测。\n在主程序中，我们设置了不同的带宽参数值[0.1、1、10]，然后对每个参数值进行拟合和预测。最后，我们计算并输出每个参数值下测试集上的均方误差。\n使用了plt.subplot函数来创建一个2x2的子图布局，并在每个子图中绘制不同带宽参数下的拟合结果。每个子图显示了训练数据集的散点图和相应的拟合曲线。\n图像如下\n\n\n你可以根据实际情况修改代码，使用自己的数据集和问题进行实验。通过观察不同带宽参数下的拟合效果和预测误差，你将能够更好地理解带宽参数对LWR算法的影响。\n\n\n作业2：应用LWR算法解决实际问题在这个作业中，你将应用LWR算法解决一个实际的问题。你可以选择感兴趣的领域，如房价预测、销量预测等，并按照以下步骤进行：\n数据集可以用我们之前用过的房价数据集，我放到这里：\n\nClick to see more\n# 数据集\nareas = np.array([2104, 1600, 2400, 1416, 3000, 1985, 1534, 1427, 1380, 1494, 1940, 2000, 1890, 4478, 1268, 2300, 1760, 1450, 3100, 2250, 2132, 2596, 1850, 2680, 1956, 1604, 2020, 2730, 2008, 1537, 2500, 1560, 2120, 2200, 1638, 2540, 2200, 2070, 2005, 1900, 2380, 1320, 2190, 2340, 2678, 1966, 1570, 1852, 2454, 2205, 2450])\nbedrooms = np.array([3,3,3,2,4,4,3,3,3,3,4,3,3,5,3,4,3,3,4,4,4,3,4,4,3,3,4,4,3,3,4,4,4,3,3,4,3,4,3,3,4,2,4,3,4,4,3,3,4,4,4])\nprices = np.array([400, 330, 369, 232, 540, 320, 267, 199, 245, 347, 334, 383, 339, 699, 259, 410, 350, 315, 590, 410, 399, 459, 325, 480, 349, 285, 365, 525, 375, 295, 450, 280, 389, 425, 315, 475, 408, 382, 350, 380, 420, 230, 394, 416, 540, 385, 279, 360, 485, 405, 450])\n\n\n\n\n收集和准备数据集：选择一个合适的数据集，并对数据进行预处理，确保数据的质量和一致性。\n划分数据集：将数据集划分为训练集和测试集，用于参数拟合和模型评估。\n使用LWR算法进行参数拟合：根据训练集使用LWR算法拟合参数。\n模型评估：使用测试集进行模型评估，计算预测结果的均方误差或其他适当的评估指标。\n结果分析和改进：分析预测结果，并根据需要对模型进行改进和调整。\n\n通过完成这个作业，你将能够将LWR算法应用到实际问题中，并通过实践加深对算法的理解。你可以探索不同的数据集和问题领域，进一步挖掘LWR算法的潜力。\n","slug":"Locally-weighted-linear-regression-optional-reading","date":"2023-07-17T07:42:47.000Z","categories_index":"","tags_index":"笔记,Machine Learning","author_index":"General_K1ng"},{"id":"85691702e05d151e003d7396dcbea440","title":"概率解释*","content":"引言当涉及到机器学习算法时，有时我们不仅仅希望通过数学的角度来理解它们的原理，还希望探索它们的概率解释。在这个部分中，我们将探讨线性回归算法的概率解释。\n你有没有想过，为什么我们在回归问题中使用平方误差作为成本函数？为什么我们假设模型的预测值和真实值之间存在高斯分布的误差？通过概率解释，我们可以更深入地理解线性回归模型的工作原理，并从统计学的角度来看待它。\n当我们谈论概率解释时，让我们以一个简单易懂的例子来说明。假设你是一位面包师傅，你烘焙面包的时间和温度是你最关注的因素。你想要根据面包的温度来预测它的烘焙时间。\n现在，假设你已经收集了一些数据，包括了面包的温度和相应的烘焙时间。你想要建立一个模型，根据温度来预测烘焙时间。这就是一个典型的线性回归问题。\n现在，让我们用概率解释来理解这个问题。我们可以将线性回归模型看作是在给定面包温度的条件下，对烘焙时间的条件分布进行建模。换句话说，我们想要找到一个条件分布，它告诉我们在已知温度的情况下，烘焙时间可能的取值范围。\n通过概率解释，我们可以得到一个关键的洞察力：我们不仅仅是在寻找一个点估计，即给定温度预测单个烘焙时间，而是在寻找一个整个概率分布，它表示了在给定温度下烘焙时间的不确定性。\n这种概率解释对于面包师傅来说非常有用。它不仅告诉你在给定温度下的预测烘焙时间，还告诉你该预测的不确定性范围。这样，你就可以更加自信地做出决策，控制烘焙时间，确保面包在最佳状态下烘焙。\n所以，通过概率解释，线性回归模型不仅可以帮助你做出预测，还可以提供预测的不确定性估计，使你更加有信心地应对面包烘焙的挑战。这就是概率解释为我们带来的额外好处。\n概率解释在面对回归问题时，为什么线性回归，尤其是最小二乘成本函数 ，是一个合理的选择呢？让我们通过一组概率假设来解释这一点，根据这些假设，最小二乘回归可以被推导为一种非常自然的算法。\n我们假设目标变量和输入之间存在以下关系：其中  是一个误差项，用于捕捉未建模的影响（例如，我们没有在回归中包含与预测房价高度相关的某些特征）或者随机噪声。我们进一步假设  是独立同分布（IID）地遵循均值为零、方差为  的高斯分布（也称为正态分布）。我们可以表示这个假设为 “”，即  的概率密度函数为：\n\n\n\n\n\n\n\n\n\n在机器学习和数学中，exp 表示指数函数，即自然指数函数，记作 ，其中  是自然对数的底数（欧拉数，约等于2.71828）。指数函数是一个常用的数学函数，它的定义是将底数  提升到给定的指数值。\n在上述笔记中，exp 是将指数函数应用于括号内的表达式。例如，在计算高斯分布的概率密度函数时，指数函数被用于计算  这个指数部分。\n指数函数具有将非负实数映射到正实数的特性，它在概率密度函数和其他数学模型中经常被使用，例如高斯分布、指数分布等。\n因此，我们可以表示给定  和由参数  控制的  的分布为：这表示了  在给定  的条件下，根据参数  的分布。需要注意的是，我们不应将  视为条件概率  的一部分，因为  不是一个随机变量。我们还可以将  的分布写为 。\n在给定 （设计矩阵，包含所有 ）和  的情况下， 的整体分布是什么样的？数据的概率由  给出。这个量通常被视为 （以及可能的 ）的函数，对于固定的  值。当我们希望明确将其视为  的函数时，我们将其称为似然函数：根据对 （从而对给定的  和 ）的独立性假设，我们还可以将其写成如下形式：现在，考虑到这个将  和  关联的概率模型，我们应该以何种方式合理地选择参数  来获得最佳估计？最大似然原理指出，我们应该选择能够使数据的概率最大化的 。换句话说，我们应该选择能够最大化  的 。\n与最大化  等价的是最大化  的任何严格递增函数。特别地，如果我们转而最大化对数似然函数 ，推导会更加简单：：因此，最大化  得到与最小化相同的结果：我们将这个结果记为 ，也就是最初的最小二乘代价函数。\n总结一下，在数据的先验概率假设下，最小二乘回归对应于找到参数  的最大似然估计。因此，在这种假设下，最小二乘回归可以被认为是一种非常自然的方法，它只是在进行最大似然估计而已。（需要注意的是，概率假设并不是使得最小二乘成为完全合理和恰当的过程所必需的，还可能存在其他自然的假设可以用来证明它的合理性。）\n此外，根据我们之前的讨论，我们的最终  的选择并不依赖于  的值，实际上，即使  是未知的，我们也会得到相同的结果。当我们讨论指数族和广义线性模型时，我们将再次利用这一事实。\t\n举例说明假设你正在研究房屋价格与其尺寸之间的关系。你收集了一些房屋的尺寸和实际售价的数据，并希望使用机器学习来构建一个预测模型。在这种情况下，你可以使用最小二乘回归作为你的算法，并通过概率解释来理解它的合理性。\n根据概率解释，我们假设房屋价格与尺寸之间的关系可以通过以下方程表示：其中  是第  个房屋的实际售价， 是对应的尺寸特征， 是我们要学习的参数，而  则表示误差项。\n根据概率假设，我们假设误差项  是从均值为零、方差为  的高斯分布中独立同分布地抽样得到的。这意味着我们认为误差是随机的，并且服从正态分布。这个假设可以让我们使用概率密度函数来描述误差项的分布情况。\n现在，我们可以根据这个概率模型来定义给定  的条件下， 的分布：这表示给定  的情况下， 的分布是一个以  为均值、 为方差的高斯分布。\n我们的目标是找到使得观测到的数据的概率最大化的参数 。也就是说，我们希望选择参数 ，使得数据的整体概率  最大化。\n根据最大似然估计的原理，我们可以通过最大化似然函数  或对数似然函数  来获得最佳参数估计。在最小二乘回归中，我们常使用对数似然函数来简化推导。\n通过计算对数似然函数 ，我们可以将最大似然估计转化为最小化残差平方和的问题，即最小化代价函数 ：这刚好是最小二乘回归中使用的成本函数。\n因此，根据概率解释，最小化最小二乘成本函数  相当于在给定概率模型的前提下，寻找参数  的最大似然估计。这说明了最小二乘回归的合理性和自然性。\n补充当使用最小二乘法进行机器学习中的回归任务时，并不需要对概率解释的细节了如指掌。嗯，你没听错，概率解释并不是机器学习中的“铁板钉钉”。\n实际上，对于许多问题来说，最小二乘法就足够了，它能够给出很好的结果，而不需要我们费神去琢磨概率解释的种种细节。毕竟，最小二乘法是机器学习中非常常见且有效的方法。\n但是，不可否认的是，在某些情况下，了解概率解释和统计学原理是很有帮助的。特别是当你处理带有噪声的数据时，概率解释可以告诉你模型的不确定性和置信度。这样一来，你就能更好地理解和解释你的模型结果了。\n总而言之，了解最小二乘法是机器学习中的重点，而对概率解释的深入探究则是可选的。如果你只是想简单地应用最小二乘法来完成回归任务，那了解一些基本的原理和实现就足够了。当然，如果你对概率解释和统计学概念感兴趣，那么对于某些特定问题来说，深入研究概率解释会给你带来更深入的理解和分析能力。\n","slug":"Probabilistic-interpretation","date":"2023-07-17T06:02:56.000Z","categories_index":"","tags_index":"笔记,Machine Learning","author_index":"General_K1ng"},{"id":"8bd50a6b3cea7ecea2a8063e70b7409b","title":"正规方程","content":"引入在机器学习和线性回归中，我们经常需要通过训练数据来学习参数，以便建立一个能够准确预测目标变量的模型。前面我们已经介绍了梯度下降法，这是一种常用的优化算法，可以帮助我们找到最小化成本函数的参数值。\n除了梯度下降法，还有一种有趣而简洁的方法可以解决线性回归问题，它被称为正规方程（The Normal Equations）。正规方程提供了一种通过代数方法直接求解最优参数的方式，而不需要像梯度下降法那样迭代更新。\n让我们以一个生动的例子来理解正规方程。假设你是一名厨师，你想要制作一道美味的蛋糕。你知道蛋糕的味道取决于配料的种类和数量。你希望找到一个最佳的配料组合，使得蛋糕的口感和味道达到最佳。\n为了解决这个问题，你决定进行一系列实验。你准备了不同数量和种类的配料，并且每次制作蛋糕后，让一群品尝师评价蛋糕的口感。你记录下每个实验中使用的配料种类和数量，以及对应的评分。\n现在，你的目标是通过这些实验数据，找到一种最佳的配料组合，以获得最佳的蛋糕口感。你想要建立一个线性模型，通过配料的数量和种类预测口感评分。这个问题就可以转化为一个线性回归问题。\n正规方程提供了一种直接求解线性回归参数的方法。它的原理类似于代数方程的求解过程。通过对训练数据进行数学运算，我们可以得到一个公式，可以直接计算出最优的参数值。\n正规方程不需要像梯度下降法那样进行迭代更新，因此在某些情况下，它可能更加高效。然而，正规方程也有一些限制，例如当特征数量非常大时，计算复杂度会增加。\n在接下来的部分，我们将详细介绍正规方程的原理和应用。正规方程为我们提供了一种有趣而直接的方式来解决线性回归问题，让我们一起探索吧！\n正规方程正规方程是一种通过代数方法直接求解线性回归参数的方法，而不需要像梯度下降法那样进行迭代更新。它的原理是通过最小化成本函数，找到使得预测值与实际值之间差异最小的参数值。\n为了理解正规方程的原理，让我们再回到蛋糕制作的例子。你已经进行了一系列实验，记录了不同配料组合的口感评分。现在，你想要找到最佳的配料组合，使得蛋糕的口感评分最高。\n回忆一下线性回归模型的表示形式：。我们的目标是找到一组最优的参数，使得尽可能接近实际的口感评分。\n我们定义成本函数来衡量预测值与实际值之间的差异。对于线性回归问题，我们通常使用平方差误差（SSE）作为成本函数，即，其中是训练样本的数量。\n现在，我们的目标是找到最优的参数，使得成本函数最小化。而正规方程就提供了一种求解最优参数的解析解。具体来说，我们通过对关于参数的导数进行求解，并将其设置为零来最小化。\n在进行矩阵表示时，我们将训练样本的特征向量表示为矩阵，其中每一行代表一个样本的特征，每一列代表一个特征维度。类似地，我们将实际值表示为向量。那么，线性回归模型可以写成矩阵形式：。\n应用矩阵微积分的概念，我们可以求解成本函数关于参数的导数。这个导数称为梯度（gradient），用表示。当梯度为零时，我们得到正规方程的解。\n通过代数计算，我们可以得到正规方程的表达式：。这个表达式直接给出了最优参数的解析解。\n正规方程的优点在于它不需要进行迭代更新，可以直接得到最优参数的解析解。然而，它的计算复杂度取决于特征的数量，当特征数量非常大时，求解逆矩阵的计算可能变得耗时。\n在实际应用中，我们可以根据问题的特点选择使用梯度下降法还是正规方程。梯度下降法适用于大规模数据集和高维特征空间，而正规方程适用于小规模数据集和低维特征空间。\n矩阵导数矩阵导数是矩阵微积分中的重要概念，用于描述函数对矩阵变量的导数。在矩阵导数中，我们将函数从一个行列的矩阵映射到实数，定义为。为了求解矩阵导数，我们需要计算函数相对于矩阵的偏导数。矩阵导数本身也是一个行列的矩阵，其中元素表示函数对的偏导数。\n例如，假设是一个2行2列的矩阵，函数：定义为：在这个例子中，表示矩阵的元素。\n我们可以通过计算偏导数来得到矩阵导数的表达式。根据定义，我们计算对每个的偏导数，然后将它们组合成矩阵的形式。对于我们的例子，我们可以得到如下结果：这个结果展示了矩阵导数的计算方式。每个元素都是相应偏导数的结果。例如，元素是对的偏导数，元素是对的偏导数，以此类推。\n最小二乘法再探讨借助矩阵导数的工具，现在让我们通过闭式解来找到使最小化的的值。我们首先将用矩阵-向量表示法重新书写。\n给定一个训练集，定义设计矩阵为一个行列的矩阵（实际上是行列，如果我们包括截距项），其行包含训练示例的输入值：此外，让是一个维向量，包含来自训练集的所有目标值：现在，由于，我们可以很容易地验证：因此，利用向量的性质，我们有 ：最后，为了最小化，让我们找到它相对于的导数。因此，我们有：在第三步中，我们使用了的事实，在第五步中使用了和的事实，其中是对称矩阵。为了最小化，我们将其导数设为零，得到正规方程：因此，最小化的值可以通过以下方程的闭式解给出：\n\n\n\n\n\n\n\n\n\n请注意，在上述步骤中，我们隐含地假设是可逆矩阵。在计算逆矩阵之前，可以进行检查。如果线性无关的样本数量少于特征数量，或者特征不是线性无关的，则将不可逆。即使在这种情况下，也有可能通过额外的技术来“修正”这种情况，但为了简洁起见，我们在这里省略了这些内容。\n举例我们再回到最开始那个做烘焙的例子，假设你是一位厨师，想要研究面包的烘焙时间和温度之间的关系。你收集了一系列实验数据，记录下了烘焙时间和使用的温度。现在，你想要找到一个数学模型来预测未来的烘焙时间。这时，线性回归和最小二乘法就能派上用场了。\n现在，让我们使用矩阵导数的工具来重新表达成本函数。首先，我们定义设计矩阵，它是一个行列的矩阵，其中每一行包含一个实验样本的特征值（在我们的例子中就是温度）。我们还定义目标向量，它是一个维向量，包含对应每个实验样本的烘焙时间。\n我们收集了一些数据，记录了不同温度下烘焙面包所需的时间。现在我们要使用这些数据来训练一个线性回归模型，以便我们可以根据温度来预测烘焙时间。\n首先，让我们创建一个虚构的数据集（这是我用程序随机生成的）。假设我们有以下数据：\n\nClick to see more\n\n\n\n温度（摄氏度）\n烘焙时间（分钟）\n\n\n\n168.7\n41.4\n\n\n197.5\n52.2\n\n\n186.6\n45.0\n\n\n179.9\n43.7\n\n\n157.8\n42.8\n\n\n157.8\n32.0\n\n\n152.9\n31.9\n\n\n193.3\n45.8\n\n\n180.1\n41.0\n\n\n185.4\n48.7\n\n\n\n\n\n\n\n\n现在，我们将数据表示为输入特征矩阵和目标变量向量。是一个包含温度特征的矩阵，是对应的烘焙时间。\n接下来，我们将为矩阵添加截距项列。这样，矩阵的第一列将始终为1，以表示截距(intercept)。\n现在，我们可以使用正规方程来求解参数。正规方程的公式为：\n这个公式会给出使得模型最优拟合数据的参数值。\n控制台会输出：\nIntercept: -19.32\nSlope: 0.35\n\n\n\n\n\n为了应用这个公式，我们需要使用Python进行计算。我们可以使用NumPy库来进行矩阵运算。让我们来看看如何在Python中计算正规方程的闭式解：\n\nClick to see more\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nnp.random.seed(42)  # 设置随机种子，以便结果可复现\n\n# 创建输入特征 X（温度）和目标变量 y（烘焙时间）\nX = np.random.uniform(150, 200, 10).reshape(-1, 1)  # 温度范围在150到200之间\ny = 10 + 0.2 * X + np.random.normal(0, 5, 10).reshape(-1, 1)  # 烘焙时间=10 + 0.2*温度 + 噪声\n\n# 添加截距项列（全为1）到 X 矩阵中\nX = np.concatenate((np.ones((X.shape[0], 1)), X), axis=1)\n\n# 计算参数 theta\ntheta = np.linalg.inv(X.T @ X) @ X.T @ y\n\nintercept = theta[0][0]\nslope = theta[1][0]\nprint(f\"Intercept: {intercept:.2f}\")\nprint(f\"Slope: {slope:.2f}\")\n\n\n# 绘制数据点\nplt.scatter(X[:, 1], y, label=\"Data\")\n\n# 绘制拟合的线性回归模型\nx_line = np.linspace(150, 200, 100)\ny_line = intercept + slope * x_line\nplt.plot(x_line, y_line, color=\"red\", label=\"Linear Regression\")\n\n# 添加标签和图例\nplt.xlabel(\"Temperature\")\nplt.ylabel(\"Baking Time\")\nplt.legend()\n\n# 显示图形\nplt.show()\n\n\n\n\n运行这段代码，我们会得到参数的值。在这个例子中，我们会得到两个参数：截距项参数和温度参数。这些参数表示烘焙时间与温度之间的线性关系。\n一旦我们求解出参数，我们就可以使用它来进行预测。给定一个新的温度值，我们可以通过计算来预测对应的烘焙时间。\n这节的内容会比较难以理解，希望可以反复阅读，如有疑问欢迎提出，说实话，我都有些没看懂。\n","slug":"The-normal-equations","date":"2023-07-17T04:09:05.000Z","categories_index":"","tags_index":"笔记,Machine Learning","author_index":"General_K1ng"},{"id":"eee27f691084ae51bee755f5fe41f548","title":"LMS算法","content":"欢迎来到新的一部分！现在我们将介绍一种非常有趣的算法，它被称为最小均方（Least Mean Squares，LMS）算法。这是一种用于优化线性回归模型的算法，它可以帮助我们找到最佳的参数组合，使得我们的预测结果与实际观测值之间的差异最小化。\nLMS算法实际上是一个非常聪明的算法，它的灵感来自于我们人类在学习过程中的一种思维方式。想象一下，当你在学习骑自行车或者学习弹吉他时，你并不会一次就掌握所有技巧。相反，你会不断地试验、调整和改进，直到你的动作越来越接近完美。\nLMS算法的原理也是类似的。它通过逐步调整模型的参数来最小化成本函数，就像我们逐步调整我们的动作来提高技能一样。在每一步中，LMS算法会计算出当前参数设置下的成本函数值，并根据这个值来调整参数，以便使下一次迭代的预测结果更接近实际观测值。这个过程就像是在不断地微调模型，让它的预测能够更准确地拟合实际数据。\n一个有趣的比喻是，想象你是一名音乐家，正在调音吉他。你会先弹奏一根弦，然后通过调整琴弦的张力来使音高趋近于理想的音高。LMS算法的工作方式类似于这个过程，它会在每一步中微调模型的参数，使得预测结果逐渐接近实际观测值，就像音高逐渐趋近理想音高一样。\nLMS算法是一种非常强大和常用的优化算法，特别适用于解决线性回归问题。它不仅可以用于预测骑行时间，还可以应用于各种其他领域，如金融、医疗和天气预测等。通过不断地微调参数，LMS算法帮助我们找到最佳的模型参数，使我们的预测结果更加准确和可靠。\nLMS算法我们继续探讨LMS算法！让我们首先回顾一下我们的目标：选择合适的参数来最小化成本函数。为了实现这一目标，我们需要一个搜索算法，该算法从一个”初始猜测”开始选择，然后通过迭代改变以使逐渐变小，直到我们收敛到使最小化的值。\n\n\n\n\n\n\n\n\n\n我们使用符号“a := b”来表示一种操作（在计算机程序中），该操作将变量a的值设置为等于变量b的值。换句话说，这个操作会用b的值覆盖a的值。相反，当我们在断言一个事实时，即a的值等于b的值，我们会写成“a = b”。\n那么，我们如何在每次迭代中更新参数呢？这就是LMS算法的精髓所在。它使用一种称为梯度下降的方法，以最陡的下降方向更新参数。具体而言，在每次迭代中，我们将参数更新为，其中是学习率。\n为了更好地理解LMS算法的更新规则，让我们以一个简单的例子来说明。假设我们只有一个训练样本，其中是我们的输入特征，是对应的目标值。我们的目标是根据输入预测出目标值。我们将使用线性模型来进行预测。\n这是一个非常自然的算法，它重复地朝着最陡的下降方向迈出一步。为了实现这个算法，我们需要计算出右侧的偏导数项。让我们首先计算出在只有一个训练样本的情况下的结果，这样我们就可以忽略的定义中的求和符号。为了更新参数和，我们需要计算成本函数对于每个参数的偏导数。通过计算，我们得到偏导数的表达式为：。这表明参数的更新量与误差项成比例，以及输入特征。根据这个结果，我们可以得到LMS算法的更新规则：这个规则被称为LMS更新规则（LMS代表“最小均方差”），也被称为Widrow-Hoff学习规则。这个规则具有几个看起来自然而直观的特性。例如，更新的幅度与误差项成比例；因此，例如，如果我们遇到一个训练样本，我们的预测几乎与的实际值相匹配，那么我们发现几乎不需要改变参数；相反，如果我们的预测与有较大的误差（即相距较远），那么参数将会有较大的变化。\n梯度下降法当我们使用机器学习算法解决问题时，经常需要最小化一个函数。梯度下降法（Gradient Descent）是一种常用的优化算法，用于找到函数的最小值。\n让我们通过一个生动的例子来解释梯度下降法。假设你是一位登山爱好者，目标是从山顶下到山脚的最短路径。你置身于山顶，但是你没有任何线索告诉你应该往哪个方向走。你面前一片云雾茫茫，你看不到山脚。然而，你手上有一个高度计可以告诉你当前的海拔高度。\n你的目标是找到一条最快的下山路径。你知道山的地形图呈现出一种斜率或坡度。你也知道下山的最陡峭方向就是当前位置的负梯度方向。\n梯度下降法的思想类似于登山者的行动。你观察当前位置的海拔高度，并朝着最陡峭的下坡方向迈出一步。然后，你再次观察新位置的海拔高度，继续朝着最陡峭的下坡方向迈出一步。你不断重复这个过程，逐步接近山脚。\n在数学中，我们使用类似的思想来最小化函数。假设我们有一个函数，我们希望找到它的最小值。梯度下降法通过迭代地计算函数的梯度，沿着梯度的反方向更新参数，以使函数的值逐渐减小。\n函数的梯度是一个向量，指示函数在给定点上最陡峭的上升方向。我们的目标是朝着最陡峭的下降方向前进，因此我们朝着梯度的反方向更新参数。\n\n\n\n\n\n\nTIP\n这个过程可以表示为以下步骤：\n\n初始化参数：选择一个初始的参数值作为起点。\n计算梯度：计算函数在当前参数值处的梯度。梯度告诉我们函数在该点上升的方向和速度。\n更新参数：根据梯度的方向和一个称为学习率的调整参数，更新参数值。\n重复步骤2和步骤3，直到达到停止条件。停止条件可以是达到最大迭代次数、参数变化很小或函数值达到某个阈值。\n\n\n\n通过迭代更新参数，梯度下降法能够找到函数的局部最小值或全局最小值，这取决于函数的性质和初始参数的选择。\n梯度下降法在机器学习中扮演重要角色，它是许多算法的基础，例如线性回归、逻辑回归和神经网络。它允许我们通过最小化成本函数来调整模型的参数，使模型更好地拟合训练数据。\n批量梯度下降我们已经推导出了适用于单个训练样本的LMS更新规则。但是，对于包含多个训练样本的训练集，我们可以通过将坐标更新组合成向量形式来简化更新规则：\n​\t\t\t\t重复直到收敛 {}\n通过将坐标的更新组合成向量θ的更新，我们可以以更简洁的方式重新编写更新式（1.1）：这种形式的更新规则被称为批量梯度下降，因为它在每次迭代中考虑整个训练集。需要注意的是，对于线性回归的优化问题，由于成本函数是一个凸二次函数，不存在局部最小值，只有一个全局最小值。因此，梯度下降算法总是会收敛到全局最小值（前提是学习率不要设置得太大）。\n\n\n当然python的代码如下，你可以自己尝试\n\nClick to see more\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 定义二次函数\ndef quadratic_function(x, y):\n    return x**2 + y**2\n\n# 定义二次函数的偏导数\ndef gradient(x, y):\n    return np.array([2*x, 2*y])\n\n# 定义梯度下降函数\ndef gradient_descent(gradient, initial_point, learning_rate, num_iterations):\n    path = [initial_point]\n    point = initial_point\n\n    for _ in range(num_iterations):\n        grad = gradient(*point)\n        point = point - learning_rate * grad\n        path.append(point)\n\n    return np.array(path)\n\n# 定义绘制等高线图的函数\ndef plot_contour(func):\n    x = np.linspace(-5, 5, 100)\n    y = np.linspace(-5, 5, 100)\n    X, Y = np.meshgrid(x, y)\n    Z = func(X, Y)\n\n    plt.figure(figsize=(8, 6))\n    plt.contour(X, Y, Z, levels=20)\n    plt.colorbar()\n    plt.xlabel('x')\n    plt.ylabel('y')\n    plt.title('Contour Plot')\n    plt.grid(True)\n\n# 设置初始点、学习率和迭代次数\ninitial_point = np.array([3.0, 4.0])\nlearning_rate = 0.1\nnum_iterations = 20\n\n# 运行梯度下降算法\npath = gradient_descent(gradient, initial_point, learning_rate, num_iterations)\n\n# 绘制等高线图和路径\nplot_contour(quadratic_function)\nplt.plot(path[:, 0], path[:, 1], '-ro')\nplt.show()\n\n\n\n首先，图像展示了一个二维平面，其中轴和轴代表二次函数的输入变量的取值范围。二次函数由公式 给出，其中等高线表示函数值相等的点。等高线的形状呈现出圆形，因为函数是关于和的平方和的形式。\n其次，等高线的颜色表示函数值的大小。颜色条(colorbar)位于图像右侧，它显示了颜色与函数值的对应关系。颜色越深表示函数值越小，而颜色越浅表示函数值越大。在这个示例中，我们选择了20个等高线水平线，因此你可以看到等高线从内部圆开始，逐渐向外部圆扩展。\n接下来，红色的路径表示梯度下降算法的路径。我们使用初始点 (3.0, 4.0)作为起始点，并选择学习率为0.1，执行了20次迭代。梯度下降算法根据当前点的梯度信息来更新下一个点的位置，直到达到指定的迭代次数。红色路径显示了从初始点开始，沿着梯度下降方向逐步更新点的位置的过程。你可以看到路径开始在较陡峭的地方，然后逐渐向梯度变小的区域移动，最终趋近于函数的最小值(0, 0)。\n面积与房价我们继续研究梯度下降算法的不同变体！让我们先来看看批量梯度下降算法在拟合房屋价格预测模型时得到的结果。根据我们之前的数据集，通过运行批量梯度下降，我们得到了参数值和，它们可以用于构建线性模型来预测房屋价格，其中表示房屋的居住面积。如果我们绘制作为（面积）的函数，并结合训练数据，我们会得到上面的图表。这个模型给出了一个大致符合数据趋势的直线。\n\n\n当然，代码如下\n\nClick to see more\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 数据集\nareas = np.array([2104, 1600, 2400, 1416, 3000, 1985, 1534, 1427, 1380, 1494, 1940, 2000, 1890, 4478, 1268, 2300, 1760, 1450, 3100, 2250, 2132, 2596, 1850, 2680, 1956, 1604, 2020, 2730, 2008, 1537, 2500, 1560, 2120, 2200, 1638, 2540, 2200, 2070, 2005, 1900, 2380, 1320, 2190, 2340, 2678, 1966, 1570, 1852, 2454, 2205, 2450])\nprices = np.array([400, 330, 369, 232, 540, 320, 267, 199, 245, 347, 334, 383, 339, 699, 259, 410, 350, 315, 590, 410, 399, 459, 325, 480, 349, 285, 365, 525, 375, 295, 450, 280, 389, 425, 315, 475, 408, 382, 350, 380, 420, 230, 394, 416, 540, 385, 279, 360, 485, 405, 450])\n\n# 数据归一化（特征缩放）\nareas_normalized = (areas - np.mean(areas)) / np.std(areas)\nprices_normalized = (prices - np.mean(prices)) / np.std(prices)\n\n# 添加偏置项\nX = np.column_stack((np.ones(len(areas_normalized)), areas_normalized))\n\n# 初始化参数\ntheta = np.zeros(2)\nalpha = 0.01\niterations = 1500\n\n# 定义代价函数\ndef compute_cost(X, y, theta):\n    m = len(y)\n    h = np.dot(X, theta)\n    J = (1 / (2 * m)) * np.sum((h - y) ** 2)\n    return J\n\n# 批量梯度下降\ndef gradient_descent(X, y, theta, alpha, iterations):\n    m = len(y)\n    J_history = []\n    for _ in range(iterations):\n        h = np.dot(X, theta)\n        theta = theta - (alpha / m) * np.dot(X.T, h - y)\n        cost = compute_cost(X, y, theta)\n        J_history.append(cost)\n    return theta, J_history\n\n# 运行批量梯度下降算法\ntheta, J_history = gradient_descent(X, prices_normalized, theta, alpha, iterations)\n\n# 绘制拟合曲线\nx_values = np.linspace(-2, 2, 100)\ny_values = theta[0] + theta[1] * x_values\n\n\n# 绘制数据点和拟合曲线\nplt.scatter(areas_normalized, prices_normalized, label='Training Data')\nplt.plot(x_values, y_values, color='red', label='Linear Regression')\nplt.xlabel('Normalized Area')\nplt.ylabel('Normalized Price')\nplt.title('House Prices vs. Area (Linear Regression)')\nplt.legend()\nplt.show()\n\n\n\n\n继续考虑卧室数量接下来，如果我们考虑卧室数量作为输入特征之一，我们可以使用批量梯度下降来拟合模型并得到参数值，，。通过将卧室数量纳入考虑，我们可以构建一个更复杂的模型来预测房屋价格。\n\n\n代码如下\n\nClick to see more\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# 数据集\nareas = np.array([2104, 1600, 2400, 1416, 3000, 1985, 1534, 1427, 1380, 1494, 1940, 2000, 1890, 4478, 1268, 2300, 1760, 1450, 3100, 2250, 2132, 2596, 1850, 2680, 1956, 1604, 2020, 2730, 2008, 1537, 2500, 1560, 2120, 2200, 1638, 2540, 2200, 2070, 2005, 1900, 2380, 1320, 2190, 2340, 2678, 1966, 1570, 1852, 2454, 2205, 2450])\nbedrooms = np.array([3,3,3,2,4,4,3,3,3,3,4,3,3,5,3,4,3,3,4,4,4,3,4,4,3,3,4,4,3,3,4,4,4,3,3,4,3,4,3,3,4,2,4,3,4,4,3,3,4,4,4])\nprices = np.array([400, 330, 369, 232, 540, 320, 267, 199, 245, 347, 334, 383, 339, 699, 259, 410, 350, 315, 590, 410, 399, 459, 325, 480, 349, 285, 365, 525, 375, 295, 450, 280, 389, 425, 315, 475, 408, 382, 350, 380, 420, 230, 394, 416, 540, 385, 279, 360, 485, 405, 450])\n\n# 特征缩放（归一化）\nareas_normalized = (areas - np.mean(areas)) / np.std(areas)\nbedrooms_normalized = (bedrooms - np.mean(bedrooms)) / np.std(bedrooms)\nprices_normalized = (prices - np.mean(prices)) / np.std(prices)\n\n# 构建设计矩阵\nX = np.column_stack((np.ones(len(areas_normalized)), areas_normalized, bedrooms_normalized))\n\n# 初始化参数\ntheta = np.zeros(3)\nalpha = 0.01\niterations = 1500\n\n# 定义代价函数\ndef compute_cost(X, y, theta):\n    m = len(y)\n    h = np.dot(X, theta)\n    J = (1 / (2 * m)) * np.sum((h - y) ** 2)\n    return J\n\n# 批量梯度下降\ndef gradient_descent(X, y, theta, alpha, iterations):\n    m = len(y)\n    J_history = []\n    for _ in range(iterations):\n        h = np.dot(X, theta)\n        theta = theta - (alpha / m) * np.dot(X.T, h - y)\n        cost = compute_cost(X, y, theta)\n        J_history.append(cost)\n    return theta, J_history\n\n# 运行批量梯度下降算法\ntheta, J_history = gradient_descent(X, prices_normalized, theta, alpha, iterations)\n\n# 输出最终回归表达式\ntheta0 = theta[0]\ntheta1 = theta[1]\ntheta2 = theta[2]\nprint(f\"最终回归表达式: hθ(x) = {theta0:.2f} + {theta1:.2f}x1 + {theta2:.2f}x2\")\n\n# 绘制拟合曲面\nx1_values = np.linspace(-2, 2, 100)\nx2_values = np.linspace(-2, 2, 100)\nx1, x2 = np.meshgrid(x1_values, x2_values)\ny_values = theta0 + theta1 * x1 + theta2 * x2\n\n# 绘制数据点和拟合曲面\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.scatter(areas_normalized, bedrooms_normalized, prices_normalized, c='b', marker='o')\nax.plot_surface(x1, x2, y_values, color='r', alpha=0.5)\nax.set_xlabel('Normalized Area')\nax.set_ylabel('Normalized Bedrooms')\nax.set_zlabel('Normalized Price')\nax.set_title('House Prices vs. Area and Bedrooms (Linear Regression)')\nplt.show()\n\n\n\n\n最终控制台会输出\n最终回归表达式: hθ(x) = 0.00 + 0.93x1 + 0.04x2\n\n\n\n你可以看到，通过添加更多的特征，我们可以得到更准确的房屋价格预测模型。这说明特征选择对于机器学习模型的性能至关重要。\n随机梯度下降除了批量梯度下降，还有一种非常有效的替代方法，它被称为随机梯度下降。这种方法的算法如下：\nLoop{    for  to ,{\n​\t\t\t\t\t\t​\t\t}\n}\n通过将坐标的更新组合成向量θ的更新，我们可以以更简洁的方式重新编写更新式:在这个算法中，我们遍历整个训练集，并且在每次遇到一个训练样本时，只使用该样本的误差梯度来更新参数。这个算法被称为随机梯度下降或增量梯度下降。与批量梯度下降不同的是，随机梯度下降可以立即开始取得进展，并且在每个样本上都继续进行更新。这使得随机梯度下降比批量梯度下降更快地将参数接近最小值。然而，需要注意的是，随机梯度下降可能无法收敛到真正的最小值，参数会在最小值周围波动，但是在实践中，这些接近最小值的参数值通常是对真实最小值的合理近似。因此，尤其是在训练集很大的情况下，随机梯度下降比批量梯度下降更受欢迎。\n通过这些不同的梯度下降算法，我们可以有效地拟合参数，从而得到准确的预测模型。在接下来的部分，我将继续更新我在机器学习部分自学的笔记，希望各位可以一起交流！\n","slug":"LMS","date":"2023-07-16T09:18:07.000Z","categories_index":"","tags_index":"笔记,Machine Learning","author_index":"General_K1ng"},{"id":"b6c077dbe8f34883367bdebb8559e973","title":"探索机器学习的魅力：从斯坦福大学CS229课程开始","content":"机器学习是当今科技领域的热门话题，而斯坦福大学的CS229课程则是深入学习机器学习的绝佳门户。这篇文章将带您踏上机器学习的征程，通过探索CS229课程中的第一个主题——监督学习，揭开这个令人着迷的领域的神秘面纱。无论您是初学者还是有一定经验的机器学习从业者，本文将带您以生动活泼且专业的方式了解监督学习的基本原理、应用领域以及最新的研究动态。\n（当然我也是小白，这只是我在学习过程当中的笔记 &gt;_&lt;）\n监督学习：预测房价的例子让我们从几个监督学习问题的例子入手。假设我们有一个数据集，其中包含了50栋房屋的居住面积和价格。我们可以将这些数据制成表格如下：\n\nClick to see more\n\n\n\n居住面积（feet^2）\n价格（1000$s）\n\n\n\n2104\n400\n\n\n1600\n330\n\n\n2400\n369\n\n\n1416\n232\n\n\n3000\n540\n\n\n1985\n320\n\n\n1534\n267\n\n\n1427\n199\n\n\n1380\n245\n\n\n1494\n347\n\n\n1940\n334\n\n\n2000\n383\n\n\n1890\n339\n\n\n4478\n699\n\n\n1268\n259\n\n\n2300\n410\n\n\n1760\n350\n\n\n1450\n315\n\n\n3100\n590\n\n\n2250\n410\n\n\n2132\n399\n\n\n2596\n459\n\n\n1850\n325\n\n\n2680\n480\n\n\n1956\n349\n\n\n1604\n285\n\n\n2020\n365\n\n\n2730\n525\n\n\n2008\n375\n\n\n1537\n295\n\n\n2500\n450\n\n\n1560\n280\n\n\n2120\n389\n\n\n2200\n425\n\n\n1638\n315\n\n\n2540\n475\n\n\n2200\n408\n\n\n2070\n382\n\n\n2005\n350\n\n\n1900\n380\n\n\n2380\n420\n\n\n1320\n230\n\n\n2190\n394\n\n\n2340\n416\n\n\n2678\n540\n\n\n1966\n385\n\n\n1570\n279\n\n\n1852\n360\n\n\n2454\n485\n\n\n2205\n405\n\n\n2450\n450\n\n\n\n\n我们可以用图表来展示这些数据：\n\n\n有了这样的数据，我们可以提出一个问题：基于波特兰其他房屋的居住面积，如何预测它们的价格呢？\n为了在接下来的讨论中使用统一的符号，我们将使用表示“输入”变量（在这个例子中是生活区域的大小），也称为输入特征；表示我们试图预测的“输出”或目标变量（价格）。对于一对，我们称其为训练示例（training example）。我们将学习的数据集，由n个训练示例的列表；构成，被称为训练集（training set）。请注意，上标“(i)”仅用于表示训练集的索引，与求幂无关。我们还将使用表示输入值的空间，表示输出值的空间。在这个例子中，。\n为了更正式地描述监督学习问题，我们的目标是给定一个训练集，学习一个函数：，使得成为y的“良好”预测器。从图表中可以看出，这个过程如下所示：\n\n\n当我们试图预测的目标变量是连续的，例如在房屋价格的例子中，我们将这种学习问题称为回归问题。回归问题的目标是建立一个模型，能够对连续的目标变量进行预测。通过分析各种特征和输入变量之间的关系，我们可以推断出目标变量的数值。在回归问题中，我们通常尝试拟合一条曲线或平面，以最好地表示数据的趋势和模式。\n相比之下，当目标变量只能取少量离散值时（比如，根据居住面积预测一个住宅是房子还是公寓），我们将这种学习问题称为分类问题。分类问题的目标是根据输入变量的特征将样本分配到预定义的离散类别中。在分类问题中，我们建立一个分类器，该分类器根据输入变量的特征预测目标变量的类别。为了将不同类别的样本区分开来，分类问题通常涉及使用统计技术或机器学习算法构建决策边界。\n线性回归让我们使我们的住房示例更加丰富，加入一个稍微复杂的数据集，我们还知道每栋房子的卧室数量。\n在这个数据集中，除了居住面积外，我们还有每个房子的卧室数量。我们可以将数据表示为以下表格：\n\nClick to see more\n\n\n\n居住面积（feet^2）\n卧室数量\n价格（1000$s）\n\n\n\n2104\n3\n400\n\n\n1600\n3\n330\n\n\n2400\n3\n369\n\n\n1416\n2\n232\n\n\n3000\n4\n540\n\n\n1985\n4\n320\n\n\n1534\n3\n267\n\n\n1427\n3\n199\n\n\n1380\n3\n245\n\n\n1494\n3\n347\n\n\n1940\n4\n334\n\n\n2000\n3\n383\n\n\n1890\n3\n339\n\n\n4478\n5\n699\n\n\n1268\n3\n259\n\n\n2300\n4\n410\n\n\n1760\n3\n350\n\n\n1450\n3\n315\n\n\n3100\n4\n590\n\n\n2250\n4\n410\n\n\n2132\n4\n399\n\n\n2596\n3\n459\n\n\n1850\n4\n325\n\n\n2680\n4\n480\n\n\n1956\n3\n349\n\n\n1604\n3\n285\n\n\n2020\n4\n365\n\n\n2730\n4\n525\n\n\n2008\n3\n375\n\n\n1537\n3\n295\n\n\n2500\n4\n450\n\n\n1560\n4\n280\n\n\n2120\n4\n389\n\n\n2200\n3\n425\n\n\n1638\n3\n315\n\n\n2540\n4\n475\n\n\n2200\n3\n408\n\n\n2070\n4\n382\n\n\n2005\n3\n350\n\n\n1900\n3\n380\n\n\n2380\n4\n420\n\n\n1320\n2\n230\n\n\n2190\n4\n394\n\n\n2340\n3\n416\n\n\n2678\n4\n540\n\n\n1966\n4\n385\n\n\n1570\n3\n279\n\n\n1852\n3\n360\n\n\n2454\n4\n485\n\n\n2205\n4\n405\n\n\n2450\n4\n450\n\n\n\n\n在这里，我们将表示为二维向量，包括居住面积和卧室数量。例如，表示训练集中第个房子的居住面积，表示卧室数量。（在设计学习问题时，我们可以自行选择包括哪些特征。如果我们收集住房数据，还可以考虑包括其他特征，如壁炉数量、卫生间数量等。稍后我们将详细讨论特征选择，但现在我们将特征视为给定的。）\n为了进行监督学习，我们需要决定如何在计算机中表示函数/假设。作为初始选择，我们假设我们决定将近似为的线性函数：在这个表达式中，是参数（也被称为权重），用于参数化从到的线性函数空间。当没有混淆的风险时，我们将在中省略θ的下标，并将其简化为。为了简化表示法，我们还引入一个约定，将设置为1（这是截距项），这样我们可以表示为：在上面的表达式中，我们将和都视为向量，其中是输入变量的数量（不包括）。现在，给定一个训练集，我们如何选择或学习参数？一个合理的方法似乎是使得尽可能接近，至少对于我们拥有的训练样本来说是如此。为了形式化这个问题，我们定义了一个函数，用于衡量每个值对应的与相应的之间的接近程度。我们定义了成本函数：让我们逐步解释成本函数的每个部分：\n\n 代表我们的模型对于输入样本  的预测值。\n 是对应于输入样本  的实际观测值。\n 表示我们的模型预测值与实际观测值之间的差异，即误差。\n 将误差进行平方，这是为了消除误差的正负号，并将大误差的影响放大，以更好地衡量它们对总体误差的贡献。\n 对所有训练样本的误差平方进行求和，得到总体误差的度量。\n 为了计算方便，我们对总体误差进行了归一化，除以2。这不会影响最终优化的结果，因为我们的目标是最小化成本函数，而不是具体的数值。\n\n因此，成本函数  衡量了模型预测值与实际观测值之间的差异的平方和的一半。我们的目标是通过调整参数  的值，使得成本函数的值最小化，从而使模型的预测尽可能接近实际观测值。\n如果听不懂，没关系，我们来举一个非常简单的例子来理解成本函数到底是什么玩意。当我们建立一个模型时，我们希望它能够根据输入数据预测出正确的结果。然而，在训练模型时，我们的预测可能与实际结果有一些差距。成本函数的作用就是衡量这些预测差距的大小。\n假设你是一名学生，每天都要骑自行车去上学。你决定根据骑行时间来预测你到达学校所需的时间。你记录了过去一周的骑行时间和实际到达学校的时间，如下所示：\n\n\n\n骑行时间（分钟）\n到达时间（分钟）\n\n\n\n20\n25\n\n\n25\n30\n\n\n30\n35\n\n\n35\n40\n\n\n40\n45\n\n\n现在，你想建立一个模型，根据骑行时间预测到达时间。你选择线性函数来表示模型，即假设到达时间与骑行时间之间存在一种线性关系。\n假设我们的模型为 ，其中  表示到达时间的预测值， 表示骑行时间。我们的目标是找到最佳的参数  和 ，使得模型的预测结果尽可能接近实际观测值。\n为了衡量模型的预测与实际观测值之间的差距，我们使用成本函数。在这个例子中，我们使用均方误差（Mean Squared Error，MSE）作为成本函数。MSE 的计算方式是将每个预测值与对应的实际观测值之间的差距平方，并取所有差距平方的平均值。\n现在，我们来计算一下成本函数的值。假设我们选择了一组参数  和 。我们可以将这些参数代入模型，并计算出每个骑行时间对应的预测值。\n\n\n\n骑行时间（分钟）\n到达时间（分钟）\n预测到达时间（分钟）\n差距（预测-实际）\n差距平方\n\n\n\n20\n25\n30\n-5\n25\n\n\n25\n30\n35\n-5\n25\n\n\n30\n35\n40\n-5\n25\n\n\n35\n40\n45\n-5\n25\n\n\n40\n45\n50\n-5\n25\n\n\n现在，我们将差距平方的平均值作为成本函数的值。在这种情况下，成本函数的计算如下：我们的目标是通过调整参数  和  的值，使得成本函数的值最小化。这意味着我们希望找到最佳的参数组合，使得模型的预测结果与实际观测值之间的差距最小化。\n希望这个例子能够更加清晰地解释成本函数的概念。成本函数用于衡量模型预测与实际观测之间的差距，并帮助我们找到最佳的参数组合。\n如果你之前接触过线性回归，你可能会注意到这个熟悉的最小二乘成本函数，它导致了普通最小二乘回归模型。无论你之前是否见过它，我们将继续讨论，并最终展示它是一个更广泛的算法家族中的特例。同时，这个成本函数的意义是衡量我们的预测与实际数据之间的差距。较小的成本值表示我们的预测较接近真实数据，而较大的成本值表示预测与真实数据之间的差距较大。\n如何有任何疑问或者建议欢迎在评论区评论&gt; &lt;!!!\n","slug":"初识机器学习","date":"2023-07-16T07:02:18.000Z","categories_index":"","tags_index":"笔记,Machine Learning","author_index":"General_K1ng"},{"id":"d99fcab655887d4444838841a030a1e7","title":"正项级数","content":"这是一个非常重要的课题，我们将开始学习关于正级数，请专心听讲。\n正项级数的定义正项级数是一种无穷级数，其项均为正实数。它的形式如下：其中为级数的第个项。\np级数p级数是指形如的级数，其中是一个正实数。该级数以分母的指数来命名。\np级数具有以下性质：\n\n如果，则p级数收敛。\n如果，则p级数发散。\n\n\n\n这个结果的证明基于积分测试。为了理解为什么这是正确的，我们可以考虑函数。这个函数在区间上连续、正值且递减，因此我们可以应用积分测试来得到级数的结果：对积分进行计算，我们得到：$$\\int_{1}^{\\infty} \\frac{1}{x^p}dx  \\left{\\right.$$因此，p级数收敛当且仅当，当时发散。\n对于，p级数的和可以用黎曼ζ函数（Riemann zeta function）来表示，它的定义为：黎曼ζ函数具有许多有趣的性质，并与数论和复分析等其他数学领域有着密切的联系。\n敛散性检验有几个用于确定正项级数收敛或发散的收敛性测试。以下是其中几个常用的测试：\n1. 比较判别法比较判别法是一种通过将待定级数与已知收敛性的另一个级数进行比较来确定级数的收敛性或发散性的方法。比较法的规则如下：\n假设  和  是具有正项的级数，并且对所有 ，满足 。\n\n如果  收敛，则  也收敛。\n如果  发散，则  也发散。\n\n换句话说，如果级数  的项始终小于或等于级数  的项，并且  收敛，那么  必定收敛。相反地，如果  发散，那么  也一定发散。\n比较测试经常用于将给定的级数与 p-级数进行比较，因为 p-级数的收敛性是众所周知的。具体而言，如果我们有一个形如  的级数，以及另一个级数 ，其中的项始终小于或等于 ，那么我们可以使用比较测试来确定  的收敛性。\n\n\n\n\n\n\n\n\n\n\n\n我们常用的一些参考无限级数有：\n\n几何级数\n调和级数\np-级数\n\n2. 极限比较判别法极限比较判别法是用于确定级数的收敛性或发散性的另一种方法。与比较法类似，它涉及将给定的级数与已知收敛性的另一个级数进行比较。然而，极限比较测试在选择要进行比较的级数方面更加灵活。\n假设  和  是具有正项的级数。令 ，其中  是一个有限的正数或者是 。\n\n如果 ，则  和  要么都收敛，要么都发散。\n如果  并且  收敛，则  也收敛。\n如果  并且  发散，则  也发散。\n\n极限比较测试在选择要进行比较的级数方面更加灵活，因为我们只需要项的比值收敛到一个有限的正数。这意味着我们通常可以找到一个更易处理的级数来进行比较，相较于比较测试的情况而言。\n3. 比值判别法比值判别法是一种用于判断级数的收敛性或发散性的测试方法。比值法规定如下：\n假设  是一个具有正项的级数，令 （这个极限可能存在也可能不存在）。\n\n如果 ，则  绝对收敛。\n如果  或 ，则  发散。\n如果  或极限不存在，则比值测试无法确定收敛性或发散性，我们需要使用其他测试方法。\n\n从直观上讲，比值测试将级数的项与具有公比  的几何级数的项进行比较。如果 ，那么级数的项的衰减速度比一个收敛的几何级数的项更快，因此该级数收敛。如果 ，那么级数的项的增长速度比一个发散的几何级数的项更快，因此该级数发散。如果 ，那么级数的项的衰减速度与一个收敛的几何级数的项相同，因此测试是不确定的。\n4. 根值判别法根值判别法是一种用于判断级数的收敛性或发散性的测试方法。根值判别法规定如下：\n假设  是一个具有正项的级数，令 （这个极限可能存在也可能不存在）。\n\n如果 ，则  绝对收敛。\n如果  或 ，则  发散。\n如果  或极限不存在，则根值测试无法确定收敛性或发散性，我们需要使用其他测试方法。\n\n从直观上讲，根值测试将级数的项与一个收敛的几何级数的项进行比较，该几何级数的公比为 。如果 ，那么级数的项的衰减速度比一个收敛的几何级数的项更快，因此该级数收敛。如果 ，那么级数的项的增长速度比一个发散的几何级数的项更快，因此该级数发散。如果 ，那么级数的项的衰减速度与一个收敛的几何级数的项相同，因此测试是不确定的。\n这章节的内容非常重要，因为我们随后提到的许多概念和扩展都是基于这一章的结论，所以一定要仔细阅读。\n","slug":"正项级数","date":"2023-07-15T09:07:26.000Z","categories_index":"","tags_index":"笔记,Math","author_index":"General_K1ng"},{"id":"8c5051666bb20a88e04fe467e55f2664","title":"无穷级数的性质","content":"欢迎来到无穷级数的奇妙世界！在这一章中，我们将探索无穷级数的性质，包括收敛、发散以及我们可以对级数进行的代数运算。理解这些性质对于数学和科学的许多领域都是至关重要的，它使我们能够做出准确的预测，解决重要的问题，并发展新的计算方法。所以，让我们一起深入探索无穷级数的惊人性质吧。\n几个重要的无穷级数除了探索无穷级数的性质，我们还将介绍和研究一些在数学中最重要的级数。其中包括几何级数，在微积分中有许多重要的应用，以及调和级数，它是一个经典的发散级数的例子。我们还将研究其他重要的级数，如交错级数和泰勒级数，在数学和科学的许多领域都有广泛的应用。所以，准备好一起探索无穷级数的性质，以及数学中一些最重要的级数吧！\n几何级数几何级数是一种特殊类型的无穷级数，其中每一项都是前一项的常数倍（说白了就是等比数列）。几何级数的一般形式为其中  是第一项， 是公比。几何级数在数学中很重要，在科学和工程中也有许多应用。\n推导通项公式为了推导出几何级数的求和公式，我们从考虑级数的部分和开始。设  为级数的前  项和，那么我们可以将方程的两边都乘以  得到将第二个方程从第一个方程中减去，我们得到这可以简化为如果 ，我们可以将两边都除以  得到这个公式给出了几何级数的前  项和。\n要求解无穷几何级数的和，我们取  趋向于无穷的极限：如果 ，那么当  趋向于无穷时， 趋向于零，所以极限简化为这就是当  时无穷几何级数的和的公式。\n几何级数的敛散性几何级数的收敛性取决于公比  的值。我们可以将几何级数分为三类：\n\n如果 ，那么级数绝对收敛。这意味着级数收敛且和是有限的。\n如果 ，那么级数可能收敛，也可能发散。在这种情况下，我们需要观察级数的项的行为来确定收敛性或发散性。\n如果 ，那么级数发散。这意味着级数的和是无穷的。\n\n例如，考虑级数\n这是一个公比为 ， 的几何级数。由于 ，该级数绝对收敛，和为\n\n\n\n\n\n\n\n\n\n这个图像生动地展示了为什么这个几何级数的和是2。当然，为了方便起见，我们让级数的第一项从  开始。每次将图像分成两半并取剩余部分的一半，即四分之一，依此类推，我们发现图像的总面积仍然是1，直到无穷项。\n几何级数的应用几何级数在数学、科学和工程中有许多应用。例如，它们可以用来模拟指数增长或衰减，如人口增长或放射性物质的衰变。它们还可以用于计算某些类型的积分和近似函数。\n结论几何级数是微积分中的一个基本概念，在各个领域中都有许多应用。理解几何级数的收敛和发散对于使用闭合解找到级数的和非常重要。\n调和级数调和级数是数学中一个众所周知的级数，它在许多不同的背景下自然出现，包括微积分、数论和物理学。特别地，它是以下形式的级数：\n调和级数之所以有趣，是因为它是一个发散的级数，也就是说它没有有限的和。这可以通过检查级数的部分和来看出，随着添加更多的项，部分和会无限增长。\n敛散性的证明为了证明调和级数的发散性，我们可以使用积分测试。积分测试表明，如果函数  对于所有  是正的、递减的和连续的，并且对于所有 ，有 ，那么级数  和不定积分  要么都收敛，要么都发散。\n对于调和级数，我们可以选择 ，它满足积分测试的条件。不定积分  可以计算为：由于该积分发散，调和级数也必定发散。\n\n\n可以看到，每个矩形的面积都是 ，所以前  个矩形的总面积是 。随着  的增加，矩形的面积逐渐接近 ，因此阶梯状的图形逐渐趋近于斜率为  的曲线。最终，当  趋向于无穷时，矩形的面积趋向于 ，阶梯状的图形趋向于曲线 。\n这种可视化可以帮助我们更好地理解级数的行为以及它与自然对数的关系。\n当然，如果你无法理解这个图像以及以上所说的证明过程，没关系，你只需要记住调和级数是发散的。\n调和级数的应用调和级数的发散性在数学和科学中有许多重要的应用，例如：\n\n调和级数在数论中被用来研究质数的分布。级数的发散意味着质数是无穷多的，这是数论中的一个基本结果。\n调和级数的发散性在物理学中也有重要的应用，特别是在电场的研究中。点电荷在电场中的电势能与点电荷与电场中所有其他电荷之间距离的倒数之和成正比。这个和等价于调和级数，它的发散性意味着点电荷的电势能是无限大的。\n\n结论总之，调和级数是数学和科学中重要而有趣的级数。它是一个发散的级数，也就是说它没有有限的和。我们可以使用积分测试来证明级数的发散性，而级数的发散性在数论和物理学中有重要的应用。\n无穷级数的一些性质\n如果给定的无穷级数  收敛，那么任何形式为  的级数，其中  是常数，也将收敛。这个性质可以通过序列极限的定义得出。\n\n\n\n\n\n\n\n\n\n\n\n我们可以看到  收敛，并且  也收敛，它们的收敛性与  相同。\n因此，这个定理可以用来证明  收敛，因为它是通过将  乘以常数 0.5 而得到的。\n\n为了证明这个性质，我们可以设  是级数  的部分和序列， 是级数  的部分和序列。那么我们有：和将第一个等式乘以 ，我们得到：现在，设  是序列  的极限，即 。由于级数  收敛，我们知道极限  是有限的。因此，根据极限的代数性质，我们有：类似地，序列  的极限为：因此，级数  也收敛，其和为 。\n综上所述，无穷级数的线性性质表明，如果给定的无穷级数收敛，那么通过将原级数的项乘以一个常数得到的任何级数也将收敛，其和将是该常数与原级数和的乘积。这个性质可以通过序列极限的定义和极限的代数性质得到。\n\n\n\n如果  和  收敛，那么  也收敛。\n\n\n\n\n\n\n\n\n\n\n\n\n\n我们可以看到  和  都收敛，而  也收敛，它们的收敛性与  和  相同。\n因此，这个定理可以用来证明  收敛，因为它是  和  的和。\n\n要证明这个结果，我们可以使用以下步骤：\n\n令 。那么  是由  和  对应的项相加得到的级数。\n\n由于  和  都收敛，它们的部分和序列  和  也收敛。即， 和 。\n\n我们想要证明  收敛。为了做到这一点，我们需要证明  的部分和序列  收敛。也就是说，我们需要证明  存在。\n\n我们可以将  表示为  和  的形式：\n\n根据极限的性质，我们有：\n\n因此，我们已经证明了  的部分和序列  收敛，因此级数  收敛。\n\n由于  被定义为 ，所以这个结果对于  和  两种情况都成立。也就是说，如果  和  收敛，那么  和  也收敛。\n\n\n\n\n\n对于仍然在任意添加括号后保持收敛的无穷级数\n\n​\t\t如果您有Python环境，我强烈建议您运行我提供的”Verifying_Property_3” Python文件，您可以看到在不同括号下的图像的差异。\n\n要了解这个结论为什么成立，考虑一个收敛于极限的无穷级数。也就是说，偏和数列，其中，当趋向于无穷时收敛于。\n现在，假设我们以任意方式给级数的项添加括号，也就是说，我们用括号将某些项分组，但不改变项的顺序。例如，我们可以写成：或者或者任何其他方式的分组。\n让我们用表示新的偏和数列，其中是前个分组的和。例如，在上述第一种分组中，我们有，，，依此类推。\n现在，考虑级数中的任意两个相邻的分组。我们将第一个分组中的项称为，将第二个分组中的项称为。那么这两个分组的和为：根据加法的结合律，我们可以重新排列这个和为：也就是说，我们可以以任何希望的方式将这些项分组，得到的和仍然相同。因此，新的分组的偏和数列与原始的偏和数列相同。换句话说，在收敛级数的项上添加括号不会改变级数的极限。\n因此，我们已经证明了对于收敛的无穷级数，在其项上添加任何括号后，级数仍然收敛，且极限不变。\n\n\n​\t\t需要注意的是，这个性质只适用于收敛的级数。对于发散的级数，重新排列项可能会导致不同的收敛性质。\n\n通过删除、添加或更改有限项，级数的收敛性不会改变，但和可能会改变。\n\n\n要正式证明这个性质，让我们考虑一个无穷级数，其中是级数的第个项。我们想要证明，如果我们通过添加、删除或更改任意有限数量的项来修改这个级数，级数的收敛性或发散性不会改变。\n首先，让我们考虑添加或删除有限数量的项的情况。设为原级数的原和，为修改后级数的新和。我们可以将表示为两个级数的和：第一个级数是原级数删除或添加有限数量的项后得到的，第二个级数是由被删除或添加的项组成的有限级数。形式上，我们可以写成：这里，是正整数，是非负整数，是修改后级数的第个项。\n由于原级数收敛于，我们有：现在，让我们考虑修改后的级数。修改后级数的第一部分收敛于与原级数相同的极限，因为它们之间只有有限数量的项不同。第二部分是一个有限级数，因此它收敛于一个有限和。因此，修改后的级数也收敛于和。\n因此，我们已经证明，如果我们通过添加或删除有限数量的项来修改一个无穷级数，级数的收敛性或发散性不会改变。\n接下来，让我们考虑更改有限数量的项的情况。假设我们通过将第个项更改为来修改级数，其中。设和分别为原和和修改后的和。那么，我们可以写成：由于和之间的差是一个有限数，级数的收敛性或发散性不会改变。然而，级数的实际和是不同的。\n总而言之，”通过删除、添加或更改有限项，级数的收敛性不会改变，但和可能会改变”是无穷级数理论中的一个基本结果。它告诉我们，我们可以通过添加、删除或更改有限数量的项来修改一个无穷级数，而不影响其收敛性或发散性。然而，级数的实际和可能会有所不同。\n\n\n\n级数收敛的必要条件是。换句话说，如果是一个收敛的级数，那么。\n\n\n要证明这个结果，假设是一个收敛的级数。根据定义，这意味着偏和序列收敛到某个有限极限。\n我们可以将级数的第个项表示为两个相邻偏和的差：将两边取极限，当时，我们得到：这里我们利用了序列收敛于的事实，因此和。\n因此，我们已经证明了如果是一个收敛的级数，那么。\n值得注意的是，这个结果的逆命题不一定成立。也就是说，仅仅因为，并不意味着是收敛的。例如，调和级数是发散的，尽管。因此，条件只是收敛的必要条件，而不是充分条件。\n\n\n当然，我们要求你不必记住或完全理解这些性质的推导过程，这些只是为了帮助你理解。在考试中，你只需要记住加粗的文字，这应该不难，对吗？\n","slug":"无穷级数的性质","date":"2023-07-15T07:46:56.000Z","categories_index":"","tags_index":"笔记,Math","author_index":"General_K1ng"},{"id":"fca5d0f1b5b938fde80803f8dc301aa3","title":"我的博客之旅：学习、分享与成长","content":"\n\n\n\n\n\n\n\n\n欢迎来到我的博客！我是金洪来，目前就读于西交利物浦大学，专业是信息与计算科学（ICS）。在我充满好奇心和激情的探索中，我决定搭建这个博客，与大家分享我的学习经历、见解和成果。对我来说，这是一次意义非凡的旅程，我希望能够与你们一起成长、互相学习和建立联系。\n自我介绍我是一个对新兴技术充满热情的学生，同时也热爱广泛阅读。在我信息与计算科学的学习中，我不仅学习了编程语言和算法，还探索了许多有趣的领域，如人工智能、数据科学和网络安全。我迷恋于技术的力量和它所带来的无限可能。通过博客，我希望能够与大家分享我的学习经验、项目经历以及对技术和生活的思考。\n搭建博客的动机我为什么突然决定搭建博客呢？首先，学习新技术时，我发现将所学知识记录下来是一种非常有效的方法，可以帮助我更好地理解和巩固所学内容。通过博客，我可以分享这些知识，并与志同道合的人们交流和互动，从中收获更多的见解和观点。其次，博客可以成为一个平台，让我与专业人士和技术大佬们建立联系。我希望能够从他们的经验中获得启发和指导，进一步提升自己的技术能力和职业发展。最重要的是，我相信博客是一个分享和学习的场所，我希望能够通过博客与读者们一起成长，共同进步。\n目标受众我的博客欢迎所有学生、志同道合的朋友、技术大佬和技术小白们。无论你是正在学习编程的初学者，还是想深入了解某个领域的专业人士，我都希望我的博客能够为你提供有价值的信息和灵感。在我的博客中，你将找到关于技术教程、项目经验、学习心得，以及我对生活和工作的见解和体验分享。我希望能够为你提供有趣且实用的内容，无论你身在何处、经历如何，我都希望我的博客能够成为你学习和成长的伙伴。\n博客内容计划在我的博客中，你将看到各种内容，涵盖了技术教程、项目经验、学习笔记以及我对生活和工作的见解和体验。我计划分享一些简单易懂的技术教程，帮助初学者快速入门。通过清晰的代码示例和详细的解释，我希望能够让你轻松理解复杂的概念和技术。同时，我也会分享一些我在项目中遇到的挑战和解决方法，以及学习过程中的心得体会。我相信通过分享这些经验，我们可以相互帮助和共同成长。此外，我会不定期地分享一些生活感悟和工作经验，希望能够给你带来一些启发和思考。\n学习和成长通过搭建博客，我期望自己能够不断学习和成长。通过与读者的互动和交流，我相信我可以提升自己的学习能力和沟通技巧。我希望能够给你提供有价值的内容和支持，帮助你解决问题、开拓思路。同时，我也希望能够通过博客启发更多的人，鼓励他们追求自己的梦想，勇敢地探索未知的领域。在这个博客的旅程中，我将不断挑战自我，拓宽自己的知识边界，并将这些经验和成长与大家分享。\n结语感谢你花时间阅读我的博客介绍。我希望你能够加入我的博客之旅，与我一起探索技术的奇妙世界，共同成长和学习。如果你对我的博客感兴趣或有任何问题、建议或想法，请随时与我联系。我期待与你在博客中互动，并希望我的博客能够对你有所帮助。谢谢！\n","slug":"我的第一篇博客","date":"2023-07-14T09:16:53.000Z","categories_index":"","tags_index":"随笔","author_index":"General_K1ng"}]