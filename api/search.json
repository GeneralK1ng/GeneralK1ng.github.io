[{"id":"97b03ceace2b3c315b6a7d6611736a00","title":"MySQL Review-1","content":"其实我在想要不要写一个数据库的复习，毕竟最近临近期末，各种考试又到来，数据库好像还是相对来说比较重要的一个技术，那就顺便来讲讲吧，主要以学校为主，以MySQL作为我们的讲解内容。\n数据库介绍什么是数据库？先从这个问题开始，顾名思义，数据库（Database）就是按照数据结构来存储，组织和管理数据的仓库。\n可以类比我们的图书馆，里面有很多的书架，每个书架上面放着不同的书，每本书又都有自己的书名，作者，页码等等的信息。\n在数据库中，书架就就相当于表，每本书就是表当中的一行数据，而书的名字，作者这些信息就相当于表当中的列。这样，当你想要寻找信息的时候，就可以做到快速的在数据库当中查找，而不用每个书架都找一遍。\n数据库的好处就在于可以方便的存储，查找和管理大量的信息。\n而我们今天所要谈到的数据库属于数据库当中的关系型数据库（Relational Database），还有另外一种称为非关系型数据库，这种我们以后再谈。\n那么什么是关系型数据库呢？\n关系型数据库关系型数据库是一种特定类型的数据库，它的结构就像是一个由表格组成的巨大Excel电子表格。这些表格中的每一行都代表数据库中的一个记录，而每一列则代表这个记录的不同属性或信息。\n比方说，我们可以有一个表格存储学生信息，表格的列可以包括学生的姓名、年龄、性别等信息，每一行则是一个具体的学生记录。\n关系型数据库之所以叫“关系型”，是因为不同表格之间可以建立关系。比如，我们可以有一个表格存储学生的成绩，这个表格中可能有学生的ID（在学生信息表格中也有的），成绩等信息。通过学生的ID，我们就可以在两个表格之间建立关系，将学生的信息和成绩联系起来。\n这种结构的好处在于它能够更好地组织和管理大量的数据。而且，如果需要更新或者修改数据，只需要在相应的表格中进行，而不需要修改整个数据库。\n关系型数据库的特点\n表结构： 数据以表格的形式组织，每个表格包含多个列，每列定义了特定的数据类型。表格中的每一行表示一个记录，也就是实际的数据项。\n关系： 表格之间可以建立关系。这种关系使得不同表格中的数据可以相互关联，从而提供更丰富、更全面的信息。关系通常通过主键和外键来建立。\nACID 属性： 关系型数据库遵循ACID（原子性、一致性、隔离性、持久性）属性，确保在数据库发生故障或者其他问题时，数据保持一致性和完整性。\n事务管理： 关系型数据库支持事务处理，这意味着可以将一系列数据库操作作为一个原子单元执行。如果其中任何一个操作失败，整个事务会被回滚，以保持数据库的一致性。\n数据完整性： 数据库提供了丰富的约束条件，如主键、唯一键、外键等，以确保数据的完整性。这意味着数据库中的数据符合预定义的规则，不会出现不一致或错误的数据。\nSQL 查询语言： 关系型数据库使用结构化查询语言（SQL）进行数据查询和操作。SQL提供了一种简单而强大的语法，用于从数据库中检索、更新和删除数据，以及定义和管理数据库结构。\n可伸缩性： 关系型数据库系统通常具有良好的可伸缩性，可以处理大量数据和复杂的查询。这使得它们适用于大型企业和复杂的数据管理需求。\n备份与恢复： 关系型数据库提供了备份和恢复机制，确保在系统故障或其他灾难性事件发生时，可以迅速恢复数据。\n\n数据库管理系统（Database Management System）这里我们又要引出另外一个很相关的概念，就是数据库管理系统，什么是数据库管理系统？它跟数据库有什么关系？\n数据库（Database）和数据库管理系统（Database Management System，简称DBMS）是两个密切相关但又不同的概念。\n\n数据库（Database）： 数据库是一个组织数据的集合，它可以包含各种各样的信息，并按照一定的结构存储。数据库的目的是为了方便数据的存储、检索、更新和管理。数据库中的数据以表格的形式组织，每个表格包含多个列，每列定义了特定的数据类型，而每一行则代表一个记录。\n数据库管理系统（DBMS）： 数据库管理系统是一个软件，它提供了对数据库进行管理和操作的工具和接口。DBMS充当了数据库和应用程序之间的桥梁，负责处理数据库的创建、维护、查询、更新和删除等操作。DBMS负责管理数据库的物理和逻辑结构，实施安全性控制，确保数据的一致性和完整性，以及提供对数据库的并发访问控制。\n\n简而言之，数据库是一个存储数据的仓库，而数据库管理系统是负责管理这个仓库的系统。DBMS通过提供一组功能和接口，使得用户和应用程序能够方便地与数据库交互，而不必关心底层数据库的细节。数据库管理系统还负责处理并发访问、故障恢复、安全性等方面的任务，以确保数据库的可靠性和效率。\n举例来说，关系型数据库（如MySQL、Oracle、SQL Server）是一种数据库类型，而针对这种数据库类型的管理系统（MySQL Server、Oracle Database Server、SQL Server）则是具体的数据库管理系统。不同类型的数据库可能需要不同类型的DBMS来进行管理。\n懂吧，我们所学的MySQL本质上是一种数据库管理系统，并且是关系型数据库管理系统（Relational Database Management System，简称RDBMS）。\nRDBMS当中的术语在学习MySQL也就是关系型数据库之前，我们需要了解一些必须的术语，这些也适用于其他RDBMS。\n\n数据库（Database）： 就像一个超级大文件夹，可以存储很多很多的数据。\n表（Table）： 就像一张电子表格，有很多行和列，每一行代表一条记录，每一列代表一种信息。\n记录（Record）： 表格中的一行，包含了某个人、物或事件的所有相关信息。\n字段（Field）： 表格中的一列，表示一种特定类型的信息，比如姓名、年龄或者成绩。\n主键（Primary Key）： 就像是一个独一无二的ID，确保每一条记录都有一个唯一的标识符。\n外键（Foreign Key）： 是一个特殊的字段，连接不同表格的关系，就像是表格之间的桥梁。\n查询（Query）： 就像是在数据库中提出的问题，要求获取符合条件的信息。\nSQL（Structured Query Language）： 是一种用于和数据库交流的语言，就像是和数据库对话的方式。\n插入（Insert）： 就是往表格里新增一条记录，就像是在表格中填写新的一行。\n更新（Update）： 就是修改表格中已有记录的信息，就像是更正之前填写的错误。\n删除（Delete）： 就是把表格中的某一行记录移除，就像是把一行数据擦掉。\n事务（Transaction）： 就像是进行一系列的操作，要么全部成功，要么全部失败，确保数据的一致性。\n备份（Backup）： 就像是数据库的复制，以防止意外情况导致数据丢失。\n恢复（Recovery）： 就是在出现问题后，通过备份重新获得数据库的正确状态。\n冗余（Redundancy）： 想象一下你有一份电话簿，如果同一个人的信息在不同的页面出现了很多次，这就是冗余。数据库设计时要尽量避免冗余，以免浪费空间和增加混乱。而且虽然冗余降低了性能，但提高了数据的安全性。。\n复合键（Composite Key）： 如果一个表格中的主键不止一个字段，而是由两个或更多字段组成，那么这就是复合键。就像用姓名和生日一起来唯一标识一个人，而不仅仅是一个属性。\n索引（Index）： 想象一本书的目录，索引就是数据库的目录，可以让我们更快地找到需要的信息。它是一种优化方法，提高数据检索的速度。\n参照完整性（Referential Integrity）： 假设你有两个表格，一个存储学生信息，另一个存储课程信息。参照完整性就是确保如果在课程表中有学生的信息，那么这个学生在学生表中一定存在。这样可以防止出现“无根的”数据，确保数据的关联性。\n\nMySQL介绍自己百度吧，这个没啥要讲的，而且安装我也就不说了，这个安装都不会装我的建议是当初为什么要学这个专业？\nMySQL有一下特点：\n\n开源性（Open Source）： MySQL 是一个开源的关系型数据库管理系统，这意味着任何人都可以免费使用它，并且可以查看和修改其源代码。这使得它成为许多开发者和企业的首选。\n跨平台性（Cross-Platform）： MySQL 可以在多个操作系统上运行，包括 Windows、Linux、macOS 等，这使得它非常灵活，能够满足不同用户的需求。\n高性能（High Performance）： MySQL 被设计成高性能的数据库系统，能够处理大规模的数据并支持高并发访问。它采用了一些优化技术，例如索引、缓存等，以提高查询和操作的速度。\n支持多种存储引擎（Storage Engines）： MySQL 支持多种存储引擎，例如 InnoDB、MyISAM 等。每个存储引擎都有其特定的优势和用途，可以根据应用的需求选择合适的引擎。\n事务支持（Transaction Support）： MySQL 支持事务处理，确保一系列操作要么全部成功，要么全部失败，以保持数据的一致性。\n安全性（Security）： MySQL 提供了一系列的安全性功能，包括用户认证、访问控制、加密传输等，以确保数据库的数据安全。\n备份和恢复（Backup and Recovery）： MySQL 允许用户进行定期的数据库备份，以防止数据丢失。在发生故障时，可以通过备份进行恢复。\n简单的 SQL 语法（Simple SQL Syntax）： MySQL 使用标准的 SQL 语法，这使得学习和使用 MySQL 相对简单，特别适合初学者。\n社区支持（Community Support）： 由于 MySQL 是开源的，有一个庞大的用户社区，用户可以在社区中分享经验、解决问题，获得及时的支持和帮助。\n\n","slug":"MySQL-Review-1","date":"2023-11-18T10:15:15.000Z","categories_index":"","tags_index":"笔记,MySQL复习","author_index":"General_K1ng"},{"id":"7d4841571c0abc342271e318c113c7dc","title":"Java_Learning(Week9)","content":"说实话，我看了一下这一周的课件，我感觉学校还是没有讲东西，OOP的思想我上一周应该说的比较详细了，这周需要讲的一些东西应该就是多态和异常了，说实话这会儿讲异常没有什么必要我感觉，其他更重要的东西都还没讲，什么链表，哈希表这些的。\n哦对了，顺便补一下之前拉下的一点东西，讲一下方法重载（Overload）和方法重写（Override）之间的区别。\n重载与重写上周我们简单提了一下方法的重写是什么，现在先来看一下重载吧。\n重载 （Overload）简单来说，Overload指的是在同一个类中创建多个具有相同名称但参数不同的方法。这样，可以根据不同的情况来调用这些方法。\nclass Calculator {\n    public int add(int a, int b) {\n        return a + b;\n    }\n\n    public double add(double a, double b) {\n        return a + b;\n    }\n}\n\n在这个例子中，Calculator类有两个add方法，一个用于整数相加，另一个用于浮点数相加。这两个方法都有相同的名称，但是它们的参数不同。这就是方法的重载。\n就是方法名称相同，但是参数类型或者数量不同，就是方法的重载。\n方法重载的规则\n方法名称必须相同： 重载的方法必须具有相同的名称。\n参数列表必须不同： 重载的方法必须有不同的参数列表（个数或类型不同）。\n返回类型可以相同也可以不同： 返回类型可以相同也可以不同，但仅仅通过返回类型的不同是无法进行重载的。\n可以有不同的访问修饰符： 重载的方法可以有不同的访问修饰符（比如public、private、protected等）。\n可以抛出不同的异常： 重载的方法可以抛出不同的异常，可以声明新的或者更广的异常\n\n重写（Override）上周已经讲过了，假设你有一个父类（比如动物类），而你想创建一个子类（比如狗类）。父类中可能有一个makeSound方法，用于发出声音。现在，如果你想在子类中改变狗的声音，你可以使用override。\n在Java中，override就是在子类中创建一个与父类相同的方法，但是子类中的这个方法有着自己的实现。这样，当你调用这个方法时，程序会自动调用子类的方法，而不是父类的方法。\nclass Animal {\n    public void makeSound() {\n        System.out.println(\"一般的动物发出的声音\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"汪汪汪！\");\n    }\n}\n\n重写的优势在于让子类能够根据自身需求来实现（重写）父类的方法，使得代码更加灵活和符合具体情境。但是，需要遵循一些规则，如保持方法签名不变，不能改变返回类型，也不能抛出比父类方法更宽泛的异常。\n方法重写的规则\n参数列表必须完全相同： 重写的方法的参数列表必须与被重写方法的参数列表完全相同。\n返回类型可以不同，但必须是父类返回值的派生类： 返回类型可以是被重写方法返回类型的子类，但是在Java 5及更早版本中，返回类型必须相同；而在Java 7及更高版本中，返回类型可以不同。\n访问权限不能比被重写方法更低： 重写的方法的访问权限不能比被重写方法的访问权限更低，例如，如果被重写方法在父类中声明为public，那么在子类中的重写方法不能声明为protected。\n只能重写父类的成员方法： 只能重写父类的成员方法，不能重写父类的静态方法或实例方法。\n不能重写final方法： 被声明为final的方法不能被子类重写。\n不能重写static方法，但能够被再次声明： 被声明为static的方法不能被子类重写，但可以在子类中被再次声明。\n同包中的子类可以重写父类所有方法，除了private和final的方法： 如果子类和父类在同一个包中，子类可以重写父类所有非private和非final的方法。\n不同包中的子类只能重写父类的声明为public和protected的非final方法： 如果子类和父类不在同一个包中，子类只能够重写父类的声明为public和protected的非final方法。\n重写的方法能够抛出任何非强制异常，但不能抛出新的强制异常，或者比被重写方法声明的更广泛的强制异常： 在重写时，可以抛出任何非强制异常，但不能抛出新的强制异常，也不能抛出比被重写方法声明的更广泛的强制异常。\n构造方法不能被重写： 构造方法不能被继承，因此也不能被重写。\n如果不能继承一个类，则不能重写该类的方法： 如果无法继承一个类，那么就无法重写该类的方法。\n\n很多，给爷背就完了。\n重写与重载之间的区别\n\n\n区别点\n重载方法\n重写方法\n\n\n\n参数列表\n必须修改\n一定不能修改\n\n\n返回类型\n可以修改\n一定不能修改\n\n\n异常\n可以修改\n可以减少或删除，一定不能抛出新的或者更广的异常\n\n\n访问\n可以修改\n一定不能做更严格的限制（可以降低限制）\n\n\n多态其实上面的重载和重写都是Java多态的体现，那么问题就来了，什么是多态？\n什么是多态多态是面向对象编程中的一个重要概念，它允许不同类的对象对同一个消息（方法调用）作出不同的响应。简而言之，同一种行为在不同的对象上可以表现出不同的形态。\n说白了，就是同一个行为具有多个不同的表现形式。\n比如动物会叫，狗叫就是汪汪，猫叫就是喵喵，就是这。\n多态的优点这都是教科书上面该写的东西，哪里都一样\n\n灵活性（Flexibility）： 多态使得代码更加灵活，能够处理多种不同类型的对象，而无需修改现有的代码。这使得系统更容易适应变化和扩展。\n可扩展性（Extensibility）： 添加新的类或子类变得更加容易。如果你需要引入新的类型，只需确保它符合已有的接口或继承关系，而不需要修改现有的代码。\n简化代码（Simplified Code）： 多态性使得代码更简洁，因为相同的操作可以适用于不同类型的对象。这减少了代码的复杂性和冗余性。\n提高代码的可读性和可维护性（Readability and Maintainability）： 通过使用多态，代码更容易理解和维护，因为它强调了对象的行为而不是具体的实现细节。\n降低耦合度（Reduced Coupling）： 多态性降低了对象之间的耦合度。通过将操作定义在接口或抽象类上，而不是具体的实现类上，减少了类之间的直接依赖，使得系统更容易修改和维护。\n可替代性（Substitutability）： 多态性使得可以在不影响代码其他部分的情况下替换对象。这对于在系统中替换部分功能或优化代码是非常有用的。\n\n多态存在的必要条件\n继承（Inheritance）： 多态性通常基于继承关系。子类必须继承自父类或实现相同的接口或抽象类，以便能够通过父类或接口类型的引用来引用子类对象。\n方法重写（Method Overriding）： 多态性要求子类必须重写（Override）父类中的方法。重写的方法在子类中具有相同的签名（方法名、参数列表和返回类型），这样在运行时可以根据对象的实际类型调用正确的方法。\n父类引用指向子类对象（Upcasting）： 多态性的关键是使用父类类型的引用指向子类对象。这种类型的引用可以容纳任何符合父类或接口的子类对象。\n运行时绑定（Runtime Binding）： 多态性的实现是在运行时确定的，而不是在编译时。这意味着系统在程序运行时能够动态地选择调用哪个方法，而不是在编译时就确定。\n一致的接口（Consistent Interface）： 多态性要求所有相关类都要有一致的接口，即它们应该共享相同的方法签名。这可以通过接口、抽象类或共同的基类来实现。\n\n第五点看不懂没关系，目前还没学到。\n为了理解这么几个必要条件，我们来举个例子。\n假设有一个动物（Animal）类和两个子类：狗（Dog）和猫（Cat）。这里使用了继承、方法重写、父类引用指向子类对象和运行时绑定这些多态性的概念。\n// 动物类\nclass Animal {\n    public void makeSound() {\n        System.out.println(\"一般的动物发出声音\");\n    }\n}\n\n这个是动物类，当中有一个makeSound()方法\n// 狗类\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"汪汪汪！\");\n    }\n\n    public void fetch() {\n        System.out.println(\"狗在接飞盘！\");\n    }\n}\n\n这是狗类，继承了动物类，然后重写了其中的叫声方法，并且拥有自己的一个成员方法是接飞盘。\n// 猫类\nclass Cat extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"喵喵喵！\");\n    }\n\n    public void scratch() {\n        System.out.println(\"猫在抓抓！\");\n    }\n}\n\n这个是猫类，同样的，重写了叫声方法，滨区给拥有自己的成员方法\n那么我们写一个测试类\n// 父类引用指向子类对象\nAnimal myDog = new Dog();\nAnimal myCat = new Cat();\n\n注意这里，开头我们使用的是Animal声明的，然后new的后面是狗对象，这就是父类引用指向子类对象。\n// 调用各自的makeSound方法，运行时绑定确定调用哪个方法\nmyDog.makeSound();  // 运行时调用Dog类的makeSound方法\nmyCat.makeSound();  // 运行时调用Cat类的makeSound方法\n\n然后我们分别调用他们各自的makeSound()，你会发现输出的是他们各自的叫声，因为我们重写了他们各自的方法。\n汪汪汪！\n喵喵喵！\n\n然后我们继续尝试调用他们各自的子类中的成员方法\n// 父类引用无法调用子类特有的方法（fetch和scratch）\n myDog.fetch();  // 编译错误，Animal类没有fetch方法\n myCat.scratch(); // 编译错误，Animal类没有scratch方法\n\n你会发现编译器已经开始报错了\nCannot resolve method 'fetch' in 'Animal'\nCannot resolve method 'scratch' in 'Animal'\n\n因为父类当中并没有这几个方法，那么此时我们可以对我们的对象进行强转。\n// 如果我们将引用类型更改为子类类型，就可以调用子类特有的方法\nDog myRealDog = (Dog) myDog;\nmyRealDog.fetch();  // 正常调用fetch方法\n\nCat myRealCat = (Cat) myCat;\nmyRealCat.scratch(); // 正常调用scratch方法\n\n此时就可以继续调用子类当中的方法了\n狗在接飞盘！\n猫在抓抓！\n\n好！\n这部分就到这里先结束。\n异常这会儿讲这个感觉还是有点怪哈，因为我们目前好像没遇到什么异常，最有名的异常应该就是数组越界异常，其他的其实还蛮少的。\n那就先讲什么是异常。\n什么是异常？异常就是程序当中的错误，就是报错，就是IDE给你标成红色的时候，那就是出异常了。\n但是并不是所有的错误都是异常，甚至有的错误是可以避免的\n比方说零不能作除数，数组访问不能越界，这些都是一些常见的异常。\n异常的分类在Java中，异常分为两个主要类别：已检查异常（Checked Exceptions）和未检查异常（Unchecked Exceptions）。这两者都是 Throwable 类的子类。\n\n已检查异常（Checked Exceptions）：\n已检查异常是在编译时被检测到的异常，程序必须显式地处理它们，否则编译器会报错。\n通常是由外部因素引起的，例如输入/输出错误、文件不存在等。\n例如：IOException、ClassNotFoundException。\n\n\n未检查异常（Unchecked Exceptions）：\n也称为运行时异常（Runtime Exceptions），是在运行时由Java虚拟机检测到的异常。\n不要求显式地捕获或声明，程序员可以选择处理或者不处理这些异常。\n通常是由程序错误引起的，例如空指针引用、数组越界等。\n例如：NullPointerException、ArrayIndexOutOfBoundsException。\n\n\n\n除了这两个主要的分类之外，还有一种特殊情况：\n那就是错误（Errors）：\n\n错误通常指示了一些严重的问题，程序可能无法恢复。与异常不同，错误通常由于系统级问题（例如内存耗尽）引起。\n例如：OutOfMemoryError、StackOverflowError。\n\n一般出现了Errors，那就一般不归我们管了，我们也管不了这些。\n这些异常和错误类的层次结构如下：\nThrowable\n|-- Error\n|-- Exception\n    |-- Checked Exceptions\n    |-- Unchecked Exceptions (Runtime Exceptions)\n\n这个层次结构也就是Java当中的类的继承结构。\nException 类的层次\n这就是这些类的继承结构，里面是类中含有的一些方法，不用管，看不懂没关系。\n在Java中，异常类都是派生自 Throwable 类。Throwable 类是所有可以作为异常抛出的类和错误的根类。异常类的层次结构主要分为两大类：Error 和 Exception，而 Exception 又分为已检查异常（Checked Exceptions）和未检查异常（Unchecked Exceptions）。\n\nThrowable 类：\nThrowable 是 Java 异常体系的根类。它有两个主要的子类：Error 和 Exception。\n任何可以作为异常抛出的类都是 Throwable 的子类。\n\n\nError 类：\nError 类用于表示严重的系统问题，通常无法通过程序来恢复。程序一般不会捕获 Error 类的实例。\n一些常见的 Error 类包括 OutOfMemoryError、StackOverflowError 等。\n\n\nException 类：\nException 类是所有异常类的父类，它表示程序运行过程中可能遇到的问题。\nException 类又分为已检查异常和未检查异常。\n\n\n已检查异常（Checked Exceptions）：\n已检查异常是在编译时被检测到的异常，程序必须显式地处理它们，否则编译器会报错。\n一些常见的已检查异常包括 IOException、ClassNotFoundException 等。\n\n\n未检查异常（Unchecked Exceptions，Runtime Exceptions）：\n未检查异常是在运行时由 Java 虚拟机检测到的异常，不要求显式地捕获或声明，程序员可以选择处理或者不处理这些异常。\n一些常见的未检查异常包括 NullPointerException、ArrayIndexOutOfBoundsException 等。\n\n\n\n捕获异常那么讲了什么是异常，那我们怎么去处理这个异常呢？\n想象一下你正在读一本书，突然有人拿走了这本书。你可以选择哭泣和放弃，或者你可以找到一本相似的书继续阅读。在编程中，当程序遇到问题时，我们可以选择放弃并让程序崩溃，或者我们可以处理这个问题，使程序继续执行。\n在Java中，我们使用try和catch来处理异常。这就像在代码中放置一个安全网，当有问题时，我们可以抓住它并执行一些特殊的代码，而不是让程序崩溃。\n以下是一个简单的例子，假设我们想要读取一个文件中的内容：\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\npublic class ReadFileExample {\n    public static void main(String[] args) {\n        try {\n            readFile();\n        } catch (FileNotFoundException e) {\n            System.out.println(\"文件找不到啦！请检查文件是否存在。\");\n        }\n    }\n\n    public static void readFile() throws FileNotFoundException {\n        File file = new File(\"example.txt\");\n        Scanner scanner = new Scanner(file);\n        // 这里是读取文件内容的代码\n        System.out.println(\"成功读取文件！\");\n    }\n}\n\n这里面涉及了Java当中的I/O，看不懂无所谓，只是举个例子，里面还有throws这个关键字，下面会讲到，这里先看。在这个例子中，我们尝试调用readFile方法，这个方法有可能抛出FileNotFoundException异常。我们用try和catch来捕获这个异常。如果文件不存在，我们就会进入catch块，并输出一条消息告诉用户文件找不到。\n此外，我们还可以多重捕获异常，怎么说呢，就是在一个try块后面跟随多个catch块的情况。这样做的目的是为不同类型的异常提供不同的处理逻辑。在Java中，catch块按照它们出现的顺序进行匹配，只有第一个匹配的catch块会执行。\n举个例子：\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\npublic class MultiCatchExample {\n    public static void main(String[] args) {\n        try {\n            readFile();\n        } catch (FileNotFoundException e) {\n            System.out.println(\"文件找不到啦！请检查文件是否存在。\");\n        } catch (NullPointerException e) {\n            System.out.println(\"空指针异常！请检查代码中的空引用。\");\n        } catch (Exception e) {\n            System.out.println(\"发生了其他异常：\" + e.getMessage());\n        }\n    }\n\n    public static void readFile() throws FileNotFoundException {\n        File file = null; // 故意设置为null，模拟空指针异常\n        Scanner scanner = new Scanner(file);\n        // 这里是读取文件内容的代码\n        System.out.println(\"成功读取文件！\");\n    }\n}\n\n在这个例子中，readFile方法有可能抛出两种异常：FileNotFoundException和NullPointerException。\n在main方法中的try块后面有两个catch块，第一个捕获FileNotFoundException，第二个捕获NullPointerException。\n如果发生了FileNotFoundException，第一个catch块会执行，如果发生了NullPointerException，则第二个catch块会执行。\n请注意，catch块的顺序很重要。如果把第二个catch块放在第一个之前，那么即使发生了NullPointerException，也会被第一个catch块捕获，因为Exception是NullPointerException的父类。\n有点像if条件语句，但是不太像。\nfinally关键字想象一下你正在玩积木，突然有人叫你去吃饭。无论你是否玩得高兴，你都应该把积木收拾好，对吧？finally 就像是你要完成的最后一步，无论怎样，都会执行的一段代码。\n在编程中，finally 关键字用于确保一段代码（通常是清理代码）无论发生什么都会被执行。\npublic class FinallyExample {\n\n    public static void main(String[] args) {\n        try {\n            divide(10, 0);\n        } catch (ArithmeticException e) {\n            System.out.println(\"除数不能为零！\");\n        } finally {\n            System.out.println(\"这里的代码总是会执行，无论有没有异常发生。\");\n        }\n    }\n\n    public static void divide(int num1, int num2) {\n        if (num2 == 0) {\n            throw new ArithmeticException(\"除数不能为零！\");\n        } else {\n            int result = num1 / num2;\n            System.out.println(\"结果是：\" + result);\n        }\n    }\n}\n\n\n在这个例子中，我们有一个 divide 方法，它可能会抛出 ArithmeticException 异常，因为我们不能将一个数除以零。在 main 方法中，我们使用 try-catch 块来捕获这个异常，然后使用 finally 关键字来确保无论是否发生异常，都会执行 finally 块内的代码。\n所以，finally 就是那个一定会执行的“清理代码”块，确保在程序执行的最后阶段，无论是否有异常，都能完成一些必要的操作。\nthrows/throw 关键字那么这就是第二种处理异常的方式，在Java中，throw 关键字用于在代码中抛出异常，而 throws 关键字用于在方法声明中指定可能会抛出的异常类型。\nthrows 关键字：想象一下你在一个游戏中扔飞盘。有时候飞盘可能会飞得太高，而你不想被砸到头。所以，你在扔飞盘之前说：“我可能会扔得很高，小心头顶！”这就是 throws 的作用。\n在编程中，throws 关键字用于告诉其他人（或其他代码）：“嘿，我这里可能会有异常发生，你需要注意一下！”。具体来说，在方法的声明中使用 throws，你在方法名后面列出可能抛出的异常类型。\n继续上面的例子：\npublic class ThrowsExample {\n\n    public static void main(String[] args) {\n        try {\n            doSomething();\n        } catch (FileNotFoundException e) {\n            System.out.println(\"文件找不到啦！请检查文件是否存在。\");\n        }\n    }\n\n    public static void doSomething() throws FileNotFoundException {\n        // 在这里做一些可能抛出 FileNotFoundException 的操作\n        throw new FileNotFoundException(\"这是一个模拟的文件未找到异常\");\n    }\n}\n\n在这个例子中，doSomething 方法可能会抛出 FileNotFoundException 异常，所以我们在方法声明中使用了 throws FileNotFoundException。\nthrow 关键字：现在，想象一下你在捡到了一个石头，然后你发现其实是一个屎蛋，然后你突然想把它扔给别人。这就是 throw 关键字的作用。\n在编程中，throw 关键字用于手动抛出异常。有时候，我们在代码中发现了一些问题，而不是等到程序崩溃，我们可以使用 throw 主动地抛出一个异常。\npublic class ThrowExample {\n\n    public static void main(String[] args) {\n        try {\n            checkAge(12);\n        } catch (IllegalArgumentException e) {\n            System.out.println(\"年龄不合法：\" + e.getMessage());\n        }\n    }\n\n    public static void checkAge(int age) {\n        if (age &lt; 18) {\n            throw new IllegalArgumentException(\"年龄必须大于等于18岁\");\n        } else {\n            System.out.println(\"年龄合法，可以继续操作\");\n        }\n    }\n}\n\n在这个例子中，checkAge 方法检查年龄是否合法，如果年龄小于18岁，就会使用 throw 抛出一个 IllegalArgumentException 异常。\n一些注意事项\n注意下面事项：\n\ncatch 不能独立于 try 存在。\n在 try/catch 后面添加 finally 块并非强制性要求的。\ntry 代码后不能既没 catch 块也没 finally块。\ntry, catch, finally 块之间不能添加任何代码。\n\n声明自定义异常那么，上面讲了这么多，这些异常其实都是Java给我们提供好的异常，但是现实开发中遇到的异常可多了去了，Java的异常不可能覆盖我们可能遇到的异常，这时候自定义异常就显得非常重要了。\n假设我们正在设计一个游戏，玩家的年龄不能小于 18 岁。如果小于 18 岁，我们就会抛出一个自定义的异常，告诉玩家不能玩这个游戏。\n我们可以通过创建一个继承自 Exception 的新类来声明自定义异常\n// 自定义异常类\nclass AgeTooYoungException extends Exception {\n    public AgeTooYoungException(String message) {\n        super(message);\n    }\n}\n\n然后我们再在测试类当中试一下：\npublic class CustomExceptionExample {\n\n    public static void main(String[] args) {\n        try {\n            checkPlayerAge(15); // 尝试使用 checkPlayerAge 方法\n        } catch (AgeTooYoungException e) {\n            System.out.println(\"抱歉，你太小了，不能玩这个游戏！\");\n            System.out.println(\"异常信息：\" + e.getMessage());\n        }\n    }\n\n    public static void checkPlayerAge(int age) throws AgeTooYoungException {\n        if (age &lt; 18) {\n            throw new AgeTooYoungException(\"年龄太小，不能玩游戏！\");\n        } else {\n            System.out.println(\"年龄合适，可以开始游戏！\");\n        }\n    }\n}\n\n其实还有更炫的，你可以把我们经常用的System.out.println中的out换成err，这样控制台打印的文字就是红色警告，非常的炫酷。\n抱歉，你太小了，不能玩这个游戏！\n异常信息：年龄太小，不能玩游戏！\n\n在这个例子中，AgeTooYoungException 是我们自定义的异常类，它继承自 Exception。我们使用 checkPlayerAge 方法来检查玩家的年龄，如果年龄小于 5 岁，就抛出 AgeTooYoungException 异常。\n在 main 方法中，我们使用 try-catch 块捕获这个异常，并输出一条友好的消息告诉玩家不能玩这个游戏。\n好了，所以也就讲了这么些东西。\n","slug":"Java-Learning-Week9","date":"2023-11-14T07:22:21.000Z","categories_index":"","tags_index":"笔记,Java初学","author_index":"General_K1ng"},{"id":"0d78bd92a017cfff181854aa3e1bedda","title":"Java_Learning(Week8)","content":"因为最近太忙了，所以直接空了三周的笔记没有写，后面看有没有时间再补上吧，这节课，我们直接开始Java编程当中的重头戏——面向对象。\n面向对象（OOP）什么是对象？首先先明确一点，对象不是找男女朋友！\n这里我想先引用我很喜欢的一本Java书（Java编程思想，非常好的工具书）当中面向对象导论中的第一句话\n\n\n\n\n\n\n\n\n\n“我们之所以将自然界分解，组织成各种概念，并按其含义分类，主要是因为我们是整个口语交流社会共同遵守的协议的参与者，这个协定以语言的形式固定下来……除非赞成这个协定中规定的有关语言信息的组织和分类，否则我们根本无法交谈”\n——Benjamin Lee Whorf (1897 - 1941)\n所以对于我们的Java这门完全面向对象的语言来说，对象就是对物体的抽象。\n当然不仅限于Java，任何支持面向对象变成的语言，我们都可以这么说，因为面向对象和语言的关系并不大，而是一种编程思想。\n现在我们来想想什么是对物体的抽象。\n比方说有一个人，我们就可以想想它具有什么特点？\n\n性别，是男是女？\n年龄，几岁了？\n姓名，我们怎么称呼？\n性格\n。。。\n\n这样我们就逐步将一个人进行了分解，这个分解的过程就是抽象的过程。\n而这些东西体现在代码上面就是我们要写的一个类（class），什么是类呢？\n什么是类？什么是类？也就是我们经常见到的class，我们每次写代码的时候都会见到它，我们必须把代码写到类里面，每次新建也都是要新建一个类，方法也必须用类包裹。\n所以，有具体想过什么是类吗？\n我用最简单的话来说，类就是一个模板，我们通过这个模板来构建对象。\n什么意思？我第一次接触也是晕头转向。但是没关系，\n比方说用上面那个例子，我们构建一个类，名字叫做Person\n那么，我们就把一个人进行抽象然后写出一个类来\npublic class Person {\n    String name;   //姓名\n    int age;\t   //年龄\n    String gender; //性别\n}\n\n对吧，这就我们最基本的对这个人进行的抽象，他肯定有名字，年龄，性别。\n接下来最终要的一句话就是，对象要根据类来创建，类是构造对象的模板。\n比如说我是一个人，我叫张三，年龄是20，性别是男。对吧，那么此处的张三就是一个“人”对象，或者说是一个Person对象，但是Person这是一个类，他是张三的模板。\n或者再来一个人，姓名是李四，年龄30，性别是女，那么我们说李四也是一个Person对象。\n所以就能发现李四和张三都是人，都是Person，我们可以通过Person这个类去构造很多对象。\n类和对象的关系\n类定义了对象的结构，包括两个大部分，属性和方法，这两点我们后面说。\n对象是类的实例，对象们具体化了类的定义，拥有类的属性和方法。\n一个类可以创建多个对象，每个对象之间是相互独立的，它们之间可以有不同的属性值。\n\n所以记住我的这句话\n类是对象的模板，对象是类的实例\n目前为止，只需要知道这些应该就够了。\n为什么需要面向对象？要搞懂这个问题我们就要讲到面向对象的对立面——面向过程。\n面向过程，顾名思义，就是面向过程，hhhhhh\n好吧，为了方便理解，我来举一个例子，比方说我们现在有一个飞机，让你用程序去控制它，我们怎么控制？\n面向过程在面向过程编程中，我们会将问题分解为一系列的步骤，然后按照顺序执行这些步骤来模拟飞机的飞行。\n\n初始化飞机参数（速度、高度、燃料等）。\n启动引擎。\n增加速度。\n升高飞机。\n检查燃料。\n如果燃料足够，继续飞行；否则，降落。\n定期检查飞机的状态。\n如果到达目的地，降落。\n\n对吧，如果是面向过程，我们就必须依次写这些过程的函数，并且必须提前将运行的时序排列好。\n而且飞机还有很多的全局变量，我们该怎么保存和管理和操作呢？比方说高度？速度？燃料量？甚至这只能描述一架飞机，如果飞机更多该怎么办呢？\n所以发现了吗？\n这种方式将问题分解为一系列步骤，每个步骤都是一个函数或方法。这些函数按照顺序执行，但问题是，我们需要管理大量的全局变量来存储飞机的状态，以及一系列函数来操作这些状态。\n面向对象那么面向对象，我们就先对飞机这个物体进行抽象，先来构建一个飞机的类，也就是飞机的class\nclass Airplane {\n    double speed;\n    double altitude;\n    double fuel;\n\n  \tvoid startEngine() {\n        // 启动引擎\n        // 实现细节\n    }\n\n    void increaseSpeed() {\n        // 增加速度\n        // 实现细节\n    }\n\n    void ascend() {\n        // 升高飞机\n        // 实现细节\n    }\n\n    void checkFuel() {\n        // 检查燃料\n        // 实现细节\n    }\n\n    // 更多方法...\n\n    void land() {\n        // 降落\n        // 实现细节\n    }\n}\n\n这里我们就简单构造了一个飞机的类，这个类里面拥有一架飞机应该有的一些参数和一些方法，或者说属性和方法，这里方法指的就是飞机可以实现的一些方法，而且每个飞机都具有自己的状态，而且不需要全局变量。不同的飞机（对象）之间是可以独立操作的，当我需要操作的时候，只需要用不同的对象调用需要的方法就行了，而且代码更加的清晰和可维护。\n当然，面向过程肯定也不是就像这么说的这么差劲了，面向过程也有节省资源，对于小规模问题更有操作性这些优点。\n总之，OOP 适用于模拟复杂的现实世界问题，提供了更有组织的代码结构和更好的可维护性。但有时，对于简单问题或需要高度的资源效率的情况，面向过程编程可能更合适。在实际编程中，我们可以根据问题的复杂性和要求来选择适当的编程方法。有时候，甚至可以将两种方法结合使用，以获得最佳的结果。\n封装思想继续上面飞机的例子，我们可以这个类里面有各种各样飞机所具备的方法，我们在需要用的时候只需要构建一个飞机对象，然后让这个对象去调用它的方法就行了，我们就不需要关心这个方法内部是怎么实现的，这让方法更具有复用性和方便别人来使用，并且更加的安全，我们不能随便去改变方法的内部，我们只能调用这个方法。\n或者再举个例子，我们目前学习的很多方法其实都是封装后的结果，比方说Math这个工具类当中的很多方法max()，pow()还记的吗？我们只需要去调用，或者传递参数，他就会返回一个结果，我们并不知道Java底层是怎么实现的，只知道我们把数字放进去，他就给我最大值，我把数字传进去，他就吐给我幂。\n所以和面向对象类似的，\n封装 是一种面向对象编程的概念，它就像是一个飞机机舱一样，将飞机内部的复杂部分隐藏在外部看不见的地方。\n比方说飞机内部的电子设备和引擎。在飞机上，有许多复杂的机械和电子零部件，例如引擎、仪表板、油箱等等。这些零部件对于让飞机正常运行非常重要，但乘客通常不需要知道所有这些细节。所以，这些零部件被封装在飞机的外部之下，乘客只能看到和使用一些简单的控制界面，如按钮、手柄和屏幕。\n封装的好处就是：\n\n隐藏细节：乘客不需要知道飞机内部的复杂性，他们只需要使用控制界面来与飞机交互。\n安全性：乘客不能随意触摸飞机内部的复杂零部件，这可以防止不必要的干预和错误操作。\n简化使用：乘客只需使用简单的控制界面，而不需要了解复杂的内部工作。\n\n所以，封装就像是将复杂性和细节隐藏在一个容器中，对外部提供了一个简化的界面，这使得事物更容易理解和使用，就像乘客使用飞机的控制面板一样。\n懂了吗？如懂，无所谓，看不懂多看几遍，或者问我。\n构造方法构造方法是 Java 编程中的一个特殊方法，它有点像一个蓝图，用来创建对象。\n你可以把构造方法比作一家工厂，用来制造不同种类的产品，而这些产品就是对象。\n为什么需要构造方法？你想想嘛，刚刚的类是什么？是对象的模板，对吧，就相当于一个蓝图，但是只有蓝图那不行的呀，我们怎么才能把这个对象构造出来呢？\n——构造方法。\n构造方法的特点\n构造方法与类名相同。\n构造方法没有返回类型（不像其他方法有int、String等返回类型）。\n构造方法可以有参数，这些参数可以帮助你设置对象的特性。\n\n我们来举一个例子，就用刚刚的飞机的例子，我们给它加上构造方法。\npublic class Airplane {\n    double speed;    // 飞机的速度\n    double altitude; // 飞机的高度\n    double fuel;     // 飞机的燃料量\n\n    // 空参构造方法，用于创建一个默认的飞机对象\n    public Airplane() {\n        this.speed = 0;\n        this.altitude = 0;\n        this.fuel = 0;\n    }\n\n    // 有参构造方法，用于创建具有特定特性的飞机对象\n    public Airplane(double speed, double altitude, double fuel) {\n        this.speed = speed;\n        this.altitude = altitude;\n        this.fuel = fuel;\n    }\n}\n\n这里要讲的东西比较多哈，先从我们有点陌生的这个this关键字开始，这里的this是什么？有什么用呢？\nthis关键字我一句话解决，为了区分类的属性变量和方法的参数。\n有时候需要在类的方法中区分类的实例变量（类的属性）和方法的参数，以避免混淆。这时候就可以使用关键字 this。\n想象一栋大楼（类），每层楼都有一扇窗户（属性），然后有人站在某一层的窗前，这个人需要知道他所在的楼层有多少窗户，也就是说，他需要引用自己所在楼层的窗户。这时，this 就像是告诉他，”这里是你所在的楼层的窗户”。\n具体来说，this 是一个特殊的关键字，它在类的方法中表示当前对象的引用。通过 this，你可以访问或修改当前对象的属性。这有助于区分属性和方法参数，因为它告诉编译器你想要访问的是对象的属性而不是方法参数。\n懂了吧，就是你在构建类之前的那些飞机的速度，高度，燃油量都是要靠this来区分滴\n空参构造好，我们再来看一下空参构造的那个方法：\n// 空参构造方法，用于创建一个默认的飞机对象\npublic Airplane() {\n    this.speed = 0;\n    this.altitude = 0;\n    this.fuel = 0;\n}\n\n这就是我们那个模板的空参构造，那么在对象构建的时候所对应的那个语句长什么样子呢？\n// 使用空参构造方法创建默认飞机\n      Airplane defaultPlane = new Airplane();\n\n熟悉吧，就长这个样子，可以看见我们在new Airplane()这个括号当中并没有传递任何参数，然后在构造方法当中我们也可以发现，我们为每个属性值都配上了默认的值，都是0。\n有参构造// 有参构造方法，用于创建具有特定特性的飞机对象\npublic Airplane(double speed, double altitude, double fuel) {\n    this.speed = speed;\n    this.altitude = altitude;\n    this.fuel = fuel;\n}\n\n这就是有参构造，可以发现这个构造方法需要接收三个参数才可以，然后就把这些参数传递给了用this声明的属性参数，那么我们在构造这个对象的时候就要这么写：\n// 使用有参构造方法创建具有特定特性的飞机\nAirplane customPlane = new Airplane(600, 10000, 500);\n\n可以发现我们向里面分别传递了三个参数，依次对应速度，高度，燃油量这几个属性，传递进去以后就创建了两个对象。\n然后我们就可以看一下这两个方法构造出来的飞机对象有什么区别吧。\npublic static void main(String[] args) {\n\n        // 使用空参构造方法创建默认飞机\n        Airplane defaultPlane = new Airplane();\n\n        // 使用有参构造方法创建具有特定特性的飞机\n        Airplane customPlane = new Airplane(600, 10000, 500);\n\n        System.out.println(\"默认飞机的速度：\" + defaultPlane.speed);\n        System.out.println(\"默认飞机的高度：\" + defaultPlane.altitude);\n        System.out.println(\"默认飞机的燃料量：\" + defaultPlane.fuel);\n\n        System.out.println(\"定制飞机的速度：\" + customPlane.speed);\n        System.out.println(\"定制飞机的高度：\" + customPlane.altitude);\n        System.out.println(\"定制飞机的燃料量：\" + customPlane.fuel);\n    }\n\n输出如下：\n默认飞机的速度：0.0\n默认飞机的高度：0.0\n默认飞机的燃料量：0.0\n定制飞机的速度：600.0\n定制飞机的高度：10000.0\n定制飞机的燃料量：500.0\n\n空参构造出来的默认飞机各个属性都是0，没问题，因为我们什么都没传递。\n定制出来的飞机因为我们传递了参数，所以各个属性也就赋上了相应的值。\n继承这里涉及继承只是简单的讲一下，因为后面需要讲到重写toString()方法，这里需要涉及一些继承的知识，只是简单过一下，方便我待会来讲重写方法。\n什么是继承？当谈到继承时，我们可以将其想象成一种关系，就像家庭关系一样，其中有父母和子女。\n在Java中，继承是一种对象之间的关系，其中一个类可以继承另一个类的属性和行为。这就像家庭中的关系，父母把一些特征和技能传给他们的孩子。\n举个例子，假设有一个基本的类叫做”人”，这个类有一些属性和方法，比如”姓名”和”走路”。现在，我们想创建一个新的类，叫做”学生”，”学生”就可以继承”人”的属性和方法。\n这意味着”学生”类可以拥有”姓名”这个属性，而且可以调用”走路”这个方法，就像”人”类一样。但同时，”学生”类还可以有自己的属性和方法，比如”学习”和”考试”。\n通过继承，我们不需要重复定义”姓名”和”走路”，因为这些已经在”人”类中定义了。而”学生”类可以专注于定义与学生相关的属性和方法，如”学习”和”考试”。\n所以，继承允许我们建立一个类之间的父子关系，使子类可以继承父类的特性，同时可以添加自己的特性。这就像家庭中的关系一样，孩子可以继承父母的一些特点，但也可以拥有自己独特的特点。\n谁是爹？所以继承你就会发现了一个问题——谁是爹？或者谁是谁的爷爷？\n爸爸的爸爸是爷爷，爷爷的爷爷是？\n是祖先，祖先的祖先是？\n发现了吗，就是终归要有个头对吧？\n所以，在Java当中就给我提供了一个类名叫做Object，我们把它称为超类，任何一个类都继承了这个类当中的方法和属性。\n你可以把Object类想象成所有类的祖先，就像一个超级爷爷或超级奶奶。这个超级爷爷或超级奶奶传下来了一些共同的特征和方法，而每个类都可以继承这些特征和方法。\n例如，Object类有一些通用的方法，比如toString()，equals()和hashCode()。这些方法可以在任何类中使用，因为每个类都继承了Object的这些方法。\n如果你的类没有显式地继承自其他类，它就会默认继承自Object类。所以，Object类就像是所有类的最远祖先，它为所有类提供了一些共同的功能。\n当你创建自己的类时，你可以使用Object类中的这些通用方法，或者你可以重写这些方法以适应你的类的需求。就像在家庭中，你可以继承一些祖先的特点，但也可以发展出自己的特点。\n方法的重写好了终于到这里了，什么是方法的重写？\n简单来说，是在面向对象当中的一种编程概念，它允许你在子类中重新创建一个已经存在的方法，但是你可以改变这个方法的行为，以适应子类的需求。\n让我们通过一个简单的例子来解释方法的重写。假设你有一个基类叫做”动物”，它有一个方法叫做”发出声音”，这个方法可以让动物发出不同的声音。然后，你有两个子类，一个是”狗”，另一个是”猫”。\n现在，你想让狗和猫分别发出它们自己的声音，而不是使用基类”动物”的声音（比如说“Siu~~”）。这就是方法的重写的地方。\n在子类中，你可以创建一个与基类中”发出声音”方法名称相同的方法，但是你可以给它不同的声音。例如，在”狗”类中，你可以创建一个”发出声音”的方法，让它返回”汪汪”声音。而在”猫”类中，你可以创建一个相同名称的方法，让它返回”喵喵”声音。\n这样，当你调用狗的”发出声音”方法时，它会返回”汪汪”声音，而调用猫的”发出声音”方法时，它会返回”喵喵”声音。\n这就是方法的重写的基本概念。你可以在子类中重新定义一个方法，以覆盖基类中的相同方法，以适应子类的需求。\n重写toString()方法好了前面铺垫了这么多，就是为了让我可以来讲为什么我们需要在类当中重写toString()方法。\n我们先把那个飞机的例子拿下来：\npublic class Airplane {\n    double speed;    // 飞机的速度\n    double altitude; // 飞机的高度\n    double fuel;     // 飞机的燃料量\n\n    // 空参构造方法，用于创建一个默认的飞机对象\n    public Airplane() {\n        this.speed = 0;\n        this.altitude = 0;\n        this.fuel = 0;\n    }\n\n    // 有参构造方法，用于创建具有特定特性的飞机对象\n    public Airplane(double speed, double altitude, double fuel) {\n        this.speed = speed;\n        this.altitude = altitude;\n        this.fuel = fuel;\n    }\n}\n\n这是那个飞机类\n// 使用空参构造方法创建默认飞机\nAirplane defaultPlane = new Airplane();\n\n// 使用有参构造方法创建具有特定特性的飞机\nAirplane customPlane = new Airplane(600, 10000, 500);\n\nSystem.out.println(defaultPlane);\nSystem.out.println(customPlane);\n\n刚刚我们是通过对象去调用其中的属性值来获得里面的这些速度啊，高度之类的，有些太麻烦了，我想直接通过打印这个对象的方式来实现打印我对应对象的属性值，可不可以？\n然后我们就会发现控制台输出了这一行：\nCPT111.week8.Airplane@7ef20235\nCPT111.week8.Airplane@27d6c5e0\n\n你就会发现输出了这么个奇怪的东西，这是什么呢？\nCPT111.week8.说明是这个类目前在这个包下面，也就是这个文件夹下面，这个类的名字叫Airplane，然后@后面跟上了一堆乱码。\n那这个其实就是这个对象的地址值，当我们有new关键字的时候，就会生成一个新的对象，然后就会产生相应的地址值，当然这一部分的数据结构我是不想讲的，要讲的话放到后面吧，这里讲不完。\n总之，这个地址值指向了内存当中的一个部分，那个部分就存放着我们的地址值，在我们执行输出语句的时候，其实JVM底层就调用我们这个对象的toString()方法，然后进行输出。\n那你就会问，我们的方法当中明明没有这个方法啊。\n那到这里应该就很显而易见了，在我们的超类Object当中就有一个toString()方法，我们可以去Java的源码当中看一下：\n/**\n * Returns a string representation of the object.\n * @apiNote\n * In general, the\n * {@code toString} method returns a string that\n * \"textually represents\" this object. The result should\n * be a concise but informative representation that is easy for a\n * person to read.\n * It is recommended that all subclasses override this method.\n * The string output is not necessarily stable over time or across\n * JVM invocations.\n * @implSpec\n * The {@code toString} method for class {@code Object}\n * returns a string consisting of the name of the class of which the\n * object is an instance, the at-sign character `{@code @}', and\n * the unsigned hexadecimal representation of the hash code of the\n * object. In other words, this method returns a string equal to the\n * value of:\n * &lt;blockquote&gt;\n * &lt;pre&gt;\n * getClass().getName() + '@' + Integer.toHexString(hashCode())\n * &lt;/pre&gt;&lt;/blockquote&gt;\n *\n * @return  a string representation of the object.\n */\npublic String toString() {\n    return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n}\n\n看见啦，上面那一大段读不懂无所谓，我们就看下面这个返回值，不要管这些方法内部是怎么实现的，我们都学了封装了，就直接看\n先通过getClass()获得这个类，然后再调用getName() 方法获得这个类名字（对应Airplane），然后字符串拼接上一个@，最后通过Integer包装类下的一个方法将这个类的hashCode转换成了十六进制的整数，然后再返回。\n对吧，这就是封装的魅力，可能不懂，但是懂了。。。\n所以我们就知道了，那一串乱码不是随便打出来的，而是超父类Object中的一个方法，而我们的飞机类在底层默认继承了这个类罢了。\n所以我们就要重写这个方法，怎么重写，其实就跟新建方法一样，不过方法名要相同\npublic String toString() {\n    return \"Airplane{speed = \" + speed + \", altitude = \" + altitude + \", fuel = \" + fuel + \"}\";\n}\n\n这就重写完成了，其实按照规范我们还要加上一个@Override注解，告诉别的开发者和JVM这个方法是重写的，但是其实没有必要，底层JVM也都知道这个方法是重写的，在调用的时候，会调用这个重写后覆盖的方法。\n当然，我的习惯还是加上。\n@Override\npublic String toString() {\n    return \"Airplane{speed = \" + speed + \", altitude = \" + altitude + \", fuel = \" + fuel + \"}\";\n}\n\nOK，现在我们再来看看直接打印这个对象会有什么结果\nAirplane{speed = 0.0, altitude = 0.0, fuel = 0.0}\nAirplane{speed = 600.0, altitude = 10000.0, fuel = 500.0}\n\n结束！！！\n到这里后，应该就可以对着课件把老师上课搞得东西自己研究出来了，我就不对着搞了，太累了。\n最近事情还是蛮多的，不一定会定时更新。\nT T\n","slug":"Java-Learning-Week8","date":"2023-11-06T10:20:06.000Z","categories_index":"","tags_index":"笔记,Java初学","author_index":"General_K1ng"},{"id":"19b17cf70fbf7b80415d6c3b17a3d380","title":"Java_Exercise(Week4)","content":"说实话在我昨天晚上做玩这周的Exercise和CW之后，我对于这周是否要写这个笔记产生了很大的怀疑，难度确实有，但是不大，问题在于，想要把我昨天做题时候的思路讲清楚，呈现明白，是一个非常浪费时间和精力的事。。\n想了想，还是写出来吧。\nExercise #4.1 Copy Even Indices编写一个 Java 方法 int[] copyEven(int[] nums)，将偶数索引处的元素复制到一个新数组中。\n该方法必须返回长度正确的新数组，并在数组中包含这些元素。\nTest cases :\ncopyEven([1, 2, 3]) → [1, 3]\ncopyEven([1, 2, 3, 4]) → [1, 3]\n\n题目解析第一题还是比较简单的，就相当于热身了，我们首先要明白我们要干什么。\n\n编写一个方法，这个方法接收一个数组，然后返回一个新数组\n判断偶数索引，并且将偶数索引的元素放到这个新数组当中\n\n那就先写呗，方法先定义出来\npublic static int[] copyEven(int[] nums){\n    //方法体\n}\n\n然后怎么去想，我们是不是要返回一个新的数组，那么数组这个我们是知道的，它必须指定长度，所以问题就来到了我们新的数组是多长的问题。\n那么，长度是多少呢？\n这里我们可以这样想，原数组的长度我们知道是nums.length对吧，那么我们还知道我们需要返回的是偶数索引处的元素，那么偶数元素有多少个？\n根据之前我们学过的计数器，我们应该可以写出以下代码。\nint count = 0;\nfor (int i = 0; i &lt; nums.length; i += 2) {\n    count++;\n}\n\n这里注意，第三个循环条件不再是i++了，因为我们需要的是偶数索引有多少个，所以我们的循环条件变成了i += 2。\n好了现在我们知道了新数组的长度了，我们就先把这个需要返回的数组创建出来。\nint[] result = new int[count];\n\n接下来我们只需要把偶数索引处的元素填进去就好了，对吧，其实上面的那个循环条件刚好就是获取偶数索引元素的，所以我们再写一个一样的，只不过循环内部改为新数组的赋值即可。\nint index = 0;\nfor (int i = 0; i &lt; nums.length; i += 2) {\n    result[index] = nums[i];\n    index++;\n}\n\n最后返回我们的result数组即可，其实并不是很难。\n完整代码\nClick to see more\n方法\npublic static int[] copyEven(int[] nums) {\n    int count = 0;\n    for (int i = 0; i &lt; nums.length; i += 2) {\n        count++;\n    }\n\n    int[] result = new int[count];\n    int index = 0;\n    for (int i = 0; i &lt; nums.length; i += 2) {\n        result[index] = nums[i];\n        index++;\n    }\n\n    return result;\n}\n\n测试数组\nint[] test1 = {1, 2, 3};\nint[] test2 = {1, 2, 3, 4};\nint[] test3 = {8, 5, 4, 9, 6, 7, 7, 6};\n\n测试结果如下\n[1, 3]\n[1, 3]\n[8, 4, 6, 7]\n\n\n\nExercise #4.2 A Diamond is FORever这题开始就稍微有那么一丢丢需要脑子了。\n编写一个 Java 方法 void diamond(int n)，该方法接收奇数整数参数 n，并打印出类似下面测试用例的 n-by-n 图案，每个组成菱形的元素用星号（*）表示，每个不组成菱形的元素用点（.）表示，每个 * 或 .之间用一个空格隔开。\nTest cases :\ndiamond(5)\n\n. . * . .\n\n. * * * .\n\n* * * * *\n\n. * * * .\n\n. . * . .\n\ndiamond(9)\n\n. . . . * . . . .\n\n. . . * * * . . .\n\n. . * * * * * . .\n\n. * * * * * * * .\n\n* * * * * * * * *\n\n. * * * * * * * .\n\n. . * * * * * . .\n\n. . . * * * . . .\n\n. . . . * . . . .\n\n题目解析这个怎么才能讲的清楚呢。。。\n还是一样，先明确一下我们需要干什么\n\n写一个方法void diamond(int n)返回值为空，接收一个整数，要求可以输出一个菱形图案\n这个接收的整数n必须为奇数\n然后就是图案的创建，我们需要打印出来一个菱形\n\n前两个应该都很简单，我们只需要创建一个方法，然后判断一下传入的是不是奇数，如果是奇数就继续，如果不是奇数就直接结束方法\npublic static void diamond(int n) {\n    if (n % 2 == 0) {\n        System.out.println(\"不是奇数\");\n        return;\n    }\n\n最难的地方就是，我们该如何打印出这个菱形图案呢？\n好我们先一步一步来哈，我想了好久才想明白该怎么讲最好。\n首先，我在这里先介绍一个数学概念——曼哈顿距离\n曼哈顿距离曼哈顿距离（Manhattan distance），也称为城市街区距离或L1距离，是计算两个点在规则网格上的距离的度量方式。它得名于纽约曼哈顿的城市街区规划，其中街道呈直角交叉。\n曼哈顿距离是通过将两个点的横向和纵向距离相加来计算的，而不考虑对角线距离。在二维平面上，曼哈顿距离是两个点在水平和垂直方向上的绝对距离之和。\n假设有两个点和，它们之间的曼哈顿距离可以用以下公式表示：其中，表示的绝对值。\n其实，说白了就是东西加南北的距离就是曼哈顿距离。\n好了，然后我们再看我们需要输出的到底是什么形状，如果没有*的话，其实就是一个n*n的正方形矩阵，而且就算如果有*的话，也能发现其实就是把一个正方形旋转了45°罢了，那么其实我们需要打印的菱形其实就是一个放倒了的正方形。\n毕竟正方形也是特殊的菱形。。。\n那这就简单啦，先说结论，从正方形正中心到边上的各个点的曼哈顿距离和相等，或者说，曼哈顿距离和相等的点的集合是一个正方形，也就是说，我们需要画出来的正方形，或者说是菱形，只需要知道他的曼哈顿距离就好。\n我画个图在这里好了。\n\n鼠标画的比较丑哈，我们需要输出的完整图案就相当于最外面这个橙色的正方形，而星号需要表示的其实就是中间的这个黑色的正方形ABCD，然后我们会发现以O为原点出发，E和F点的曼哈顿距离，也就是和其实是相等的，正方形的几何性质我就不多说了，什么全等啊之类的证明自己喜欢证可以去证一下，但是这里我们也就发现了我们需要输出的这个图形其实就是一个放倒了的正方形，并且他的曼哈顿距离就相当于最外面这个橙色正方形的一半，也就是。\n那么我们回到我们的题目，我们拿到的n其实是什么？\n是橙色正方形的边长，比如如果n=5，那就相当于五个单位长度\n那么我们怎么表示中间的这个菱形呢？\n利用我们刚刚说的曼哈顿距离，我们就能通过双层循环嵌套写出来。\nint mid = n / 2;\nfor (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; n; j++) {\n        if (Math.abs(j - mid) + Math.abs(i - mid) &lt;= mid)\n            System.out.print(\"* \");\n        else\n            System.out.print(\". \");\n    }\n    System.out.println();\n}\n\n我先解释一下这个循环，首先我们在外部定义一个变量mid用来记录我们的曼哈顿距离，因为我们说过了其实就是最外侧大正方形的一半。\n然后通过循环嵌套进行输出一个平面的n*n的矩阵，但是这个矩阵内部我们需要输出一个菱形，这个菱形满足曼哈顿距离和小于等于我们的mid，\n于是就写出来了循环内的if条件，满足条件的我们输出*，反之输出.即可\n完整代码\nClick to see more\n方法\npublic static void diamond(int n) {\n    if (n % 2 == 0) {\n        System.out.println(\"不是奇数\");\n        return;\n    }\n\n    int mid = n / 2;\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            if (Math.abs(j - mid) + Math.abs(i - mid) &lt;= mid)\n                System.out.print(\"* \");\n            else\n                System.out.print(\". \");\n        }\n        System.out.println();\n    }\n}\n\n测试数字\ndiamond(30);\nSystem.out.println(\"====================================================================\");\ndiamond(5);\nSystem.out.println(\"====================================================================\");\ndiamond(9);\n\n测试结果如下\n不是奇数\n====================================================================\n. . * . . \n. * * * . \n* * * * * \n. * * * . \n. . * . . \n====================================================================\n. . . . * . . . . \n. . . * * * . . . \n. . * * * * * . . \n. * * * * * * * . \n* * * * * * * * * \n. * * * * * * * . \n. . * * * * * . . \n. . . * * * . . . \n. . . . * . . . . \n\n\n\nExercise #4.3 Arithmetic Series编写一个 Java 方法 int[] arithSeries(int n)，在输入一个大于等于 0 的整数 n 时，输出一个具有 [1, 1, 2, 1, 2, 3, ....., 1, 2, 3, ..., n] 模式的数组。\n注意，数组的长度将是 ，高斯的著名推导恰好是 。\nTest cases :\narithSeries(2) → [1, 1, 2]\narithSeries(3) → [1, 1, 2, 1, 2, 3]\narithSeries(4) → [1, 1, 2, 1, 2, 3, 1, 2, 3, 4]\n\n题目解析这道题感觉还是在考察循环的嵌套，虽然感觉并不是很难，并且题目里面也说出来了数组的长度应该为多长，所以说大的难点几乎是没有。\n那么还是一样，明确一下目的。\n\n写一个方法，接收一个整数n，然后返回一个数组\n这个数组是一个有规律的数列 [1, 1, 2, 1, 2, 3, ....., 1, 2, 3, ..., n] \n长度已知是 \n\n那那，基本上就完了吧，外层循环用来控制有多少组，内部循环就是保证1；1,2；1,2,3。。。这样子就好。\npublic static int[] arithSeries(int n) {\n    int length = (n(n + 1))/2;\n    int[] series = new int[length];\n    int index = 0;\n\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= i; j++) {\n            series[index] = j;\n            index++;\n        }\n    }\n\n    return series;\n}\n\n然后就好了。。。感觉没什么需要特别强调的，就是注意一下索引别越界就好。\n好像以上就是完整代码hhh。\nExercise #4.4 Band Matrix编写一个 Java 方法 void bandMatrix(int n, int width)，该方法接收两个整数参数 n 和 width，并打印出类似下面的 n-by-n 图案，其中每个元素与主对角线的距离严格大于宽度的为 0，不大于宽度的为星号(*)，每个 0 或 * 之间有两个空格。请注意，这里的距离是指你向上/下/左/右移动到任何对角线条目的最少次数\n\nTest cases :\nbandMatrix(4, 0)\n\n*  0  0  0\n\n0  *  0  0\n\n0  0  *  0\n\n0  0  0  *\n\nbandMatrix(4, 1)\n\n*  *  0  0\n\n*  *  *  0\n\n0  *  *  *\n\n0  0  *  *\n\nbandMatrix(4, 2)\n\n*  *  *  0\n\n*  *  *  *\n\n*  *  *  *\n\n0  *  *  *\n\n题目解析还是一样的先明确我们需要什么\n\n写一个方法，接收两个整数，一个是n，另一个是width，分别代表维度和宽度，没有返回值\n要求输出一个矩阵\n矩阵内部要满足一定要求：每个元素与主对角线的距离严格大于宽度的为 0，不大于宽度的为星号(*)，每个 0 或 * 之间有两个空格。\n\n这个跟上面那个菱形的还挺像的，但是我个人感觉是没上面的难。\n首先我们先构建方法\n  public static void bandMatrix(int n, int width) {\n//方法体\n  }\n\n然后一想，还是矩阵，那就一样的循环嵌套\npublic static void bandMatrix(int n, int width) {\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            //该怎么输出？\n        }\n        System.out.println();\n    }\n}\n\n然后就是里面该怎么进行输出呢？\n题目已经说的很清楚了，用if写出来呗\nif (Math.abs(i - j) &lt;= width) {\n    System.out.print(\"*  \");\n} else {\n    System.out.print(\"0  \");\n}\n\n对吧。。。\n然后就，就，就结束了。\n完整代码\nClick to see more\n方法\npublic static void bandMatrix(int n, int width) {\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            if (Math.abs(i - j) &lt;= width) {\n                System.out.print(\"*  \");\n            } else {\n                System.out.print(\"0  \");\n            }\n        }\n        System.out.println();\n    }\n}\n\n测试\nbandMatrix(4,0);\nSystem.out.println(\"========================================\");\nbandMatrix(4,1);\nSystem.out.println(\"========================================\");\nbandMatrix(5,3);\n\n测试结果\n*  0  0  0  \n0  *  0  0  \n0  0  *  0  \n0  0  0  *  \n========================================\n*  *  0  0  \n*  *  *  0  \n0  *  *  *  \n0  0  *  *  \n========================================\n*  *  *  *  0  \n*  *  *  *  *  \n*  *  *  *  *  \n*  *  *  *  *  \n0  *  *  *  *  \n\n\n\nExercise #4.5 Even Odd Swap编写一个 Java 方法 int[] evenOddSwap(int[]nums)，给定一个包含相同数目偶数和奇数的整数数组、按出现的顺序交换所有偶数和奇数对。\nTest cases :\nevenOddSwap([1, 2, 3, 4]) → [2, 1, 4, 3]\n\nevenOddSwap([100, 25]) → [25, 100]\n\nevenOddSwap([]) → []\n\nevenOddSwap([11, 55, 100, 200, 300, 7]) → [100, 200, 11, 55, 7, 300]\n\n题目解析噔噔咚。。。\n这个应该是今天最难的一道了，昨天开始做到这里让我有点惊讶怎么会这么难。。。\n但是最后还是做出来了，也有可能是我的思路过于抽象？\n算了，我就按照我的思路来讲解了。\n但是我现在好累，我实在不想再敲代码了。\n简单来说，分别找到奇数元素和偶数元素所对应的索引，然后交换，然后返回新数组。\n说着比较简单，但是基本上提示到位了。\n下周再把这个更出来。\n","slug":"Java-Exercise-Week4","date":"2023-10-14T04:44:30.000Z","categories_index":"","tags_index":"笔记,Java初学","author_index":"General_K1ng"},{"id":"a8c731e8e4e06940923b6b0b44a5b222","title":"Java_Learning(Week4)","content":"有一说一，咱们学校这个课的进度是真的赶啊，这才几节课就到数组和方法了。。\n循环补充什么？原来上周没有讲什么是For循环，那我上周笔记不就多写了！\n怪不得感觉上周写的这么多。。。算了无所谓了，那么这里就来补充一些上周没有提到的东西。\nbreak关键字break 关键字用于立即退出当前所在的循环，不再执行剩余的循环迭代。它的主要用途是在满足某个条件时，提前跳出循环，以节省计算资源或处理特殊情况。\n使用情况：\n\nbreak 可以用在 for、while、和 do-while 循环中，以及 switch 语句中。\n\nfor (int i = 1; i &lt;= 10; i++) {\n    if (i == 5) {\n        break; // 当 i 等于 5 时，退出循环\n    }\n    System.out.println(i);\n}\n\n上述代码就只会输出数字 1 到 4，然后退出循环，也就是说，循环后面的就不会执行了，就会直接跳出。\ncontinue 关键字continue 关键字用于跳过当前迭代，并继续下一次迭代。它的主要用途是在某些条件下，跳过某些循环迭代，但不会退出整个循环。\n简单来说就是跳过一次循环，继续执行下面的循环操作。\n使用情况：\n\ncontinue 可以用在 for、while、和 do-while 循环中。\n\nfor (int i = 1; i &lt;= 5; i++) {\n    if (i == 3) {\n        continue; // 当 i 等于 3 时，跳过当前迭代\n    }\n    System.out.println(i);\n}\n\n上述代码将输出数字 1、2、4、5，跳过了数字 3。\n循环结构嵌套跟if一样，循环结构也是可以进行嵌套操作的，无论是while循环还是For循环，或者两者杂交，都可以。\n基本的嵌套循环结构最常见的循环嵌套是使用for循环。下面是一个简单的例子，演示如何使用嵌套的for循环打印一个矩形图案：\nfor (int i = 1; i &lt;= 5; i++) {\n    for (int j = 1; j &lt;= 5; j++) {\n        System.out.print(\"* \");\n    }\n    System.out.println(); // 换行\n}\n\n上述代码将输出一个5x5的矩形，如下所示：\n* * * * * \n* * * * * \n* * * * * \n* * * * * \n* * * * * \n\n外部循环和内部循环在嵌套循环中，通常有外部循环和内部循环的概念。外部循环的迭代次数决定了内部循环的执行次数。下面的示例展示了如何使用嵌套循环生成一个数字三角形：\nfor (int i = 1; i &lt;= 5; i++) {\n    for (int j = 1; j &lt;= i; j++) {\n        System.out.print(j + \" \");\n    }\n    System.out.println();\n}\n\n这将输出以下数字三角形：\n1 \n1 2 \n1 2 3 \n1 2 3 4 \n1 2 3 4 5 \n\n控制循环的流程然后我们就可以通过学到的continue和break关键字进行循环的控制了。break用于退出循环，而continue用于跳过当前迭代并进入下一次迭代。\nfor (int i = 1; i &lt;= 5; i++) {\n    if (i == 3) {\n        continue; // 跳过i等于3的迭代\n    }\n    for (int j = 1; j &lt;= 5; j++) {\n        if (j == 4) {\n            break; // 退出内部循环\n        }\n        System.out.print(i + \"-\" + j + \" \");\n    }\n    System.out.println();\n}\n\n这就会输出：\n1-1 1-2 1-3 \n2-1 2-2 2-3 \n4-1 4-2 4-3 \n5-1 5-2 5-3 \n\n可以发现，当进行最外层循环并没有进行第三次操作，直接进行到了第四次，然后内部循环在第四次直接跳出了，所以也并没有打印3之后的数字。\n那么这里就要强调一个重点：\nbreak和continue的注意事项\nbreak 只会退出包含它的最内层循环。\n在多层嵌套循环中，可以使用带标签的 break 来退出指定的外部循环。\n\nouterloop:\nfor (int i = 1; i &lt;= 3; i++) {\n    for (int j = 1; j &lt;= 3; j++) {\n        if (i * j == 6) {\n            break outerloop; // 通过标签退出外部循环\n        }\n        System.out.println(i * j);\n    }\n}\n\n\ncontinue 只会影响包含它的当前循环迭代。\n在多层嵌套循环中，continue 只会影响包含它的最内层循环迭代。\n\nfor (int i = 1; i &lt;= 3; i++) {\n    for (int j = 1; j &lt;= 3; j++) {\n        if (i * j == 6) {\n            continue; // 跳过当前内部循环的迭代\n        }\n        System.out.println(i * j);\n    }\n}\n\n循环嵌套的性能说实话，这周看了很多人写的代码，让我大为震惊，最高的循环嵌套次数打到了五六个for循环嵌套，这个不是说不行，但是循环嵌套的性能是很低的，专业一点是时间复杂度是很高的，嵌套循环的时间复杂度是外部循环次数与内部循环次数的乘积。如果循环次数很大，可能会导致程序运行时间过长。\n所以，尽量避免不必要的嵌套循环。\n记住！\n一定要记住！\n用循环实现多个骰子呃，其实没啥写的，既然课件上面有，我就写在这里吧，我不会去用Math.random()那个方法，过于复杂，这里我是直接创建Random的对象来进行随机数的产生。\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class DiceSimulator {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);// 创建键盘录入的对象\n\n        System.out.print(\"请输入要投掷的骰子次数: \");// 一个提示\n        int numberOfThrows = scanner.nextInt();// 接收需要投掷的次数，或者说有几个骰子\n\n        if (numberOfThrows &lt;= 0) {// 无效判断，如果是负数或者0就直接停止\n            System.out.println(\"无效的次数。请输入一个正整数。\");\n            return;\n        }\n\n        Random random = new Random(); // 创建Random随机类\n\n        System.out.println(\"投掷结果：\");\n        for (int i = 0; i &lt; numberOfThrows; i++) {// 用for循环实现，只要小于录入的投掷次数就持续循环\n            int diceRoll = random.nextInt(6) + 1; // 生成1到6之间的随机整数\n            System.out.println(\"第 \" + (i + 1) + \" 次投掷: \" + diceRoll);// 输出\n        }\n\n    }\n}\n\n应该没有什么需要我特别强调的吧，看注释应该都能看懂。\n数组说实话讲到这里还是有些惊讶的，没想到这周能涉及到数组，按理说应该会在循环和条件语句那里停一段时间做做算法题什么的，没想到进度这么猛。所以我感觉其实对大部分人来说还是比较困难的。\n但是那能怎么办呢？\n什么是数组？数组是一种数据结构，用于存储相同类型的数据元素的集合。在Java中，数组具有以下特点：\n\n固定大小： 数组一旦创建，其大小通常是固定的，不能随意增加或减少。这意味着在创建数组时必须指定其大小，而且不可更改。\n索引访问： 数组中的每个元素都有一个唯一的索引值，用于访问该元素。索引通常从0开始，然后递增，最大索引是数组大小减1。\n相同数据类型： 数组中的所有元素必须是相同的数据类型，例如整数、浮点数、字符等。\n\n记住，数组是一种数据结构，在内存当中用来存储数据，不仅是Java当中，C和C++当中，包括任何语言当中你都能见到数组身影。\n为什么需要数组？记住，数组是一种数据结构，跟什么语言关系不大，我还是要强调一遍。\n为什么需要数组呢，主要有以下几点：\n\n组织数据： 数组提供了一种有效的方式来组织和存储大量数据，这些数据可以按顺序排列，并且可以通过索引快速访问。\n快速访问： 数组的查询是非常快速的，如果我们知道索引的话，数组就允许我们以常量时间（O(1)）访问特定索引位置的元素，这使得查找、插入和删除操作变得非常高效。\n内存管理： 数组在内存中是连续存储的，这有助于减少内存访问的开销，提高数据的读取速度。\n数学和算法： 数组是许多数学和算法问题的基本工具，例如排序、搜索、统计等。\n\n总之，数组是一种数据结构，为我们实际应用有很大帮助，有以下几点作用：\n\n存储和访问数据： 数组用于存储和访问大量数据元素，如存储学生成绩、员工信息、图像像素等。\n迭代和遍历： 数组使得我们可以轻松遍历数据集，执行各种操作，例如打印所有元素、查找特定元素等。\n排序和搜索： 数组是许多排序和搜索算法的基础，如冒泡排序、快速排序、二分查找等。\n实现其他数据结构： 数组可以用来实现其他高级数据结构，如栈、队列、堆等。\n多维数组： 数组可以扩展到多维，用于表示矩阵、图形等复杂结构。\n缓存性能优化： 数组的连续内存存储有助于提高缓存性能，因为数据通常在内存中连续存储，这降低了内存访问的开销。\n\n如何声明和创建数组？我们必须要先声明数组这个变量，才能在程序中使用数组。下面是声明数组变量的语法：\ndataType[] arrayName;   // 首选的方法\n \n或者\n \ndataType arrayName[];  // 效果相同，但不是首选方法\n\n注意: 建议使用 **dataType[] arrayName** 的声明风格声明数组变量。 dataType arrayName[] 风格是来自 C/C++ 语言 ，在Java中采用是为了让 C/C++ 程序员能够快速理解Java语言。\n然后接下来就是创建数组：\narrayName = new dataType[arraySize]; // 创建数组\n\n其中：\n\ndataType 表示数组中元素的数据类型，例如 int、double、String 等。\narrayName 是数组的名称，可以根据需要自定义。\narraySize 是数组的大小，即数组可以容纳的元素数量。\n\n上面的语法语句做了两件事：\n\n使用 dataType[arraySize] 创建了一个数组。\n把新创建的数组的引用赋值给变量 arrayName。\n\n当然我们一般直接写一行，直接声明并创建：\ndataType[] arrayName = new dataType[arraySize]\n\n当然我们如果知道数组当中需要存放的值，我们也可以这样直接创建：\ndataType[] arrayName = {value0, value1, ..., valuek};\n\n然后最值得注意的就是数组的索引是从0开始的，为什么呢？我也不知道，记住就行。\n那么最后举个例子创建一个用来存放整型的长度为5的数组吧！\nint[] numbers; // 声明一个整数数组\nnumbers = new int[5]; // 创建一个包含5个整数的数组\n\n数组的赋值与访问可以使用数组的索引来访问和赋值数组元素。数组的索引从0开始，最大索引是数组长度减1。\nint[] numbers = new int[5];\nnumbers[0] = 10; // 给第一个元素赋值\nnumbers[1] = 20; // 给第二个元素赋值\n\nint firstNumber = numbers[0]; // 访问第一个元素\nint secondNumber = numbers[1]; // 访问第二个元素\n\n那么如果我们此时去访问除了第一和第二索引之外的值会发生什么？\n因为我们没有赋值，所以其实返回的就是默认值，默认值是0。\npublic class ArrayExample {\n    public static void main(String[] args) {\n        int[] numbers = new int[5];\n        \n        // 给索引0和1赋值\n        numbers[0] = 10;\n        numbers[1] = 20;\n        \n        // 访问索引2、3、4\n        System.out.println(numbers[2]); // 默认为0\n        System.out.println(numbers[3]); // 默认为0\n        System.out.println(numbers[4]); // 默认为0\n    }\n}\n\n输出如下：\n0\n0\n0\n\n那如果我访问比这个数组长度更长的索引会发生什么嘞？\npublic class ArrayExample {\n    public static void main(String[] args) {\n        int[] numbers = new int[5];\n        \n        // 给索引0和1赋值\n        numbers[0] = 10;\n        numbers[1] = 20;\n        \n        // 访问索引5\n        System.out.println(numbers[5]);\n    }\n}\n\n会直接报出异常，哈哈：\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length 5\n\tat CPT111.DiceSimulator.main(DiceSimulator.java:15)\n\n这里我们触发了数组索引越界异常（ArrayIndexOutOfBoundsException），这是一个运行时异常。在Java中，数组的索引从0开始，所以有效索引范围是0到数组长度减1。\n不清楚运行时异常是什么没关系，你就把它当做你的程序的一个bug就好，在非常后面我们就会了解到。\n数组的遍历遍历数组是访问数组中所有元素的常见操作。可以使用循环来遍历数组，常见的是for循环遍历，当然在之后也有增强for，现阶段我们就先用普通for进行遍历吧。\nint[] numbers = {1, 2, 3, 4, 5};\nfor (int i = 0; i &lt; numbers.length; i++) {\n    System.out.println(numbers[i]);\n}\n\n这里我们遍历并且输出了这个数组当中存储的数据，然后就是讲一下这个number.length这个就是会返回对应数组的长度。\n求数组当中的平均值，最大值，最小值，总和那就按照课件我们继续使用上面那个我们扔骰子的代码，把它继续更改一下，无非就是把每次随机的值存储到一个数组里面进行输出。\n我就直接把代码丢到这里了：\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class DiceSimulator {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        System.out.print(\"请输入要投掷的骰子次数: \");\n        int numberOfThrows = scanner.nextInt();\n\n        if (numberOfThrows &lt;= 0) {\n            System.out.println(\"无效的次数。请输入一个正整数。\");\n            return;\n        }\n\n        Random random = new Random();\n        \n        int[] diceValues = new int[numberOfThrows]; // 创建一个数组来存储每次投掷的值\n\n        System.out.println(\"投掷结果：\");\n\n        for (int i = 0; i &lt; numberOfThrows; i++) {\n            int diceRoll = random.nextInt(6) + 1;\n            diceValues[i] = diceRoll; // 将投掷结果存储到数组中\n            System.out.println(\"第 \" + (i + 1) + \" 次投掷: \" + diceRoll);\n        }\n        \n        int max = diceValues[0]; // 初始化最大值\n        int min = diceValues[0]; // 初始化最小值\n\n        //计算总和\n        int sum = 0;\n        for (int i = 0; i &lt; diceValues.length; i++) {\n            sum += diceValues[i];\n        }\n        \n        // 计算平均值\n        double average = (double) sum / numberOfThrows;\n\n        // 计算最大值\n        for (int i = 0; i &lt; diceValues.length; i++) {\n            if (diceValues[i] &gt; max){\n                max = diceValues[i];\n            }\n        }\n\n        //计算最小值\n        for (int i = 0; i &lt; diceValues.length; i++) {\n            if (diceValues[i] &lt; min){\n                min = diceValues[i];\n            }\n        }\n\n        System.out.println(\"总和: \" + sum);\n        System.out.println(\"最大值: \" + max);\n        System.out.println(\"最小值: \" + min);\n        System.out.println(\"平均值: \" + average);\n    }\n}\n\n本来有更好的写法，但是为了帮助大家理解遍历计算这些值的方法，就先这样写了，这里也要强调一件事情，那就是一个循环只干一件事情。\n比如计算总和，那么这个循环就只计算总和，不要想着一个循环里面我们既计算总和，又把最大值一算，这个习惯很不好，如果各位后续开发一些项目出了bug，想要进行排查的时候你就知道如果你写一个非常臃肿的循环有多么头疼了。\n不要以为一个循环解决了很多事情就觉得自己很聪明，其实hhh。。。\n那么数组就先到这里，后面有补充的我会继续补充，毕竟课件就讲了这些，这还是我补充过的。\n方法这个我是更没想到，我们居然讲到方法了，这可真的有点太快了。。。\n课件的引入我就不想说了，就是让我们看我们的代码，wow，我们的main方法为什么写的这么长，有没有什么办法让他简单易读又不影响正常逻辑呢？\n什么是方法？Java方法是一种编程结构，它们是一组有序的语句，用于执行特定的功能或任务。这些功能可以解决各种问题。\n\n问题解决步骤的组合： 方法实际上是问题解决步骤的组合。它们让你将一个大问题分解为更小、可管理的部分，然后以特定的方式组合这些部分，以实现所需的功能。\n方法存在于类或对象中： 方法通常与类或对象相关联。它们可以被定义在类的内部，以便与类的其他成员（如属性和其他方法）共享数据和行为。此外，一些方法也可以与对象相关联，使其成为对象的行为。\n方法的创建和引用： 在编写Java程序时，你可以创建方法并在程序中使用它们。创建方法意味着定义方法的名称、参数和执行的操作。一旦定义，你可以在程序的其他部分引用这些方法，以便重复使用它们，而不必每次都重新编写相同的代码。\n\n说白了，目的就是为了更加简洁，减少代码量，重复使用。\n刚好这些就是方法的优点。\n方法的命名规则当然，这个上课没说，但是这里我要提一下。\n\n方法名应该有意义： 方法名应该反映方法的功能和目的。使用清晰、有意义的词汇来描述方法的操作，这有助于其他开发人员理解代码的含义。\n采用驼峰命名法（Camel Case）： Java通常使用驼峰命名法来命名方法，这意味着方法名的首字母小写，后续的单词首字母大写，并且不使用下划线或连字符。例如：calculateTotalAmount()。\n遵循Java标识符规则： 方法名必须遵守Java标识符的规则。合法的方法名可以包含字母、数字和下划线，但必须以字母（a-z或A-Z）或下划线（_）开头。不能使用Java的关键字作为方法名。\n使用动词或动词短语： 方法名通常以动词或动词短语开头，以表示方法正在执行的操作。例如，calculateTotal() 或 validateInput()。\n选择恰当的名字长度： 方法名应该足够长以清楚地描述其功能，但不要过于冗长。避免使用过长的方法名，因为这可能会降低代码的可读性。\n根据约定选择命名： Java社区有一些广泛接受的命名约定，例如：\nget 开头的方法通常用于获取对象的属性值，例如 getName()\nset 开头的方法通常用于设置对象的属性值，例如 setName(String name)\nis 开头的方法通常用于布尔属性的getter方法，例如 isActive()\n\n\n命名一致性： 在整个代码库中保持方法命名的一致性非常重要。如果一个方法执行类似的操作，应该使用类似的命名约定。\n避免使用缩写： 尽量避免使用缩写，除非缩写是广泛理解的，不会导致歧义。使用完整的单词可以提高代码的可读性。\n根据领域专业知识选择命名： 如果您的代码与特定领域相关，尽量使用该领域的专业术语来命名方法，以提高代码的可理解性。\n使用Java命名约定： 遵循Java编码规范和约定，这有助于保持代码的一致性，并让其他人更容易理解你的代码。\n\n好！那就继续！\n方法的定义一般来说，定义一个方法，语法如下：\n修饰符 返回类型 方法名(参数列表) throws 异常列表 {\n    // 方法体\n}\n\n\n有点看不懂无所谓，我放一张图（来自菜鸟教程）。\n\n这个异常抛出可以不用管，目前先不写也无所谓，主要以这张图为主。\n\n修饰符（Modifiers）： 修饰符用于控制方法的访问权限和行为。修饰符可以是以下之一：\npublic：方法可以被任何类访问。\nprivate：方法只能被定义它的类访问。\nprotected：方法可以被同一包内的类和继承该类的子类访问。\n没有修饰符（默认情况下）：方法在同一包内可见，但不对其他包可见。\n\n\n返回类型（Return Type）： 返回类型指定了方法执行后返回的数据类型。它可以是任何Java数据类型，包括原始数据类型（如int、double）和引用数据类型（如对象、数组）。如果方法不返回任何值，可以使用关键字 void 表示。\n方法名（Method Name）： 方法名是方法的标识符，用于在程序中引用该方法。方法名必须遵守Java标识符的规则，如字母、数字和下划线的组合，但不能以数字开头。\n参数列表（Parameter List）： 参数列表包含方法接受的输入参数。参数是方法执行所需的数据，它们由括号括起来，多个参数之间用逗号分隔。每个参数由参数类型和参数名称组成。例如：int x, String name。\nthrows 异常列表（Throws Exception List）： 异常列表指定了方法可能会抛出的异常。异常是程序运行时可能出现的问题的表示。在方法声明中使用 throws 关键字，后跟一个异常类的列表，以通知调用方需要处理这些异常。\n方法体（Method Body）： 方法体是包含在花括号 {} 中的代码块，它定义了方法的实际操作。方法体包含了方法的执行逻辑，可以访问方法参数和局部变量，并执行各种操作。\n\n调用方法这。。。目前学的就是静态方法，也就是static修饰的方法，如果要在main方法中调用，那就直接调用好了，调用，然后传递需要的参数即可。\n应该没什么需要特别强调的，待会的例子应该就能看懂了。\n示例我们继续用上面的代码，把生成数组，计算最大值最小值平均值和总和的这些循环，都给他封装成方法。\n生成数组\n// 模拟骰子投掷并返回结果数组\npublic static int[] simulateDiceRolls(int numberOfThrows) {\n    Random random = new Random();\n    int[] diceValues = new int[numberOfThrows];\n\n    for (int i = 0; i &lt; numberOfThrows; i++) {\n        diceValues[i] = random.nextInt(6) + 1;\n    }\n\n    return diceValues;\n}\n\n计算总和\n// 计算数组的总和\npublic static int calculateSum(int[] array) {\n    int sum = 0;\n    for (int value : array) {\n        sum += value;\n    }\n    return sum;\n}\n\n计算最大值\n// 计算数组的最大值\npublic static int calculateMax(int[] array) {\n    int max = array[0];\n    for (int value : array) {\n        if (value &gt; max) {\n            max = value;\n        }\n    }\n    return max;\n}\n\n计算最小值\n// 计算数组的最小值\npublic static int calculateMin(int[] array) {\n    int min = array[0];\n    for (int value : array) {\n        if (value &lt; min) {\n            min = value;\n        }\n    }\n    return min;\n}\n\n计算平均值\n    // 计算数组的平均值\n    public static double calculateAverage(int[] array) {\n        int sum = calculateSum(array);\n        return (double) sum / array.length;\n    }\n}\n\n好了，这就是我们把那些循环啊，生成数组之类的语句全都写成了方法，那么最后再来看看我们的main方法变成什么样子了吧！\npublic static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n\n    System.out.print(\"请输入要投掷的骰子次数: \");\n    int numberOfThrows = scanner.nextInt();\n\n    if (numberOfThrows &lt;= 0) {\n        System.out.println(\"无效的次数。请输入一个正整数。\");\n        return;\n    }\n\n    int[] diceValues = simulateDiceRolls(numberOfThrows);// 调用方法生成数组\n\n    System.out.println(\"投掷结果：\");\n    for (int i = 0; i &lt; numberOfThrows; i++) {\n        System.out.println(\"第 \" + (i + 1) + \" 次投掷: \" + diceValues[i]);\n    }\n\n    int sum = calculateSum(diceValues);// 调用方法计算和\n    int max = calculateMax(diceValues);// 调用方法计算最大值\n    int min = calculateMin(diceValues);// 调用方法计算最小值\n    double average = calculateAverage(diceValues);// 调用方法计算平均值\n\n    System.out.println(\"总和: \" + sum);\n    System.out.println(\"最大值: \" + max);\n    System.out.println(\"最小值: \" + min);\n    System.out.println(\"平均值: \" + average);\n}\n\n然后这次的内容就到这里了吧，感觉真的进度有些太快了，不知道这周的lab又是什么样子。。。\n","slug":"Java-Learning-Week4","date":"2023-10-09T10:37:13.000Z","categories_index":"","tags_index":"笔记,Java初学","author_index":"General_K1ng"},{"id":"db575aff8a359d17ed235c7bc3cb6733","title":"Java_Exercise(Week3)","content":"这周开始就进入到了条件语句和循环语句了，那么随之而来的就是一些简单的算法题目了，当然对于刚开始接触的人来说还是有些困难的，但是不急，只要把每一步想明白，其实没什么难的，重点在于思路，为什么要用if，为什么要用循环，为什么这个循环是for循环，那个要用while循环，怎么说呢，一定要自己去真真切切的把代码打一遍你才能真的懂，自己不敲代码那真的是不可能学会的。\nExercise #3.1 Pandemic Spread编写 Java 程序 PandemicSpread，模拟大流行病的传播速度，输入如下内容：\n\ninit：第 1 天的初始感染人数\nnumInfect：一名感染者每天新感染的健康人的平均数量\npopulation：该地区的总人数返回全部人口受感染的日期。\n\n\n测试用例：\nTest case 1 :\nInput:\n1\n2\n10\nOutput:\n4\n(Explanation: Total Infected Day 1 = 1; Day 2 = 3; Day 3 = 9; Day 4 = 27)\n\nTest case 2:\nInput:\n5\n3\n1000\nOutput:\n5\n\n题目分析我们先把这个题目进行分析，首先告诉我们需求是要模拟疫情的传播速度，然后定义了三个变量，分别是：\n\ninit：第一天的初始感染人数。它代表在大流行病开始时已经有多少人被感染了。\nnumInfect：一名感染者每天新感染的健康人的平均数量。它表示每个已感染者每天平均能传染给多少个健康人。\npopulation：该地区的总人数。它代表了整个地区内的人口数量。\n\n然后其实意图就很明显了，举个例子，假设在某个地区，第一天的初始感染人数是 1，一名感染者每天平均感染 2 个健康人，而该地区的总人口是 10。我们的目标就是找出在这种情况下，需要多少天才能使整个人口都被感染。\n对吧？这种题就跟小学生的应用题一样，可能手算都会但是让你写一个程序呢？不急，我们就先按小学生的思路走。\n根据题目要求，我们可以逐天模拟传播的过程。\n\n第一天，只有一个人被感染，并且他每天平均感染 2 个健康人。\n第二天，已感染人数将变为 1 + 1 * 2 = 3。\n第三天，已感染人数将变为 3 + 3 * 2 = 9。\n第四天，已感染人数将变为 9 + 9 * 2 = 27。\n\n然而，根据题目要求，我们只需要知道全部人口被感染的日期，所以我们可以直接返回第四天作为答案。\n所以其实我们该怎么写代码呢？\n如果不知道那就先把变量初始化了呗，反之一定是要用的，对吧？\nint init = sc.nextInt(); // 第一天有多少人被感染了\nint numInfect = sc.nextInt(); // 每个感染者平均能传染给多少人\nint population = sc.nextInt(); // 总人口\n\n当然你要在此之前记得导入Scanner的包，这里我就不写了，后面完整代码可以看到。。。\n然后就能发现一个问题，其实我们无法确定需要多少天才能使整个人口都被感染。每天新增感染人数取决于已感染人数和每个感染者平均每天感染的健康人数。因此，我们需要通过逐天迭代的方式来模拟传播过程，直到已感染人数达到或超过总人口数量。\n那么不就是我们所说的循环了吗？那么用哪个循环？while还是for？\n我在这周最开始的教程里面其实讲过了，当知道具体循环次数的时候一般用for循环，当不确定的时候就用while循环。显然，此刻我们不知道要循环多少次。\n然后我们来想循环应该怎么来写，看看上面我们的模拟传播过程，有没有发现一些规律？\n我觉得都大学生了，这个规律应该还是能看出来的。。。吧？\n第一天，只有一个人被感染，对吧？然后，每个被感染的人每天平均再感染2个健康人。所以，第二天，已感染的人数是1（初始感染）加上1（初始感染者）乘以2（每个感染者每天平均感染的人数），等于3人。\n接下来，第三天，已感染的人数是3（第二天的感染人数）加上3（第二天的感染人数）乘以2（每个感染者每天平均感染的人数），等于9人。\n再往后，第四天，已感染的人数是9（第三天的感染人数）加上9（第三天的感染人数）乘以2（每个感染者每天平均感染的人数），等于27人。\n这个规律就是每一天的感染人数都是前一天的感染人数乘以2再加上前一天的感染人数。\n所以这部分代码我想，还是非常简单的，首先，我们初始化一个变量叫做day，它表示当前是第几天，我们从第一天开始。\n还有一个变量叫做infected，它表示已经感染的人数，我们从初始感染人数开始。\n然后，我们使用一个while循环，它会一直运行直到所有人都被感染。在循环里，我们计算每一天新感染的人数，用newInfections表示，它等于infected * numInfect，也就是前一天的感染人数乘以2。\n接下来，我们将新感染的人数加到已感染的人数上，这样我们就更新了每一天的感染情况。\n最后，我们将day加1，表示进入下一天。然后，循环会继续运行，计算下一天的感染情况，直到所有人都被感染。\nint day = 1; // 定义天数，我们从第一天开始\nint infected = init; // 用infected这个变量表示已感染的人数，第一天感染的人数就是init变量所记录的值\n\nwhile (infected &lt; population) { // 循环结束条件，只要已感染人数小于总人数就一直继续循环\n    int newInfections = infected * numInfect; // 用已感染的人数乘以平均传染的速率并且用一个变量来接收，表示每日新增感染人数\n    infected += newInfections;// 然后更新已感染人数\n    day++; // 天数加一\n}\n\n整个代码逻辑其实还是非常简单清晰的吧，如果还不懂的欢迎留言。\n最后很简单了，我们只需要把day进行输出就行了。\nSystem.out.println(day);\n\n完整代码\nClick to see more\nimport java.util.Scanner;\n\npublic class PandemicSpread {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int init = sc.nextInt(); // 第一天有多少人被感染了\n        int numInfect = sc.nextInt(); // 每个感染者平均能传染给多少人\n        int population = sc.nextInt(); // 总人口\n\n        int day = 1; // 定义天数，我们从第一天开始\n        int infected = init; // 用infected这个变量表示已感染的人数，第一天感染的人数就是init变量所记录的值\n\n        while (infected &lt; population) { // 循环结束条件，只要已感染人数小于总人数就一直继续循环\n            int newInfections = infected * numInfect; // 用已感染的人数乘以平均传染的速率并且用一个变量来接收，表示每日新增感染人数\n            infected += newInfections;// 然后更新已感染人数\n            day++; // 天数加一\n        }\n\n        System.out.println(day);// 输出\n    }\n}\n\n\n\nExercise #3.2 Right Triangle编写一个 Java 程序 RightTriangle，接收三个整数输入数，并判断它们是否构成直角三角形的边长。\n\n当且仅当以下两个条件为真时，您的程序必须打印输出为真：\n\n三个整数均为正数（大于零）。\n您可以找到两个整数，这两个整数的平方和等于第三个整数的平方。\n\n测试用例：\nTest cases 1:\nInput:\n5\n12\n13\nOutput:\ntrue\n(since they are all positive and 52  + 122 == 132)\nTest cases 2:\nInput:\n5\n4\n3\nOutput:\ntrue\n(since they are all positive and 42 + 32  == 52)\nTest cases 3:\nInput:\n-3\n-4\n5\nOutput:\nfalse\n(since -3 and -4 are not positive)\n\n题目分析说实话，这种题是不是拿到手感觉非常简单，然后一到了写代码的时候就头疼，我去，要考虑的东西好多啊。。。\n但是，无所谓，一步一步跟着思路走。\n说穿了，这不就是勾股定理嘛。勾股定理需要什么？三个边长，对吧？那就写咯。\nint side1 = sc.nextInt();\n   int side2 = sc.nextInt();\n   int side3 = sc.nextInt();\n\n为什么不用a,b,c来当做变量名称呢？因为牵扯到下面的条件判断，因为我们熟悉的勾股定理的判定是对吧？但其实也是直角三角形，所以为了避免到时候条件的书写上出现一些混乱，还是用边长来当作变量名吧，当然这是我的习惯，你们可以用什么都行。\n然后我们该怎么判断？想想勾股定理\n\n所有三个整数必须为正数（大于零）。\n其中两个整数的平方和等于第三个整数的平方。\n\n所以我们先满足最基本的都要是正整数嘛，这还不简单？\nif (side1 &gt; 0 &amp;&amp; side2 &gt; 0 &amp;&amp;side3 &gt; 0 ){\n    // 布拉布拉\n}\n\n我只要写个if不就行啦，确实，然后我们想想接下来我们已经保证了三个都是正整数，然后就是怎么保证任意两边长的平方和等于第三边平方呢？\n毕竟老师上课讲到了if语句的嵌套是合法的对吧，那我继续嵌套就好啦！\nif (side1 &gt; 0 &amp;&amp; side2 &gt; 0 &amp;&amp;side3 &gt; 0 ){\n    if (Math.pow(side1,2) + Math.pow(side2,2) == Math.pow(side3,2)){\n        System.out.println(true)\n    }\n}\n\n我还用到了Math.pow()这个函数，真强\n对吧？然后呢？这只是一种情况对吧？\n一共应该有三种情况，我们都加上。\nif (side1 &gt; 0 &amp;&amp; side2 &gt; 0 &amp;&amp;side3 &gt; 0 ){\n    if (Math.pow(side1,2) + Math.pow(side2,2) == Math.pow(side3,2)){\n        System.out.println(true)\n    }\n    if (Math.pow(side1,2) + Math.pow(side3,2) == Math.pow(side2,2)){\n        System.out.println(true)\n    }\n    if (Math.pow(side2,2) + Math.pow(side3,2) == Math.pow(side1,2)){\n        System.out.println(true)\n    }\n}\n\n真简单！但是有没有发现一个问题，就是当我们输入负数的时候，程序无法做出反应，这个代码只能输出满足条件的true却不能输出不满足条件的false，怎么办呢？\n简单，我们只需要在外部定义一个布尔变量，初始化为false，只要这些条件都不满足，我在条件语句最后就直接输出它不就好了，然后我们if条件内也需要改一下，因为如果是这样的话，满足条件时就会输出一行true和一行false。\n怎么改呢？\nboolean isRight = false;\nif (side1 &gt; 0 &amp;&amp; side2 &gt; 0 &amp;&amp;side3 &gt; 0 ){\n    if (Math.pow(side1,2) + Math.pow(side2,2) == Math.pow(side3,2)){\n        isRight = true;\n    }\n    if (Math.pow(side1,2) + Math.pow(side3,2) == Math.pow(side2,2)){\n        isRight = true;\n    }\n    if (Math.pow(side2,2) + Math.pow(side3,2) == Math.pow(side1,2)){\n        isRight = true;\n    }\n}\nSystem.out.println(isRight);\n\n我们只需要改一下就能满足题意了。但是，其实这个代码是还可以简化一下的。\n第一点就是精度问题，我们用到了Math.pow()这个函数，但是其实这个函数的底层接受的是double变量，如果我们传递int进去，Java会自动帮我们转换成double（还记得吗？隐式转换！）类型的浮点数再进行运算，但是浮点数由于二进制的原因精度上可能会有所欠缺，所以我建议最好写成乘号相乘，避免一些精度上的失误。\n然后就是语句的一些简化，这里我们用了太多的if语句，其实内部可以简写为一句，运用我们之前刚学的逻辑或（||）符号即可。\n更改完代码如下：\nboolean isRight = false;\nif (side1 &gt; 0 &amp;&amp; side2 &gt; 0 &amp;&amp; side3 &gt; 0) {\n    if (side1 * side1 + side2 * side2 == side3 * side3 ||\n        side1 * side1 + side3 * side3 == side2 * side2 ||\n        side2 * side2 + side3 * side3 == side1 * side1) {\n        isRight = true;\n    }\n}\nSystem.out.println(isRight);\n\n\n可读性和简洁性一下子就上来了，对吧。\n完整代码\nClick to see more\nimport java.util.Scanner;\n\npublic class RightTriangle {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        // 输入的三个整数作为边长\n        int side1 = sc.nextInt();\n        int side2 = sc.nextInt();\n        int side3 = sc.nextInt();\n\n        // 判断所有边是否为正整数\n        boolean isPositive = side1 &gt; 0 &amp;&amp; side2 &gt; 0 &amp;&amp; side3 &gt; 0;\n\t\t\n        boolean isRight = false;// 定义变量\n        if (isPositive) {\n            if (side1 * side1 + side2 * side2 == side3 * side3 || \n                side1 * side1 + side3 * side3 == side2 * side2 ||\n                side2 * side2 + side3 * side3 == side1 * side1) {\n                isRight = true;\n            }\n        }\n        System.out.println(isRight);\n    }\n}\n\n\n\n你们知道我最开始写出来的代码长什么样子吗？我都不敢给你看。。。\n算了还是放在这里吧，看不懂也没关系，毕竟我们还没有学方法，但是这个逻辑写得我都想抽自己，上面的是我后来优化的时候写出来的，以上面为准。\n\nClick to see more\nimport java.util.Scanner;\n\npublic class RightTriangle {\n    \n    public static boolean isPositive(int a, int b, int c) {// 判断是否为正整数\n        return a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; c &gt; 0;\n    }\n\n    public static int calculateSumOfSquares(int a, int b, int c, int maxSide) {// 分情况计算平方和\n        if (maxSide == a) {\n            return (b * b) + (c * c);\n        } else if (maxSide == b) {\n            return (a * a) + (c * c);\n        } else {\n            return (a * a) + (b * b);\n        }\n    }\n\n    public static boolean isRightTriangle(int a, int b, int c) {// 判断是否满足勾股定理\n        if (!isPositive(a, b, c)) {// 方法复用，先判断是否为正整数\n            return false; \n        }\n\n        int maxSide = Math.max(Math.max(a, b), c);// 寻找三边最大值，最长的一边就是斜边\n        int sumOfSquares = calculateSumOfSquares(a, b, c, maxSide);// 调用方法，计算平方和\n        int squareOfMaxSide = maxSide * maxSide;// 计算斜边平方\n\n        return sumOfSquares == squareOfMaxSide; // 判断平方和是否等于斜边平方\n    }\n\n    public static void main(String[] args) {// 主程序入口\n        Scanner sc = new Scanner(System.in);\n\n        int side1 = sc.nextInt();\n        int side2 = sc.nextInt();\n        int side3 = sc.nextInt();// 接收三个变量\n\n        boolean isRight = isRightTriangle(side1, side2, side3);// 判断\n        System.out.println(isRight);// 输出\n    }\n}\n\n\n\nExercise #3.3 Hailstone Sequence好累啊，今天还是中秋节，写这篇文章之前我刚下飞机，现在是第二天凌晨两点半了，撑不住了，先睡觉，明天继续把剩下来的肝完。\n海尔斯通序列的计算方法如下：\n\n从一个整数 n 开始\n如果 n 是偶数，则序列中的下一个数字是 \n如果 n 是奇数，则下一个数字是 \n继续计算，直到到达 1\n\n例如\n 时，序列为 3、10、5、16、8、4、2、1 时，序列为 12, 6, 3, 10, 5, 16, 8, 4, 2, 1\n编写一个 Java 程序 HailStone，在输入正整数 n 时，打印从 n 开始的 Hailstone 序列的长度。\n测试用例：\nTest case 1:\nInput:\n3\nOutput:\n8\n\nTest case 2:\nInput:\n12\nOutput:\n10\n\n题目分析这个题属于是前面两个练习的结合，但是是属于非常简单，非常直观的结合，感觉不需要很费劲的去写这道题的思路分析，我就简单写一下，明确我们需要什么就好了。\n目标：\n\n我们需要编写一个 Java 程序，接受输入的正整数 n。\n根据规则计算从 n 开始的海尔斯通序列，直到序列中的数字变为 1。\n在计算过程中，我们需要追踪序列的长度。\n最终，我们需要打印出这个序列的长度。\n\n对吧，那就很明显了，其中牵扯到奇数和偶数的判断，这就涉及到了if条件语句，然后又需要不断的迭代去寻找数列并且要记录长度，这就牵扯到了循环，这都是一目了然的事情。\n所以，怎么解决呢？\n首先，我们需要一个变量来表示序列的长度，初始化为1。\nint sequenceLength = 1;\n\n然后，我们可以使用一个循环来计算序列，直到 n 变为 1。\nwhile (n != 1) {\n    // 布拉布拉\n}\n\n在循环中，我们需要根据奇偶性分别执行不同的操作：\n\n如果 n 是偶数，将 n 除以 2。\n如果 n 是奇数，将 n 乘以 3 并加 1。\n在每一步中，将序列长度加 1。\n\n当 n 变为 1 时，循环结束。\nwhile (n != 1) {\n    // 如果 n 是偶数\n    if (n % 2 == 0) {\n        n = n / 2;\n    } else {  // 如果 n 是奇数\n        n = 3 * n + 1;\n    }\n    sequenceLength++;  // 每次操作后，序列长度加 1\n}\n\n最后，我们打印出序列的长度。\nSystem.out.println(sequenceLength);\n\n整体非常的简单，可以说是一目了然。\n完整代码我的代码牵扯到一些方法的知识，可以先尝试看看能不能读懂，其实没有想的那么高大上，只不过最开始写的时候习惯了。。。\n当然你可以按照上面的来写，也是很简单的。\n\nClick to see more\nimport java.util.Scanner;\n\npublic class HailStone {\n    \n    public static int hailstoneLength(int n) {\n            int sequenceLength = 1; // 初始化序列长度为 1\n\n            while (n != 1) {\n                if (n % 2 == 0) {\n                    n = n / 2; // 如果 n 是偶数，下一个数是 n/2\n                } else {\n                    n = (3 * n) + 1; // 如果 n 是奇数，下一个数是 3n+1\n                }\n\n                sequenceLength++; // 序列长度加 1\n            }\n\n            return sequenceLength;\n        }\n\n        public static void main(String[] args) {\n            Scanner sc = new Scanner(System.in);\n\n            int n = sc.nextInt();\n\n            int sequenceLength = hailstoneLength(n);\n            System.out.println(sequenceLength);\n        }\n}\n\n\n\nCW1 #3.1 Armstrong Numbers这可是重头戏，我都有点不想一步一步讲了，算了先看题吧。 \n阿姆斯特朗数是一个 n 位数，等于其 n 次幂的总和。例如\n\n153 是一个三位数，个位数的立方之和等于 153\n1634 是一个四位数，个位数的 4 次方之和等于 1634\n\n\n编写一个 Java 程序 Armstrong，输入两个正整数 a 和 k、打印前 k 个大于或等于 a 的阿姆斯特朗数。\n测试用例：\nTest case 1:\nInput:\n100\n2\nOutput:\n153\n370\n\nTest case 2:\nInput:\n1500\n1\nOutput:\n1634\n\n题目分析呃一时不知道该怎么起手，先看这个数字，这个数字要求它的每一位数的某个次方之和等于它自己。\n举个例子就是，如果输入 a = 1 和 k = 5，那么程序应该输出前五个大于或等于 1 的阿姆斯特朗数。输出如下：\n1\n2\n3\n4\n5\n\n这里的输出是前五个大于或等于 1 的阿姆斯特朗数。\n这里我们就直接跳过变量初始化，然后Scanner之类的了，过于麻烦，而且我不相信还有人不会。\nok，接下来就是分块来思考，我们需要哪些功能。\n位数获取首先我们需要知道给出的数字的位数是多少对吧，也就是说这个数字的长度是多少。\n其实可以直接使用一个方法，可能没学过，但是无所谓，现在教给你，那就是String.valueOf()，然后我们再使用length()方法即可，那么，什么意思？\nString.valueOf()会将传入的int转换成String类型的字符串再返回，然后再通过length()方法就可以知道这个字符串的长度了。\nint a = 10;\nint digit = String.valueOf(a).length();\nSystem.out.println(digit);\n\n就会输出\n2\n\n当然还有一种更难的方法，牵扯到了一点递归的知识，看不懂没关系，可以体会一下，我先把代码放在这里，然后再简单讲解一下，如果看不懂也无所谓，本来我也想用while循环的，但是最后写出来的代码时间复杂度略高。。。\npublic static int countDigits(int number) {\n        if (number == 0) {\n            return 0;\n        }\n        return 1 + countDigits(number / 10);\n    }\n\n当我们遇到一个大问题时，递归就像是把它变成了一堆相同或类似的小问题。我们通过解决这些小问题来解决整个大问题。\n想象一下，你有一个大盒子里面有很多小盒子，每个小盒子里又有更小的盒子，以此类推，直到最小的盒子里没有其他盒子为止。\n递归就是一种类似的思想。\n在编程中，我们可以写一个函数，这个函数可以调用自己。当我们调用这个函数时，它会解决一个小问题，然后再调用自己来解决更小的问题。这个过程会一直持续下去，直到我们解决了最小的问题，然后逐层返回结果，最终得到整个问题的解。\n举个例子，假设我们要计算一个数的位数。我们可以把这个问题分解为计算这个数除以 10 的结果的位数，然后再加上 1。这个过程会一直重复，直到我们的数变成 0，这时我们就知道它的位数是多少了。\n递归就像是一个问题的拆解过程，将大问题变成了一系列更小的问题，然后通过递归调用来解决这些小问题，最终得到整个问题的解答。\n一般递归的形式就是让方法自己调用自己，但是要设定跳出的条件，不然就会无限递归，导致爆栈。。\n接着我们再简单看一下这个代码：\n这段代码是一个递归函数\npublic static int countDigits(int number) {\n\n这是静态方法，它接受一个整数参数 number，并返回一个整数作为结果。函数名为 countDigits。\nif (number == 0) {\n    return 0;\n}\n\n这是递归函数的终止条件。如果输入的 number 等于 0，说明已经处理完所有位数，直接返回 0。\nreturn 1 + countDigits(number / 10);\n\n这是递归调用的部分。如果输入的 number 不等于 0，将 number 除以 10，可以得到去掉最右边一位的结果。然后将这个结果传递给 countDigits 函数，继续递归计算剩余位数的数量。最后，将递归结果加上 1，表示当前位数，并返回。\n递归函数的基本思想是将一个大问题分解为一个或多个相同的小问题，并通过递归调用来解决这些小问题，最终得到整个问题的解。在这个例子中，通过每次除以 10 来逐渐缩小数字的范围，直到数字变为 0，从而计算出整数的位数。\n好吧，反正无所谓，感觉第一种更好用。\n获取每一位上的数字然后下一步就是我们如何获得这个数字每一位上的数字，因为我们需要分别拿每一位上的数字进行平方和相加，对吧，这一部分我来想想怎么获取每一位上的数字。\n这个其实在lab上有一个部分已经涉及了，就是怎么将数字反转。\n用到的方法其实就是我们的取模操作（%）\nint digit = num % 10;\n\n只要我们每一次对这个数字进行取模操作，每次模于10，就会发现每次的余数刚好是她的个位数字，然后我们在把这个数字除以10，因为是 int 类型，所以就相当于直接删去了个位数字，然后再加入循环就可以做到取出每一位上的数字了。\nwhile (num != 0){\n          int digit = num % 10;\n          num /= 10;\n      }\n\n这样就拿到了每一个位上的数字，应该不是很难，但是估计有人能发现这个循环有个问题就是还没有进行平方和操作，那么我们就在里面加上一句就行了。\nint numDigits = String.valueOf(num).length();\nint sum = 0;\nwhile (num != 0){\n          int digit = num % 10;\n          sum += Math.pow(digit,numDigits);\n          num /= 10;\n      }\n\n这样我们先通过Math.pow()这个方法计算平方，digit就是每一个位子上的数字，numDigits就是我们上一部分获得的一共有多少位，也就是我们计算的幂，然后再在循环外部先初始化一个sum变量等于0，然后通过赋值操作计算这个数字的平方和即可。\n判断是否是Armstrong数字这一步很简单，就在上面的代码基础上就能完成，非常简单，无非就是判断这个数字是不是和计算出来的平方和相等就行了，对吧？\n我们先定义一个变量，用来记录最开始传入的数字，为什么要定义这个变量，因为后续的那个while循环操作会把原来的数字进行操作，如果不记录到时候比较的时候就会出错。\nint originalNum = num;\n\n这里其实我想稍微的涉及一些方法相关的知识，如果看不懂也无所谓，后面我会给出一个不用方法的版本。\n首先我简短的提一下什么是方法，方法就是我们在代码当中有很多功能性的一些代码，我们需要重复用到，我们就会把他单独封装出来，为了更方便的使用，比如我们这里就可以定义一个方法叫做isArmstrong，用来判断传入的数字是不是 Armstrong 数字。\npublic static boolean isArmstrong(int num){ // 定义方法，返回Boolean变量\n      int originalNum = num;// 定义变量记录最初传入的数字\n      int numDigits = String.valueOf(num).length();// 计算传入数字的位数（长度），也就是幂\n      int sum = 0;// 定义一个平方和变量，初始化为0\n\n      while (num != 0){// 循环操作，计算平方和\n          int digit = num % 10;\n          sum += Math.pow(digit,numDigits);\n          num /= 10;\n      }\n      return sum == originalNum; // 比较 平方和 和 最初的数字是否相等，如果相等就返回true，不等就返回false\n  }\n\n如果不懂就看注释吧，如果是 true 就说明这个数字是 Armstrong 数字，反之就不是。\n通过循环不断的寻找接下来就是不断的寻找符合要求的数字了呗，那这一步我放到main方法当中好了。\npublic static void main(String[] args) { // 主入口\n      Scanner sc = new Scanner(System.in);\n\n      int a = sc.nextInt();\n      int k = sc.nextInt(); // 老生常谈，不想说了，看一下a和k分别代表啥\n\n      int count = 0; // 计数器，作为循环的跳出条件\n      int number = a; // 记录数字，a是初始数字，number用来记录后续更新的数字\n\n      while (count &lt; k) { //循环\n          if(isArmstrong(number)){ // 判断是否是Armstrong数字，调用方法，传入number进行判断\n              System.out.println(number);// 打印满足条件的数字\n              count++;//然后计数器加一\n          }\n          number++;// 不管条件是否满足都一直向后更新number的值，用于一直向后遍历寻找\n      }\n  }\n\n这一部分注释已经写得很完整了，应该不需要再多说了。\n完整代码带方法版：\n\nClick to see more\nimport java.util.Scanner;\n\npublic class Armstrong {\n    public static boolean isArmstrong(int num){\n        int originalNum = num;\n        int numDigits = String.valueOf(num).length();\n        int sum = 0;\n\n        while (num != 0){\n            int digit = num % 10;\n            sum += Math.pow(digit,numDigits);\n            num /= 10;\n        }\n        return sum == originalNum;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int a = sc.nextInt();\n        int k = sc.nextInt();\n\n        int count = 0;\n        int number = a;\n\n        while (count &lt; k) {\n            if(isArmstrong(number)){\n                System.out.println(number);\n                count++;\n            }\n            number++;\n        }\n    }\n}\n\n\n\n不带方法版：\n\nClick to see more\nimport java.util.Scanner;\n\npublic class Armstrong {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int a = sc.nextInt(); // 输入起始数值\n        int k = sc.nextInt(); // 输入要找到的阿姆斯特朗数的个数\n\n        int count = 0; // 计数器，记录已找到的阿姆斯特朗数的个数\n        int number = a; // 当前要检查的数值\n\n        while (count &lt; k) {\n            int originalNum = number; // 保存当前数值，用于后面的比较\n            int numDigits = String.valueOf(number).length(); // 计算当前数值的位数\n            int sum = 0; // 保存每个位上数字的幂和\n\n            int num = number;\n            while (num != 0) {\n                int digit = num % 10; // 取出当前数值的个位数字\n                sum += Math.pow(digit, numDigits); // 计算幂和\n                num /= 10; // 去掉个位数字\n            }\n\n            if (sum == originalNum) { // 如果幂和等于原始数值，说明是阿姆斯特朗数\n                System.out.println(number); // 输出阿姆斯特朗数\n                count++; // 计数器加1\n            }\n            number++; // 继续检查下一个数值\n        }\n    }\n}\n\n\n\n\n终于结束啦！！！累死了。。。\n","slug":"Java-Exercise-Week3","date":"2023-09-29T16:54:42.000Z","categories_index":"","tags_index":"笔记,Java初学","author_index":"General_K1ng"},{"id":"40a5a3eda9f47ccd7f66db869eb2a067","title":"Java_Learning(Week 3)","content":"什么是布尔类型？呃其实上周笔记应该都讲了，这周不知道为什么又提到了，那就再稍微过一下，什么是布尔类型呢？\nboolean：\n\nboolean数据类型表示一位的信息；\n只有两个取值：true 和 false；\n这种类型只作为一种标志来记录 true/false 情况；\n默认值是 false；\n例子：boolean a = true。\n\n就这么些，就是一个可以记录是和否的数据类型，只需要记住默认值是false就行，这个还慢重要的。\nJava当中的运算符逻辑运算符所以说讲布尔其实是为了引出几个逻辑运算符号，那方便复习和讲一些东西，我就把Java当中所有的运算符都放到这里一讲就好，刚好上面是布尔，那就先从逻辑运算开始，在此之前我们先想清楚几个逻辑运算的本质。\n分别是与，或，非，其实很简单，高中应该都学过基本的逻辑\n\n与就是两个都真，条件才真；\n或就是两个其中一个为真，条件就真；\n非就是将得到的真和假反转\n\n操作符也很简单，假如例子是A = true, B = false\n\n\n\n操作符\n描述\n例子\n\n\n\n&amp;&amp;\n两个都真，条件才真\n(A &amp;&amp; B) = false\n\n\n||\n两个其中一个为真，条件就真\n(A || B) = true\n\n\n!\n将得到的真和假反转\n!A = false\n\n\n然后就是课上提到了一个“XOR”操作，其实就是我们常说的逻辑异或，其实意思就是如果两个值不同，那么异或结果就是1（真），如果两个值相同，异或结果就是0（假）。\n那么我们如何只用与或非来进行异或的操作呢？\n这个其实不太好想，所以我们一步一步来，跟上我的思路。\n\n思考定义： 逻辑异或操作返回的结果是当两个输入值不相同时为真，相同时为假，对吧？也就是说，只有一个输入为真时，结果为真。反过来说，只有一个输入为假时，结果为真。\n\n分析真值表： 我们把逻辑异或的真值表列出来，这有一些小麻烦，但是很值得这么干\n\n\n\nA\nB\nA XOR B\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\n\n这里其实就比较直观了，我们已经知道了返回条件是只有一个为真的时候结果真，所以我们可以使用逻辑与运算符 &amp;&amp; 来检查两个输入是否不同时为真。例如， (A &amp;&amp; !B) 表示 A 为真且 B 不为真。\n\n然后，我们再考虑另一个条件： (B &amp;&amp; !A) 表示 B 为真且 A 不为真，这也符合逻辑异或的条件之一。\n\n最后，我们可以使用逻辑或运算符 || 来将这两个条件组合起来：(A &amp;&amp; !B) || (B &amp;&amp; !A)。\n\n\npublic class xor {\n    public static void main(String[] args) {\n        boolean a = false;\n        boolean b = true;\n\n        System.out.println((!a &amp;&amp; b) || ( a &amp;&amp; !b));\n    }\n}\n\n其实我们也可以按照检查只有一个输入为假时，结果为真来实现，本质上是一样的。\n关系运算符Java当中的关系运算符，这个更简单，说白了就是小学学的大于小于号，这些来实现一些条件判断，直接把表格列在这里，自己看看：\n\n\n\n运算符\n描述\n示例\n\n\n\n==\n等于（相等）\n5 == 5 结果为 true\n\n\n!=\n不等于\n5 != 3 结果为 true\n\n\n&gt;\n大于\n7 &gt; 4 结果为 true\n\n\n&lt;\n小于\n3 &lt; 6 结果为 true\n\n\n&gt;=\n大于等于\n4 &gt;= 4 结果为 true\n\n\n&lt;=\n小于等于\n2 &lt;= 5 结果为 true\n\n\n对吧，自己打开IDE自己输着玩，玩着玩着就知道这些是什么了。\n算术运算符这个过于简单，但是为了笔记完整性，我也只是列出表格\n\n\n\n运算符\n描述\n示例\n\n\n\n+\n加法\n5 + 3 结果为 8\n\n\n-\n减法\n7 - 4 结果为 3\n\n\n*\n乘法\n2 * 6 结果为 12\n\n\n/\n除法\n10 / 2 结果为 5\n\n\n%\n取模（取余数）\n10 % 3 结果为 1\n\n\n提一嘴，整型的除法和浮点数的除法还是有细微区别的，注意一下。\n然后就是还有自增和自减的操作，这里也列出来\n\n\n\n运算符\n描述\n示例\n\n\n\n++\n自增，相当于a = a + 1\n见下文\n\n\n–\n自减，相当于a = a - 1\n见下文\n\n\n这里牵扯到了一个前缀自增自减和后缀自增自减的区别，那么有什么区别呢？\n\n前缀自增和前缀自减：前缀自增和前缀自减在变量之前执行增加或减少操作，然后返回变量的新值。在前缀运算中，操作先执行，然后返回值。\n\n后缀自增和后缀自减：后缀自增和后缀自减在变量之后执行增加或减少操作，然后返回变量的旧值。在后缀运算中，先返回值，然后再执行操作。\n\n\n说实话大部分情况下两者好像没什么区别，但是其实还是有一些细微的区别的，那就是谁先赋值，谁先自增自减，我写一个例子代码：\npublic class PrefixPostfixExample {\n    public static void main(String[] args) {\n        int x = 5;\n        int y = 5; //定义变量\n\n        // 前缀自增示例\n        System.out.println(\"前缀自增示例:\");\n        System.out.println(\"x 的初始值：\" + x); // 输出 5\n        int prefixIncrementResultX = ++x; // 前缀自增\n        System.out.println(\"前缀自增后 x 的值：\" + x); // 输出 6\n        System.out.println(\"前缀自增的结果：\" + prefixIncrementResultX); // 输出 6\n\n        // 后缀自增示例\n        System.out.println(\"\\n后缀自增示例:\");\n        System.out.println(\"y 的初始值：\" + y); // 输出 5\n        int postfixIncrementResultY = y++; // 后缀自增\n        System.out.println(\"后缀自增后 y 的值：\" + y); // 输出 6\n        System.out.println(\"后缀自增的结果：\" + postfixIncrementResultY); // 输出 5\n    }\n}\n\n最后输出如下：\n前缀自增示例:\nx 的初始值：5\n前缀自增后 x 的值：6\n前缀自增的结果：6\n\n后缀自增示例:\ny 的初始值：5\n后缀自增后 y 的值：6\n后缀自增的结果：5\n\n发现区别了吗，前缀自增返回的结果是6，而后缀自增的结果返回的却是5。\n\n原因就是前缀自增是先进行自增操作，然后再返回值给prefixIncrementResultX这个变量，最后输出就是已经自增过的值。\n然而后缀自增是先进行赋值，也就是先把y = 5这个值赋值给了prefixIncrementResultY，也就是说此时这个变量记录的是5，然后y在此时才进行了自增操作，所以输出结果y = 6但是prefixIncrementResultY还等于5，因为实际上y在自增后还没有赋值。\n\n有点绕，但是建议仔细思考，因为我已经用的是最简单的话把这个点讲清楚辣。\n位运算符这个就更抽象了，但是其实就是二进制层面的一些运算操作，后面除非是考试或者一些比较特殊的算法题目和性能优化问题，不然其实一般很少会涉及到这里，我就列出来：\n\n\n\n运算符\n描述\n示例\n\n\n\n&amp;\n按位与（AND）\n5 &amp; 3 结果为 1\n\n\n|\n按位或（OR）\n5 | 3 结果为 7\n\n\n^\n按位异或（XOR）\n5 ^ 3 结果为 6\n\n\n~\n按位取反（NOT）\n~5 结果为 -6\n\n\n&lt;&lt;\n左移位\n5 &lt;&lt; 2 结果为 20\n\n\n&gt;&gt;\n右移位（带符号）\n10 &gt;&gt; 1 结果为 5\n\n\n&gt;&gt;&gt;\n无符号右移位\n-10 &gt;&gt;&gt; 1 结果为 2147483643\n\n\n为了方便说明，我还是写个代码来举例子\npublic class bitwiseOperator {\n    public static void main(String[] args) {\n        int a = 5;   // 二进制表示为 0101\n        int b = 3;   // 二进制表示为 0011\n\n        int bitwiseAnd = a &amp; b;      // 按位与，结果为 1 (0001)\n        int bitwiseOr = a | b;       // 按位或，结果为 7 (0111)\n        int bitwiseXor = a ^ b;      // 按位异或，结果为 6 (0110)\n        int bitwiseNot = ~a;         // 按位取反，结果为 -6 (11111111111111111111111111111010)\n        int leftShift = a &lt;&lt; 2;      // 左移位，结果为 20 (10100)\n        int rightShift = 10 &gt;&gt; 1;    // 右移位，结果为 5 (0000 0101)\n        int unsignedRightShift = -10 &gt;&gt;&gt; 1; // 无符号右移位，结果为 2147483643 (0111 1111 1111 1111 1111 1111 1111 1011)\n\n\n        System.out.println(bitwiseAnd);\n        System.out.println(bitwiseOr);\n        System.out.println(bitwiseXor);\n        System.out.println(bitwiseNot);\n        System.out.println(leftShift);\n        System.out.println(rightShift);\n        System.out.println(unsignedRightShift);\n    }\n}\n\n怎么说呢，你看第一个位与运算a &amp; b，就是在二进制层面对5和3每一位进行与运算，只有都是1才能返回1，反之返回的都是0，所以运算后得到的结果是0001也就是十进制的1，懂了吧，下面的位或啊，位异或啊都是这个道理。\n然后就是取反(~)，”取反” 是一种位运算操作，也称为按位取反或位取反。它用于翻转二进制数的每个位，将0变为1，将1变为0。具体来说，如果一个二进制位的值为0，那么在取反操作后，它的值将变为1；如果一个二进制位的值为1，那么在取反操作后，它的值将变为0。所以说你就可以看见5取反后得到了-6，那么为什么是-6捏，其实因为二进制表达数字最外面的一个0和1是表达正负号的，hh，底层的一些知识其实不用知道也行。\n移位顾名思义就是二进制数向左/右移动指定数量的位，同时在低位补零。左移n位相当于将原始数乘以2的n次方。例如，将整数5左移2位就得到了20。\n然后无符号右移位就是无符号右移不保留符号位，总是在高位补零。没有无符号左移位，但是可以通过一些方式达到类似的效果，但是没必要知道，起码现在没必要。\n这一块没搞懂无所谓，感觉考试也应该不会闲着没事考这里。。。\n赋值运算符写到这里我快累死了，赋值运算符，就是先运算，然后再赋值，先列表我再看看有没有什么需要强调的：\n\n\n\n运算符\n描述\n示例\n\n\n\n=\n赋值\nint x = 5;\n\n\n+=\n加后赋值（加法赋值）\nx += 3; // 相当于 x = x + 3;\n\n\n-=\n减后赋值（减法赋值）\nx -= 2; // 相当于 x = x - 2;\n\n\n*=\n乘后赋值（乘法赋值）\nx *= 4; // 相当于 x = x * 4;\n\n\n/=\n除后赋值（除法赋值）\nx /= 2; // 相当于 x = x / 2;\n\n\n%=\n取模后赋值（取余数赋值）\nx %= 3; // 相当于 x = x % 3;\n\n\n&lt;&lt;=\n左移位后赋值\nx &lt;&lt;= 2; // 相当于 x = x &lt;&lt; 2;\n\n\n&gt;&gt;=\n右移位后赋值（带符号）\nx &gt;&gt;= 1; // 相当于 x = x &gt;&gt; 1;\n\n\n&gt;&gt;&gt;=\n无符号右移位后赋值\nx &gt;&gt;&gt;= 1; // 相当于 x = x &gt;&gt;&gt; 1;\n\n\n&amp;=\n按位与后赋值\nx &amp;= 3; // 相当于 x = x &amp; 3;\n\n\n|=\n按位或后赋值\nx |= 6; // 相当于 x = x | 6;\n\n\n^=\n按位异或后赋值\nx ^= 5; // 相当于 x = x ^ 5;\n\n\n好像真没什么说的吧，比如x += 3就相当于x = x + 3，其他的同理，自己慢慢看，实在不行最好自己打开IDE自己打一遍就回了。\n条件运算符（三元运算符）这个有点意思，但是也很简单，和if-else语句有点像，我先写出来，这个表达方式如下：\ncondition ? expression1 : expression2\n\n其中，condition 是一个布尔表达式，如果为true，则表达式的值为 expression1，否则为 expression2。这种运算符允许你根据条件的真假选择不同的值。\n举个例子吧！\nint age = 20;\nString status = (age &gt;= 18) ? \"成年人\" : \"未成年人\";\n\nSystem.out.println(\"年龄状态：\" + status); // 输出 \"成年人\"\n\n\n就像代码说的，我先定义我20岁，然后三元运算符开始，判断是否大于18岁，如果大于就返回成年人，小于就返回未成年人。\n但是这一般只用于简单的条件判断，后面会讲它和if语句的一些区别。\n后面其实还有instanceof运算符，但是这里我不准备写，因为这在后面才会涉及，而且我们还没有认识什么是对象，什么是类，现在写了只会让人更晕。\n条件语句这一部分很符合直观，而且很易于理解，并且课上讲的也很明白步骤很清楚。所以我就来稍微写一下。\n执行逻辑非常的清晰易懂，执行顺序是从上到下，一旦满足条件，就执行相应的代码块，并且在执行完一个代码块后，程序会继续执行条件语句之后的代码。在使用条件语句时，要特别注意条件的逻辑和顺序，以确保程序按照预期方式执行。\n然后就是条件语句是顺序结构。\nif语句if语句用于在条件满足时执行一段代码块。\n\n语法格式：\nif (条件表达式) {\n    // 在条件为真时执行的代码块\n}\n\n示例：\nint x = 10;\nif (x &gt; 2) {\n    System.out.println(\"x大于5\");\n}\n\nelse-if语句else if语句用于在多个条件之间进行选择，只有一个条件满足时会执行相应的代码块。\n\n语法格式：\nif (条件表达式1) {\n    // 在条件1为真时执行的代码块\n} else if (条件表达式2) {\n    // 在条件2为真时执行的代码块\n} else {\n    // 所有条件都不满足时执行的代码块\n}\n\n示例：\nint x = 10;\nif (x &gt; 10) {\n    System.out.println(\"x大于10\");\n} else if (x == 10) {\n    System.out.println(\"x等于10\");\n} else {\n    System.out.println(\"x小于10\");\n}\n\n这里有几个注意的点，使用 if，else if，else 语句的时候：\n\nif 最多只能有 1 个 else ，else 必须在所有的 else if 之后。\nif 可以有很多个 else if，它们必须在 else 之前。\n一旦其中有一个 else if 为 true，其他的 else if 以及 else 都将跳过执行。\n\nelse语句else语句用于在前面的条件都不满足时执行一段默认的代码块。\n语法格式：\nif (条件表达式) {\n    // 在条件为真时执行的代码块\n} else {\n    // 在条件为假时执行的代码块\n}\n\n示例：\nint x = 5;\nif (x &gt; 10) {\n    System.out.println(\"x大于10\");\n} else {\n    System.out.println(\"x不大于10\");\n}\n\n嵌套然后就是注意一下条件语句的嵌套在Java当中是合法的，这意味着你可以在一个条件语句的代码块内包含另一个条件语句，以实现更复杂的条件逻辑。嵌套条件语句允许你根据多个条件的组合来进行更精细的控制程序流程。\n以下是一个示例，展示了如何嵌套条件语句：\nint x = 10;\nint y = 5;\n\nif (x &gt; 5) {\n    System.out.println(\"x大于5\");\n    \n    if (y &gt; 3) {\n        System.out.println(\"y大于3\");\n    } else {\n        System.out.println(\"y不大于3\");\n    }\n} else {\n    System.out.println(\"x不大于5\");\n}\n\n可以试着画一下这个的流程图，感受一下条件语句的嵌套。\n三元运算符和if-else语句的区别还记的三元运算符吧，不记得就往上翻，然后再下来。\n区别就是：\n\n三元运算符通常用于简单的条件判断，当条件为真时返回一个值，否则返回另一个值。它适用于将条件表达式的结果分配给一个变量，或者在一个表达式中根据条件返回不同的值。\nif-else语句用于更复杂的条件逻辑，它可以包含多个条件分支，并且可以执行多个不同的代码块，每个代码块可以包含多个语句。if-else语句通常用于根据不同的条件执行不同的操作。\n\n当然这么说可能不太能理解，就是三元运算符适合在简单情况下使用，处理的都是一些非常简单的判断，if可以实现更加负责的代码块，而且在实际开发中肯定是if语句用的更多，因为代码可读性更强，更容易理解，更方便维护。\n循环结构写到这里我快吐了，东西真的多我去，下午才上的课，我现在正在敲笔记O(∩_∩)O呵呵~。\n程序语句的执行可以分为不同的结构，其中之一是顺序结构，它表示代码会按照书写的顺序一次执行一次。\n然而，有时候我们需要让一组操作重复执行多次，这就需要用到循环结构了。\n在Java中，有三种主要的循环结构可供选择，每种都在不同的情况下有其优势和用途：\n\nwhile 循环：这是一种最基本的循环结构，它在开始执行之前检查一个条件，只有条件为真时才会执行循环体。这使得它非常适合处理需要反复执行，但不确定执行次数的情况。\ndo…while 循环：与while循环类似，但不同之处在于它首先执行循环体，然后再检查条件。这确保循环体至少会被执行一次，即使条件一开始就为假。\nfor 循环：这是一种更为复杂但强大的循环结构，通常用于需要在已知次数的情况下执行一组语句。它具有明确的初始化、条件和迭代部分，使得循环的控制非常精确。\n\n当然，在Java 5中引入了一种增强型for循环，这个目前我们还不需要了解，因为这个主要是用来遍历数组和集合元素。简化了循环过程，不再需要显式控制循环索引，而是直接迭代数组或集合的元素。\nwhile循环while 循环是Java中最基本的循环结构之一。它允许重复执行一组语句，只要指定的条件为真（true）时，循环会一直执行。当条件不再为真时，循环停止执行，程序继续执行下一个语句。\n语法：\nwhile (条件) {\n    // 循环体\n}\n\n\n条件：这是一个布尔表达式（boolean expression），当条件为true时，循环体会被执行。如果条件一开始就为false，循环体将不会被执行，而是直接跳过循环。\n循环体：这是需要重复执行的一组Java语句。它们位于大括号 {} 内，可以包含一个或多个语句。循环体中的语句会重复执行，直到条件为false。\n\n执行流程：\n\n首先，计算条件的值。\n如果条件为真，执行循环体内的代码。\n执行完循环体后，再次计算条件的值。\n如果条件仍然为真，继续执行循环体。\n这个过程将一直重复，直到条件为假为止。\n一旦条件为假，程序将继续执行while循环后面的语句或代码块。\n\n示例：\nint i = 1;\nwhile (i &lt;= 5) {\n    System.out.println(\"当前数字是：\" + i);\n    i++; // 注意这里要更新条件，不然就会形成无限循环\n}\n\n上述示例中，循环会从1一直执行到5。首先，条件 i &lt;= 5 被检查，因为1小于等于5，所以循环体内的代码会被执行。然后，i 的值递增，条件再次检查，这个过程一直重复，直到 i 的值变成6时，条件变为false，循环停止。\n注意事项：\n\n在while循环中，一定要确保在某个点上条件会变为false，否则可能导致无限循环。\n为了避免无限循环，通常在循环体内需要更新循环条件，确保最终条件变为false。\n如果条件一开始就为false，循环体将不会被执行，这可能会导致循环完全被跳过。\n\ndo…while循环万恶之源，我的建议是千万别碰这个玩意，我到现在都没搞清楚这个的执行逻辑，并且这玩意是真的难用，开发当中除非找事一般没人会用这个玩意，但是毕竟是学校，要考试的辣，而且谁知道会不会考一些八股文知识，所以笔记还是要有的。\ndo…while 循环 是Java中的另一种循环结构，和while循环很像，但有一个重要的区别：它首先执行循环体，然后再检查条件。这意味着无论条件是否为真，循环体至少会被执行一次。懂了吗，反正我没懂o(￣︶￣)o。\n语法：\ndo {\n    // 循环体\n} while (条件);\n\n执行流程：\n\n首先，执行循环体内的代码。\n执行完循环体后，计算条件的值。\n如果条件为真，继续执行循环体。\n这个过程将一直重复，直到条件为false。\n一旦条件为假，程序将继续执行do…while循环后面的语句或代码块。\n\n示例：\nint i = 1;\ndo {\n    System.out.println(\"当前数字是：\" + i);\n    i++; \n} while (i &lt;= 5);\n\n\n上述示例中，无论如何，循环体都会执行一次。然后，条件 i &lt;= 5 被检查，如果条件为真，循环体将再次执行，这个过程将一直重复，直到 i 的值变成6时，条件变为false，循环停止。\n注意事项：\n\n与while循环不同，do…while循环保证循环体至少会执行一次。\n为了避免无限循环，通常在循环体内需要更新循环条件，确保最终条件变为false。\n如果条件一开始就为false，循环体将至少被执行一次，然后停止执行。\n\n我还是要强调，没事我的建议是别用！\nfor循环基本上可以说是大伙最爱的循环结构了，后面也是大伙用得基本上最多的循环体了。\nfor 循环 是Java中一种非常强大的循环结构，通常用于需要在已知次数下执行一组语句的情况。for循环具有严格的控制结构，包括初始化、条件和迭代部分，使得它非常适合对循环进行精确控制。\n语法：\nfor (初始化; 条件; 迭代) {\n    // 循环体\n}\n\n\n初始化：这是一个在循环开始之前执行的表达式。通常用于初始化循环控制变量，它只会在循环开始时执行一次。\n条件：这是一个布尔表达式（boolean expression），它在每次循环迭代之前都会被检查。只有在条件为true时，循环体才会被执行。如果条件一开始就为false，循循环体将不会被执行。\n迭代：这是在每次循环迭代之后执行的表达式。通常用于更新循环控制变量的值。\n循环体：这是需要重复执行的一组Java语句，位于花括号 {} 内，可以包含一个或多个语句。\n\n执行流程：\n\n首先，执行初始化部分，通常用于初始化循环计数器。\n然后，计算条件的值。如果条件为true，继续执行循环体。\n执行循环体内的代码。\n执行完循环体后，执行迭代部分，通常用于更新循环计数器。\n再次计算条件的值。\n如果条件仍然为true，继续执行循环体，然后重复以上步骤，直到条件为false。\n一旦条件为假，程序将继续执行for循环后面的语句或代码块。\n\n示例：\nfor (int i = 1; i &lt;= 5; i++) {\n    System.out.println(\"当前数字是：\" + i);\n}\n\n在上述示例中，初始化部分初始化了一个计数器变量 i，条件部分检查 i 是否小于等于5，迭代部分每次增加 i 的值。循环体内的代码会重复执行，直到 i 的值变成6，条件变为false，循环停止。\n注意事项：\n\nfor循环通常用于已知循环次数的情况，因为它提供了精确的控制。\n循环变量（例如，上述示例中的 i）通常在循环内部定义，这意味着它的作用范围仅限于循环体内。\n初始化、条件和迭代部分都可以包含多个表达式，它们以逗号分隔。\nfor循环可以嵌套，即在一个for循环内包含另一个for循环。\n\n虽然说它很好用，非常的方便，条件也很严格，但是我要说的是，当年听从一位前辈说的，本质上所有的循环都是while循环，所以for循环完全可以写成while循环的格式，并且更加的简洁，方便看，他建议我养成习惯以后只写while循环，当然了，这个看个人习惯。\nfor循环和while循环的区别不得不提到一个老生常谈的话题了，for循环和while训话有什么区别，用最简单的话来说\n\nfor循环更适合在已知循环次数的情况下使用\nwhile循环则更适合在循环次数不确定的情况下使用\n\n这里这例子我一时半会儿还真举不出来，但是，嘿嘿学到循环和条件了这题还会少吗？等Exercise出来的时候再讲吧。\n","slug":"Java-Learning-Week-3","date":"2023-09-25T08:09:43.000Z","categories_index":"","tags_index":"笔记,Java初学","author_index":"General_K1ng"},{"id":"359c9a1a9e0f8b70b5c766d3c5f40981","title":"Java_Exercise(Week 2)","content":"Exercise #2.1 What day is it?编写一个 Java 程序，将日期作为输入，并打印出该日期所在星期的哪一天。\n程序应使用三个整数：y（年）、m（月）和 d（日）。对于 m，1 月用 1，2 月用 2，以此类推。对于输出，周日打印 0，周一打印 1，周二打印 2，以此类推。\n使用以下公式：\n\n\n\n\n测试用例：\nTest case 1:\nInput:\n2018\n12\n24\nOutput: \nIt's day 1 !\n\n解决给出来的一些程序问题，毕竟我们不牵扯算法的问题，公式和算法都已经给你呈现了，我们要做的只是把公式翻译成Java语言就行了，只要看好输入输出的测试用例，然后注意一下公式的表达，基本上不会出什么问题。\n代码如下：\n\nClick to see more\nimport java.util.Scanner; //牵扯到输入，所以必须导入Scanner包\n\npublic class DateToDay {\n    public static void main(String[] args) { //main方法入口\n        Scanner sc = new Scanner(System.in); // 创建Scanner的对象\n        int y = sc.nextInt(); \n        int m = sc.nextInt();\n        int d = sc.nextInt(); //调用方法分别记录输入的y,m,d的值\n\n        int a = y - (14 - m) / 12; \n        int b = a + a/4 - a/100 + a/400;\n        int c = m + 12 * ((14 - m) /12) - 2; //分别将录入的值用a,b,c来记录，便于公式的表达\n\n        int day = (d + b + (31 * c) / 12) % 7; //带入公式\n\n        System.out.println(\"It's day \" + day + \" !\"); //控制台输出，注意输出时的空格\n    }\n}\n\n\n\nExercise #2.2 CMYK to RGB有几种不同的格式用于表示颜色。您可能知道 RGB 格式，它在 0 到 255 的整数范围内指定红色 (R)、绿色 (G) 和蓝色 (B) 的级别。还有一种格式叫 CMYK 格式，它规定了青色 (C)、洋红色 (M)、黄色 (Y) 和黑色 (K) 在 0.0 到 1.0 的实数范围内的级别。\n\n编写一个 Java 程序，使用以下公式将 CMYK 格式转换为 RGB 格式：白 = 1 - 黑红色 = 255 × 白色 × (1 - 青色)绿 = 255 × 白 × (1 - 洋红)蓝 = 255 × 白 × (1 - 黄)\n您的程序必须输入青色、洋红色、黄色和黑色这四个数字；计算相应的 RGB 值，每个值都四舍五入为最接近的整数；并按下面的测试用例打印 RGB 值：\nTest case 1:\nInput:  \n0.0\n0.0\n1.0\n0.0\nOutput: \nred = 255\ngreen = 255\nblue = 0\n\nTest case 2:\nInput:\n0.0\n1.0\n0.75\n0.50\nOutput:\nred = 128\ngreen = 0\nblue = 32\n\n\n\n这道题比上一道提升了一点难度，但是难度不大，还是重点在于搞清楚变量之间的关系，并且有一些小坑注意避免，所以这道题的代码分开写便于理解。\n\nClick to see more\n首先我们先分析题目吧，说白了，让你按照公式把几个值进行转换，然后打印输出，公式都给你了，那就直接照着公式打吧：\n首先我们先要键盘录入，然后再来接受键盘录入的值，分别是青色，洋红色，黄色和黑色。\nScanner sc = new Scanner(System.in); //创建Scanner的对象\ndouble cyan = sc.nextDouble();\ndouble magenta = sc.nextDouble();\ndouble yellow = sc.nextDouble();\ndouble black = sc.nextDouble(); //用double来接受录入的值\n\n然后我们再开始按照公式进行转换\ndouble white = 1 - black;\ndouble red = 255 * white * (1 - cyan);\ndouble green = 255 * white * (1 - magenta);\ndouble blue = 255 * white * (1 - yellow);\n\n照着公式打应该是不会打错的，比较容易出错的一步就是要打印输出，我们先写一下吧\nSystem.out.println(\"red = \" +  red);\nSystem.out.println(\"green = \" + green);\nSystem.out.println(\"blue = \" + blue);\n\n看上去好像没问题啊，那我们先拿第一个测试用例试一下\n输出如下：\nred = 255.0\ngreen = 255.0\nblue = 0.0\n\n看上去好像没问题对不对？但是其实是错的，其实看一下预期发现应该是整数类型而不是double，那这不简单嘛，那前两天刚学了基本数据类型的强转，那我们来强转一下一定行，hh\nSystem.out.println(\"red = \" +  (int)red);\nSystem.out.println(\"green = \" + (int)green);\nSystem.out.println(\"blue = \" + (int)blue);\n\n这样一定行了吧，第一个测试用例确实通过了，但是第二个呢？\n输出如下：\nred = 127\ngreen = 0\nblue = 31\n\n发现了吗，blue的要求应该是32，而这里却输出了31，为什么？因为基本数据类型的强转当中，double转int是向下取整，而测试用例需要我们向上取整，这下发现了吧，我们应该使用的是Math.round()方法。\n完整的代码应该是这样：\nimport java.util.Scanner;\n\npublic class CMYKtoRGB {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        double cyan = sc.nextDouble();\n        double magenta = sc.nextDouble();\n        double yellow = sc.nextDouble();\n        double black = sc.nextDouble();\n\n        double white = 1 - black;\n        double red = 255 * white * (1 - cyan);\n        double green = 255 * white * (1 - magenta);\n        double blue = 255 * white * (1 - yellow);\n\n        System.out.println(\"red = \" +  Math.round(red));\n        System.out.println(\"green = \" +  Math.round(green));\n        System.out.println(\"blue = \" +  Math.round(blue));\n\n\n    }\n}\n\n所以一定要看清测试用例，和明白问题关键在哪，学会自己分析问题。\n\n\nExercise #2.3 Great Circle Distance大圆距离是球面上两点和（x2,y2）之间最短路径的长度。\n计算公式如下。\n\n编写一个 Java 程序，输入四个复数 x1、y1、x2、y2，它们是地球表面两点的经度和纬度（以度为单位）；使用地球的平均半径 r = 6,371.0 千米；并打印出两点之间的大圆距离 dist（单位：千米）。\n请注意，输入的数字是以度为单位的，但 Java 的三角函数使用的是弧度。使用 Math.toRadians() 将度转换为弧度。\n测试用例如下：\nTest case 1:\nInput:\n80.0\n25.0\n155.0\n102.5\nOutput: \n7509.440708014122 kilometres\n\nTest case 2:\nInput:\n10.55\n39.33\n21.47\n-7.88\nOutput:\n5169.256612492542 kilometres\n\n这个题看着很吓人，但是其实还是最开始那句话，不要被题吓到，算法和公式不是我们需要考虑的问题，我们并不需要知道怎么才能用经纬度算出两点之间的距离，根本不需要数学和物理知识，你只需要如何把公式翻译成代码就好，程序员最最重要的一点就是要明白需求，而不是想别的。\n首先看到题目，肯定我们需要有键盘录入，其次接收的变量类型应该是double，再然后就是一个非常长的公式，仔细的打出来就好。\n\nClick to see more\n首先我们还是要先创建变量来接收键盘录入的值，分别有四个x1、y1、x2、y2，必须用double。\nScanner sc = new Scanner(System.in);\n\ndouble x1 = sc.nextDouble();\ndouble y1 = sc.nextDouble();\ndouble x2 = sc.nextDouble();\ndouble y2 = sc.nextDouble();\n\n然后必须要注意题目里面已经给你提醒了，我们Java程序用的是弧度制，我们的输入都是角度，必须用 Math.toRadians() 来进行转换，为了我的代码更加的简洁，优雅（如何写优雅的代码可以看上一章）我们可以这样写：\ndouble x1 = Math.toRadians(sc.nextDouble());\ndouble y1 = Math.toRadians(sc.nextDouble());\ndouble x2 = Math.toRadians(sc.nextDouble());\ndouble y2 = Math.toRadians(sc.nextDouble());\n\n我们把键盘录入的值直接传递给 Math.toRadians() 这个函数，然后这个函数返回的值直接赋值给我们的这四个变量，简洁，优雅。\n接着我们再定义一个变量r用来表示地球的半径\ndouble r = 6371.0\n\n然后就是枯燥又考验细心的公式环节，这个公式很长很长，注意不要输错了，括号要保持清楚，所以我建议是在每个运算符之间要进行空格，便于查看和debug。\ndouble dist = 2 * r * Math.asin(Math.sqrt(Math.sin((x2 - x1)/2) * Math.sin((x2 - x1)/2) + Math.cos(x1) * Math.cos(x2) * Math.sin((y2 - y1)/2) * Math.sin((y2 - y1)/2)));\n\n然后我们输出即可，完整代码如下：\nimport java.util.Scanner; //导包\n\npublic class GreatCircleDistance {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in); //新建对象\n\n        double x1 = Math.toRadians(sc.nextDouble());\n        double y1 = Math.toRadians(sc.nextDouble());\n        double x2 = Math.toRadians(sc.nextDouble());\n        double y2 = Math.toRadians(sc.nextDouble());//用变量接收转换为弧度的键盘录入的值\n\n        double r = 6371.0;//定义地球半径\n\n        double dist = 2 * r * Math.asin(Math.sqrt(Math.sin((x2 - x1)/2) * Math.sin((x2 - x1)/2) + Math.cos(x1) * Math.cos(x2) * Math.sin((y2 - y1)/2) * Math.sin((y2 - y1)/2))); //痛苦的公式\n\n        System.out.println(dist + \" kilometres\");//输出\n    }\n}\n\n不是很难。\n\n\nCW1 #2.1 Area of a Pentagon给定 r = 五角形中心到顶点的长度（实数），编写一个 Java 程序，计算五边形的面积。\n\n五边形面积的计算公式是其中，s 是边长，计算公式为测试用例：\nTest case 1:\nInput:\n2.5\nOutput: \nArea = 14.86025806711178\n\nTest case 2:\nInput:\n1.0\nOutput:\nArea = 2.377641290737884\n\n相比前面的这个感觉其实根本没什么难度，还是强调那句话，公式都有了，翻译就好。\n代码如下：\n\nClick to see more\nimport java.util.Scanner; //导包\n\npublic class AreaOfAPentagon {\n    public static void main(String[] args) { //主入口\n        Scanner sc = new Scanner(System.in); //新建对象\n\n        double r = sc.nextDouble(); //接收键盘录入\n        double s = 2 * r * Math.sin(Math.PI / 5); //带入公式\n\n        double area = (5 * s * s) / (4 * Math.tan(Math.PI / 5)); //带入公式\n\n        System.out.println(\"Area = \" + area); //输出\n    }\n}\n\n\n\n这次的作业感觉就是lab的一次强化练习吧。\n","slug":"Java-Exercise-Week2","date":"2023-09-22T08:43:31.000Z","categories_index":"","tags_index":"笔记,Java初学","author_index":"General_K1ng"},{"id":"4b98df5a945ea20ec148c80f048ac74c","title":"Java_Learning(Week2)","content":"变量是什么？变量是计算机编程中的一个基本概念，用于存储和表示数据。变量是程序中用来保存数据的一种标识符，它可以是数字、文本、对象或任何其他数据类型的值。通过给变量赋值，程序可以在运行过程中存储、操作和使用数据。\n数据类型在Java中，变量可以分为以下几种主要类型：\n\n原始数据类型（Primitive Data Types）： 用于存储单一的数值，例如整数、浮点数、字符和布尔值。Java的原始数据类型包括int、double、char、boolean等。\n引用数据类型（Reference Data Types）： 用于存储对象的引用。这些变量不直接存储对象的数据，而是存储对象在内存中的地址。Java的引用数据类型包括类（Class）、接口（Interface）、数组（Array）等。\n\n原始数据类型（Primitive Data Types）：\nbyte（字节）：\n大小：8位（1字节）\n范围：-128 到 127\n用途：通常用于节省内存，存储小整数值。\n\n\nshort（短整数）：\n大小：16位（2字节）\n范围：-32,768 到 32,767\n用途：存储中等范围的整数。\n\n\nint（整数）：\n大小：32位（4字节）\n范围：-2^31 到 2^31-1\n用途：存储整数值，是最常用的整数数据类型。\n\n\nlong（长整数）：\n大小：64位（8字节）\n范围：-2^63 到 2^63-1\n用途：用于存储大整数值，通常用于需要大范围整数的情况。\n\n\nfloat（浮点数）：\n大小：32位（4字节）\n用途：存储小数值，具有单精度，通常用于科学计算和工程计算中。\n\n\ndouble（双精度浮点数）：\n大小：64位（8字节）\n用途：存储小数值，具有双精度，通常用于大多数浮点数计算。\n\n\nchar（字符）：\n大小：16位（2字节）\n范围：0 到 65,535\n用途：存储单个字符，例如字母、数字或符号。\n\n\nboolean（布尔值）：\n大小：取决于实现\n只有两个值：true 和 false\n用途：表示真假值，通常用于条件判断。\n\n\n\n引用数据类型（Reference Data Types）：引用数据类型是指对象类型，它们不直接存储数据，而是存储对对象的引用。常见的引用数据类型包括类（Class）、接口（Interface）、数组（Array）等。这些类型的变量存储的是对象的引用地址，而不是对象的实际数据。\n变量的声明与初始化为什么要声明变量？为什么要声明变量呢？声明变量是为了告诉编译器变量的名称、类型和内存分配。在Java中，声明变量有以下重要原因：\n\n类型检查： 声明变量可以让编译器检查代码中的类型错误。如果你尝试将不兼容的数据类型赋给一个已声明的变量，编译器会直接报错。\n内存分配： 声明变量让编译器知道需要为该变量分配多少内存空间。这是因为不同数据类型需要不同大小的内存来存储。\n代码可读性： 变量声明可以提高代码的可读性。通过看变量名和类型，其他开发人员可以更容易地理解代码的用途和意图。\n作用域控制： 变量的声明还确定了变量的作用域，即在哪些部分的代码中可以访问该变量。作用域规则有助于防止变量被误用或滥用。\n\n在Java中，变量的声明通常包括变量名和类型，例如：\nint age; // 声明一个整数变量\ndouble salary; // 声明一个双精度浮点数变量\nString name; // 声明一个字符串变量\n\n在声明后，可以使用赋值语句将值分配给变量，这一步称为变量的初始化，例如：\nage = 30; // 将值30赋给age变量\nsalary = 50000.0; // 将值50000.0赋给salary变量\nname = \"Jin\"; // 将字符串\"Jin\"赋给name变量\n\n什么是变量的初始化？变量的初始化是指在声明变量的同时给它一个初始值。在Java中，可以选择性地在声明时初始化变量，也可以在稍后的代码中初始化。如果不初始化变量，它们将具有默认值，这取决于变量的数据类型。例如，int类型的变量默认初始化为0，boolean类型的变量默认初始化为false，Object类型的变量默认初始化为null。\n声明变量的要求\n变量名称规则： 变量的名称必须遵循一定的命名规则。变量名称可以包含字母、数字、下划线（_）和美元符号（$），但必须以字母、下划线或美元符号开头，不能以数字开头。变量名称区分大小写，即myVariable和myvariable是不同的变量名。\n关键字冲突： 变量名称不能与Java的关键字（保留字）相同。例如，不能使用关键字int作为变量名。\n合法标识符： 变量名称必须是合法的标识符。这意味着变量名称不能包含空格、特殊字符（如@、#、%等），也不能是Java中已经定义的类名、方法名等标识符。\n类型声明： 变量的声明必须包括其数据类型。数据类型确定了变量可以存储的数据种类和范围。例如，int、double、String等都是合法的数据类型。\n唯一性： 在同一个作用域内，变量名必须是唯一的。不能在同一作用域内声明两个同名的变量。\n声明语法： 变量的声明语法为：数据类型 变量名;。例如，int age;声明了一个整数类型的变量名为age。\n\n什么是包装类？课件当中还提到了一个难以理解的概念，就是包装类（Wrapper Class），如果目前无法理解其实无所谓，在后续的泛型部分应该会详细讲，这里我就提一下。\n在Java中，每种原始数据类型都有对应的包装类（Wrapper Class），用于将原始数据类型封装成对象。这些包装类提供了一些额外的功能，例如在集合类中存储原始数据类型的值，以及执行一些与对象相关的操作。以下是原始数据类型和其对应的包装类：\n\n\n\n\n\n\n\n\n\n对象的概念很重要，但是要理解也非常的抽象，需要长时间的感觉，所以我会在后面的笔记中渗透一些面向对象的内容，理解什么是对象，什么是面向对象。\n\n\n\n原始数据类型\n对应的包装类\n\n\n\nbyte\nByte\n\n\nshort\nShort\n\n\nint\nInteger\n\n\nlong\nLong\n\n\nfloat\nFloat\n\n\ndouble\nDouble\n\n\nchar\nCharacter\n\n\nboolean\nBoolean\n\n\n包装类的用处这一段我去找的资料，看个乐就行，反正现在看不懂非常正常。\n\n将原始数据类型转换为对象： 原始数据类型是基本的数据类型，不能直接用于面向对象编程（OOP）。包装类允许将原始数据类型封装成对象，从而可以在对象上执行各种操作。\n在集合中存储原始数据类型： Java集合（如ArrayList、HashMap等）只能存储对象，而不能存储原始数据类型。包装类使得可以将原始数据类型的值存储在集合中，因为它们都是对象。\n提供额外的功能和方法： 包装类提供了许多有用的方法，这些方法可以用于执行各种操作，如转换为字符串、比较、数学运算等。这些方法使得在处理数据时更加灵活和方便。\n处理空值（null）： 包装类可以存储null值，这在某些情况下非常有用，例如表示缺失数据或处理可能为null的情况。\n支持泛型（Generics）： 在泛型代码中，只能使用对象类型，而不是原始数据类型。包装类允许您在泛型类中使用原始数据类型的值。\n与其他API的兼容性： 某些Java API和库只接受对象作为参数，这时您需要使用包装类将原始数据类型封装成对象以便与这些API进行交互。\nJava反射： 反射是一种机制，可以在运行时检查和操作类的属性和方法。包装类使得可以通过反射机制来访问原始数据类型的信息和值。\n\n再强调一遍，看不懂无所谓的！\n如果让我用大白话来说，包装类无非是为了让Java当中的一些操作更加灵活和方便。\n类型转换在Java中，数据类型转换是将一个数据类型的值转换为另一个数据类型的过程。数据类型转换通常涉及到原始数据类型之间的转换以及对象之间的转换。Java中的数据类型转换可以分为两种类型：隐式转换（Implicit Conversion）和显式转换（Explicit Conversion）。\n隐式转换（Implicit Conversion）：隐式转换是自动进行的类型转换，不需要显式指定，通常发生在以下情况：\n\n小类型到大类型： 当将一个小范围的数据类型转换为一个大范围的数据类型时，会发生隐式转换。例如，将一个int赋值给long，或将一个float赋值给double。\n整数到浮点数： 当将整数类型转换为浮点数类型时，会发生隐式转换。例如，将int赋值给float。\n字面量常量转换： 在赋值常量字面量时，会进行隐式转换。例如，将整数字面量42赋值给long类型的变量。\n表达式中的类型提升： 在表达式中，如果包含多个操作数，它们的数据类型会自动提升到更大的数据类型，以便执行操作。这种提升也是隐式转换的一部分。\n\n隐式转换是安全的，因为它不会导致数据丢失。例如，将int转换为long不会导致数据精度损失。\n显式转换（Explicit Conversion）：显式转换需要通过强制类型转换操作符（cast）来明确指定。它通常用于以下情况：\n大类型到小类型： 当将一个大范围的数据类型转换为一个小范围的数据类型时，需要进行显式转换。这可能导致数据精度损失，因此需要程序员明确表示他们知道潜在的风险。例如，将double强制转换为int。\ndouble d = 3.14;\nint i = (int) d; // 显式转换，将double转换为int，会损失小数部分\n\n对象之间的转换： 当需要将一个对象从一种类转换为另一种类时，需要进行显式转换。这需要使用强制类型转换操作符，并确保类型之间存在继承关系或实现关系。\n// 显式将父类引用转换为子类引用\nParentClass parent = new ChildClass();\nChildClass child = (ChildClass) parent; // 显式转换\n\n字符到整数的转换： 当需要将字符类型（char）的字符表示为其对应的Unicode码点时，需要进行显式转换。\nchar c = 'A';\nint unicode = (int) c; // 显式转换，将字符'A'转换为Unicode码点65\n\n总结一下就是，显式转换别乱用，比较容易出错的，隐式转换JVM都帮你完成了，你只需要操点心就行。\n什么是转义符？看了看我们的课件，第一周的Lab和后面的一些练习当中就出现了转义符的相关知识，那就来了解一下好了。\n在计算机编程中，转义符是一种特殊字符，通常用来表示一些特殊的字符或控制字符序列。转义符以反斜杠符号（\\）开头，后跟一个或多个字符，用于表示不容易直接输入或显示的字符。转义符的主要目的是允许你在字符串或字符常量中插入特殊字符，或者执行某些控制操作。\n以下是一些常见的转义符及其用途：\n\n\\n： 表示换行符，用于在文本中创建新的一行。\n\\t： 表示制表符，用于在文本中创建水平制表符（通常用于缩进文本）。\n\\r： 表示回车符，用于将光标移到行的开头。\n\\b： 表示退格符，用于删除光标前的字符。\n\\f： 表示换页符，通常在控制打印机输出时使用。\n\\： 表示反斜杠自身，用于在字符串中插入反斜杠字符。\n‘： 表示单引号字符，用于在字符常量中插入单引号。\n“： 表示双引号字符，用于在字符串中插入双引号。\n\\uXXXX： 表示Unicode转义序列，其中XXXX是一个四位十六进制数，用于表示特定的Unicode字符。例如，\\u0041表示字符’A’。\n\n使用转义符可以在字符串中插入特殊字符，从而实现格式化文本、创建多行文本、处理特殊字符等目的。例如，要创建一个包含换行的多行字符串，可以使用\\n转义符，如下所示：\nString multiLineString = \"This is the first line.\\nThis is the second line.\";\nSystem.out.println(multiLineString);\n\n或者你要是想要在打印输出的时候输出双引号本身，你就可以在需要输出的双引号前加上\\。\npublic static void main(String[] args) {\n\t\tSystem.out.println(\"Hello world!\");\n        System.out.println(\"\\\"Hello world!\\\"\");\n    }\n\n最后就会输出\nHello world!\n\"Hello world!\"\n\n所以其实没啥重要的知识，忘了自己上网查就好。\n良好的编程习惯！这一部分非常的重要，好的习惯养成就是在最开始学习编程的时候养成的，不然后续很多的坏习惯可能会导致团队协作，项目开发，版本维护等等等问题，所以这一部分还是挺重要的。\n我们的最终的目的是可以编写优雅的代码，什么样子的代码可以称得上优雅？\n\n有意义的变量名： 变量名应该能清晰地表达变量的用途和含义。避免使用单个字母或无意义的缩写。例如，使用totalAmount而不是amt，使用customerName而不是cn。尤其是很多国人，千万不要用拼音来，其实拼音还好，最怕的是用拼音缩写，真的逆天，记住一定要让别人和你自己都能看懂，为什么说你自己呢？因为在编程当中有一句话：“刚写完的代码只有我和上帝看得懂，一周后，只有上帝看得懂。。。”如果养成了良好习惯，就能极大程度的避免这一点，并且后期工作一般是很多人来维护同一个项目，如果你的变量名很抽象，很容易导致团队合作的脱节。\n注释： 使用注释来解释代码的意图和关键部分，但不要过度注释。注释应该是清晰、简洁、易于理解的。及时更新注释以反映代码的变化。我平时最讨厌两种人，一种是让我加注释的，另一种是不让我加注释的XD。\n缩进和格式化： 使用一致的缩进和代码格式化规范，以增加代码的可读性。使用空格或制表符进行缩进，选择一种风格并保持一致。一定要缩进，一定要换行！不然问别人问题别人都不想给你看。\n函数和方法： 函数和方法应该短小而专注于单一任务。遵循单一职责原则（SRP）。使用有意义的函数名，并确保函数的命名与其功能一致。记住，一个函数或者方法只干一件事，实现功能的时候一定是越细化越好，现在可能看不出来，但是一旦到了大型项目，这样的好处就体现出来了，可以快速定位bug，快速针对功能进行更新，修改，删除。\n避免魔法数值： 避免在代码中直接使用未经解释的魔法数值。使用常量或枚举类型来表示这些数值，并为其命名以提高代码的可维护性。魔法数值就是直接把一个数字写到代码里面，这会非常的致命。\n异常处理： 始终处理可能引发异常的情况。不要忽略异常或简单地将其抛出。使用try-catch块或throws声明来处理异常。等我们学到异常之后就能理解了，现在可以先不用管。\n代码复用： 遵循”不要重复自己”（DRY）原则，将常用的代码块提取到函数、方法或类中以便复用。\n代码测试： 编写单元测试来验证代码的正确性。自动化测试可以帮助及早发现和修复问题。每次写完一个部分，或者一个小功能时候养成一个习惯针对这一部分写几个测试用例来验证一下，可以有效降低bug率。\n版本控制： 使用版本控制系统（如Git）来跟踪代码的历史记录和更改。提交代码前进行代码审查。\n命名约定： 遵循命名约定，例如Java中的驼峰命名法（camelCase），以及类名以大写字母开头等。\n文档化： 编写文档来描述项目、模块、函数和方法的用法和API。这有助于其他开发人员理解和使用你的代码。\n性能考虑： 在编写代码时考虑性能问题，但不要过度优化。只有在有明确性能问题时才进行优化。采访过一位大佬，代码的易读性&gt;代码的性能。\n安全性： 注意代码的安全性，避免常见的安全漏洞，如SQL注入、跨站脚本（XSS）等。\n错误处理： 考虑错误处理策略，包括日志记录和向用户提供有用的错误信息。\n持续学习： 不断学习新的编程技术和最佳实践，保持对编程世界的好奇心和进取心。\n\n","slug":"Java-Learning-week2","date":"2023-09-18T13:14:43.000Z","categories_index":"","tags_index":"笔记,Java初学","author_index":"General_K1ng"},{"id":"b6ddc4ee88d4afe7e2e1051d594b4d83","title":"Java_Learning(Week 1)","content":"整理CPT111这门课程（Java Programming）的一些笔记，从最简单的开始，不是简单的翻译，但是还是会以学校进程和教材为主。\n选择一个趁手的IDE在我们选择IDE前，容我先简单介绍一下什么是IDE，为什么我们需要IDE。\n什么是IDE？IDE是集成开发环境（Integrated Development Environment）的缩写。是一种软件应用程序，旨在帮助程序员编写、调试和管理他们的代码项目。IDE为开发者提供了一套工具和功能，使他们更轻松地进行软件开发工作。以下是IDE的一些主要特点和功能：\n\n代码编辑器：IDE包含一个文本编辑器，用于编写源代码。这个编辑器通常会提供语法高亮显示、自动完成、代码格式化等功能，以帮助程序员编写更高效和规范的代码。\n编译器和解释器：IDE集成了编译器（对于编译型语言）或解释器（对于解释型语言），可以将源代码转换为可执行的程序或直接执行代码。这使得程序员可以更轻松地检查代码的语法错误和逻辑错误。\n调试器：IDE通常包含一个强大的调试器，用于帮助程序员识别和修复代码中的错误。调试器允许程序员逐步执行代码、查看变量的值，并在运行时检测问题。\n项目管理工具：IDE允许程序员创建和管理代码项目。这包括创建、打开、保存和组织文件和文件夹，以及管理依赖项和库。\n版本控制集成：许多IDE集成了版本控制工具，如Git，以便程序员能够更轻松地跟踪和管理代码的版本历史。\n自动化构建工具：IDE通常包含自动构建工具，可以自动构建和部署代码项目，减少了手动操作的需求。\n代码分析工具：IDE可以提供代码分析和性能分析工具，帮助程序员识别潜在的性能瓶颈和代码质量问题。\n集成开发环境：IDE将上述所有功能整合在一个统一的界面中，使程序员能够在一个环境中进行所有开发活动，提高了工作效率。\n\n我们为什么需要IDE？总结两个字，方便！方便就完事了，理论上你完全可以用电脑自带的笔记本进行代码的书写，但是我相信没有人会这么干，趁手的IDE可以大幅度提升你的开发效率和开发质量，并且可以帮助你更好的后期维护和debug(虽然这往往和IDE没有多大关系)。\n安装IDEAIntelliJ IDEA（通常称为IDEA）是一款由JetBrains开发的强大集成开发环境（IDE），主要用于Java、Kotlin和其他编程语言的开发。它具有许多优点，如智能代码编辑、强大的代码导航、集成的构建工具、版本控制、调试器和丰富的插件生态系统等。下面是安装IntelliJ IDEA的详细步骤：\n安装IntelliJ IDEA：\n\n下载IntelliJ IDEA： 前往JetBrains官方网站（ https://www.jetbrains.com/idea/download/ ），  选择适用于您操作系统的版本（Windows、macOS、Linux）并下载Community Edition（免费版本）或Ultimate Edition（付费版本）。初学者完全使用社区版本完全就够用了，虽然我们学校提供了教育免费版，如果不嫌麻烦的话也可以。\n安装JDK： IntelliJ IDEA需要Java Development Kit (JDK) 才能运行。虽然目前我知道好像IDEA可以自己给你装JDK，并且有很完备的版本管理，非常方便。\n安装IntelliJ IDEA：\n在Windows上，运行下载的安装程序（.exe文件）并按照提示进行安装。\n在macOS上，将下载的IntelliJ IDEA文件拖到“应用程序”文件夹中。\n在Linux上，解压下载的文件并运行idea.sh脚本。\n\n\n启动IntelliJ IDEA： 打开安装好的IntelliJ IDEA应用程序。\n激活或注册：\n如果你选择Ultimate Edition，并且有有效的许可证，可以直接输入许可证信息激活。\n如果你选择Community Edition，它是免费的，无需激活。\n\n\n配置首选项： 在首次运行IDEA时，您可以根据您的偏好配置IDEA的外观、主题、插件等设置。\n\n一些基本的设置自己上网搜索，比如字体，主题之类的，这里不作详细介绍。\n为什么不用学校推荐的NetBeans?我觉得难用，就是这么简单，难用，而且后续很多的企业开发当中基本上公司配备的Java用的IDE都是IDEA，你也不想特立独行吧？（\n打出你的第一句Hello Word！为什么要打出Hello World？别问，问就是传统。\n创建新项目\n打开IntelliJ IDEA。\n在欢迎屏幕上，选择 “Create New Project”（创建新项目）。\n\n\n\n配置项目\n在 “Project name”（项目名称）字段中输入您的项目名称，例如 “CPT111”。\n在 “Project location”（项目位置）字段中选择您要保存项目的文件夹位置。\n选择JDK，没有JDK就用IDEA给你装一个，免去了复杂的环境配置。\n点击 “Finish”（完成）。\n\n创建后的界面如下：\n\n运行其实这个默认的Main方法就是最普通的HelloWorld了，对着这个代码直接右键运行就好。\n\n简单解释一下代码与非常简单的Python不同，Java的 Hello World 令人有些费解，但是不急，逐行分析一下\npublic class Main {\n    public static void main(String[] args) {\n\n        System.out.println(\"Hello world!\");\n    }\n}\n\n\npublic：这是一个访问修饰符，表示这个类是公共的，可以从其他类中访问。在Java中，类通常会被声明为public、private或protected，以控制其可见性。\nclass：这个关键词用于定义一个类。在Java中，所有的代码都必须位于类中，这是面向对象编程的基本概念。\nHelloWorld：这是类的名称，通常类名的第一个字母大写。类名必须与文件名相匹配，并且在Java中，每个程序都必须包含至少一个类，其中一个类必须包含一个main方法，作为程序的入口点。\n{ 和 }：这些大括号用于定义类的开始和结束，以及方法的开始和结束。在Java中，大括号用于组织代码块。\npublic static void main(String[] args)：这是一个特殊的方法，叫做main方法。它是Java程序的入口点，当程序运行时，会从main方法开始执行。让我们来解释main方法的各个部分：\npublic：同样是访问修饰符，表示main方法是公共的，可以从其他类中访问。\nstatic：这是一个关键词，表示main方法是静态的，可以在不创建类的实例的情况下调用。\nvoid：这是返回类型，表示main方法不返回任何值。\nmain：这是方法的名称，Java程序会从这里开始执行。\n(String[] args)：这是方法的参数列表。在这里，main方法接受一个字符串数组作为参数，通常用来接收命令行参数。\n\n\nSystem.out.println(\"Hello, World!\");：这是main方法中的一行代码，用于在控制台上打印文本消息。让我们分解这行代码：\nSystem：这是一个类，代表了Java的系统资源和标准输入/输出。\nout：这是System类的一个静态成员，代表标准输出流。\nprintln：这是一个方法，用于将文本输出到标准输出流，并在最后自动添加一个换行符。\n\"Hello, World!\"：这是要打印的文本消息，包含在双引号中。\n\n\n\n如果这上面的你都不能理解，也别急，你只要知道System.out.println(\"Hello world!\")这一句是输出就好，也就是打印。\n","slug":"Java-Learning","date":"2023-09-18T08:56:41.000Z","categories_index":"","tags_index":"笔记,Java初学","author_index":"General_K1ng"},{"id":"f742bd6c1e232d7ef58dbc0bfbd5e353","title":"核方法","content":"核方法（Kernel Methods）“Kernel methods”（核方法）是机器学习领域中一类重要的算法和技术，它们主要用于处理非线性问题和高维数据。核方法在分类、回归和聚类等任务中具有广泛的应用，并在支持向量机（Support Vector Machines，SVM）等算法中发挥着关键作用。\n线性可分 vs. 线性不可分在介绍核方法之前，让我们先了解一下线性可分和线性不可分的概念：\n\n线性可分：在一个二分类问题中，如果可以通过一条直线（在二维空间中）或一个超平面（在高维空间中）将两类样本完美地分开，那么我们称该问题是线性可分的。\n线性不可分：如果两类样本在特征空间中不能被一条直线或一个超平面完美地分开，那么我们称该问题是线性不可分的。\n\n在传统的机器学习中，对于线性可分的问题，我们可以使用线性分类器（如感知机、逻辑回归、线性SVM等）来解决，它们在处理线性问题上表现良好。但对于线性不可分的问题，传统的线性分类器就会遇到困难，因为它们无法在原始的特征空间中找到合适的线性边界。\n核方法的核心思想是通过一个数学技巧，将原始的特征空间映射到一个更高维度的特征空间，使得在新的高维空间中，数据在某种意义上变得线性可分。这个数学技巧就是所谓的“核函数”。\n核函数是一种特殊的函数，它可以计算在高维特征空间中两个样本之间的相似度。通过核函数，我们可以在不显式计算高维特征空间中的数据点的情况下，直接在原始的低维特征空间中进行计算，从而大大节省了计算资源。\n一旦我们得到了在高维特征空间中的相似度，我们可以使用线性分类器（如线性SVM）来找到一个超平面，将样本分开。在原始的低维特征空间中，这个超平面对应于一个非线性边界，从而实现了对线性不可分问题的有效处理。\n常用的核函数包括线性核、多项式核、高斯核（径向基核函数），它们分别对应着不同的映射函数。通过选择适当的核函数，我们可以将核方法应用于不同类型的数据，并取得良好的分类性能。\n特征图（Feature Maps）在机器学习和核方法的上下文中，**”特征地图”（Feature Map）**是一个重要的概念，它与核函数密切相关。\n在介绍特征地图之前，我们先回顾一下核方法的基本思想：核方法通过使用核函数将原始的低维特征空间映射到一个高维特征空间，使得数据在高维空间中可能是线性可分的，然后在高维空间中使用线性分类器来处理原始的非线性问题。\n特征地图是与核函数对应的映射函数。具体地说，核函数  可以计算原始特征空间中两个样本  和  在高维特征空间中的内积（或称为相似度），即 ，其中  是特征地图函数。\n换句话说，给定一个核函数 ，我们可以找到一个特征地图函数 ，使得 。这样，我们就可以通过核函数的计算结果来隐式地得到样本在高维特征空间中的内积，而无需直接计算映射后的高维特征。\n举例来说，如果我们使用高斯核函数（径向基核函数），其形式为 ，那么相应的特征地图函数就是 。在这里，样本在高维特征空间中的内积  可以通过计算核函数  得到，而无需直接计算  和 。\n特征地图的引入使得核方法具有高效处理高维特征空间的能力，因为我们无需显式地计算映射后的高维特征，而只需计算核函数的结果。这在处理复杂的非线性问题时非常有用，因为在高维空间中，数据可能更容易线性可分，从而提高了分类和回归等任务的性能。\n举例回顾我们关于线性回归的讨论，我们考虑了从房屋的居住面积（用表示）预测房屋价格（用表示）的问题，并且将一个的线性函数拟合到训练数据。但是，如果价格可以更准确地表示为的非线性函数呢？在这种情况下，我们需要比线性模型更具表现力的模型族。\n我们开始考虑拟合三次函数 。实际上，我们可以将这个三次函数视为另一组特征变量的线性函数（如下所定义）。具体地说，令函数  定义为：这个函数将输入  映射成一个包含四个新的数字的向量。我们可以看到，这些数字分别是  和 。所以，当我们把房屋面积  输入到函数  中，我们得到一个新的向量，比如对于某个具体的房屋面积 ，我们会得到 。\n现在让我们来理解为什么这组数字又把房屋面积问题转换成了线性问题。原始问题是要预测房屋价格 ，它与房屋面积  之间的关系可能是一个复杂的三次函数。但是，当我们使用特殊的函数  将房屋面积  映射成新的特征向量  时，我们得到了一个新的问题。\n新问题是：如何用参数向量  中的四个数字  来表示房屋价格与新特征向量  之间的关系？换句话说，我们想找到一个线性模型来拟合这组新的特征。\n这个新的问题是线性的，因为我们的目标是找到四个数字 ，使得房屋价格  可以通过  来近似表示。这里的  表示参数向量  的转置， 是特征向量。所以这就变成了一个线性模型：我们只需要找到合适的  来使得  与房屋价格  尽可能接近即可。\n让 表示包含  的向量。那么我们可以将  的三次函数重写为：其中  是新的特征变量。因此， 的三次函数可以视为基于  的线性函数。为了区分这两组变量，在核方法的背景下，我们将“原始”输入值称为问题的输入属性（在本例中是 ，即房屋面积）。当原始输入映射到一组新的量  时，我们将称这些新的量为特征变量。（不幸的是，不同的作者在不同的上下文中使用不同的术语来描述这两个概念。）我们称  为特征图，它将属性映射为特征。\n通过这样的方式，我们把原始的非线性问题转化成了一个线性问题，使得我们可以用线性模型来处理这个新的特征空间。线性问题比非线性问题更容易解决，我们可以使用已知的数学方法来找到最佳的 ，从而得到一个在新特征空间中表现良好的模型。\n这就是特征地图的精妙之处：通过将原始特征映射到一个新的高维特征空间，我们可以使用线性模型来处理复杂的非线性关系，从而提高了模型的表现能力。核方法通过隐式计算高维特征空间中的内积，进一步简化了计算过程，使得在高维空间中处理问题变得高效。\n带有特征的最小均方（LMS with features）什么是带有特征的最小均方？“LMS” 是 “最小均方误差”（Least Mean Squares）的缩写。它是一种经典的优化算法，通常用于机器学习中的参数估计和模型训练。在这个算法中，我们尝试通过最小化均方误差来调整模型的参数，从而使得模型在训练数据上更好地拟合。\n“LMS with features” 指的是在 LMS 算法中使用特征来进行参数估计和模型拟合的版本。特征是用来表示数据的属性或变量，在机器学习中，我们通常会用特征来描述样本的特点，从而帮助模型理解和预测数据。\n在 “LMS with features” 中，我们假设模型的输出（或目标值）是由一组特征和模型的参数进行线性组合得到的。例如，如果我们用  表示样本的特征， 表示模型的参数，那么模型的输出可以表示为 。而 “LMS with features” 的目标就是通过最小化预测值与真实值之间的均方误差，来找到最优的参数 ，从而使得模型在训练数据上拟合得更好。\n“LMS with features” 算法通常是迭代的，它会根据预测结果和真实结果之间的误差来更新模型的参数。在每一次迭代中，模型会根据当前参数预测输出，并计算预测值与真实值之间的差距。然后，根据这个差距，算法会通过一定的学习率来调整参数的值，使得预测结果逐渐趋近于真实结果。\n这种算法被广泛用于线性回归和神经网络等机器学习模型的训练过程中。通过使用特征来表示数据，LMS 可以根据数据的特点来调整模型的参数，从而更好地适应不同的问题和数据集。\n推导我们将推导出用于拟合模型 的梯度下降算法。首先回忆一下，对于普通的最小二乘问题，我们要拟合 ，批量梯度下降的更新公式为（参见第一节课笔记以获取其推导）：在这里，每个变量的含义如下：\n\n 是我们要优化的参数向量，它用来拟合模型 。\n 是第  个训练样本的特征向量。\n 是第  个训练样本的真实标签或目标值。\n 是模型的预测值，即 。\n\n接下来，我们引入一个特征映射 ，它将属性 （在  中）映射到特征 （在  中）。这样，我们的目标就是拟合函数 ，其中  是  中的向量，而不是 。\n为了在特征映射下进行参数更新，我们将算法中所有出现的  替换为 ，得到新的参数更新公式：在这个公式中，每个变量的含义如下：\n\n 是我们要优化的参数向量，它用来拟合模型 。\n 是第  个训练样本在特征映射下的特征向量。\n 是第  个训练样本的真实标签或目标值。\n 是模型的预测值。\n\n这个新的更新公式可以用于梯度下降算法中的每一步迭代，以更新参数 ，从而逐渐使模型在训练数据上拟合得更好。特别地，如果我们使用随机梯度下降算法，即每次只用一个样本进行更新，更新规则变为：这样我们就得到了用于拟合模型  的梯度下降算法。这个算法在机器学习中非常常用，特别是在支持向量机（SVM）等模型中，它们使用了核方法和特征映射来处理非线性问题。\n举例当我们想预测房价时，最初使用了简单的线性模型 ，其中  是房屋的居住面积， 是房价， 和  是需要学习的参数。但有时候，房价可能不仅仅与面积成线性关系，可能是一种曲线或弯曲的关系，比如更大的房屋不仅仅是线性地增长更贵，可能有更多的因素在影响房价。所以我们需要更灵活的模型来适应这种复杂的关系。\n这时候，我们可以考虑使用一个三次函数来预测房价，就像  这样的函数。但是，我们仍然希望能够使用梯度下降这样的优化算法来找到最优的参数 。\n现在问题是，我们之前的梯度下降算法是针对线性模型设计的，而现在我们的模型是三次函数。这时，我们可以通过一个特殊的函数 ，将原来的房屋面积  映射成一个新的向量 ，我们把这个向量当做新的特征来处理。这样，我们的模型变成了 ，这就是一个线性模型！\n通过这个巧妙的映射，我们把原本的非线性问题转换成了线性问题。现在我们可以使用梯度下降算法来学习参数 ，使得预测的房价  尽可能接近真实的房价 。\n更新参数的公式为：在这里， 是我们需要学习的参数向量， 是一个房屋的面积特征， 是这个房屋的真实价格。 是学习率，它控制我们在每次更新中改变参数的步长。\n通过反复迭代这个更新过程，我们的模型会逐渐学到最优的参数 ，从而能够更好地拟合房价数据。这就是梯度下降算法的一个简单应用，通过特征映射的方式，我们可以在复杂的问题中使用线性模型来得到更好的预测结果。\n","slug":"Kernel-methods","date":"2023-07-29T07:55:10.000Z","categories_index":"","tags_index":"Machine Learning,笔记","author_index":"General_K1ng"},{"id":"8dcfbd65ba007c0c6564bd13d62b9cd1","title":"文本分类的事件模型","content":"文本分类的多项式事件模型在文本分类中，我们有一个专门的模型叫做多项式事件模型，它在处理文本分类问题时表现较好。这个模型与我们之前介绍的朴素贝叶斯有些相似，但也有一些不同之处。\n问题描述我们要解决的问题是对电子邮件进行分类，判断其是垃圾邮件还是正常邮件。对于一封电子邮件，我们可以将其表示为由单词组成的向量 ，其中  是第  个单词在词汇表中的标识， 是邮件中的单词总数。\n伯努利事件模型 vs. 多项式事件模型在文本分类的特定情境中，朴素贝叶斯的形式使用了所谓的伯努利事件模型（有时称为多变量伯努利事件模型）。在这个模型中，我们假设生成一封电子邮件的方式是：首先根据类先验概率  随机确定下一封邮件是垃圾邮件还是正常邮件。然后，发送电子邮件的人遍历字典，独立地根据概率  决定是否在邮件中包含每个单词 。因此，一封邮件的概率由  给出。\n这里介绍了另一种模型，称为多项式事件模型（Multinomial event model）。为了描述这个模型，我们将使用不同的符号和特征来表示电子邮件。我们用  表示邮件中第  个单词的标识。因此， 现在是一个取值范围为  的整数，其中  是我们词汇表（字典）的大小。一封由  个单词组成的电子邮件现在用长度为  的向量  来表示；请注意，不同文档的  可以不同。例如，如果一封电子邮件以 “A NeurIPS…” 开头，则 （“a”是字典中的第一个单词），（如果“neurips”是字典中的第35000个单词）。\n多项式事件模型的生成过程在多项式事件模型中，生成一封邮件的过程是这样的：\n\n根据类别先验概率  随机确定邮件是垃圾邮件还是正常邮件。\n通过从多项式分布  生成第一个单词 。\n然后，第二个单词  独立于 ，但仍从相同的多项式分布中生成。\n依此类推，直到生成所有  个单词的邮件。\n\n详细来说，首先根据  决定是否为垃圾邮件或非垃圾邮件，与之前相同。然后，邮件的发送者通过从某个多项式分布（）生成  来撰写邮件。接下来，第二个单词  独立于  但是从相同的多项式分布中选择，对于 、 等等，都是相同的过程，直到生成邮件的所有  个单词。因此，整体的邮件概率由  给出。请注意，这个公式看起来类似于之前在伯努利事件模型下给出的邮件概率公式，但公式中的术语现在具有非常不同的含义。特别地， 现在是一个多项式分布，而不是伯努利分布。\n我们新模型的参数与之前一样：、（对于任意 ）和。请注意，我们假设对于所有  的值，是相同的（即生成一个单词的分布不依赖于其在邮件中的位置 ）。\n参数估计我们的目标是通过训练集  来估计模型的参数。对于多项式事件模型，参数包括先验概率  和条件概率 。\n为了估计这些参数，我们最大化似然函数 。其中， 是类别先验概率， 和  分别是给定类别的条件概率。使用拉普拉斯平滑来获得更好的性能，参数估计公式如下：\n类别先验概率：垃圾邮件样本数总样本数\n条件概率：在垃圾邮件中出现的第个单词的样本数垃圾邮件中的单词总数在正常邮件中出现的第个单词的样本数正常邮件中的单词总数\n如果我们有一个训练集 ，其中  （这里， 是第  个训练样本中的单词数），数据的似然函数可以表示为：通过最大化这个似然函数，我们可以得到参数的最大似然估计：如果我们在估计和时应用拉普拉斯平滑（在实践中需要以获得良好的性能），我们将在分子中加1，在分母中加上，从而得到：\n朴素贝叶斯分类器尽管朴素贝叶斯分类器不一定是最优的分类算法，但由于其简单性和易于实现，通常在文本分类问题中表现出令人惊讶的良好效果。因此，它经常作为首选尝试的算法之一。\n通过以上的多项式事件模型和参数估计，我们可以构建一个朴素贝叶斯分类器，用于文本分类任务。希望这样的改写能够让您更好地理解文本分类问题及其相关模型。如果还有其他问题或需要进一步解释，请随时问我！\n","slug":"Event-models-for-text-classification","date":"2023-07-29T06:54:26.000Z","categories_index":"","tags_index":"Machine Learning,笔记","author_index":"General_K1ng"},{"id":"8b18e271b14b3d6ddbc293dffc4eb5b3","title":"拉普拉斯平滑","content":"解决稀疏数据问题：拉普拉斯平滑当我们用机器学习构建垃圾邮件过滤器时，朴素贝叶斯算法是一个强大的工具。然而，在实践中应用该算法时，我们可能会遇到一个小问题，那就是稀疏数据问题。\n稀疏数据问题是什么？稀疏数据问题出现在我们有大量特征，但某些特征在训练集中很少出现，甚至有些特征在某类邮件中根本没有出现。这就像探险家在茫茫大草原上追踪狼群，但是草原上的脚印却非常零散，有些地方甚至一点踪迹都没有。\n解决方案：拉普拉斯平滑为了解决这个问题，我们引入了拉普拉斯平滑（Laplace Smoothing）。这就像是在草原上找到了一种神奇的踪迹增强剂，让我们能够更好地跟踪狼群一样！\n在朴素贝叶斯算法中，我们需要估计特征在某个类别下的条件概率。在稀疏数据情况下，有些特征在训练集中可能没有出现，导致概率估计为零。为了避免这种情况，我们采用拉普拉斯平滑来平滑概率估计。\n改进朴素贝叶斯算法尽管朴素贝叶斯算法在许多问题上表现不错，但在某些特定情况下，特别是在文本分类任务中，它可能面临一些问题。让我们简要讨论当前形式下算法存在的问题，并探讨如何通过一种简单的改进来提高其性能。\n问题：稀疏数据假设我们在进行垃圾邮件/电子邮件分类问题，并且要使用朴素贝叶斯算法来进行分类。在假设情景中，你完成了CS229课程并在项目中取得优秀成绩，决定在20xx年5月20日前将你的工作提交给NeurIPS学术会议进行发表。由于你在邮件中讨论了该学术会议，你开始收到带有“neurips”一词的消息。但这是你的第一篇NeurIPS论文，直到此时为止，你之前没有收到过包含“neurips”一词的邮件；尤其是“neurips”一词从未出现在你的垃圾邮件/非垃圾邮件训练集中。假设“neurips”是词典中的第35000个单词，那么你的朴素贝叶斯垃圾邮件过滤器因此选择了参数φ_{35000|y}的最大似然估计为：这意味着因为在垃圾邮件或非垃圾邮件的训练示例中从未见过“neurips”，它认为在任何一类邮件中看到该单词的概率都是零。因此，当尝试判断一个包含“neurips”的消息是否为垃圾邮件时，它计算了类别的后验概率，并得到：这是因为每个术语“”都包含一个的项，这个项被乘到其中。因此，我们的算法得到了的结果，并且无法进行预测。\n更广泛地说，因为在有限的训练集中没有见过某个事件，将其概率估计为零是一个统计上不好的做法。考虑对取值在的多项式随机变量的均值进行估计的问题。我们可以用来参数化我们的多项式分布。给定一组独立的观测值，最大似然估计为：\n解决方案：拉普拉斯平滑如上所述，如果我们使用这些最大似然估计，一些的值可能为零，这是个问题。为了避免这种情况，我们可以采用拉普拉斯平滑，用以下估计代替：在这里，是特征可能的取值个数，是训练样本总数。\n在这里，我们在分子上加了，在分母上加了。请注意，仍然成立（请自行验证！），这是一个希望得到的性质，因为是我们知道必须总和为的概率的估计值。而且，对于所有的值，不等于，解决了概率被估计为零的问题。在某些（可以说相当强的）条件下，可以证明拉普拉斯平滑实际上给出了的最优估计器。\n拉普拉斯平滑的优点是对所有特征都给予了一个非零的概率估计，避免了概率为零的问题。这样，即使某个特征在训练集中没有出现，它仍然有一个较小但非零的概率估计，不会影响到后续的概率计算。\n考虑回到我们的朴素贝叶斯分类器，并应用拉普拉斯平滑，我们可以得到以下参数的估计值：请注意，对于是否应用拉普拉斯平滑通常并不重要，因为我们通常会有相当数量的垃圾邮件和非垃圾邮件，所以将是的一个合理估计值，并且通常会远离0。\n通过拉普拉斯平滑，我们能够更好地解决稀疏数据问题，并使得朴素贝叶斯算法在文本分类等任务中表现得更加优秀。\n","slug":"Laplace-smoothing","date":"2023-07-29T06:21:21.000Z","categories_index":"","tags_index":"Machine Learning,笔记","author_index":"General_K1ng"},{"id":"060cf84ea8728915ecf4c659557a0907","title":"朴素贝叶斯","content":"机器学习中的文本分类在GDA中，特征向量是连续的实值向量。现在我们来讨论另一种学习算法，其中是离散值。\n在机器学习中，我们经常遇到特征是离散值的情况，这里我们来讨论这种情况。举个例子，我们打算用机器学习构建一个电子邮件垃圾邮件过滤器。这个过滤器的任务是判断一封电子邮件是否是垃圾邮件，然后自动将其过滤到专门的垃圾邮件文件夹里。这个问题属于文本分类的范畴，而文本分类又是一个更大问题集的一部分。\n特征表示方式我们假设我们有一个训练集（一组被标记为垃圾邮件或非垃圾邮件的电子邮件）。我们将通过指定用于表示邮件的特征  来构建我们的垃圾邮件过滤器。\n我们将通过一个特征向量来表示一封电子邮件，其长度等于字典中的单词数。具体地，如果一封电子邮件包含字典中的第  个单词，则我们将设置 ；否则，我们设置 。例如，向量表示的一封电子邮件可能如下所示：该特征向量用于表示包含单词“a”和“buy”，但不包含“aardvark”，“aardwolf”或“zygmurgy”的电子邮件。所编码到特征向量的单词集合称为词汇表，因此特征向量 x 的维度等于词汇表的大小。例如，如果词汇表包含1000个单词，那么特征向量  的维度将是1000。在这种表示下，我们可以通过特征向量来表示每封电子邮件中包含哪些特定的单词。\n\n\n\n\n\n\n\n\n\n在实际应用中，我们通常不会查阅完整的英语字典来获取所有可能的单词列表。而是根据训练集来确定特征向量中的单词。通常只将在训练集中至少出现一次的单词加入特征向量。这样可以减少建模所需的单词数量，降低计算和空间需求。此外，一些高频的“内容无关”单词（如 “the”, “of”, *”and”*）也会被排除，因为它们对判断电子邮件是否是垃圾邮件没有太大帮助。这些高频单词被称为停用词（stop words）。\n朴素贝叶斯分类器现在我们需要构建一个生成模型来对条件概率  建模。但如果我们的词汇表有50000个单词，那么特征向量 ，也就是一个由0和1组成的50000维向量。如果我们想用多项式分布来显式建模 ，那么可能的结果有个，参数数量将非常庞大。\n为了简化建模，我们做出了一个非常强的假设，称为朴素贝叶斯（Naive Bayes）假设。假设在给定  的条件下，所有的  是条件独立的。这样，我们得到了朴素贝叶斯分类器。举个例子，如果  表示垃圾邮件；”buy” 对应单词编号2087，而”price” 对应单词编号39831。那么我们假设在已知 （某封电子邮件是垃圾邮件）的情况下，是否知道 （是否包含”buy”）对于判断 （是否包含”price”）是无关的。更形式化地，我们可以写成 。（注意，这不是说  和  是独立的，而是说在给定  的条件下， 和  是条件独立的。）\n我们现在有：第一个等式是概率的一般性质，而第二个等式就是由朴素贝叶斯假设得到的结果。尽管朴素贝叶斯假设非常强，但由此产生的算法在很多问题上表现良好。\n参数化和最大似然估计在朴素贝叶斯算法中，我们使用一些参数来表示模型。这些参数是 ， 和 。它们的解释非常简单： 表示在垃圾邮件（）中，包含单词  的比例。\n通过给定的训练集 ，我们可以写出数据的联合似然：为了估计参数 ， 和 ，我们使用最大似然估计。也就是找到使得联合似然函数最大化的参数值。\n具体地，我们可以通过如下公式来计算参数的最大似然估计值：在上面的方程中，符号“∧”表示“与”。这些参数有一个非常自然的解释。例如，只是垃圾邮件（）中包含单词的比例。\n预测新样本的类别在拟合好这些参数后，我们可以用来预测新样本的类别。假设我们有一个新样本的特征表示 ，我们希望判断它是垃圾邮件还是非垃圾邮件（还是）。\n我们可以简单地计算后验概率来进行预测：然后，我们选择具有较高后验概率的类别作为预测结果。\n处理更多离散值的情况最后，我们指出，虽然我们主要针对特征是二元值的问题开发了朴素贝叶斯算法，但对可以在，，，中取值的情况，其推广是简单的。在这种情况下，我们只需将建模为多项式而不是伯努利分布。实际上，即使某些原始输入属性（例如我们之前的例子中的房屋生活面积）是连续值的，将其离散化（即将其转换为一组小的离散值）并应用朴素贝叶斯也是相当常见的。例如，如果我们使用某个特征来表示生活面积，我们可以将连续值离散化如下：\n\n\n\nLiving area (sq. feet)\n&lt; 400\n400-800\n800-1200\n1200-1600\n&gt;1600\n\n\n\n\n1\n2\n3\n4\n5\n\n\n因此，对于一所生活面积为890平方英尺的房屋，我们将相应特征的值设置为3。然后，我们可以应用朴素贝叶斯算法，用多项式分布来建模，就像之前所描述的那样。当原始的连续值属性不适合用多元正态分布建模时，将特征进行离散化并使用朴素贝叶斯（而不是GDA）通常会得到更好的分类器。\n","slug":"Naive-bayes","date":"2023-07-24T07:28:32.000Z","categories_index":"","tags_index":"Machine Learning,笔记","author_index":"General_K1ng"},{"id":"68643f4a3340f18395afd7c596807d57","title":"高斯判别分析","content":"高斯判别分析（GDA）让我们来讨论生成学习算法中的一个重要模型——高斯判别分析（Gaussian Discriminant Analysis，简称 GDA）。在这个模型中，我们假设数据的条件概率  符合多元正态分布。在深入探讨 GDA 模型之前，我们先简要介绍一下多元正态分布的性质。\n多元正态分布在  维空间中的多元正态分布，也被称为多元高斯分布，由均值向量  和协方差矩阵  参数化，其中  是对称且半正定的。我们用  来表示这个分布，其概率密度函数如下所示：在上面的方程中，“”表示矩阵的行列式。\n对于服从  分布的随机变量 ，其均值是 ，这并不令人意外：对于一个向量值随机变量 ，协方差定义为 ，这推广了实值随机变量的方差概念。协方差也可以定义为 。（你应该能够自行证明这两个定义是等价的。）如果 ，那么：以下是一些高斯分布密度函数的示例：\n\n\n最左边的图显示的是均值为零（即2x1的零向量）且协方差矩阵（2x2的单位矩阵）的高斯分布。这个分布也被称为标准正态分布。\n中间的图显示的是均值为零且的高斯分布。\n最右边的图显示的是均值为零且的高斯分布。我们可以观察到，随着变得更大，高斯分布变得更加“扩展”，而随着变得更小，分布则变得更“压缩”。\n\n让我们看更多的例子：\n\n上面的图显示了均值为0的高斯分布，并分别显示了它们的协方差矩阵：左侧的图显示了熟悉的标准正态分布，我们可以看到随着协方差矩阵中的非对角元素增加，密度趋向于线（由给出）。当我们查看同样三个密度的等高线图时，这一点更加清晰：\n\n以下是通过变化生成的另一组示例：\n\n上面使用的图分别是:从左边和中间的图中，我们可以看到通过减小协方差矩阵的非对角元素，密度再次变得“压缩”，但是方向相反。最后，当我们更一般地改变参数时，等高线将形成椭圆（右边的图显示了一个例子）。\n作为我们最后的一组例子，我们固定，通过改变，我们可以将密度的均值移动到不同的位置。\n\n上面的数字是使用生成的，分别是\n高斯判别分析模型当我们面对一个分类问题，其中输入特征是连续值随机变量时，我们可以使用高斯判别分析（Gaussian Discriminant Analysis，GDA）模型，它使用多元正态分布来建模。该模型为：写出分布，这是：在这里，我们的模型参数是、、和。（请注意，尽管有两个不同的均值向量和，但通常使用一个协方差矩阵来应用该模型。）数据的对数似然是由以下公式给出：通过对参数最大化，我们可以找到参数的最大似然估计：从图示上看，该算法的过程如下所示：\n\n在图中显示了训练集，以及对每个类别中的数据进行拟合的两个高斯分布的等高线。注意，这两个高斯分布的等高线具有相同的形状和方向，因为它们共享协方差矩阵，但它们具有不同的均值和。图中还显示了给出决策边界的直线，该边界使得。在边界的一侧，我们将预测是最可能的结果，而在另一侧，我们将预测。\n讨论：GDA和逻辑回归GDA模型与逻辑回归之间有着有趣的关系。事实上，如果我们将  看作是  的函数，我们会发现它可以写成以下形式：\n在这里， 是 、、 和  的一些合适函数。这恰好是逻辑回归——一个判别算法——用来建模  的形式。\n\n\n\n\n\n\n\n\n\n这里使用了重新定义右侧的  的约定，通过添加额外的坐标 ，将它们变成  维向量\n那么我们什么时候更喜欢一种模型而不是另一种模型呢？一般来说，当在同一数据集上训练时，GDA和逻辑回归会给出不同的决策边界。那么哪个模型更好呢？\n我们刚刚证明了如果  是多元高斯分布（具有共享的 ），那么  必定遵循一个逻辑函数。然而，反过来并不成立；即  是一个逻辑函数并不意味着  是多元高斯分布。这表明GDA对数据做出了比逻辑回归更强的建模假设。事实上，当这些建模假设正确时，GDA将对数据拟合得更好，是一个更优的模型。特别地，当  确实是高斯分布（具有共享的 ）时，GDA是渐近有效的。简单来说，这意味着在非常大的训练集（大 n）的极限情况下，没有比GDA更好的算法（例如在准确估计  方面）。特别地，可以证明在这种情况下，GDA将优于逻辑回归；而更一般地说，即使对于较小的训练集大小，我们通常也会预期GDA更优。\n相比之下，逻辑回归通过做出明显较弱的假设，更加健壮且对错误的建模假设不太敏感。有许多不同的假设集会导致  采取逻辑函数的形式。例如，如果 ，并且 ，那么  将是逻辑函数。在这样的泊松分布数据上，逻辑回归也会表现良好。但是，如果我们在这样的数据上使用GDA，并将高斯分布拟合到这样的非高斯分布数据上，结果将变得不那么可预测，GDA可能（或者可能不会）表现良好。\n总结起来：GDA做出了更强的建模假设，在建模假设正确或近似正确的情况下更具数据效率（即需要较少的训练数据来学习得更好）。逻辑回归做出了较弱的假设，对于与建模假设的偏差更具有鲁棒性。具体而言，当数据确实是非高斯分布时，在大规模数据集的极限情况下，逻辑回归几乎总是比GDA表现更好。因此，在实践中，逻辑回归比GDA更常用。（我们接下来讨论的朴素贝叶斯算法也涉及有关判别模型与生成模型的类似考虑，但朴素贝叶斯算法仍被认为是一种非常优秀且广受欢迎的分类算法。）\n","slug":"Gaussian-discriminant-analysis","date":"2023-07-22T06:04:23.000Z","categories_index":"","tags_index":"Machine Learning,笔记","author_index":"General_K1ng"},{"id":"6e9ecff97c79fc9b7ee5419e3db98187","title":"生成式学习算法","content":"生成式学习算法：从动物外貌特征到分类预测到目前为止，我们已经讨论了一些学习算法，这些算法主要关注于建模条件分布 ，也就是在给定输入  的情况下输出  的概率分布。例如，逻辑回归使用  来建模 ，其中  是 sigmoid 函数。在这次笔记中，我们将探讨一种不同类型的学习算法。\n判别式学习算法在考虑一个分类问题时，我们希望根据动物的一些特征来学习如何区分大象 (y = 1) 和狗 (y = 0)。判别式学习算法，例如逻辑回归或感知机算法，试图找到一条直线，即决策边界，来将大象和狗分开。然后，为了对新的动物进行分类，算法会检查它在决策边界的哪一侧，并根据结果进行预测。\n生成式学习算法：全新的方法现在，我们来探讨一种全新的学习方法。首先，我们可以构建一个描述大象外貌特征的模型。然后，我们可以构建一个独立的描述狗外貌特征的模型。最后，当我们需要对一个新的动物进行分类时，我们可以将其与大象模型进行匹配，并将其与狗模型进行匹配，从而确定新动物更像我们在训练集中见过的大象还是更像狗。\n生成式学习算法 vs. 判别式学习算法刚才我们提到的直接学习  的算法（例如逻辑回归）或者直接学习从输入空间  到标签 {0, 1} 的映射（例如感知机算法），都属于判别式学习算法。而在这里，我们将讨论一类试图对条件概率 （以及类先验 ）进行建模的算法，这些算法被称为生成式学习算法。例如，对于一个表示示例是狗（0）还是大象（1）的问题， 建模了狗的特征分布，而  建模了大象的特征分布。\n从条件概率到后验概率在建模了  （称为类先验）和条件概率  之后，我们的算法可以使用贝叶斯规则来推导给定  的后验概率 ：这里，分母  由  给出（您应该能够从概率的标准性质验证这一点），因此也可以用我们已经学到的  和  的数量来表示。实际上，如果我们正在计算  以进行预测，那么我们实际上不需要计算分母，因为分母  只是用于归一化 ，以确保其概率总和为1。但由于我们只关心预测的类别，而不是具体的概率值，我们可以忽略归一化项，直接计算分子部分来得到预测的类别。\n","slug":"Generative-learning-algorithms","date":"2023-07-22T05:45:25.000Z","categories_index":"","tags_index":"Machine Learning,笔记","author_index":"General_K1ng"},{"id":"944f20daa7bfde2d1440fd8c10bf6bf0","title":"（实战）鸢尾花数据集的三分类","content":"上一章的难度相比各位估计应该也是云里雾里吧，那么这一章就来实战一下如何运用softmax回归来进行多分类吧！刚好顺便来弥补一下之前我们在对鸢尾花进行分类的时候只运用了二分类的遗憾，今天，我们就直接开始，三分类！\nSoftmax回归概念回顾首先我们先回顾一下什么是Softmax回归，它是一种用于多分类问题的分类算法，也称为多类别逻辑回归或多项逻辑回归。Softmax回归广泛用于机器学习和深度学习中，尤其在图像识别、自然语言处理和语音识别等任务上。\n简单来说，softmax回归将输入的样本通过线性变换和一个softmax函数映射为类别的概率分布。它主要包含两个步骤：\n\n线性变换：对于给定的输入样本，首先通过一个线性变换计算每个类别的得分。这个得分可以看作是输入样本属于每个类别的权重。\nSoftmax函数：然后，将得分通过softmax函数转换为概率分布。Softmax函数可以将原始得分转换为非负且和为1的概率值，这样可以表示每个类别的概率。\n\n假设我们有n个类别，对于第i个类别，它的得分为。那么Softmax函数的计算如下：其中，是指数函数，是求和函数。\n最终，输入样本属于第i个类别的概率为。可以选择概率最高的类别作为预测结果。\n在训练过程中，通常使用交叉熵损失函数来衡量预测结果和真实标签之间的差异，并通过梯度下降等优化算法来更新模型的参数，使得预测结果更接近真实情况。\n好像还是有些难懂，那再用人话来说一遍吧。\n人话版本1. 什么是分类问题？\n首先，什么是分类问题。在机器学习中，分类问题是指将事物分为不同的类别。比如，我们可以将动物分为猫、狗和鸟三个类别，或者将邮件分为垃圾邮件和非垃圾邮件两个类别。\n2. 什么是Softmax回归？\n它是一种机器学习算法，用于解决分类问题。假设我们有很多特征，比如动物的体重、体长和年龄，我们想要根据这些特征把动物分成不同的类别，比如猫、狗和鸟。Softmax回归可以帮助我们做这件事。\n3. 如何工作？\nSoftmax回归的工作方式有两个关键步骤：\n步骤一：计算得分\n对于给定的一个动物，我们会用一些数学计算得到它属于每个类别的得分。这个得分可以理解为，每个类别有多大的可能性与这个动物匹配。\n步骤二：转换为概率\n有了得分后，我们需要将它们转换成概率。概率是一个介于0到1之间的数值，表示某个动物属于某个类别的可能性有多大。Softmax回归使用一个特殊的函数，称为softmax函数，来做这个转换。它会把得分转换成概率，确保所有类别的概率加起来等于1。\n4. 如何做预测？\n在训练阶段，我们会用一堆已知类别的动物数据来让机器学习算法学习。它会通过调整一些参数来找到最佳的方式来预测动物的类别。\n然后，在预测阶段，当我们有一个新的动物数据时，我们会用训练好的模型，通过同样的计算和转换过程，得到动物属于每个类别的概率。最后，我们会选择概率最高的类别作为预测结果，就像猫、狗和鸟中选择概率最高的那个类别。\n怎么计算得分假设我们有一个分类问题，有个类别需要进行分类。对于给定的输入样本，我们会为每个类别分配一个得分（也称为logit），表示输入样本属于该类别的可能性大小。\n对于第个类别，得分的计算是通过将输入样本的特征与相应的权重进行线性组合得到的。假设输入样本有个特征（即特征向量的长度为），则该类别的得分可以表示为：其中， 是与每个特征相关联的权重， 是输入样本的特征值， 是偏置项（也称为截距项）。\n对于输入样本，我们需要为每个类别计算一个得分。\n怎么转换成概率得到每个类别的得分后，我们需要将它们转换为概率，以便进行分类。\n我们使用softmax函数来执行这个转换。对于第个类别的得分，它在Softmax函数中的概率表示为：其中，是指数函数，它会将得分转换为非负数。是求和函数，对所有类别的得分进行求和。\n通过这个计算，我们可以获得每个类别的概率。这些概率的和总是等于1，因为softmax函数的特性保证了这一点。\n最后，在预测阶段，我们选择具有最高概率的类别作为预测结果。例如，如果softmax函数给出了猫的概率为0.8，狗的概率为0.15，鸟的概率为0.05，那么我们将预测这个输入样本属于”猫”类别。\n实战开始选取模块与库那么还是老样子，选择我们应该用那些库，其实跟上次的都差不多。\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n首先，我们导入了所需的库，包括 pandas 用于数据处理，numpy 用于数值计算，matplotlib.pyplot 用于绘图，以及一些用于机器学习的模块如 train_test_split 用于数据集划分，StandardScaler 用于特征缩放，accuracy_score、confusion_matrix 和 classification_report 用于评估分类模型的性能。\n读取文件# 读取数据\ndata = pd.read_csv('iris.csv') # 你的文件路径！\n\n然后，我们使用 pandas 读取了一个名为 “iris.csv” 的数据集，该数据集包含了鸢尾花（Iris）的一些测量数据以及其所属的物种标签。\n跟上次一样的数据预处理过程，不过这一次我们还需要干一个事情就是将Species列转换成数值，使用One-hot编码。那么什么是One-hot编码呢？\nOne-hot编码在softmax回归中，我们需要将类别标签转换成一种称为One-hot编码的形式。One-hot编码是一种向量表示方法，将一个类别表示为一个向量，其中只有一个元素是1，其他元素都是0。例如，山鸢尾类别可以表示为[1, 0, 0]，变色鸢尾类别可以表示为[0, 1, 0]，维吉尼亚鸢尾类别可以表示为[0, 0, 1]。\n# 将Species列转换成数值，使用One-hot编码\ndata = pd.get_dummies(data, columns=['Species'])\n\n我们将数据集中的 “Species” 列进行了转换，并使用 One-hot 编码将其转换成了数值形式，这是因为机器学习算法通常只接受数值输入。\n数据预处理其实这一步真的跟之前二分类那一次都差不多了，无非是分离标签，分离特征，划分训练集和预测集，最后再把特征缩放一下。\n# 将特征和标签进行分离\nX = data.drop(['Species_setosa', 'Species_versicolor', 'Species_virginica'], axis=1).values\ny = data[['Species_setosa', 'Species_versicolor', 'Species_virginica']].values\n\n我们将数据集中的特征和标签进行了分离。在这个数据集中，特征是花的测量数据，而标签是表示鸢尾花所属物种的 One-hot 编码形式。\n# 将数据集划分为训练集和测试集\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n我们使用 train_test_split 函数将数据集划分为训练集和测试集。训练集用于模型的训练，测试集用于评估模型的性能。这里将数据集划分成 80% 的训练集和 20% 的测试集，并且使用 random_state 参数设置了随机种子，以确保每次划分的结果都是相同的，便于我们复现结果。\n# 特征缩放\nscaler = StandardScaler()\nX_train_scaled = scaler.fit_transform(X_train)\nX_test_scaled = scaler.transform(X_test)\n\n接着，我们对特征进行了缩放处理，这是为了确保不同特征的数值范围一致，从而避免某些特征对模型训练的影响过大。这里使用了 StandardScaler 类进行标准化处理，将特征缩放到均值为 0、方差为 1 的标准正态分布。\nSoftmax函数就是我们上面所说的那个，我在这里再放一下：我们翻译成代码就是\n# 定义Softmax函数\ndef softmax(scores):\n    exp_scores = np.exp(scores - np.max(scores, axis=1, keepdims=True))\n    return exp_scores / np.sum(exp_scores, axis=1, keepdims=True)\n\n定义 Softmax 函数，这是一个常用的激活函数，用于将模型输出转换为类别概率。它将原始的线性输出（也称为 “scores“）转换为一个概率分布，确保所有概率值在 0 到 1 之间，并且它们的和等于 1。这里的实现避免了数值不稳定性问题，通过减去每个样本的最大分数，可以使指数运算更稳定。\n损失函数：交叉熵这里我们需要再定义一个函数，我们称之为交叉熵函数，为了训练模型，我们需要定义一个损失函数来衡量预测结果和真实标签之间的差异。在softmax回归中，我们使用交叉熵损失函数来衡量预测概率和真实标签之间的距离。我们的目标是最小化交叉熵损失函数，使得模型的预测尽可能接近真实情况。\n# 定义交叉熵损失函数\ndef cross_entropy_loss(y_true, y_pred):\n    num_samples = y_true.shape[0]\n    log_likelihood = -np.log(y_pred[range(num_samples), np.argmax(y_true, axis=1)])\n    loss = np.sum(log_likelihood) / num_samples\n    return loss\n\n交叉熵是常用的分类问题损失函数，它通过计算模型输出概率与真实标签之间的差异来评估模型性能。这里的实现使用了 NumPy 数组运算，避免了显式的循环操作，提高了计算效率。\n训练函数这一步，我们需要使用我们的老朋友梯度下降算法来优化模型参数（权重和偏置）。梯度下降算法会根据损失函数的梯度方向，逐步更新模型的参数，以使损失函数逐渐减小。\n通过迭代训练过程，我们的模型将学习如何将输入样本映射到合适的类别，并且我们可以使用训练好的模型进行预测。\n# 定义训练函数\ndef train_softmax_regression(X, y, learning_rate, epochs):\n    num_samples, num_features = X.shape\n    num_classes = y.shape[1]\n\n    # 初始化权重和偏置\n    W = np.random.randn(num_features, num_classes)\n    b = np.zeros((1, num_classes))\n\n    # 记录每个epoch的损失\n    losses = []\n\n    for epoch in range(epochs):\n        # 前向传播\n        scores = np.dot(X, W) + b\n        probabilities = softmax(scores)\n\n        # 计算损失\n        loss = cross_entropy_loss(y, probabilities)\n        losses.append(loss)\n\n        # 反向传播\n        error = probabilities - y\n        dW = np.dot(X.T, error) / num_samples\n        db = np.sum(error, axis=0, keepdims=True) / num_samples\n\n        # 参数更新\n        W -= learning_rate * dW\n        b -= learning_rate * db\n\n    return W, b, losses\n\n我们定义了训练函数 train_softmax_regression。该函数使用批量梯度下降法来训练 Softmax 回归模型。在训练过程中，我们根据损失函数的梯度更新模型的权重和偏置，不断优化模型以使其更好地拟合训练数据。同时，我们还记录了每个 epoch 的损失值，以便后续的可视化和分析。\n开始调用设置学习率和迭代次数这一步跟之前也非常像，无非是梯度下降嘛\n# 设置学习率和迭代次数\nlearning_rate = 0.01\nepochs = 1000\n\n# 调用训练函数，训练Softmax回归模型\nW, b, losses = train_softmax_regression(X_train_scaled, y_train, learning_rate, epochs)\n\n在这里，我们设置了学习率和迭代次数，并调用训练函数 train_softmax_regression 对模型进行训练。通过不断地迭代优化权重和偏置，模型将逐渐适应训练数据。\n模型预测# 使用训练好的模型进行预测\nscores_test = np.dot(X_test_scaled, W) + b\nprobabilities_test = softmax(scores_test)\ny_pred = np.argmax(probabilities_test, axis=1)\n\n现在，我们使用训练好的模型对测试集进行预测。首先，我们计算测试集的模型输出分数（即未经过 Softmax 函数处理的值），然后将其转换为概率分布，最后根据概率值选择最可能的类别作为预测结果。\n模型评估设置这里我们需要写一些代码，方便我们后期对模型进行评估\n准确率# 计算准确率\naccuracy = accuracy_score(np.argmax(y_test, axis=1), y_pred)\nprint(\"准确率：\", accuracy)\n\n接下来，我们计算模型的准确率，即模型在测试集上的分类正确率。这里使用了 accuracy_score 函数，它将预测结果与真实标签进行比较，并输出分类的准确率。\n分类报告与混淆矩阵# 输出分类报告和混淆矩阵\nprint(\"\\n分类报告：\")\nprint(classification_report(np.argmax(y_test, axis=1), y_pred))\n\nprint(\"\\n混淆矩阵：\")\nprint(confusion_matrix(np.argmax(y_test, axis=1), y_pred))\n\n最后，我们输出分类报告和混淆矩阵，用于详细评估模型在各个类别上的分类性能。分类报告提供了精确率、召回率和 F1 分数等指标，而混淆矩阵展示了模型预测结果与真实标签之间的对应关系。\n\n\n\n\n\n\n\n\n\n混淆矩阵是分类器在测试集上的分类结果的矩阵表示。矩阵的行表示真实类别，列表示预测类别。对角线上的元素表示正确分类的样本数，非对角线上的元素表示错误分类的样本数。\n可视化处理这一步我们就需要进行可视化处理，因为程序写一大堆，不如图像来的直观，便捷。\n损失函数# 可视化损失值随着迭代次数的变化\nplt.plot(range(epochs), losses)\nplt.xlabel('Epochs')\nplt.ylabel('Loss')\nplt.title('Training Loss')\nplt.show()\n\n我们使用 matplotlib 库绘制了损失值随着迭代次数的变化曲线图，用于可视化模型训练的过程和损失值的收敛情况。这个图可以帮助我们判断模型是否在训练中得到了有效的优化。\n结果散点图我们需要绘制分类结果的散点图和预测结果的散点图。散点图将数据集中的样本点可视化为不同颜色和符号的点，以显示不同类别的分布和模型的分类结果。\n# 准备绘制子图的布局\nfig, axes = plt.subplots(2, 2, figsize=(15, 10))\naxes = axes.ravel()\n\n首先，我们创建了一个 2x2 的子图布局，即总共有 4 个子图。plt.subplots(2, 2) 返回一个包含 2 行 2 列的 Figure 对象和一个 Axes 对象数组。然后，通过 axes.ravel() 将该数组转换为一维数组，以便更方便地对每个子图进行操作。\n# 绘制每个子图\nfor i in range(3):\n    # 绘制分类结果的散点图\n    axes[i].scatter(X_train[y_train[:, 0] == 1, i], X_train[y_train[:, 0] == 1, i + 1], label='Class 1 (Train)', marker='o', c='blue')\n    axes[i].scatter(X_train[y_train[:, 1] == 1, i], X_train[y_train[:, 1] == 1, i + 1], label='Class 2 (Train)', marker='s', c='green')\n    axes[i].scatter(X_train[y_train[:, 2] == 1, i], X_train[y_train[:, 2] == 1, i + 1], label='Class 3 (Train)', marker='^', c='red')\n\n    # 绘制预测结果的散点图，使用不同的颜色和符号\n    axes[i].scatter(X_test[y_pred == 0, i], X_test[y_pred == 0, i + 1], label='Class 1 (Test)', marker='x', c='blue', alpha=0.5)\n    axes[i].scatter(X_test[y_pred == 1, i], X_test[y_pred == 1, i + 1], label='Class 2 (Test)', marker='x', c='green', alpha=0.5)\n    axes[i].scatter(X_test[y_pred == 2, i], X_test[y_pred == 2, i + 1], label='Class 3 (Test)', marker='x', c='red', alpha=0.5)\n\n    axes[i].set_xlabel(data.columns[i])\n    axes[i].set_ylabel(data.columns[i + 1])\n    axes[i].legend()\n\n\n接着，我们使用循环遍历每个子图，并在每个子图中绘制两个类别的散点图：一个是分类结果的散点图，另一个是预测结果的散点图。我们使用 scatter 函数绘制散点图，其中包含了训练集和测试集中不同类别的样本点。\n对于分类结果的散点图，我们分别使用不同的颜色和符号来表示每个类别。蓝色圆点表示 “Class 1”，绿色正方形表示 “Class 2”，红色三角形表示 “Class 3”。我们从训练集 X_train 和标签 y_train 中选择相应的样本点，根据标签的 One-hot 编码来确定样本的类别。\n对于预测结果的散点图，我们使用虚线的 X 符号来表示。同样，我们根据预测结果 y_pred 来选择测试集 X_test 中的样本点，并根据预测的类别来确定样本所属的类别。\n在每个子图中，我们设置了 x 轴和 y 轴的标签，分别为数据集的不同特征列，用以标识每个散点图中数据点的位置。同时，我们添加了图例来说明不同类别的符号和颜色含义。\n\n# 设置整体图的标题和坐标轴\nplt.suptitle('Classification and Prediction Results')\nplt.tight_layout()\nplt.show()\n\n最后，我们为整体图设置了标题 “Classification and Prediction Results”，使用 suptitle 函数来实现。同时，我们通过 tight_layout() 函数调整子图之间的布局，使得图像更美观。最后，使用 plt.show() 来显示绘制的图像。\n完整代码如下\n\nClick to see more\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n\n# 读取数据\ndata = pd.read_csv('iris.csv') # 记得改自己文件的路径\n\n# 将Species列转换成数值，使用One-hot编码\ndata = pd.get_dummies(data, columns=['Species'])\n\n# 将特征和标签进行分离\nX = data.drop(['Species_setosa', 'Species_versicolor', 'Species_virginica'], axis=1).values\ny = data[['Species_setosa', 'Species_versicolor', 'Species_virginica']].values\n\n# 将数据集划分为训练集和测试集\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# 特征缩放\nscaler = StandardScaler()\nX_train_scaled = scaler.fit_transform(X_train)\nX_test_scaled = scaler.transform(X_test)\n\ndef softmax(scores):\n    exp_scores = np.exp(scores - np.max(scores, axis=1, keepdims=True))\n    return exp_scores / np.sum(exp_scores, axis=1, keepdims=True)\n\ndef cross_entropy_loss(y_true, y_pred):\n    num_samples = y_true.shape[0]\n    log_likelihood = -np.log(y_pred[range(num_samples), np.argmax(y_true, axis=1)])\n    loss = np.sum(log_likelihood) / num_samples\n    return loss\n\ndef train_softmax_regression(X, y, learning_rate, epochs):\n    num_samples, num_features = X.shape\n    num_classes = y.shape[1]\n\n    # 初始化权重和偏置\n    W = np.random.randn(num_features, num_classes)\n    b = np.zeros((1, num_classes))\n\n    # 记录每个epoch的损失\n    losses = []\n\n    for epoch in range(epochs):\n        # 前向传播\n        scores = np.dot(X, W) + b\n        probabilities = softmax(scores)\n\n        # 计算损失\n        loss = cross_entropy_loss(y, probabilities)\n        losses.append(loss)\n\n        # 反向传播\n        error = probabilities - y\n        dW = np.dot(X.T, error) / num_samples\n        db = np.sum(error, axis=0, keepdims=True) / num_samples\n\n        # 参数更新\n        W -= learning_rate * dW\n        b -= learning_rate * db\n\n    return W, b, losses\n\nlearning_rate = 0.01\nepochs = 1000\n\nW, b, losses = train_softmax_regression(X_train_scaled, y_train, learning_rate, epochs)\n\n# 预测\nscores_test = np.dot(X_test_scaled, W) + b\nprobabilities_test = softmax(scores_test)\ny_pred = np.argmax(probabilities_test, axis=1)\n\n# 准确率\naccuracy = accuracy_score(np.argmax(y_test, axis=1), y_pred)\nprint(\"准确率：\", accuracy)\n\n# 分类报告和混淆矩阵\nprint(\"\\n分类报告：\")\nprint(classification_report(np.argmax(y_test, axis=1), y_pred))\n\nprint(\"\\n混淆矩阵：\")\nprint(confusion_matrix(np.argmax(y_test, axis=1), y_pred))\n\n# 可视化损失\nplt.plot(range(epochs), losses)\nplt.xlabel('Epochs')\nplt.ylabel('Loss')\nplt.title('Training Loss')\nplt.show()\n\n# 准备绘制子图的布局\nfig, axes = plt.subplots(2, 2, figsize=(15, 10))\naxes = axes.ravel()\n# 绘制每个子图\nfor i in range(3):\n    # 绘制分类结果的散点图\n    axes[i].scatter(X_train[y_train[:, 0] == 1, i], X_train[y_train[:, 0] == 1, i + 1], label='Class 1 (Train)', marker='o', c='blue')\n    axes[i].scatter(X_train[y_train[:, 1] == 1, i], X_train[y_train[:, 1] == 1, i + 1], label='Class 2 (Train)', marker='s', c='green')\n    axes[i].scatter(X_train[y_train[:, 2] == 1, i], X_train[y_train[:, 2] == 1, i + 1], label='Class 3 (Train)', marker='^', c='red')\n\n    # 绘制预测结果的散点图，使用不同的颜色和符号\n    axes[i].scatter(X_test[y_pred == 0, i], X_test[y_pred == 0, i + 1], label='Class 1 (Test)', marker='x', c='blue', alpha=0.5)\n    axes[i].scatter(X_test[y_pred == 1, i], X_test[y_pred == 1, i + 1], label='Class 2 (Test)', marker='x', c='green', alpha=0.5)\n    axes[i].scatter(X_test[y_pred == 2, i], X_test[y_pred == 2, i + 1], label='Class 3 (Test)', marker='x', c='red', alpha=0.5)\n\n    axes[i].set_xlabel(data.columns[i])\n    axes[i].set_ylabel(data.columns[i + 1])\n    axes[i].legend()\n\n# 设置整体图的标题和坐标轴\nplt.suptitle('Classification and Prediction Results')\nplt.tight_layout()\nplt.show()\n\n\n\n结果评估图像评估先来看我们第一张损失函数图像\n\n可以看得出，随着我们迭代次数的增加，模型的损失在不断的减小，符合我们的预期，可以说是一个很好的模型。那么我们接着往下看。\n\n这张图当中可以看得出来，训练集的数据已经用不同颜色和形状分布在各个地方，我们也能发现我们的预测集的x也合理的分布在他们所在的区域。\n当然最开始我是只画了一张图像的，就是第一张，我只对比了Sepal.Width和Sepal.Length两个维度下，三个品种之间的关系，你可以发现绿色和红色纠缠在一起，并不能很好的区分。是因为我们只画两个维度，但是实际模型考虑了四个维度，限于二维图像的表示限度，所以我就多画了几个图，尽可能多的考虑每个维度之间不同的结果，其实就可以发现分类其实是成功了的。\n当然我也画了三维图像，那个更加明显，不过，给各位留作思考吧！\n嘿嘿以后再说吧，其实目前我们已经可以很明显的看出来三者是可以区分的。\n控制台评估我们也生成了一份报告，如果图像并不能很好的分析的话，我们可以看实际的数据报告是什么样的。\n准确率： 0.9333333333333333\n\n分类报告：\n              precision    recall  f1-score   support\n\n           0       1.00      1.00      1.00        10\n           1       0.89      0.89      0.89         9\n           2       0.91      0.91      0.91        11\n\n    accuracy                           0.93        30\n   macro avg       0.93      0.93      0.93        30\nweighted avg       0.93      0.93      0.93        30\n\n\n混淆矩阵：\n[[10  0  0]\n [ 0  8  1]\n [ 0  1 10]]\n\n\n准确率： 准确率是分类器预测正确的样本数占总样本数的比例。在这个例子中，准确率为0.9333333333333333，即约为93.33%。\n\n分类报告： 分类报告提供了关于每个类别的精确率（precision）、召回率（recall）和F1-score的信息。精确率是分类器预测为某一类别的样本中真实属于该类别的比例，召回率是真实属于某一类别的样本中被分类器预测为该类别的比例，F1-score是精确率和召回率的调和平均值。macro avg表示各类别的平均值，weighted avg表示按样本数加权的平均值。\n在这个例子中，对于类别0，精确率和召回率都为1.00，F1-score也为1.00；对于类别1，精确率和召回率都为0.89，F1-score为0.89；对于类别2，精确率和召回率都为0.91，F1-score为0.91。整体的macro avg和weighted avg的准确率、召回率和F1-score都在0.93左右。\n\n混淆矩阵： 混淆矩阵是分类器在测试集上的分类结果的矩阵表示。矩阵的行表示真实类别，列表示预测类别。对角线上的元素表示正确分类的样本数，非对角线上的元素表示错误分类的样本数。\n在这个例子中，对于类别0，有10个样本被正确分类；对于类别1，有8个样本被正确分类，1个样本被错误分类为类别2；对于类别2，有10个样本被正确分类，1个样本被错误分类为类别1。可以看到，大部分样本被正确分类，但仍有一些样本被错误分类。\n\n\n综合来看，这个分类器在测试集上的表现还是不错的，准确率达到了约93.33%。各类别的精确率、召回率和F1-score也都较为接近，说明模型对于不同类别的预测表现都较为稳定。但仍然有少数样本被错误分类，可能需要进一步优化模型，调整参数或特征，以进一步提高分类器的性能。\n其实大家可以多跑几次，会发现每次都会有些小差距，但是准确率一般都在91%~97%附近，还是蛮不错的模型了噢！\n任务留个小任务吧。\n思考：在多维度数据下，有什么方法可以更好的数据可视化？在这次分类中我们就可以发现一张二维图像可能很难看出三者之间的分类情况，何况我画了三张，对比了每两个维度三者之间的关系才可以勉强分析，那么有什么好方法呢？\n","slug":"irisSoftmax","date":"2023-07-21T10:46:33.000Z","categories_index":"","tags_index":"Machine Learning,笔记","author_index":"General_K1ng"},{"id":"6d0e0a76d24875617f81e74389647d3a","title":"构建GLM","content":"这节我们就要开始构造GLM了。\n假设您想建立一个模型，根据一些特征x（比如商店促销活动、最近的广告、天气、星期几等）来估计在任何给定的小时内到达您的商店（或您的网站上的页面浏览次数）的顾客数量y。我们知道泊松分布通常是用于描述访问者数量的好模型。有了这个信息，我们该如何为我们的问题构建一个模型呢？幸运的是，泊松分布是指数分布族的一种，因此我们可以应用广义线性模型（GLM）。在本节中，我们将描述一种构建GLM模型来解决这类问题的方法。\n问题背景首先，让我们考虑一个分类或回归问题，我们希望根据特征 x 预测随机变量 y 的值。为了推导适用于这个问题的GLM，我们做出以下三个假设：\n\n假设一： 在给定 x 和参数 θ 的情况下，y | x; θ 的分布服从某个指数族分布，其参数为 η。\n假设二： 在给定 x 的情况下，我们的目标是预测 T(y) 的期望值，即 *E[y | x]*。在我们的大多数示例中，我们有 T(y) = y，这意味着我们希望我们学习的假设 h 所输出的预测 h(x) 满足 *h(x) = E[y | x]*。（需要注意的是，这个假设对于逻辑回归和线性回归中的  的选择是成立的。例如，在逻辑回归中，我们有 。）\n假设三： 自然参数 η 和输入 x 之间是线性相关的：。（或者，如果 η 是向量值的，则 。）\n\n值得注意的是，第三个假设可能看起来较不充分，并且更应该被视为设计GLM的“选择”，而不是严格的假设。这三个假设/设计选择使我们能够推导出一类非常优雅的学习算法，即GLMs，具有许多理想的特性，如易于学习。此外，由此产生的模型通常非常有效，适用于对 y 的不同类型分布进行建模；例如，我们很快将展示逻辑回归和普通最小二乘法都可以作为GLMs的特定实例推导出来。\n普通最小二乘法（Ordinary Least Squares）为了证明普通最小二乘法是GLM模型族的一个特例，我们首先考虑目标变量 y（在GLM术语中也称为响应变量）为连续型的情况。我们将 y 给定 x 的条件分布建模为高斯分布 ，，其中 μ 可能依赖于 x。这样，我们就选择了上面提到的指数族分布中的分布作为高斯分布。\n正如之前提到的，将高斯分布表示为指数族分布时，我们有 。所以我们有：\n1. 首先，根据假设2，我们有:这表示我们的目标是预测 y 的条件期望值。\n2. 其次，由于我们选择的指数族分布是高斯分布，所以根据高斯分布的性质，其期望值 μ 就等于 η，即:3. 接下来，根据假设3，我们有:这表示 η 和输入 x 之间是线性相关的。\n将这些信息结合起来，我们得到：这就证明了普通最小二乘法是GLM模型族的一个特例。在普通最小二乘法中，我们的目标是最小化预测值与真实值之间的平方差，从而得到拟合效果最优的线性模型。普通最小二乘法是线性回归问题中最常见和经典的解决方法。在下一节，我们将继续探讨GLM模型族的其他实例，例如逻辑回归。\n逻辑回归（Logistic regression）接下来，我们将探讨逻辑回归。在这种情况下，我们对二元分类感兴趣，因此 y 只能取 0 或 1。考虑到 y 是二值的，选择伯努利分布族来建模给定 x 条件下 y 的条件分布是很自然的。将伯努利分布表示为指数族分布时，我们得到 。此外，注意到如果 ，则 。按照与普通最小二乘法相似的推导，我们得到：\n1. 首先，根据假设2，我们有：这表示我们的目标是预测 y 的条件期望值。\n2. 其次，由于我们选择的指数族分布是伯努利分布，所以根据伯努利分布的性质，其期望值 φ 就等于  函数的规范响应函数，即：3. 接下来，根据假设3，我们有：这表示 η 和输入 x 之间是线性相关的。\n将这些信息结合起来，我们得到：这就给出了逻辑回归的假设函数形式 。如果您曾经好奇我们是如何得到逻辑函数  的形式的，现在这就是答案：一旦我们假设 y 在给定 x 的条件下服从伯努利分布，逻辑函数的形式就是GLMs和指数族分布所定义的结果。\n此外，为了引入一些更多的术语，将分布的均值表示为自然参数的函数的函数 g（）称为规范响应函数。它的逆函数  被称为规范链接函数。因此，对于高斯族，规范响应函数是恒等函数；而对于伯努利分布，规范响应函数是逻辑函数。\n\n\n\n\n\n\n\n\n\n很多文献使用g来表示链接函数，而来表示响应函数；但是，我们在这里使用的符号，继承自早期的机器学习文献，将更符合本课程其他部分使用的符号。\nSoftmax回归（Softmax regression）让我们再来看一个GLM的例子，即Softmax回归。这个模型适用于多类别分类问题，其中响应变量 y 可以取 k 个值中的任意一个，即 y ∈ {1, 2, . . . , k}。例如，我们不再只将电子邮件分类为垃圾邮件或非垃圾邮件（二元分类问题），而是希望将其分类为三类，比如垃圾邮件、个人邮件和工作邮件。虽然响应变量仍然是离散的，但现在可以取多于两个值。因此，我们将其建模为多项式分布。\n参数化多项式分布为了参数化包含 k 个可能结果的多项式分布，我们可以使用 k 个参数  来指定每个结果的概率。但是，这些参数是冗余的，即不独立的（因为知道任意 k-1 个  将唯一确定最后一个，因为它们必须满足 ）。因此，我们只使用 k-1 个参数  来参数化多项式分布，其中 ，而 。为了方便起见，我们还可以让 ，但是我们应该记住这不是一个参数，并且完全由  确定。\n表示为指数族分布为了将多项式分布表示为指数族分布，我们定义  如下：，，，，，与之前的例子不同，这里我们不再有 ；而且， 现在是一个 k - 1 维向量，而不是一个实数。我们用  来表示向量  的第 i 个元素。\n指示函数我们再引入一个非常有用的符号。指示函数 1{·} 在其参数为真时取值为 1，在其参数为假时取值为 0（1{True} = 1，1{False} = 0）。例如，1{2 = 3} = 0，1{3 = 5 - 2} = 1。因此，我们还可以将  与  之间的关系表示为 (。（在继续阅读之前，请确保你理解了这是为什么！）此外，我们有 。\n多项式分布是指数族的成员现在，我们准备展示多项式分布是指数族的成员。我们有以下推导：\n\n其中：\n\n\n这样，我们完成了将多项式分布表述为指数族分布的过程。\n链接函数和响应函数我们得到了链接函数的定义（对于 i = 1, . . . , k）为：为方便起见，我们还定义了 。为了求反函数并得到响应函数，我们有：这意味着 ，将其代回公式得到响应函数为：这个从 η 到 φ 的函数被称为Softmax函数，它是一个非常有用的函数，常用于多类别分类问题中，用于将线性输出转换为类别概率。\n完成 Softmax 回归为了完成我们的模型，我们使用之前给出的第三个假设，即  与  呈线性关系。因此，我们有 （对于 ），其中 是我们模型的参数。为了方便起见，我们还可以定义 ，这样 ，如之前所述。因此，我们的模型假设给定  时  的条件分布为：这个适用于 y ∈ {1, . . . , k} 的分类问题的模型被称为 softmax 回归。它是逻辑回归的一种推广。\n模型输出我们的假设将输出：换句话说，我们的假设输出对于每个值 i = 1, . . . , k 的估计概率 。（尽管上面定义的  只有 k − 1 维，很显然  可以通过计算  获得。）\n参数拟合最后，我们讨论参数拟合。与我们之前推导普通最小二乘法和逻辑回归时类似，如果我们有一个包含 n 个示例的训练集 {}，并希望学习该模型的参数 ，我们首先将写出对数似然函数：得到上面第二行的式子，我们使用了之前给出的  的定义。现在，我们可以通过最大化  关于  来获得参数的最大似然估计，使用梯度上升或牛顿法等方法进行优化。\n\n\n\n\n\n\n\n\n\n这个部分主要讲解了Softmax回归模型的建立过程和数学推导。如果不懂，没有关系。\n深入了解数学推导对于机器学习的初学者并非必须，但它有助于加深对机器学习算法和模型的理解。对于初学者，重点应该放在理解基本概念和算法的直觉上，而不是过于深入的数学推导。\n理解数学推导可以帮助你更好地理解算法是如何工作的、为什么选择特定的方法以及它们的局限性。这对于在实际问题中选择合适的模型、调整超参数以及解决算法的性能问题非常有帮助。此外，深入了解数学推导还可以帮助你更好地理解机器学习文献和研究论文，从而保持对新进展的敏感性。\n然而，对于初学者来说，过度关注数学细节可能会让学习过程变得繁琐，甚至让人望而却步。如果你对数学不是特别熟悉，你可以先掌握机器学习的基本概念、常用算法和实践技巧。一旦你对机器学习有了较好的理解，再逐步深入学习数学推导也是一种不错的学习路径。\n最重要的是保持学习的兴趣和动力。你可以根据自己的兴趣和学习目标来决定学习深入数学推导的程度。有时候，实际动手实践和解决实际问题可能比过多纠结于数学推导更加有意义。不断实践和尝试在真实数据上应用机器学习算法将有助于你更快地掌握这门领域。\n","slug":"ConstructingGLMs","date":"2023-07-20T08:10:30.000Z","categories_index":"","tags_index":"Machine Learning,笔记","author_index":"General_K1ng"},{"id":"9397670a03548da92beb1eda8943120b","title":"指数族","content":"为了逐步理解广义线性模型（GLM），我们从定义指数族分布开始！指数族分布是一类神奇的分布，它具有以下形式：其中：\n\ny 是随机变量的取值；\nη 是参数向量（也称为典范参数）；\nT(y) 是充分统计量（sufficient statistic）的向量（对于我们考虑的分布，通常有T(y) = y）；\na(η) 是对数分区函数（log partition function）；\nb(y) 是规范化因子（normalizing factor）。\n\n不要被公式吓到，让我们看看它们的可爱之处！\n 就像一枚魔法徽章，它确保分布  在所有 y 上的和或积等于 1，这样我们就能有一个完美的概率分布。\n这个指数族分布包含许多我们耳熟能详的朋友，比如正态分布、伯努利分布、泊松分布等。而在广义线性模型中，我们将利用指数族分布的特性来构建适用于回归和分类问题的模型。\n探索不同的分布族在 GLM 世界中，固定 T、a 和 b 的选择定义了一个由 η 参数化的分布族（或集合）。当我们改变 η 时，我们会得到这个族中的不同分布。每个族族中的成员都有自己的个性和特点，让我们带着好奇心探索一番！\n伯努利分布和高斯分布是指数族分布的宠儿！让我们看看伯努利分布和高斯分布是指数族分布的两个魔法示例。\n伯努利分布：它是二分类问题中的常客！伯努利分布的均值为 ，写作 Bernoulli()。它规定了  上的分布，使得  和 。随着  的变化，我们会得到具有不同均值的伯努利分布。我们将展示通过改变  获得的这类伯努利分布恰好是指数家族分布。\n我们将Bernoulli分布写成：因此，自然参数由给出。有趣的是，如果我们通过将表示为的函数来反演这个定义，我们会得到。这就是熟悉的sigmoid函数！这在我们将逻辑回归推导为GLM时再次出现。\n将伯努利分布表达成指数家族分布为了将伯努利分布完整地表述为指数家族分布，我们还有以下参数：这表明伯努利分布可以使用适当的T、a和b的选择来写成以上公式的形式。\n高斯分布（正态分布）让我们来研究一下高斯分布。咦，还记得我们推导线性回归时提到的那个方差  吗？其实它对最终的  和  是没有影响的，所以我们可以大胆地选择  的任意值，而不改变任何结果。为了简化接下来的推导，我们就设定  吧！\n\n\n\n\n\n\n\n\n\n嗯，其实如果我们保留  作为一个变量，高斯分布也可以归入指数分布族。在这种情况下， 是一个依赖于  和  的二维向量。然而，在广义线性模型（GLM）中，我们可以通过考虑指数分布族的更一般定义来处理  参数：。这里的  被称为离散参数，对于高斯分布，。但是，为了简便起见，我们在这里只考虑了我们之前假定的情况。\n\n好的，现在让我们来看看高斯分布的奇妙之处：接下来，让我们来看看高斯分布在指数族中的参数表示：指数分布族中还有许多其他分布：多项式分布（稍后我们会看到），泊松分布（用于建模计数数据；也请参阅问题集）；伽马分布和指数分布（用于建模连续、非负的随机变量，比如时间间隔）；贝塔分布和狄利克雷分布（用于概率分布）等等。\n在下一节中，我们将向你展示一个通用的“方法”，用于构建模型，其中 （在给定  和  的情况下）来自上述任意分布之一。\n","slug":"The-exponential-family","date":"2023-07-20T07:17:04.000Z","categories_index":"","tags_index":"Machine Learning,笔记","author_index":"General_K1ng"},{"id":"005491f74262b9b4c835e159a3d618ac","title":"一些题外话","content":"这章节的在课程的笔记里面就是叫题外话，因为和下一节都比较短，所以我就放到一起来记录。\n题外话：感知机学习算法咱们现在稍微偏离一下主题，来简单探讨一种历史上颇具趣味的算法，同时在后面学习理论的时候也会再次回到它。这个算法是从逻辑回归方法修改而来，以强制其输出值为 0 或 1。为了实现这个目标，我们自然而然地改变了函数 g 的定义，将其设定为阈值函数：如果我们继续使用之前定义的 ，但使用这个修改过的 g 函数定义，并采用更新规则：那么我们得到了感知机学习算法。\n感知机学习算法是机器学习中的一个简单算法，用于解决二分类问题。它的灵感来源于神经科学中的感知神经元概念，由 Frank Rosenblatt 于 1957 年提出。\n算法的目标是找到一个超平面，将数据分为两个类别。假设输入样本是一个  维特征向量 ，超平面的表达式为 ，其中  是需要学习的参数向量。对于任意输入 ，如果 ，则预测为正类；如果 ，则预测为负类。\n算法的更新规则如下：\n\n初始化  为一个随机向量或零向量。\n\n对于每个训练样本 ，其中  是标签（1 或 -1）：\na. 计算预测值：。\nb. 如果  和  异号，则更新 ：，其中  是学习率。\n\n\n算法将持续迭代以上步骤，直到所有样本被正确分类或达到预定的迭代次数。需要注意的是，感知机算法只能解决线性可分问题，如果数据线性不可分，则无法收敛。\n在 1960 年代，这个”感知机”被认为是描述大脑中个体神经元工作的一个简略模型。虽然感知机在外观上可能与之前讨论过的其他算法相似，但它实际上与逻辑回归和最小二乘线性回归有很大的不同；特别是，为感知机的预测赋予有意义的概率解释，或将其推导为最大似然估计算法都是非常困难的。不过，它作为学习理论的一个出发点，将为我们的分析提供有趣的帮助。\n另一种最大化的算法现在我们回到使用sigmoid函数作为  的逻辑回归，并讨论一种不同的最大化  的算法。\n让我们首先考虑用牛顿法来寻找函数的零点。假设我们有一个函数 ，我们希望找到一个值 ，使得 。这里， 是一个实数。牛顿法的更新公式如下：这个方法有一个直观的解释，我们可以将其看作是通过一个与当前猜测  处的  相切的线性函数来近似函数 ，然后求解该线性函数为零的位置，并将下一个猜测  设为该位置。\n下面是牛顿法的示意图：\n\n在最左边的图中，我们看到函数  的曲线以及直线 。我们试图找到 ，使得 ；在该例子中， 的值约为 1.3。假设我们将算法的初始值设为 。牛顿法接着拟合了一个与  处的  相切的直线，并求解该直线的零点。（中间的图）这给出了下一个猜测的 ，约为 2.8。最右边的图显示了再进行一次迭代的结果，将  更新为约 1.8。经过几次迭代后，我们迅速接近 。\n牛顿法提供了一种找到  的方法。那么，如果我们想要用它来最大化某个  函数呢？ 函数的极大值对应于其一阶导数  等于零的点。因此，我们可以令 ，然后使用相同的算法来最大化 ，得到更新规则：（思考一下：如果我们想要用牛顿法来最小化而不是最大化一个函数，这将如何改变？）\n最后，在逻辑回归的设置中， 是一个向量，因此我们需要将牛顿法推广到这种多维情况（也称为牛顿-拉夫逊方法）。推广到多维的公式如下：其中， 通常表示  对于  的偏导数的向量； 是一个  的矩阵（实际上是 ，假设我们包括截距项），称为Hessian 矩阵，其元素由以下公式给出：通常情况下，牛顿法 比（批量）梯度下降收敛得更快，并且需要较少的迭代次数来接近最小值。然而，一次牛顿法的迭代可能比一次梯度下降的迭代更昂贵，因为它需要找到和求逆一个  的 Hessian 矩阵；但只要  不是太大，整体上牛顿法通常更加高效。当牛顿法应用于最大化逻辑回归的对数似然函数  时，得到的方法也称为 Fisher scoring 方法。\n广义线性模型下一章节我们就要学习到广义线性模型，到目前为止，我们已经看到了一个回归示例和一个分类示例。在回归示例中，我们有，而在分类示例中，，其中和是和的合适定义函数。在下一节当中，我们将展示这两种方法都是更广泛的模型家族——广义线性模型（Generalized Linear Models，GLMs）的特例。我们还将展示如何导出和应用GLM家族中的其他模型来解决其他分类和回归问题。\n","slug":"Some-Digression","date":"2023-07-20T06:30:32.000Z","categories_index":"","tags_index":"Machine Learning,笔记","author_index":"General_K1ng"},{"id":"6ad60e40b1cfbe85f1c534ea3d1910e1","title":"（实战）鸢尾花数据集的二分类","content":"所以说第一行打不了字是吧，莫名其妙。（不用管这一行，刚刚发现我的编辑器第一行莫名其妙打不了字，所以你看到的这是第二行，很烦）\n昨天我学习了逻辑回归，今天就要实战一下啦！因为光看纸上的知识总感觉有点枯燥，咱们动手试试，把学到的知识化为力量吧！今天我们要玩的游戏是逻辑回归，而游戏场地就是鸢尾花的数据集。\n数据集：鸢尾花大冒险咱们先打开Excel，看看我们要玩的鸢尾花数据集是什么样子滴！第一列是索引，我们直接删掉啦！（记得一定要删掉哦！不然程序会迷失方向，不信你试试！不过别问我为什么知道… T T）\n\n可以发现，第一行是表头数据，分别有Sepal.Length（萼片长度），Sepal.Width（萼片宽度），Petal.Length（花瓣长度），Petal.Width（花瓣宽度），Species（种类），这几个，而Species中分为三个种类，分别是“setosa”，“versicolor”和“virginica”，分别是“小山鸢尾”、“变色鸢尾”和“维吉尼亚鸢尾”。\n准备阶段：选取我们的“法宝”首先，咱们得明确自己的任务和目标哦：我们要用逻辑回归算法解决一个二分类问题，把这个法宝应用于鸢尾花数据集。目标是训练逻辑回归模型，并查看它在测试集上的“施法”效果。\n这里咱们可要动用一些神奇的“法宝”呢！数据处理用强大的Pandas，数值计算可凭借老生常谈的numpy库，train_test_split可用来把数据分为训练集和测试集，LogisticRegression则是我们要打造的逻辑回归模型，还有accuracy_score、precision_score和recall_score这三把尺子，它们能帮我们测量评估指标的准确度哦！最后，还有matplotlib.pyplot可将数据可视化，让我们一起瞧瞧吧！\n所以准备工作差不多就这些，先把所需要的模块导入。\nimport pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score\nimport matplotlib.pyplot as plt\n\n魔法准备：定义一些有趣的“法术”现在，我们要定义一些有趣的“法术”来玩逻辑回归啦！这些“法术”都是数学公式变身的，让Python来帮我们算算就好啦！\ndef sigmoid(z):\n    return 1 / (1 + np.exp(-z))\n\ndef log_likelihood(features, target, weights):\n    scores = np.dot(features, weights)\n    ll = np.sum(target * scores - np.log(1 + np.exp(scores)))\n    return ll\n\ndef logistic_regression(features, target, num_steps, learning_rate):\n    intercept = np.ones((features.shape[0], 1))\n    features = np.hstack((intercept, features))\n    weights = np.zeros(features.shape[1])\n\n    for step in range(num_steps):\n        scores = np.dot(features, weights)\n        predictions = sigmoid(scores)\n\n        output_error_signal = target - predictions\n        gradient = np.dot(features.T, output_error_signal)\n        weights += learning_rate * gradient\n\n        # Print log-likelihood every 100 steps\n        if step % 100 == 0:\n            print(f\"Step {step}, Log-Likelihood: {log_likelihood(features, target, weights)}\")\n\n    return weights\n\n第一个“法术”叫做sigmoid，它是逻辑回归中的魔法函数，负责把输入的数值变成0到1之间的可爱小数哦！\n接下来是log_likelihood，“法术”嘛，它能算出对数似然性，看起来有点高深，其实是帮我们衡量预测结果的好坏程度！\n最后一个“法术”是logistic_regression，这个可厉害了！它用梯度上升算法，一步步地训练逻辑回归模型，就像咱们在山上慢慢攀登一样！它还会在每爬100步的时候，打印出对数似然性，让我们知道自己的成长进度哦！\n大冒险准备：数据预处理怎么个处理法，其实好像没什么需要处理的，无非就是读取，存储，几个简单的转换？差不多吧。\n# 加载数据集并分成训练集和测试集\ndata_path = 'iris.csv' # 你的路径！\ndata = pd.read_csv(data_path)\n\n# 将'setosa'标记为1，其他两种花标记为0，实现二分类问题\ndata['Species'] = data['Species'].map({'setosa': 1, 'versicolor': 0, 'virginica': 0})\n\n# 提取特征和标签\nfeatures = data.drop('Species', axis=1)\ntarget = data['Species']\n\n# 分割数据集\ntrain_features, test_features, train_target, test_target = train_test_split(features, target, test_size=0.2, random_state=42)\n\n首先，我们要加载数据集，它就像我们的宝藏地图一样，指引着我们前进的方向。我们用pd.read_csv()将数据从csv文件中读取出来，并把花的种类标记为1和0，就像宝藏上的标记一样，让我们可以区分哪些是我们要找的，哪些是普通的岩石。瞧，鸢尾花的种类有点像三个魔法宝石，我们要把其中一个宝石标记为1，其他两个标记为0，这样它们就变成了我们要寻找的目标。\n接下来，我们得把宝藏中的特征和目标提取出来。特征就像地图上的路线，目标就像我们要找的宝藏。咱们把特征放进features变量，把目标放进target变量，这样咱们就能对它们进行后续的处理啦。\n鸢尾花大冒险的第一步就是分割数据集，将宝藏地图分成训练集和测试集，这样我们才能在训练中不断成长，最后测试一下自己的探险成果。通过train_test_split，我们将数据集分成了两部分，80%的数据用来训练，20%的数据留作测试，而随机种子random_state=42则确保我们在不同的时候玩同样的游戏。\n参数：选个好武器，准备战斗# 使用训练集来训练逻辑回归模型\nnum_steps = 1000\nlearning_rate = 0.01\nweights = logistic_regression(train_features, train_target, num_steps, learning_rate)\n\n接下来，我们要选择适合鸢尾花大冒险的武器了。先把自己的装备整理一下，我们需要设定一些超级厉害的“法宝”：迭代次数num_steps和学习率learning_rate，这些会决定我们在冒险中的表现。好了，现在我们就准备好了，可以正式进入鸢尾花的世界了！\n“法宝”已经准备齐全，现在我们需要通过logistic_regression函数，调用那些魔法“法术”来进行模型的训练。这个过程就像在修炼魔法一样，每一步都在增强我们的力量。训练过程中，我们会在每爬100步的时候，打印出当前的对数似然性，这样我们就能看到自己的成长历程。\n你也可以在这部分通过调整迭代次数和学习率来观察不同情况下的模型表现。\n探索成果，评估表现！test_intercept = np.ones((test_features.shape[0], 1))\ntest_features = np.hstack((test_intercept, test_features))\ntest_predictions = sigmoid(np.dot(test_features, weights))\ntest_predictions = np.round(test_predictions)\n\naccuracy = accuracy_score(test_target, test_predictions)\nprecision = precision_score(test_target, test_predictions)\nrecall = recall_score(test_target, test_predictions)\n\nprint(f\"Accuracy: {accuracy}, Precision: {precision}, Recall: {recall}\")\n\n这一部分代码使用训练后的模型权重对测试集进行预测，并计算评估指标。首先，将测试集的特征矩阵添加一列全为1的列作为截距，然后通过逻辑函数sigmoid和权重矩阵计算预测结果。为了得到最终的分类结果，将预测概率四舍五入为0或1。\n最后，计算预测结果与测试集真实标签之间的准确率、精确率和召回率，并将结果打印输出。\n\n\n\n\n\n\nTIP\n这里我再来贴一下什么是准确率，精确率和召回率。\n\n准确率（Accuracy）： 准确率是最常用的模型性能指标之一，它表示模型正确预测的样本数与总样本数之间的比例。即：(预测正确的样本数) / (总样本数)。准确率越高，表示模型的整体性能越好。\n精确率（Precision）： 精确率是针对预测为正例的样本而言的，它表示在所有预测为正例的样本中，模型正确预测为正例的比例。即：(真正例数) / (真正例数 + 假正例数)。精确率高表示模型对正例的预测较准确。\n召回率（Recall）： 召回率是针对实际为正例的样本而言的，它表示在所有实际为正例的样本中，模型正确预测为正例的比例。即：(真正例数) / (真正例数 + 假负例数)。召回率高表示模型对正例的识别能力较强。\n\n\n\n数据可视化由于鸢尾花数据集有四个特征，我们可以选择任意两个特征来进行可视化处理。\nfeature_names = ['Sepal.Length', 'Sepal.Width', 'Petal.Length', 'Petal.Width']\ntarget_names = ['setosa', 'versicolor/virginica']\n\nfig, axes = plt.subplots(nrows=3, ncols=2, figsize=(12, 15))\n\nfor idx, ax in enumerate(axes.flat):\n    i, j = idx // 2, idx % 2\n    ax.scatter(data[data['Species'] == 1][feature_names[i]], data[data['Species'] == 1][feature_names[j]], label='setosa')\n    ax.scatter(data[data['Species'] == 0][feature_names[i]], data[data['Species'] == 0][feature_names[j]], label='versicolor/virginica')\n    ax.scatter(test_features[test_target == 1][:, i+1], test_features[test_target == 1][:, j+1], marker='o', edgecolors='red', facecolors='none', label='setosa (predicted)')\n    ax.scatter(test_features[test_target == 0][:, i+1], test_features[test_target == 0][:, j+1], marker='x', color='red', label='versicolor/virginica (predicted)')\n    ax.set_xlabel(feature_names[i])\n    ax.set_ylabel(feature_names[j])\n    ax.legend()\n\nplt.tight_layout()\nplt.show()\n\n最后这一部分代码进行了数据可视化处理，使用散点图展示了不同特征组合下的分类结果。这部分代码使用了matplotlib.pyplot库，创建了6个子图，并在每个子图中绘制了鸢尾花数据集中的两个特征。蓝色的点代表’Setosa’类别，橙色的点代表’Versicolor’和’Virginica’类别。预测集的结果用红色的圆圈（’o’）表示’Setosa’类别，用红色的叉（’x’）表示’Versicolor’和’Virginica’类别。\n完整代码如下\n\nClick to see more\nimport pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score\nimport matplotlib.pyplot as plt\n\n# 1. 逻辑回归算法的代码实现\ndef sigmoid(z):\n    return 1 / (1 + np.exp(-z))\n\ndef log_likelihood(features, target, weights):\n    scores = np.dot(features, weights)\n    ll = np.sum(target * scores - np.log(1 + np.exp(scores)))\n    return ll\n\ndef logistic_regression(features, target, num_steps, learning_rate):\n    intercept = np.ones((features.shape[0], 1))\n    features = np.hstack((intercept, features))\n    weights = np.zeros(features.shape[1])\n\n    for step in range(num_steps):\n        scores = np.dot(features, weights)\n        predictions = sigmoid(scores)\n\n        output_error_signal = target - predictions\n        gradient = np.dot(features.T, output_error_signal)\n        weights += learning_rate * gradient\n\n        # Print log-likelihood every 100 steps\n        if step % 100 == 0:\n            print(f\"Step {step}, Log-Likelihood: {log_likelihood(features, target, weights)}\")\n\n    return weights\n\n# 2. 选择一个适合的二分类数据集\n# 在此示例中，我们将使用鸢尾花数据集\n\n# 3. 加载数据集并分成训练集和测试集\ndata_path = 'iris.csv' # 你的路径！！！\ndata = pd.read_csv(data_path)\n\n# 将'setosa'标记为1，其他两种花标记为0，实现二分类问题\ndata['Species'] = data['Species'].map({'setosa': 1, 'versicolor': 0, 'virginica': 0})\n\n# 提取特征和标签\nfeatures = data.drop('Species', axis=1)\ntarget = data['Species']\n\n# 分割数据集\ntrain_features, test_features, train_target, test_target = train_test_split(features, target, test_size=0.2, random_state=465)\n\n# 4. 使用训练集来训练逻辑回归模型\nnum_steps = 1000\nlearning_rate = 0.01\nweights = logistic_regression(train_features, train_target, num_steps, learning_rate)\n\n# 5. 在测试集上评估模型性能\ntest_intercept = np.ones((test_features.shape[0], 1))\ntest_features = np.hstack((test_intercept, test_features))\ntest_predictions = sigmoid(np.dot(test_features, weights))\ntest_predictions = np.round(test_predictions)\n\naccuracy = accuracy_score(test_target, test_predictions)\nprecision = precision_score(test_target, test_predictions)\nrecall = recall_score(test_target, test_predictions)\n\nprint(f\"Accuracy: {accuracy}, Precision: {precision}, Recall: {recall}\")\n\n# 6. 数据可视化处理（放到同一张图里的子图中）\n# 由于鸢尾花数据集有四个特征，我们可以选择任意两个特征来进行可视化处理。\n\nfeature_names = ['Sepal.Length', 'Sepal.Width', 'Petal.Length', 'Petal.Width']\ntarget_names = ['setosa', 'versicolor/virginica']\n\nfig, axes = plt.subplots(nrows=3, ncols=2, figsize=(12, 15))\n\nfor idx, ax in enumerate(axes.flat):\n    i, j = idx // 2, idx % 2\n    ax.scatter(data[data['Species'] == 1][feature_names[i]], data[data['Species'] == 1][feature_names[j]], label='setosa')\n    ax.scatter(data[data['Species'] == 0][feature_names[i]], data[data['Species'] == 0][feature_names[j]], label='versicolor/virginica')\n    ax.scatter(test_features[test_target == 1][:, i+1], test_features[test_target == 1][:, j+1], marker='o', edgecolors='red', facecolors='none', label='setosa (predicted)')\n    ax.scatter(test_features[test_target == 0][:, i+1], test_features[test_target == 0][:, j+1], marker='x', color='red', label='versicolor/virginica (predicted)')\n    ax.set_xlabel(feature_names[i])\n    ax.set_ylabel(feature_names[j])\n    ax.legend()\n\nplt.tight_layout()\nplt.show()\n\n# 7. 尝试调整学习率、迭代次数等参数，观察对模型性能的影响\n# 你可以尝试不同的学习率和迭代次数，观察模型在测试集上的性能变化。\n\n\n\n结论\n\n于是我们就能得到如上的图片，并且控制台打印如下：\nStep 0, Log-Likelihood: -466.2106144434709\nStep 100, Log-Likelihood: -0.36586843732581664\nStep 200, Log-Likelihood: -0.261779308423121\nStep 300, Log-Likelihood: -0.2055975355203343\nStep 400, Log-Likelihood: -0.17016379364395556\nStep 500, Log-Likelihood: -0.14565669423300498\nStep 600, Log-Likelihood: -0.12763643409226652\nStep 700, Log-Likelihood: -0.11379421631281457\nStep 800, Log-Likelihood: -0.1028071299788049\nStep 900, Log-Likelihood: -0.09386101997678553\nAccuracy: 1.0, Precision: 1.0, Recall: 1.0\n\n图片分析\n图片中的子图：在图片中的每个子图中，横轴和纵轴分别表示两个特征，点的分布代表鸢尾花数据集中的样本分布。蓝色点表示’Setosa’类别，橙色点表示’Versicolor’和’Virginica’类别。红色圆圈（’o’）表示模型预测为’Setosa’类别的样本，红色叉（’x’）表示模型预测为’Versicolor’和’Virginica’类别的样本。\n分析子图的区分度：观察每个子图中的蓝色点和橙色点的分布情况，可以看出这两类样本在这两个特征上的区分度。如果两类样本在某个特征上有明显的分离，说明该特征对分类有较强的区分能力。\n分析预测结果：观察红色圆圈和红色叉的分布情况，它们代表了模型在测试集上的预测结果。如果模型分类准确，预测为’Setosa’类别的样本应该位于蓝色点的附近，预测为’Versicolor’和’Virginica’类别的样本应该位于橙色点的附近。如果红色圆圈和红色叉分布与蓝色点和橙色点重叠较少，说明模型的预测效果较好。\n\n控制台分析从控制台打印的日志可以看出模型在训练过程中的对数似然性（Log-Likelihood）逐步增大，并在迭代次数较少时就收敛到一个较小的负值。最后，模型在测试集上的评估结果显示准确率（Accuracy）、精确率（Precision）和召回率（Recall）均为1.0，即100%。\n对于对数似然性的变化：\n\n在训练初始阶段（Step 0到Step 100），对数似然性从一个较大的负值逐渐减小，说明模型的拟合效果在改进，损失逐渐减小。\n在训练中期（Step 100到Step 500），对数似然性下降幅度较大，模型在这个阶段学习到了较多的特征权重，开始更好地拟合训练集。\n在训练后期（Step 500到Step 900），对数似然性下降速度减缓，模型接近收敛。这时候模型已经较好地拟合训练集，但仍然可能存在一些小的误差。\n\n对于评估结果：\n\n准确率、精确率和召回率均为1.0，表示模型在测试集上的分类结果完美地匹配了真实标签。准确率表示模型正确分类样本的比例，精确率表示模型预测为正类的样本中真正为正类的比例，召回率表示模型正确识别正类样本的比例。这些指标都为1.0表明模型对于’Setosa’类别的预测完全正确，没有产生误分类。\n\n综合来看，这个结果可能存在一些问题：\n\n数据集可能过于简单：鸢尾花数据集相对简单，可能存在较强的线性关系，使得逻辑回归模型能够在这个数据集上表现得很好。\n过拟合：虽然在测试集上表现良好，但模型可能在训练集上过拟合，过度拟合了训练集的特点，导致在测试集上泛化能力较差。\n\n为了更好地评估模型性能，你可以进行交叉验证和尝试使用其他复杂度较高的数据集。交叉验证能够更全面地评估模型的泛化能力，复杂度较高的数据集能够更好地反映模型在现实场景中的表现。同时，尝试调整学习率、迭代次数等超参数，观察对模型性能的影响。这样可以更全面地评估模型的性能，并找到合适的模型和参数组合。\n","slug":"Secondary-classification-of-Iris","date":"2023-07-19T10:14:24.000Z","categories_index":"","tags_index":"Machine Learning,笔记","author_index":"General_K1ng"},{"id":"4c5f4ebe8f68ff24ce30098465671f7c","title":"分类与逻辑回归","content":"在机器学习的广袤领域中，分类问题犹如一片神秘的森林，吸引着众多探险家的目光。我们可以将自己想象成一位勇敢的森林导游，带领着各种生物来到分类问题的奇妙世界。\n什么是分类问题？在这片森林中，我们将聚焦于探讨分类问题。这与我们之前遇到的回归问题有些相似，但又有所不同。在分类问题中，我们要预测的目标值只有少数几种离散取值。我们现在先专注于二分类问题，也就是只能是0或者1。就像在森林中，我们要将每个生物划分为两类，比如“可爱的小动物”和“奇怪的怪兽”。0通常被称为负类，而1被称为正类，有时也用符号“-”和“+”来表示。在训练样本中，对于每个输入，我们都有相应的标签，也被称为标签。\n分类问题是机器学习中最常见的任务之一，我们的目标是构建一个模型，能够将新的未知数据准确地分类到正确的类别中。\n这个森林中的探险涉及以下关键要素：\n\n特征（Features）：每个生物都有一组特征，描述了它们的某些属性。这些特征可以是数字、文字、图像等形式，用于描述样本的特点。\n类别（Classes）：我们的目标是将每个生物分到预先定义的类别中。这些类别可以是二元的（例如，可爱的/奇怪的、是/否）或多元的（例如，红色/蓝色/绿色、动物种类）。\n训练数据（Training Data）：我们拥有一批标记好的样本，这些样本是已知类别的数据。我们将用这些数据来训练我们的模型，让它能够学习如何进行正确的分类。\n分类器（Classifier）：作为森林导游，我们需要一个特殊的工具，帮助我们将新生物正确地分类。这个工具就是分类器，它会根据生物的特征来做出分类决策，并将其划分到最有可能的类别中。一些常见的分类器包括逻辑回归、决策树、支持向量机等。\n\n我们可以使用分类问题的技术来构建垃圾邮件过滤器、图像识别器、情感分析器等各种实用的应用。\n了解了分类问题的本质和关键要素，我们就可以自信地踏入这片神奇的森林。接下来，让我们深入研究森林中一种重要的工具——逻辑回归，帮助我们更好地了解并解决分类问题。在这次奇妙的探险中，我们将发现更多的惊喜和乐趣！:deciduous_tree:\n逻辑回归：智慧护卫的二分类大师在机器学习的世界中，逻辑回归是一位智慧而灵活的护卫，专门擅长解决二分类问题。想象一下，他是我们探险中的得力助手，帮助我们在数据的海洋中，区分出两个不同的类别。无论是判断邮件是否为垃圾邮件，预测疾病是否会发生，还是决定客户是否会购买某个产品，逻辑回归都能忠实地指引我们找到正确答案。\n逻辑回归与线性回归的区别在分类问题中，我们通常会遇到一个挑战：目标值只能取0或者1，而线性回归的模型可能会给出超过这个范围的预测结果。为了解决这个问题，逻辑回归改变了我们的模型假设，引入了一个新的假设函数。这个函数使用了一个特殊的函数，也称为逻辑函数或Sigmoid函数，来确保预测结果总是在0和1之间。\n逻辑函数（Sigmoid函数）我们可以忽略是离散值的事实，使用我们之前的线性回归算法来尝试预测给定的。然而，很容易构造出在这种方法表现非常糟糕的例子。直观地讲，当我们知道时，的取值大于1或小于0是没有意义的。\n为了解决这个问题，让我们改变我们假设的形式。我们将选择：当这被称为逻辑函数或Sigmoid函数。以下是的绘图：\n\n\n我们可以看到，当趋近于正无穷时，趋近于1，而当趋近于负无穷时，趋近于0。这样的性质让我们的预测结果总是在合理的范围内，非常适合处理分类问题。此外，，因此也包括，始终保持在0和1之间。与之前一样，我们保持了的约定，使得。\n逻辑回归的拟合在逻辑回归中，我们需要拟合参数。与线性回归一样，我们使用了最大似然估计的方法来拟合参数。这意味着我们为分类模型赋予一组概率假设，然后通过最大似然估计来找到最合适的参数，使得我们的模型能够尽可能地拟合训练数据。 :detective:\n逻辑回归的参数拟合与最大似然估计在逻辑回归中，我们已经选择了逻辑函数作为我们的激活函数，它有助于将预测结果限制在0和1之间。同时，逻辑函数的导数具有一个非常有用的性质，这对我们进行参数拟合非常重要。\n我们将其写为：\n似然性与最大似然估计为了拟合逻辑回归模型的参数，我们需要定义一个衡量拟合程度的度量，这就是似然性（Likelihood）。对于逻辑回归而言，我们可以通过最大似然估计来找到最合适的参数。\n假设我们有个训练样本，每个样本的特征为，对应的标签为，其中。我们假设这些样本是独立生成的，即每个样本的生成与其他样本无关。然后，我们就可以写出参数的似然性。\n让我们假设：请注意，这可以更紧凑地写成假设这个训练示例是独立生成的，我们可以写出参数的似然性：\n为了计算方便，我们通常取似然性的对数，得到对数似然性（Log-Likelihood）：我们的目标是最大化对数似然性，即找到能够使得训练样本出现概率最大的参数。\n梯度上升算法我们如何最大化似然性？类似于我们在线性回归的推导中所做的，我们可以使用梯度上升算法。类似于线性回归中的梯度下降算法，梯度上升算法通过迭代更新参数来逐步寻找似然性的最大值。\n在向量表示法中，我们的更新将由 给出。（请注意更新公式中的正号而不是负号，因为现在我们要最大化函数而不是最小化。）\n\n\n\n\n\n\n\n\n\n这个更新公式表示在梯度上升算法中如何更新参数。在梯度上升算法中，我们希望最大化对数似然性，因为这是参数在训练数据上的似然性。梯度表示对数似然性关于参数的梯度向量，它告诉我们在当前参数的取值下，如何调整参数的方向，才能更好地拟合训练数据。\n具体来说，是学习率，表示每次更新参数的步长。在每一次迭代中，我们将当前的参数与学习率乘以梯度相加，得到新的参数。这样，我们逐步地沿着梯度的方向更新参数，直到达到一个满意的似然性最大值或者收敛。\n让我们从只有一个训练示例开始，我们可以计算对数似然性关于参数的偏导数，得到梯度：然后，我们使用以下更新规则来更新参数：其中，是学习率，用于控制每次更新的步长。\n可能有人看不懂，就用更易懂的表达来详细讲一下：\n\nClick to see more\n假设我们只有一个训练示例，其中是输入特征，是对应的标签。我们希望通过更新参数来使得我们的模型能够更好地拟合这个示例。\n首先，我们计算对数似然性关于参数的偏导数。这里需要用到逻辑函数的导数公式。\n推导过程如下：\n\n首先，我们计算对数似然性关于的偏导数：其中，表示通过逻辑函数将映射到0和1之间的预测结果。\n\n我们可以将上述偏导数的计算过程进行解释：\n\n首先，表示实际标签与预测值之间的差异。当预测值与实际标签一致时，差异为0，表示预测准确；当预测值与实际标签不一致时，差异为非零值，表示预测错误。\n其次，是预测错误的差异的方向，表示我们需要调整参数的方向，使得预测更加准确。\n最后，表示输入特征的第个分量，表示该特征对参数的影响程度。\n\n\n根据这个偏导数的计算结果，我们可以得到随机梯度上升法则的更新公式：其中，是学习率，用于控制每次参数更新的步长。这个公式告诉我们，在每一次更新中，我们将根据预测结果与实际标签的差异，乘以输入特征的对应分量，再乘以学习率，来更新参数。\n通过这样的参数更新过程，我们逐步调整参数的取值，使得我们的模型能够更好地拟合训练示例。这样，我们就可以使用逻辑回归来解决分类问题，并取得优秀的结果。\n\n\n\n\n如果将其与LMS更新规则进行比较，我们会发现它们看起来完全一样；但这并不是同一个算法，因为现在被定义为的非线性函数。尽管如此，令人惊讶的是，对于一个相当不同的算法和学习问题，我们最终得到了相同的更新规则。这是巧合吗，还是背后有更深层次的原因？我们将在讨论广义线性模型（GLM）时回答这个问题。\n任务任务，确实，只看不练可能什么都学不会，那么问题就来了，依旧是我让GPT生成的。\n作业任务一：逻辑回归代码实现与应用任务描述：学生需要使用Python或其他编程语言实现逻辑回归算法，并应用该算法来解决一个二分类问题。\n任务步骤：\n\n编写逻辑回归算法的代码实现，包括计算逻辑函数、计算对数似然性、梯度上升算法等关键部分。\n选择一个适合的二分类数据集，可以使用公开数据集或者自己构造一个数据集。\n将数据集分成训练集和测试集。\n使用训练集来训练你实现的逻辑回归模型。\n在测试集上评估你的模型性能，计算准确率、精确率、召回率等指标。\n最好进行数据可视化处理，让结果更直观。\n可选：尝试调整学习率、迭代次数等参数，观察对模型性能的影响。\n\n\n\n\n\n\n\nTIP\n\n准确率（Accuracy）： 准确率是最常用的模型性能指标之一，它表示模型正确预测的样本数与总样本数之间的比例。即：(预测正确的样本数) / (总样本数)。准确率越高，表示模型的整体性能越好。\n精确率（Precision）： 精确率是针对预测为正例的样本而言的，它表示在所有预测为正例的样本中，模型正确预测为正例的比例。即：(真正例数) / (真正例数 + 假正例数)。精确率高表示模型对正例的预测较准确。\n召回率（Recall）： 召回率是针对实际为正例的样本而言的，它表示在所有实际为正例的样本中，模型正确预测为正例的比例。即：(真正例数) / (真正例数 + 假负例数)。召回率高表示模型对正例的识别能力较强。\n\n\n\n我们这里可以使用一些著名的数据集，比如鸢尾花数据集\n作业任务二：逻辑回归性能优化任务描述：学生需要探索不同方法来优化逻辑回归算法的性能，并比较它们的效果。\n任务步骤：\n\n研究逻辑回归算法的原理和应用场景，了解逻辑回归的优缺点。\n选择一个适合的二分类数据集，可以使用公开数据集或者自己构造一个数据集。\n将数据集分成训练集和测试集。\n使用标准的逻辑回归算法来训练模型，并在测试集上评估模型性能，计算准确率、精确率、召回率等指标。\n尝试以下优化方法，并比较它们对模型性能的影响：\n特征缩放：尝试对特征进行缩放，例如使用标准化或归一化处理。\n多项式特征：尝试使用多项式特征来增加模型的复杂度。\n正则化：尝试使用L1或L2正则化来减少过拟合问题。\n不同的损失函数：尝试使用其他损失函数，如交叉熵损失函数。\n学习率调整：尝试使用不同的学习率，并观察其对模型训练的影响。\n\n\n分析不同优化方法对模型性能的影响，讨论哪些方法对提高模型性能效果更明显。\n\n","slug":"Classification-and-logistic-regression","date":"2023-07-18T09:41:28.000Z","categories_index":"","tags_index":"Machine Learning,笔记","author_index":"General_K1ng"},{"id":"465c62620dad1684532695600a6cd19f","title":"局部加权线性回归*","content":"引言回顾最小二乘法的概率解释，我们曾深入研究过如何通过最小化误差的平方和，寻找最佳的模型参数。这个方法的确非常强大，但有时候我们需要更加灵活和精确的工具来解决特定的问题。\n于是，引入局部加权线性回归（Locally Weighted Linear Regression）。这个方法可以被视为我们探险旅程中的一把望远镜，帮助我们看到更加微妙的模式和趋势。它以一种非常独特的方式，通过为每个数据点赋予一定的权重，使得我们的模型更加关注那些在当前预测点附近的样本。\n这里的”局部加权”，就好像是一把神奇的放大镜，它能够放大我们感兴趣的那些数据点，并且根据它们的特点，为我们提供一种个性化的预测模型。无论是在金融领域，医疗研究，还是天气预测，局部加权线性回归都能够以其独特的魅力，帮助我们更好地理解和解决问题。\n这就像是在一片茂密的丛林中，我们只专注于离我们最近的树木和植被，而忽略了远处的景象。局部加权线性回归带给我们的是一种局部敏感性，使我们能够更加准确地预测和理解数据的变化。\n局部加权线性回归（LWS）欠拟合与过拟合考虑一个让我们一起探索的有趣问题：如何从输入预测输出呢？这就是我们今天要聊的局部加权线性回归（LWR）算法啦！想象一下，我们置身于一个神奇的数据世界中，我们希望找到一种方法，能够让我们的模型更好地适应这些数据点。\n嘿，看看这张魔法般的图片吧！最左边的图展示了我们试图通过一条直线去拟合这些数据点的情况。可是，你有没有发现，这些点并不完全落在这条线上呢？是不是感觉有些不太对劲？没错，这就是我们所谓的欠拟合。这位可爱的小模型童鞋似乎没有完全抓住数据中的结构，留下了一些没被捕捉到的东西。\n\n\n于是，我们心生了一个奇妙的想法：如果我们再加上一个特征，试试拟合这样的模型，会发生什么呢？嗯嗯，看中间的图，你会发现拟合效果好像稍微好了一些。看起来添加更多的特征会让拟合效果变得更好，是不是有些开心呢？但是，小心别太过头哦！右边的图就展示了一个过拟合的例子，我们使用了一个5阶多项式去拟合这些数据。看起来，尽管拟合曲线完全通过了数据点，但它在对不同房屋面积预测房价方面的表现可能并不好。所以，记住了，过于贪心可不是好事哦！\n权重好啦，让我们稍微放慢脚步，先来简单介绍一下局部加权线性回归（LWR）算法吧！想象一下，当我们拥有足够多的训练数据时，特征的选择变得不那么重要了。这里，LWR算法就是我们的小助手，帮助我们更好地拟合数据。虽然我们只是稍微提一下，但是不要担心，在后面的作业中，你将有机会深入探索LWR算法的一些特性。\n在传统的线性回归算法中，要在查询点处进行预测（也就是评估），我们会按照以下步骤进行：\n\n通过最小化来拟合参数。\n将作为我们的预测结果输出。\n\n然而，在局部加权线性回归算法中，我们将迈出一小步，踏入了一个可爱而神奇的世界。请跟紧我，我们一起看看LWR算法的魔法步骤：\n\n通过最小化来拟合参数。\n将作为我们的预测结果输出。\n\n在这里，是非负权重值。直观地说，如果对于特定的，很大，那么在选择时，我们会努力使尽可能小。如果很小，那么在拟合中，的误差项将被忽略。\n那么，如何确定这些神奇的权重呢？一个非常常见的权重选择方式是：\n\n\n\n\n\n\n\n\n\n如果x是向量值的，这个公式可以推广为或者，其中或的选择适当。\n请注意，权重值取决于我们希望预测的特定点。而且，如果很小，那么会接近1；如果很大，那么就会很小。所以，我们可以说，对于与查询点相近的训练样本，我们赋予它们更高的“权重”，而离查询点更远的样本则具有较低的“权重”。真是一种魔法般的思想！\n还要注意的是，虽然权重公式在形式上类似于高斯分布的密度函数，但与高斯分布并没有直接的关联，特别是不是一个随机变量，无论它是否服从正态分布或其他分布。（这是一种可爱的小魔法，不是吗？）\n带宽参数控制着训练样本权重随其与查询点之间距离的衰减速度。你知道吗？这个就是我们所说的带宽参数，它也是你在后面任务中将要实验的内容之一。它决定了魔法的强弱程度！\n现在，我们已经见识了第一个非参数算法的例子，它就是局部加权线性回归。相比之下，之前我们接触的（无权重的）线性回归算法被称为参数学习算法，因为它具有一组固定的有限参数（），这些参数与数据进行拟合。一旦我们拟合了参数并将它们存储起来，我们就不再需要保留训练数据来进行未来的预测。\n但是，和LWR不同哦！为了使用局部加权线性回归进行预测，我们需要保留整个训练集。这就是所谓的非参数，因为为了表示假设，我们需要存储与训练集规模成线性增长的信息量。\n特点LWR算法的魔力之一在于它的灵活性和适应性。它不仅仅是一个固定的模型，而是根据数据的特点和查询点的需求，为每个预测问题个性化地构建模型。这就像我们有一位聪明的小精灵，他根据数据的不同部分，以及与查询点的距离，灵活地调整预测模型，以获得最佳的结果。\n嗯，你或许会问，为什么要引入这种灵活性呢？这是因为在现实世界中，我们经常面对各种各样的数据模式和问题。有时，数据可能在某个区域内呈现出线性关系，而在另一个区域则呈现出非线性关系。有时，我们对于某些区域的预测更加关注，希望能够更准确地捕捉到那些重要的点。这时，LWR算法就展现出了它的独特优势。\n让我们回到我们的探险之旅。在LWR算法中，带宽参数起着至关重要的作用。这个参数控制着样本权重随其与查询点之间距离的衰减速度。想象一下，如果我们选择一个较小的，那么只有离查询点非常近的训练样本才会受到较高的权重，而离查询点较远的样本则会受到较低的权重。这就好像我们的小精灵更注重那些距离查询点更近的样本，认为它们对于预测更加重要。\n另一方面，如果我们选择一个较大的，那么样本的权重衰减速度将变得较慢，离查询点较远的样本仍然会有较高的权重。这就好像我们的小精灵更加关注整体的数据趋势，不过仍然保留了远离查询点的样本的影响。\n嘿，还记得我们之前提到的权重选择公式吗？，这是一个非常常见的选择。但也请注意，这只是一个示例，实际上还有其他的权重选择方式，可以根据具体问题进行调整和探索。\n我知道你一定迫不及待地想要实践一下LWR算法了。在接下来的作业中，你将有机会亲自尝试不同的带宽参数，并观察它对预测结果的影响。这将帮助你更好地理解LWR算法的运作原理和特性。\nLWR算法步骤LWR算法的执行包括以下步骤：\n\n拟合参数θ：通过最小化加权误差来拟合参数。这里，是一个非负的权重值，用于调整每个训练样本在拟合过程中的重要性。\n预测：使用得到的参数对新的查询点进行预测。计算，将其作为我们的预测结果输出。\n\n在这里，我们将通过逐步展开这些步骤，深入了解每个步骤的细节和原理。\n拟合参数在LWR算法中，拟合参数的关键在于最小化加权误差。这里的权重决定了每个训练样本的重要性，进而影响参数的拟合过程。\n要拟合参数，我们需要选择合适的权重。在LWR中，一个常见的权重选择方式是使用高斯核函数，就是刚刚我们见到的：复习一下，在这个公式中，是第个训练样本的特征值，是查询点的特征值，是带宽参数。这个公式的作用是根据查询点与训练样本之间的距离，赋予每个训练样本一个权重值。距离越近的样本将具有较高的权重，对参数的拟合起到更大的影响；而距离较远的样本则具有较低的权重，对参数的拟合影响较小。\n这里，带宽参数起着关键的作用。它决定了权重随着距离的衰减速度。较小的会导致权重衰减较快，只有距离查询点较近的样本会对参数拟合产生较大的影响；而较大的会导致权重衰减较慢，距离查询点较远的样本仍然具有较高的权重。\n为了拟合参数，我们可以使用各种数值优化方法，如梯度下降或正规方程法。在优化过程中，我们使用加权误差作为目标函数，并根据权重对样本进行加权。\n预测一旦我们拟合了参数，我们就可以使用它来对新的查询点进行预测。预测的过程非常简单，我们只需计算，并将其作为我们的预测结果输出。\n这个预测过程可以看作是使用已经拟合好的参数对新的输入进行线性组合的过程。通过将参数与特征值进行线性组合，我们得到了我们对于新查询点的预测结果。\n通过拟合参数和预测过程，LWR算法为我们提供了一种灵活而强大的方式来适应不同的数据模式和预测需求。它允许我们个性化地构建模型，并根据查询点的特征和数据的分布情况进行个性化的预测。\n任务这个任务是我让GPT给出来的，因为毕竟在斯坦福原有的课程当中，这节课选修课，我也没找到作业在哪（其实是我懒）。。。TT\n任务1：调整带宽参数在这个作业中，你将尝试调整带宽参数，并观察其对LWR算法的影响。你可以选择一些不同的值，比如0.1、1、10，并进行如下实验：\n\n对于每个值，使用LWR算法进行参数拟合，并得到相应的参数。\n使用得到的参数对测试集中的样本进行预测，并计算预测结果的均方误差（Mean Squared Error）。\n观察不同值下的预测结果和均方误差之间的关系。\n\n通过这个作业，你将能够理解带宽参数对LWR算法的影响。较小的值会导致模型更关注查询点附近的训练样本，可能会出现过拟合的情况；而较大的值则会使模型更加关注整体的数据趋势，可能会出现欠拟合的情况。你可以通过观察均方误差来评估不同值下模型的性能。\n这个任务我写了个小程序，有python环境的可以尝试一下：\n\nClick to see more\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.datasets import make_regression\nfrom sklearn.model_selection import train_test_split\n\ndef compute_weights(X_train, x, tau):\n    # 计算权重值\n    weights = np.exp(-(np.linalg.norm(X_train - x, axis=1) ** 2) / (2 * tau ** 2))\n    return weights\n\ndef fit_lwr(X_train, y_train, x, tau):\n    # 拟合参数θ\n    X = np.hstack((np.ones((X_train.shape[0], 1)), X_train))  # 添加常数项\n    weights = compute_weights(X_train, x, tau)\n    W = np.diag(weights)\n    theta = np.linalg.inv(X.T @ W @ X) @ X.T @ W @ y_train\n    return theta\n\ndef predict_lwr(X_train, y_train, X_test, tau):\n    predictions = []\n    for x in X_test:\n        theta = fit_lwr(X_train, y_train, x, tau)\n        x = np.hstack(([1], x))  # 添加常数项\n        y_pred = theta.T @ x\n        predictions.append(y_pred)\n    return np.array(predictions)\n\n# 生成示例数据集\nX, y = make_regression(n_samples=100, n_features=1, noise=10, random_state=42)\n\n# 划分数据集\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# 设置不同的带宽参数\ntau_values = [0.1, 1, 10]\n\n# 绘制数据集和拟合结果的图像\nplt.figure(figsize=(12, 8))\n\nfor i, tau in enumerate(tau_values):\n    plt.subplot(2, 2, i+1)\n\n    # 绘制训练数据集\n    plt.scatter(X_train, y_train, color='b', label='Training Data')\n\n    # 拟合参数θ\n    theta = fit_lwr(X_train, y_train, X_train, tau)\n    print(f\"带宽参数τ = {tau}，拟合得到的参数θ：{theta}\")\n\n    # 预测并计算均方误差\n    y_pred = predict_lwr(X_train, y_train, X_test, tau)\n    mse = np.mean((y_pred - y_test) ** 2)\n    print(f\"带宽参数τ = {tau}，测试集上的均方误差：{mse}\\n\")\n\n    # 绘制拟合曲线\n    x_plot = np.linspace(np.min(X_train), np.max(X_train), 100)\n    X_plot = np.hstack((np.ones((x_plot.shape[0], 1)), x_plot.reshape(-1, 1)))\n    y_plot = X_plot @ theta\n    plt.plot(x_plot, y_plot, label=f\"τ = {tau}\")\n\n    plt.xlabel('X')\n    plt.ylabel('y')\n    plt.legend()\n    plt.title(f'Local Weighted Linear Regression (τ = {tau})')\n\nplt.tight_layout()\nplt.show()\n\n\n这段代码首先使用make_regression函数生成一个示例数据集，（运用了种子来进行随机数据集，便于复现），然后使用train_test_split将数据集划分为训练集和测试集。\n然后，compute_weights函数用于计算权重值，fit_lwr函数用于拟合参数，predict_lwr函数用于进行预测。\n在主程序中，我们设置了不同的带宽参数值[0.1、1、10]，然后对每个参数值进行拟合和预测。最后，我们计算并输出每个参数值下测试集上的均方误差。\n使用了plt.subplot函数来创建一个2x2的子图布局，并在每个子图中绘制不同带宽参数下的拟合结果。每个子图显示了训练数据集的散点图和相应的拟合曲线。\n图像如下\n\n\n你可以根据实际情况修改代码，使用自己的数据集和问题进行实验。通过观察不同带宽参数下的拟合效果和预测误差，你将能够更好地理解带宽参数对LWR算法的影响。\n\n\n作业2：应用LWR算法解决实际问题在这个作业中，你将应用LWR算法解决一个实际的问题。你可以选择感兴趣的领域，如房价预测、销量预测等，并按照以下步骤进行：\n数据集可以用我们之前用过的房价数据集，我放到这里：\n\nClick to see more\n# 数据集\nareas = np.array([2104, 1600, 2400, 1416, 3000, 1985, 1534, 1427, 1380, 1494, 1940, 2000, 1890, 4478, 1268, 2300, 1760, 1450, 3100, 2250, 2132, 2596, 1850, 2680, 1956, 1604, 2020, 2730, 2008, 1537, 2500, 1560, 2120, 2200, 1638, 2540, 2200, 2070, 2005, 1900, 2380, 1320, 2190, 2340, 2678, 1966, 1570, 1852, 2454, 2205, 2450])\nbedrooms = np.array([3,3,3,2,4,4,3,3,3,3,4,3,3,5,3,4,3,3,4,4,4,3,4,4,3,3,4,4,3,3,4,4,4,3,3,4,3,4,3,3,4,2,4,3,4,4,3,3,4,4,4])\nprices = np.array([400, 330, 369, 232, 540, 320, 267, 199, 245, 347, 334, 383, 339, 699, 259, 410, 350, 315, 590, 410, 399, 459, 325, 480, 349, 285, 365, 525, 375, 295, 450, 280, 389, 425, 315, 475, 408, 382, 350, 380, 420, 230, 394, 416, 540, 385, 279, 360, 485, 405, 450])\n\n\n\n\n收集和准备数据集：选择一个合适的数据集，并对数据进行预处理，确保数据的质量和一致性。\n划分数据集：将数据集划分为训练集和测试集，用于参数拟合和模型评估。\n使用LWR算法进行参数拟合：根据训练集使用LWR算法拟合参数。\n模型评估：使用测试集进行模型评估，计算预测结果的均方误差或其他适当的评估指标。\n结果分析和改进：分析预测结果，并根据需要对模型进行改进和调整。\n\n通过完成这个作业，你将能够将LWR算法应用到实际问题中，并通过实践加深对算法的理解。你可以探索不同的数据集和问题领域，进一步挖掘LWR算法的潜力。\n","slug":"Locally-weighted-linear-regression-optional-reading","date":"2023-07-17T07:42:47.000Z","categories_index":"","tags_index":"Machine Learning,笔记","author_index":"General_K1ng"},{"id":"85691702e05d151e003d7396dcbea440","title":"概率解释*","content":"引言当涉及到机器学习算法时，有时我们不仅仅希望通过数学的角度来理解它们的原理，还希望探索它们的概率解释。在这个部分中，我们将探讨线性回归算法的概率解释。\n你有没有想过，为什么我们在回归问题中使用平方误差作为成本函数？为什么我们假设模型的预测值和真实值之间存在高斯分布的误差？通过概率解释，我们可以更深入地理解线性回归模型的工作原理，并从统计学的角度来看待它。\n当我们谈论概率解释时，让我们以一个简单易懂的例子来说明。假设你是一位面包师傅，你烘焙面包的时间和温度是你最关注的因素。你想要根据面包的温度来预测它的烘焙时间。\n现在，假设你已经收集了一些数据，包括了面包的温度和相应的烘焙时间。你想要建立一个模型，根据温度来预测烘焙时间。这就是一个典型的线性回归问题。\n现在，让我们用概率解释来理解这个问题。我们可以将线性回归模型看作是在给定面包温度的条件下，对烘焙时间的条件分布进行建模。换句话说，我们想要找到一个条件分布，它告诉我们在已知温度的情况下，烘焙时间可能的取值范围。\n通过概率解释，我们可以得到一个关键的洞察力：我们不仅仅是在寻找一个点估计，即给定温度预测单个烘焙时间，而是在寻找一个整个概率分布，它表示了在给定温度下烘焙时间的不确定性。\n这种概率解释对于面包师傅来说非常有用。它不仅告诉你在给定温度下的预测烘焙时间，还告诉你该预测的不确定性范围。这样，你就可以更加自信地做出决策，控制烘焙时间，确保面包在最佳状态下烘焙。\n所以，通过概率解释，线性回归模型不仅可以帮助你做出预测，还可以提供预测的不确定性估计，使你更加有信心地应对面包烘焙的挑战。这就是概率解释为我们带来的额外好处。\n概率解释在面对回归问题时，为什么线性回归，尤其是最小二乘成本函数 ，是一个合理的选择呢？让我们通过一组概率假设来解释这一点，根据这些假设，最小二乘回归可以被推导为一种非常自然的算法。\n我们假设目标变量和输入之间存在以下关系：其中  是一个误差项，用于捕捉未建模的影响（例如，我们没有在回归中包含与预测房价高度相关的某些特征）或者随机噪声。我们进一步假设  是独立同分布（IID）地遵循均值为零、方差为  的高斯分布（也称为正态分布）。我们可以表示这个假设为 “”，即  的概率密度函数为：\n\n\n\n\n\n\n\n\n\n在机器学习和数学中，exp 表示指数函数，即自然指数函数，记作 ，其中  是自然对数的底数（欧拉数，约等于2.71828）。指数函数是一个常用的数学函数，它的定义是将底数  提升到给定的指数值。\n在上述笔记中，exp 是将指数函数应用于括号内的表达式。例如，在计算高斯分布的概率密度函数时，指数函数被用于计算  这个指数部分。\n指数函数具有将非负实数映射到正实数的特性，它在概率密度函数和其他数学模型中经常被使用，例如高斯分布、指数分布等。\n因此，我们可以表示给定  和由参数  控制的  的分布为：这表示了  在给定  的条件下，根据参数  的分布。需要注意的是，我们不应将  视为条件概率  的一部分，因为  不是一个随机变量。我们还可以将  的分布写为 。\n在给定 （设计矩阵，包含所有 ）和  的情况下， 的整体分布是什么样的？数据的概率由  给出。这个量通常被视为 （以及可能的 ）的函数，对于固定的  值。当我们希望明确将其视为  的函数时，我们将其称为似然函数：根据对 （从而对给定的  和 ）的独立性假设，我们还可以将其写成如下形式：现在，考虑到这个将  和  关联的概率模型，我们应该以何种方式合理地选择参数  来获得最佳估计？最大似然原理指出，我们应该选择能够使数据的概率最大化的 。换句话说，我们应该选择能够最大化  的 。\n与最大化  等价的是最大化  的任何严格递增函数。特别地，如果我们转而最大化对数似然函数 ，推导会更加简单：：因此，最大化  得到与最小化相同的结果：我们将这个结果记为 ，也就是最初的最小二乘代价函数。\n总结一下，在数据的先验概率假设下，最小二乘回归对应于找到参数  的最大似然估计。因此，在这种假设下，最小二乘回归可以被认为是一种非常自然的方法，它只是在进行最大似然估计而已。（需要注意的是，概率假设并不是使得最小二乘成为完全合理和恰当的过程所必需的，还可能存在其他自然的假设可以用来证明它的合理性。）\n此外，根据我们之前的讨论，我们的最终  的选择并不依赖于  的值，实际上，即使  是未知的，我们也会得到相同的结果。当我们讨论指数族和广义线性模型时，我们将再次利用这一事实。\t\n举例说明假设你正在研究房屋价格与其尺寸之间的关系。你收集了一些房屋的尺寸和实际售价的数据，并希望使用机器学习来构建一个预测模型。在这种情况下，你可以使用最小二乘回归作为你的算法，并通过概率解释来理解它的合理性。\n根据概率解释，我们假设房屋价格与尺寸之间的关系可以通过以下方程表示：其中  是第  个房屋的实际售价， 是对应的尺寸特征， 是我们要学习的参数，而  则表示误差项。\n根据概率假设，我们假设误差项  是从均值为零、方差为  的高斯分布中独立同分布地抽样得到的。这意味着我们认为误差是随机的，并且服从正态分布。这个假设可以让我们使用概率密度函数来描述误差项的分布情况。\n现在，我们可以根据这个概率模型来定义给定  的条件下， 的分布：这表示给定  的情况下， 的分布是一个以  为均值、 为方差的高斯分布。\n我们的目标是找到使得观测到的数据的概率最大化的参数 。也就是说，我们希望选择参数 ，使得数据的整体概率  最大化。\n根据最大似然估计的原理，我们可以通过最大化似然函数  或对数似然函数  来获得最佳参数估计。在最小二乘回归中，我们常使用对数似然函数来简化推导。\n通过计算对数似然函数 ，我们可以将最大似然估计转化为最小化残差平方和的问题，即最小化代价函数 ：这刚好是最小二乘回归中使用的成本函数。\n因此，根据概率解释，最小化最小二乘成本函数  相当于在给定概率模型的前提下，寻找参数  的最大似然估计。这说明了最小二乘回归的合理性和自然性。\n补充当使用最小二乘法进行机器学习中的回归任务时，并不需要对概率解释的细节了如指掌。嗯，你没听错，概率解释并不是机器学习中的“铁板钉钉”。\n实际上，对于许多问题来说，最小二乘法就足够了，它能够给出很好的结果，而不需要我们费神去琢磨概率解释的种种细节。毕竟，最小二乘法是机器学习中非常常见且有效的方法。\n但是，不可否认的是，在某些情况下，了解概率解释和统计学原理是很有帮助的。特别是当你处理带有噪声的数据时，概率解释可以告诉你模型的不确定性和置信度。这样一来，你就能更好地理解和解释你的模型结果了。\n总而言之，了解最小二乘法是机器学习中的重点，而对概率解释的深入探究则是可选的。如果你只是想简单地应用最小二乘法来完成回归任务，那了解一些基本的原理和实现就足够了。当然，如果你对概率解释和统计学概念感兴趣，那么对于某些特定问题来说，深入研究概率解释会给你带来更深入的理解和分析能力。\n","slug":"Probabilistic-interpretation","date":"2023-07-17T06:02:56.000Z","categories_index":"","tags_index":"Machine Learning,笔记","author_index":"General_K1ng"},{"id":"8bd50a6b3cea7ecea2a8063e70b7409b","title":"正规方程","content":"引入在机器学习和线性回归中，我们经常需要通过训练数据来学习参数，以便建立一个能够准确预测目标变量的模型。前面我们已经介绍了梯度下降法，这是一种常用的优化算法，可以帮助我们找到最小化成本函数的参数值。\n除了梯度下降法，还有一种有趣而简洁的方法可以解决线性回归问题，它被称为正规方程（The Normal Equations）。正规方程提供了一种通过代数方法直接求解最优参数的方式，而不需要像梯度下降法那样迭代更新。\n让我们以一个生动的例子来理解正规方程。假设你是一名厨师，你想要制作一道美味的蛋糕。你知道蛋糕的味道取决于配料的种类和数量。你希望找到一个最佳的配料组合，使得蛋糕的口感和味道达到最佳。\n为了解决这个问题，你决定进行一系列实验。你准备了不同数量和种类的配料，并且每次制作蛋糕后，让一群品尝师评价蛋糕的口感。你记录下每个实验中使用的配料种类和数量，以及对应的评分。\n现在，你的目标是通过这些实验数据，找到一种最佳的配料组合，以获得最佳的蛋糕口感。你想要建立一个线性模型，通过配料的数量和种类预测口感评分。这个问题就可以转化为一个线性回归问题。\n正规方程提供了一种直接求解线性回归参数的方法。它的原理类似于代数方程的求解过程。通过对训练数据进行数学运算，我们可以得到一个公式，可以直接计算出最优的参数值。\n正规方程不需要像梯度下降法那样进行迭代更新，因此在某些情况下，它可能更加高效。然而，正规方程也有一些限制，例如当特征数量非常大时，计算复杂度会增加。\n在接下来的部分，我们将详细介绍正规方程的原理和应用。正规方程为我们提供了一种有趣而直接的方式来解决线性回归问题，让我们一起探索吧！\n正规方程正规方程是一种通过代数方法直接求解线性回归参数的方法，而不需要像梯度下降法那样进行迭代更新。它的原理是通过最小化成本函数，找到使得预测值与实际值之间差异最小的参数值。\n为了理解正规方程的原理，让我们再回到蛋糕制作的例子。你已经进行了一系列实验，记录了不同配料组合的口感评分。现在，你想要找到最佳的配料组合，使得蛋糕的口感评分最高。\n回忆一下线性回归模型的表示形式：。我们的目标是找到一组最优的参数，使得尽可能接近实际的口感评分。\n我们定义成本函数来衡量预测值与实际值之间的差异。对于线性回归问题，我们通常使用平方差误差（SSE）作为成本函数，即，其中是训练样本的数量。\n现在，我们的目标是找到最优的参数，使得成本函数最小化。而正规方程就提供了一种求解最优参数的解析解。具体来说，我们通过对关于参数的导数进行求解，并将其设置为零来最小化。\n在进行矩阵表示时，我们将训练样本的特征向量表示为矩阵，其中每一行代表一个样本的特征，每一列代表一个特征维度。类似地，我们将实际值表示为向量。那么，线性回归模型可以写成矩阵形式：。\n应用矩阵微积分的概念，我们可以求解成本函数关于参数的导数。这个导数称为梯度（gradient），用表示。当梯度为零时，我们得到正规方程的解。\n通过代数计算，我们可以得到正规方程的表达式：。这个表达式直接给出了最优参数的解析解。\n正规方程的优点在于它不需要进行迭代更新，可以直接得到最优参数的解析解。然而，它的计算复杂度取决于特征的数量，当特征数量非常大时，求解逆矩阵的计算可能变得耗时。\n在实际应用中，我们可以根据问题的特点选择使用梯度下降法还是正规方程。梯度下降法适用于大规模数据集和高维特征空间，而正规方程适用于小规模数据集和低维特征空间。\n矩阵导数矩阵导数是矩阵微积分中的重要概念，用于描述函数对矩阵变量的导数。在矩阵导数中，我们将函数从一个行列的矩阵映射到实数，定义为。为了求解矩阵导数，我们需要计算函数相对于矩阵的偏导数。矩阵导数本身也是一个行列的矩阵，其中元素表示函数对的偏导数。\n例如，假设是一个2行2列的矩阵，函数：定义为：在这个例子中，表示矩阵的元素。\n我们可以通过计算偏导数来得到矩阵导数的表达式。根据定义，我们计算对每个的偏导数，然后将它们组合成矩阵的形式。对于我们的例子，我们可以得到如下结果：这个结果展示了矩阵导数的计算方式。每个元素都是相应偏导数的结果。例如，元素是对的偏导数，元素是对的偏导数，以此类推。\n最小二乘法再探讨借助矩阵导数的工具，现在让我们通过闭式解来找到使最小化的的值。我们首先将用矩阵-向量表示法重新书写。\n给定一个训练集，定义设计矩阵为一个行列的矩阵（实际上是行列，如果我们包括截距项），其行包含训练示例的输入值：此外，让是一个维向量，包含来自训练集的所有目标值：现在，由于，我们可以很容易地验证：因此，利用向量的性质，我们有 ：最后，为了最小化，让我们找到它相对于的导数。因此，我们有：在第三步中，我们使用了的事实，在第五步中使用了和的事实，其中是对称矩阵。为了最小化，我们将其导数设为零，得到正规方程：因此，最小化的值可以通过以下方程的闭式解给出：\n\n\n\n\n\n\n\n\n\n请注意，在上述步骤中，我们隐含地假设是可逆矩阵。在计算逆矩阵之前，可以进行检查。如果线性无关的样本数量少于特征数量，或者特征不是线性无关的，则将不可逆。即使在这种情况下，也有可能通过额外的技术来“修正”这种情况，但为了简洁起见，我们在这里省略了这些内容。\n举例我们再回到最开始那个做烘焙的例子，假设你是一位厨师，想要研究面包的烘焙时间和温度之间的关系。你收集了一系列实验数据，记录下了烘焙时间和使用的温度。现在，你想要找到一个数学模型来预测未来的烘焙时间。这时，线性回归和最小二乘法就能派上用场了。\n现在，让我们使用矩阵导数的工具来重新表达成本函数。首先，我们定义设计矩阵，它是一个行列的矩阵，其中每一行包含一个实验样本的特征值（在我们的例子中就是温度）。我们还定义目标向量，它是一个维向量，包含对应每个实验样本的烘焙时间。\n我们收集了一些数据，记录了不同温度下烘焙面包所需的时间。现在我们要使用这些数据来训练一个线性回归模型，以便我们可以根据温度来预测烘焙时间。\n首先，让我们创建一个虚构的数据集（这是我用程序随机生成的）。假设我们有以下数据：\n\nClick to see more\n\n\n\n温度（摄氏度）\n烘焙时间（分钟）\n\n\n\n168.7\n41.4\n\n\n197.5\n52.2\n\n\n186.6\n45.0\n\n\n179.9\n43.7\n\n\n157.8\n42.8\n\n\n157.8\n32.0\n\n\n152.9\n31.9\n\n\n193.3\n45.8\n\n\n180.1\n41.0\n\n\n185.4\n48.7\n\n\n\n\n\n\n\n\n现在，我们将数据表示为输入特征矩阵和目标变量向量。是一个包含温度特征的矩阵，是对应的烘焙时间。\n接下来，我们将为矩阵添加截距项列。这样，矩阵的第一列将始终为1，以表示截距(intercept)。\n现在，我们可以使用正规方程来求解参数。正规方程的公式为：\n这个公式会给出使得模型最优拟合数据的参数值。\n控制台会输出：\nIntercept: -19.32\nSlope: 0.35\n\n\n\n\n\n为了应用这个公式，我们需要使用Python进行计算。我们可以使用NumPy库来进行矩阵运算。让我们来看看如何在Python中计算正规方程的闭式解：\n\nClick to see more\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nnp.random.seed(42)  # 设置随机种子，以便结果可复现\n\n# 创建输入特征 X（温度）和目标变量 y（烘焙时间）\nX = np.random.uniform(150, 200, 10).reshape(-1, 1)  # 温度范围在150到200之间\ny = 10 + 0.2 * X + np.random.normal(0, 5, 10).reshape(-1, 1)  # 烘焙时间=10 + 0.2*温度 + 噪声\n\n# 添加截距项列（全为1）到 X 矩阵中\nX = np.concatenate((np.ones((X.shape[0], 1)), X), axis=1)\n\n# 计算参数 theta\ntheta = np.linalg.inv(X.T @ X) @ X.T @ y\n\nintercept = theta[0][0]\nslope = theta[1][0]\nprint(f\"Intercept: {intercept:.2f}\")\nprint(f\"Slope: {slope:.2f}\")\n\n\n# 绘制数据点\nplt.scatter(X[:, 1], y, label=\"Data\")\n\n# 绘制拟合的线性回归模型\nx_line = np.linspace(150, 200, 100)\ny_line = intercept + slope * x_line\nplt.plot(x_line, y_line, color=\"red\", label=\"Linear Regression\")\n\n# 添加标签和图例\nplt.xlabel(\"Temperature\")\nplt.ylabel(\"Baking Time\")\nplt.legend()\n\n# 显示图形\nplt.show()\n\n\n\n\n运行这段代码，我们会得到参数的值。在这个例子中，我们会得到两个参数：截距项参数和温度参数。这些参数表示烘焙时间与温度之间的线性关系。\n一旦我们求解出参数，我们就可以使用它来进行预测。给定一个新的温度值，我们可以通过计算来预测对应的烘焙时间。\n这节的内容会比较难以理解，希望可以反复阅读，如有疑问欢迎提出，说实话，我都有些没看懂。\n","slug":"The-normal-equations","date":"2023-07-17T04:09:05.000Z","categories_index":"","tags_index":"Machine Learning,笔记","author_index":"General_K1ng"},{"id":"eee27f691084ae51bee755f5fe41f548","title":"LMS算法","content":"欢迎来到新的一部分！现在我们将介绍一种非常有趣的算法，它被称为最小均方（Least Mean Squares，LMS）算法。这是一种用于优化线性回归模型的算法，它可以帮助我们找到最佳的参数组合，使得我们的预测结果与实际观测值之间的差异最小化。\nLMS算法实际上是一个非常聪明的算法，它的灵感来自于我们人类在学习过程中的一种思维方式。想象一下，当你在学习骑自行车或者学习弹吉他时，你并不会一次就掌握所有技巧。相反，你会不断地试验、调整和改进，直到你的动作越来越接近完美。\nLMS算法的原理也是类似的。它通过逐步调整模型的参数来最小化成本函数，就像我们逐步调整我们的动作来提高技能一样。在每一步中，LMS算法会计算出当前参数设置下的成本函数值，并根据这个值来调整参数，以便使下一次迭代的预测结果更接近实际观测值。这个过程就像是在不断地微调模型，让它的预测能够更准确地拟合实际数据。\n一个有趣的比喻是，想象你是一名音乐家，正在调音吉他。你会先弹奏一根弦，然后通过调整琴弦的张力来使音高趋近于理想的音高。LMS算法的工作方式类似于这个过程，它会在每一步中微调模型的参数，使得预测结果逐渐接近实际观测值，就像音高逐渐趋近理想音高一样。\nLMS算法是一种非常强大和常用的优化算法，特别适用于解决线性回归问题。它不仅可以用于预测骑行时间，还可以应用于各种其他领域，如金融、医疗和天气预测等。通过不断地微调参数，LMS算法帮助我们找到最佳的模型参数，使我们的预测结果更加准确和可靠。\nLMS算法我们继续探讨LMS算法！让我们首先回顾一下我们的目标：选择合适的参数来最小化成本函数。为了实现这一目标，我们需要一个搜索算法，该算法从一个”初始猜测”开始选择，然后通过迭代改变以使逐渐变小，直到我们收敛到使最小化的值。\n\n\n\n\n\n\n\n\n\n我们使用符号“a := b”来表示一种操作（在计算机程序中），该操作将变量a的值设置为等于变量b的值。换句话说，这个操作会用b的值覆盖a的值。相反，当我们在断言一个事实时，即a的值等于b的值，我们会写成“a = b”。\n那么，我们如何在每次迭代中更新参数呢？这就是LMS算法的精髓所在。它使用一种称为梯度下降的方法，以最陡的下降方向更新参数。具体而言，在每次迭代中，我们将参数更新为，其中是学习率。\n为了更好地理解LMS算法的更新规则，让我们以一个简单的例子来说明。假设我们只有一个训练样本，其中是我们的输入特征，是对应的目标值。我们的目标是根据输入预测出目标值。我们将使用线性模型来进行预测。\n这是一个非常自然的算法，它重复地朝着最陡的下降方向迈出一步。为了实现这个算法，我们需要计算出右侧的偏导数项。让我们首先计算出在只有一个训练样本的情况下的结果，这样我们就可以忽略的定义中的求和符号。为了更新参数和，我们需要计算成本函数对于每个参数的偏导数。通过计算，我们得到偏导数的表达式为：。这表明参数的更新量与误差项成比例，以及输入特征。根据这个结果，我们可以得到LMS算法的更新规则：这个规则被称为LMS更新规则（LMS代表“最小均方差”），也被称为Widrow-Hoff学习规则。这个规则具有几个看起来自然而直观的特性。例如，更新的幅度与误差项成比例；因此，例如，如果我们遇到一个训练样本，我们的预测几乎与的实际值相匹配，那么我们发现几乎不需要改变参数；相反，如果我们的预测与有较大的误差（即相距较远），那么参数将会有较大的变化。\n梯度下降法当我们使用机器学习算法解决问题时，经常需要最小化一个函数。梯度下降法（Gradient Descent）是一种常用的优化算法，用于找到函数的最小值。\n让我们通过一个生动的例子来解释梯度下降法。假设你是一位登山爱好者，目标是从山顶下到山脚的最短路径。你置身于山顶，但是你没有任何线索告诉你应该往哪个方向走。你面前一片云雾茫茫，你看不到山脚。然而，你手上有一个高度计可以告诉你当前的海拔高度。\n你的目标是找到一条最快的下山路径。你知道山的地形图呈现出一种斜率或坡度。你也知道下山的最陡峭方向就是当前位置的负梯度方向。\n梯度下降法的思想类似于登山者的行动。你观察当前位置的海拔高度，并朝着最陡峭的下坡方向迈出一步。然后，你再次观察新位置的海拔高度，继续朝着最陡峭的下坡方向迈出一步。你不断重复这个过程，逐步接近山脚。\n在数学中，我们使用类似的思想来最小化函数。假设我们有一个函数，我们希望找到它的最小值。梯度下降法通过迭代地计算函数的梯度，沿着梯度的反方向更新参数，以使函数的值逐渐减小。\n函数的梯度是一个向量，指示函数在给定点上最陡峭的上升方向。我们的目标是朝着最陡峭的下降方向前进，因此我们朝着梯度的反方向更新参数。\n\n\n\n\n\n\nTIP\n这个过程可以表示为以下步骤：\n\n初始化参数：选择一个初始的参数值作为起点。\n计算梯度：计算函数在当前参数值处的梯度。梯度告诉我们函数在该点上升的方向和速度。\n更新参数：根据梯度的方向和一个称为学习率的调整参数，更新参数值。\n重复步骤2和步骤3，直到达到停止条件。停止条件可以是达到最大迭代次数、参数变化很小或函数值达到某个阈值。\n\n\n\n通过迭代更新参数，梯度下降法能够找到函数的局部最小值或全局最小值，这取决于函数的性质和初始参数的选择。\n梯度下降法在机器学习中扮演重要角色，它是许多算法的基础，例如线性回归、逻辑回归和神经网络。它允许我们通过最小化成本函数来调整模型的参数，使模型更好地拟合训练数据。\n批量梯度下降我们已经推导出了适用于单个训练样本的LMS更新规则。但是，对于包含多个训练样本的训练集，我们可以通过将坐标更新组合成向量形式来简化更新规则：\n​\t\t\t\t重复直到收敛 {}\n通过将坐标的更新组合成向量θ的更新，我们可以以更简洁的方式重新编写更新式（1.1）：这种形式的更新规则被称为批量梯度下降，因为它在每次迭代中考虑整个训练集。需要注意的是，对于线性回归的优化问题，由于成本函数是一个凸二次函数，不存在局部最小值，只有一个全局最小值。因此，梯度下降算法总是会收敛到全局最小值（前提是学习率不要设置得太大）。\n\n\n当然python的代码如下，你可以自己尝试\n\nClick to see more\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 定义二次函数\ndef quadratic_function(x, y):\n    return x**2 + y**2\n\n# 定义二次函数的偏导数\ndef gradient(x, y):\n    return np.array([2*x, 2*y])\n\n# 定义梯度下降函数\ndef gradient_descent(gradient, initial_point, learning_rate, num_iterations):\n    path = [initial_point]\n    point = initial_point\n\n    for _ in range(num_iterations):\n        grad = gradient(*point)\n        point = point - learning_rate * grad\n        path.append(point)\n\n    return np.array(path)\n\n# 定义绘制等高线图的函数\ndef plot_contour(func):\n    x = np.linspace(-5, 5, 100)\n    y = np.linspace(-5, 5, 100)\n    X, Y = np.meshgrid(x, y)\n    Z = func(X, Y)\n\n    plt.figure(figsize=(8, 6))\n    plt.contour(X, Y, Z, levels=20)\n    plt.colorbar()\n    plt.xlabel('x')\n    plt.ylabel('y')\n    plt.title('Contour Plot')\n    plt.grid(True)\n\n# 设置初始点、学习率和迭代次数\ninitial_point = np.array([3.0, 4.0])\nlearning_rate = 0.1\nnum_iterations = 20\n\n# 运行梯度下降算法\npath = gradient_descent(gradient, initial_point, learning_rate, num_iterations)\n\n# 绘制等高线图和路径\nplot_contour(quadratic_function)\nplt.plot(path[:, 0], path[:, 1], '-ro')\nplt.show()\n\n\n\n首先，图像展示了一个二维平面，其中轴和轴代表二次函数的输入变量的取值范围。二次函数由公式 给出，其中等高线表示函数值相等的点。等高线的形状呈现出圆形，因为函数是关于和的平方和的形式。\n其次，等高线的颜色表示函数值的大小。颜色条(colorbar)位于图像右侧，它显示了颜色与函数值的对应关系。颜色越深表示函数值越小，而颜色越浅表示函数值越大。在这个示例中，我们选择了20个等高线水平线，因此你可以看到等高线从内部圆开始，逐渐向外部圆扩展。\n接下来，红色的路径表示梯度下降算法的路径。我们使用初始点 (3.0, 4.0)作为起始点，并选择学习率为0.1，执行了20次迭代。梯度下降算法根据当前点的梯度信息来更新下一个点的位置，直到达到指定的迭代次数。红色路径显示了从初始点开始，沿着梯度下降方向逐步更新点的位置的过程。你可以看到路径开始在较陡峭的地方，然后逐渐向梯度变小的区域移动，最终趋近于函数的最小值(0, 0)。\n面积与房价我们继续研究梯度下降算法的不同变体！让我们先来看看批量梯度下降算法在拟合房屋价格预测模型时得到的结果。根据我们之前的数据集，通过运行批量梯度下降，我们得到了参数值和，它们可以用于构建线性模型来预测房屋价格，其中表示房屋的居住面积。如果我们绘制作为（面积）的函数，并结合训练数据，我们会得到上面的图表。这个模型给出了一个大致符合数据趋势的直线。\n\n\n当然，代码如下\n\nClick to see more\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 数据集\nareas = np.array([2104, 1600, 2400, 1416, 3000, 1985, 1534, 1427, 1380, 1494, 1940, 2000, 1890, 4478, 1268, 2300, 1760, 1450, 3100, 2250, 2132, 2596, 1850, 2680, 1956, 1604, 2020, 2730, 2008, 1537, 2500, 1560, 2120, 2200, 1638, 2540, 2200, 2070, 2005, 1900, 2380, 1320, 2190, 2340, 2678, 1966, 1570, 1852, 2454, 2205, 2450])\nprices = np.array([400, 330, 369, 232, 540, 320, 267, 199, 245, 347, 334, 383, 339, 699, 259, 410, 350, 315, 590, 410, 399, 459, 325, 480, 349, 285, 365, 525, 375, 295, 450, 280, 389, 425, 315, 475, 408, 382, 350, 380, 420, 230, 394, 416, 540, 385, 279, 360, 485, 405, 450])\n\n# 数据归一化（特征缩放）\nareas_normalized = (areas - np.mean(areas)) / np.std(areas)\nprices_normalized = (prices - np.mean(prices)) / np.std(prices)\n\n# 添加偏置项\nX = np.column_stack((np.ones(len(areas_normalized)), areas_normalized))\n\n# 初始化参数\ntheta = np.zeros(2)\nalpha = 0.01\niterations = 1500\n\n# 定义代价函数\ndef compute_cost(X, y, theta):\n    m = len(y)\n    h = np.dot(X, theta)\n    J = (1 / (2 * m)) * np.sum((h - y) ** 2)\n    return J\n\n# 批量梯度下降\ndef gradient_descent(X, y, theta, alpha, iterations):\n    m = len(y)\n    J_history = []\n    for _ in range(iterations):\n        h = np.dot(X, theta)\n        theta = theta - (alpha / m) * np.dot(X.T, h - y)\n        cost = compute_cost(X, y, theta)\n        J_history.append(cost)\n    return theta, J_history\n\n# 运行批量梯度下降算法\ntheta, J_history = gradient_descent(X, prices_normalized, theta, alpha, iterations)\n\n# 绘制拟合曲线\nx_values = np.linspace(-2, 2, 100)\ny_values = theta[0] + theta[1] * x_values\n\n\n# 绘制数据点和拟合曲线\nplt.scatter(areas_normalized, prices_normalized, label='Training Data')\nplt.plot(x_values, y_values, color='red', label='Linear Regression')\nplt.xlabel('Normalized Area')\nplt.ylabel('Normalized Price')\nplt.title('House Prices vs. Area (Linear Regression)')\nplt.legend()\nplt.show()\n\n\n\n\n继续考虑卧室数量接下来，如果我们考虑卧室数量作为输入特征之一，我们可以使用批量梯度下降来拟合模型并得到参数值，，。通过将卧室数量纳入考虑，我们可以构建一个更复杂的模型来预测房屋价格。\n\n\n代码如下\n\nClick to see more\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\n# 数据集\nareas = np.array([2104, 1600, 2400, 1416, 3000, 1985, 1534, 1427, 1380, 1494, 1940, 2000, 1890, 4478, 1268, 2300, 1760, 1450, 3100, 2250, 2132, 2596, 1850, 2680, 1956, 1604, 2020, 2730, 2008, 1537, 2500, 1560, 2120, 2200, 1638, 2540, 2200, 2070, 2005, 1900, 2380, 1320, 2190, 2340, 2678, 1966, 1570, 1852, 2454, 2205, 2450])\nbedrooms = np.array([3,3,3,2,4,4,3,3,3,3,4,3,3,5,3,4,3,3,4,4,4,3,4,4,3,3,4,4,3,3,4,4,4,3,3,4,3,4,3,3,4,2,4,3,4,4,3,3,4,4,4])\nprices = np.array([400, 330, 369, 232, 540, 320, 267, 199, 245, 347, 334, 383, 339, 699, 259, 410, 350, 315, 590, 410, 399, 459, 325, 480, 349, 285, 365, 525, 375, 295, 450, 280, 389, 425, 315, 475, 408, 382, 350, 380, 420, 230, 394, 416, 540, 385, 279, 360, 485, 405, 450])\n\n# 特征缩放（归一化）\nareas_normalized = (areas - np.mean(areas)) / np.std(areas)\nbedrooms_normalized = (bedrooms - np.mean(bedrooms)) / np.std(bedrooms)\nprices_normalized = (prices - np.mean(prices)) / np.std(prices)\n\n# 构建设计矩阵\nX = np.column_stack((np.ones(len(areas_normalized)), areas_normalized, bedrooms_normalized))\n\n# 初始化参数\ntheta = np.zeros(3)\nalpha = 0.01\niterations = 1500\n\n# 定义代价函数\ndef compute_cost(X, y, theta):\n    m = len(y)\n    h = np.dot(X, theta)\n    J = (1 / (2 * m)) * np.sum((h - y) ** 2)\n    return J\n\n# 批量梯度下降\ndef gradient_descent(X, y, theta, alpha, iterations):\n    m = len(y)\n    J_history = []\n    for _ in range(iterations):\n        h = np.dot(X, theta)\n        theta = theta - (alpha / m) * np.dot(X.T, h - y)\n        cost = compute_cost(X, y, theta)\n        J_history.append(cost)\n    return theta, J_history\n\n# 运行批量梯度下降算法\ntheta, J_history = gradient_descent(X, prices_normalized, theta, alpha, iterations)\n\n# 输出最终回归表达式\ntheta0 = theta[0]\ntheta1 = theta[1]\ntheta2 = theta[2]\nprint(f\"最终回归表达式: hθ(x) = {theta0:.2f} + {theta1:.2f}x1 + {theta2:.2f}x2\")\n\n# 绘制拟合曲面\nx1_values = np.linspace(-2, 2, 100)\nx2_values = np.linspace(-2, 2, 100)\nx1, x2 = np.meshgrid(x1_values, x2_values)\ny_values = theta0 + theta1 * x1 + theta2 * x2\n\n# 绘制数据点和拟合曲面\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.scatter(areas_normalized, bedrooms_normalized, prices_normalized, c='b', marker='o')\nax.plot_surface(x1, x2, y_values, color='r', alpha=0.5)\nax.set_xlabel('Normalized Area')\nax.set_ylabel('Normalized Bedrooms')\nax.set_zlabel('Normalized Price')\nax.set_title('House Prices vs. Area and Bedrooms (Linear Regression)')\nplt.show()\n\n\n\n\n最终控制台会输出\n最终回归表达式: hθ(x) = 0.00 + 0.93x1 + 0.04x2\n\n\n\n你可以看到，通过添加更多的特征，我们可以得到更准确的房屋价格预测模型。这说明特征选择对于机器学习模型的性能至关重要。\n随机梯度下降除了批量梯度下降，还有一种非常有效的替代方法，它被称为随机梯度下降。这种方法的算法如下：\nLoop{    for  to ,{\n​\t\t\t\t\t\t​\t\t}\n}\n通过将坐标的更新组合成向量θ的更新，我们可以以更简洁的方式重新编写更新式:在这个算法中，我们遍历整个训练集，并且在每次遇到一个训练样本时，只使用该样本的误差梯度来更新参数。这个算法被称为随机梯度下降或增量梯度下降。与批量梯度下降不同的是，随机梯度下降可以立即开始取得进展，并且在每个样本上都继续进行更新。这使得随机梯度下降比批量梯度下降更快地将参数接近最小值。然而，需要注意的是，随机梯度下降可能无法收敛到真正的最小值，参数会在最小值周围波动，但是在实践中，这些接近最小值的参数值通常是对真实最小值的合理近似。因此，尤其是在训练集很大的情况下，随机梯度下降比批量梯度下降更受欢迎。\n通过这些不同的梯度下降算法，我们可以有效地拟合参数，从而得到准确的预测模型。在接下来的部分，我将继续更新我在机器学习部分自学的笔记，希望各位可以一起交流！\n","slug":"LMS","date":"2023-07-16T09:18:07.000Z","categories_index":"","tags_index":"Machine Learning,笔记","author_index":"General_K1ng"},{"id":"b6c077dbe8f34883367bdebb8559e973","title":"探索机器学习的魅力：从斯坦福大学CS229课程开始","content":"机器学习是当今科技领域的热门话题，而斯坦福大学的CS229课程则是深入学习机器学习的绝佳门户。这篇文章将带您踏上机器学习的征程，通过探索CS229课程中的第一个主题——监督学习，揭开这个令人着迷的领域的神秘面纱。无论您是初学者还是有一定经验的机器学习从业者，本文将带您以生动活泼且专业的方式了解监督学习的基本原理、应用领域以及最新的研究动态。\n（当然我也是小白，这只是我在学习过程当中的笔记 &gt;_&lt;）\n监督学习：预测房价的例子让我们从几个监督学习问题的例子入手。假设我们有一个数据集，其中包含了50栋房屋的居住面积和价格。我们可以将这些数据制成表格如下：\n\nClick to see more\n\n\n\n居住面积（feet^2）\n价格（1000$s）\n\n\n\n2104\n400\n\n\n1600\n330\n\n\n2400\n369\n\n\n1416\n232\n\n\n3000\n540\n\n\n1985\n320\n\n\n1534\n267\n\n\n1427\n199\n\n\n1380\n245\n\n\n1494\n347\n\n\n1940\n334\n\n\n2000\n383\n\n\n1890\n339\n\n\n4478\n699\n\n\n1268\n259\n\n\n2300\n410\n\n\n1760\n350\n\n\n1450\n315\n\n\n3100\n590\n\n\n2250\n410\n\n\n2132\n399\n\n\n2596\n459\n\n\n1850\n325\n\n\n2680\n480\n\n\n1956\n349\n\n\n1604\n285\n\n\n2020\n365\n\n\n2730\n525\n\n\n2008\n375\n\n\n1537\n295\n\n\n2500\n450\n\n\n1560\n280\n\n\n2120\n389\n\n\n2200\n425\n\n\n1638\n315\n\n\n2540\n475\n\n\n2200\n408\n\n\n2070\n382\n\n\n2005\n350\n\n\n1900\n380\n\n\n2380\n420\n\n\n1320\n230\n\n\n2190\n394\n\n\n2340\n416\n\n\n2678\n540\n\n\n1966\n385\n\n\n1570\n279\n\n\n1852\n360\n\n\n2454\n485\n\n\n2205\n405\n\n\n2450\n450\n\n\n\n\n我们可以用图表来展示这些数据：\n\n\n有了这样的数据，我们可以提出一个问题：基于波特兰其他房屋的居住面积，如何预测它们的价格呢？\n为了在接下来的讨论中使用统一的符号，我们将使用表示“输入”变量（在这个例子中是生活区域的大小），也称为输入特征；表示我们试图预测的“输出”或目标变量（价格）。对于一对，我们称其为训练示例（training example）。我们将学习的数据集，由n个训练示例的列表；构成，被称为训练集（training set）。请注意，上标“(i)”仅用于表示训练集的索引，与求幂无关。我们还将使用表示输入值的空间，表示输出值的空间。在这个例子中，。\n为了更正式地描述监督学习问题，我们的目标是给定一个训练集，学习一个函数：，使得成为y的“良好”预测器。从图表中可以看出，这个过程如下所示：\n\n\n当我们试图预测的目标变量是连续的，例如在房屋价格的例子中，我们将这种学习问题称为回归问题。回归问题的目标是建立一个模型，能够对连续的目标变量进行预测。通过分析各种特征和输入变量之间的关系，我们可以推断出目标变量的数值。在回归问题中，我们通常尝试拟合一条曲线或平面，以最好地表示数据的趋势和模式。\n相比之下，当目标变量只能取少量离散值时（比如，根据居住面积预测一个住宅是房子还是公寓），我们将这种学习问题称为分类问题。分类问题的目标是根据输入变量的特征将样本分配到预定义的离散类别中。在分类问题中，我们建立一个分类器，该分类器根据输入变量的特征预测目标变量的类别。为了将不同类别的样本区分开来，分类问题通常涉及使用统计技术或机器学习算法构建决策边界。\n线性回归让我们使我们的住房示例更加丰富，加入一个稍微复杂的数据集，我们还知道每栋房子的卧室数量。\n在这个数据集中，除了居住面积外，我们还有每个房子的卧室数量。我们可以将数据表示为以下表格：\n\nClick to see more\n\n\n\n居住面积（feet^2）\n卧室数量\n价格（1000$s）\n\n\n\n2104\n3\n400\n\n\n1600\n3\n330\n\n\n2400\n3\n369\n\n\n1416\n2\n232\n\n\n3000\n4\n540\n\n\n1985\n4\n320\n\n\n1534\n3\n267\n\n\n1427\n3\n199\n\n\n1380\n3\n245\n\n\n1494\n3\n347\n\n\n1940\n4\n334\n\n\n2000\n3\n383\n\n\n1890\n3\n339\n\n\n4478\n5\n699\n\n\n1268\n3\n259\n\n\n2300\n4\n410\n\n\n1760\n3\n350\n\n\n1450\n3\n315\n\n\n3100\n4\n590\n\n\n2250\n4\n410\n\n\n2132\n4\n399\n\n\n2596\n3\n459\n\n\n1850\n4\n325\n\n\n2680\n4\n480\n\n\n1956\n3\n349\n\n\n1604\n3\n285\n\n\n2020\n4\n365\n\n\n2730\n4\n525\n\n\n2008\n3\n375\n\n\n1537\n3\n295\n\n\n2500\n4\n450\n\n\n1560\n4\n280\n\n\n2120\n4\n389\n\n\n2200\n3\n425\n\n\n1638\n3\n315\n\n\n2540\n4\n475\n\n\n2200\n3\n408\n\n\n2070\n4\n382\n\n\n2005\n3\n350\n\n\n1900\n3\n380\n\n\n2380\n4\n420\n\n\n1320\n2\n230\n\n\n2190\n4\n394\n\n\n2340\n3\n416\n\n\n2678\n4\n540\n\n\n1966\n4\n385\n\n\n1570\n3\n279\n\n\n1852\n3\n360\n\n\n2454\n4\n485\n\n\n2205\n4\n405\n\n\n2450\n4\n450\n\n\n\n\n在这里，我们将表示为二维向量，包括居住面积和卧室数量。例如，表示训练集中第个房子的居住面积，表示卧室数量。（在设计学习问题时，我们可以自行选择包括哪些特征。如果我们收集住房数据，还可以考虑包括其他特征，如壁炉数量、卫生间数量等。稍后我们将详细讨论特征选择，但现在我们将特征视为给定的。）\n为了进行监督学习，我们需要决定如何在计算机中表示函数/假设。作为初始选择，我们假设我们决定将近似为的线性函数：在这个表达式中，是参数（也被称为权重），用于参数化从到的线性函数空间。当没有混淆的风险时，我们将在中省略θ的下标，并将其简化为。为了简化表示法，我们还引入一个约定，将设置为1（这是截距项），这样我们可以表示为：在上面的表达式中，我们将和都视为向量，其中是输入变量的数量（不包括）。现在，给定一个训练集，我们如何选择或学习参数？一个合理的方法似乎是使得尽可能接近，至少对于我们拥有的训练样本来说是如此。为了形式化这个问题，我们定义了一个函数，用于衡量每个值对应的与相应的之间的接近程度。我们定义了成本函数：让我们逐步解释成本函数的每个部分：\n\n 代表我们的模型对于输入样本  的预测值。\n 是对应于输入样本  的实际观测值。\n 表示我们的模型预测值与实际观测值之间的差异，即误差。\n 将误差进行平方，这是为了消除误差的正负号，并将大误差的影响放大，以更好地衡量它们对总体误差的贡献。\n 对所有训练样本的误差平方进行求和，得到总体误差的度量。\n 为了计算方便，我们对总体误差进行了归一化，除以2。这不会影响最终优化的结果，因为我们的目标是最小化成本函数，而不是具体的数值。\n\n因此，成本函数  衡量了模型预测值与实际观测值之间的差异的平方和的一半。我们的目标是通过调整参数  的值，使得成本函数的值最小化，从而使模型的预测尽可能接近实际观测值。\n如果听不懂，没关系，我们来举一个非常简单的例子来理解成本函数到底是什么玩意。当我们建立一个模型时，我们希望它能够根据输入数据预测出正确的结果。然而，在训练模型时，我们的预测可能与实际结果有一些差距。成本函数的作用就是衡量这些预测差距的大小。\n假设你是一名学生，每天都要骑自行车去上学。你决定根据骑行时间来预测你到达学校所需的时间。你记录了过去一周的骑行时间和实际到达学校的时间，如下所示：\n\n\n\n骑行时间（分钟）\n到达时间（分钟）\n\n\n\n20\n25\n\n\n25\n30\n\n\n30\n35\n\n\n35\n40\n\n\n40\n45\n\n\n现在，你想建立一个模型，根据骑行时间预测到达时间。你选择线性函数来表示模型，即假设到达时间与骑行时间之间存在一种线性关系。\n假设我们的模型为 ，其中  表示到达时间的预测值， 表示骑行时间。我们的目标是找到最佳的参数  和 ，使得模型的预测结果尽可能接近实际观测值。\n为了衡量模型的预测与实际观测值之间的差距，我们使用成本函数。在这个例子中，我们使用均方误差（Mean Squared Error，MSE）作为成本函数。MSE 的计算方式是将每个预测值与对应的实际观测值之间的差距平方，并取所有差距平方的平均值。\n现在，我们来计算一下成本函数的值。假设我们选择了一组参数  和 。我们可以将这些参数代入模型，并计算出每个骑行时间对应的预测值。\n\n\n\n骑行时间（分钟）\n到达时间（分钟）\n预测到达时间（分钟）\n差距（预测-实际）\n差距平方\n\n\n\n20\n25\n30\n-5\n25\n\n\n25\n30\n35\n-5\n25\n\n\n30\n35\n40\n-5\n25\n\n\n35\n40\n45\n-5\n25\n\n\n40\n45\n50\n-5\n25\n\n\n现在，我们将差距平方的平均值作为成本函数的值。在这种情况下，成本函数的计算如下：我们的目标是通过调整参数  和  的值，使得成本函数的值最小化。这意味着我们希望找到最佳的参数组合，使得模型的预测结果与实际观测值之间的差距最小化。\n希望这个例子能够更加清晰地解释成本函数的概念。成本函数用于衡量模型预测与实际观测之间的差距，并帮助我们找到最佳的参数组合。\n如果你之前接触过线性回归，你可能会注意到这个熟悉的最小二乘成本函数，它导致了普通最小二乘回归模型。无论你之前是否见过它，我们将继续讨论，并最终展示它是一个更广泛的算法家族中的特例。同时，这个成本函数的意义是衡量我们的预测与实际数据之间的差距。较小的成本值表示我们的预测较接近真实数据，而较大的成本值表示预测与真实数据之间的差距较大。\n如何有任何疑问或者建议欢迎在评论区评论&gt; &lt;!!!\n","slug":"初识机器学习","date":"2023-07-16T07:02:18.000Z","categories_index":"","tags_index":"Machine Learning,笔记","author_index":"General_K1ng"},{"id":"d99fcab655887d4444838841a030a1e7","title":"正项级数","content":"这是一个非常重要的课题，我们将开始学习关于正级数，请专心听讲。\n正项级数的定义正项级数是一种无穷级数，其项均为正实数。它的形式如下：其中为级数的第个项。\np级数p级数是指形如的级数，其中是一个正实数。该级数以分母的指数来命名。\np级数具有以下性质：\n\n如果，则p级数收敛。\n如果，则p级数发散。\n\n\n\n这个结果的证明基于积分测试。为了理解为什么这是正确的，我们可以考虑函数。这个函数在区间上连续、正值且递减，因此我们可以应用积分测试来得到级数的结果：对积分进行计算，我们得到：$$\\int_{1}^{\\infty} \\frac{1}{x^p}dx  \\left{\\right.$$因此，p级数收敛当且仅当，当时发散。\n对于，p级数的和可以用黎曼ζ函数（Riemann zeta function）来表示，它的定义为：黎曼ζ函数具有许多有趣的性质，并与数论和复分析等其他数学领域有着密切的联系。\n敛散性检验有几个用于确定正项级数收敛或发散的收敛性测试。以下是其中几个常用的测试：\n1. 比较判别法比较判别法是一种通过将待定级数与已知收敛性的另一个级数进行比较来确定级数的收敛性或发散性的方法。比较法的规则如下：\n假设  和  是具有正项的级数，并且对所有 ，满足 。\n\n如果  收敛，则  也收敛。\n如果  发散，则  也发散。\n\n换句话说，如果级数  的项始终小于或等于级数  的项，并且  收敛，那么  必定收敛。相反地，如果  发散，那么  也一定发散。\n比较测试经常用于将给定的级数与 p-级数进行比较，因为 p-级数的收敛性是众所周知的。具体而言，如果我们有一个形如  的级数，以及另一个级数 ，其中的项始终小于或等于 ，那么我们可以使用比较测试来确定  的收敛性。\n\n\n\n\n\n\n\n\n\n\n\n我们常用的一些参考无限级数有：\n\n几何级数\n调和级数\np-级数\n\n2. 极限比较判别法极限比较判别法是用于确定级数的收敛性或发散性的另一种方法。与比较法类似，它涉及将给定的级数与已知收敛性的另一个级数进行比较。然而，极限比较测试在选择要进行比较的级数方面更加灵活。\n假设  和  是具有正项的级数。令 ，其中  是一个有限的正数或者是 。\n\n如果 ，则  和  要么都收敛，要么都发散。\n如果  并且  收敛，则  也收敛。\n如果  并且  发散，则  也发散。\n\n极限比较测试在选择要进行比较的级数方面更加灵活，因为我们只需要项的比值收敛到一个有限的正数。这意味着我们通常可以找到一个更易处理的级数来进行比较，相较于比较测试的情况而言。\n3. 比值判别法比值判别法是一种用于判断级数的收敛性或发散性的测试方法。比值法规定如下：\n假设  是一个具有正项的级数，令 （这个极限可能存在也可能不存在）。\n\n如果 ，则  绝对收敛。\n如果  或 ，则  发散。\n如果  或极限不存在，则比值测试无法确定收敛性或发散性，我们需要使用其他测试方法。\n\n从直观上讲，比值测试将级数的项与具有公比  的几何级数的项进行比较。如果 ，那么级数的项的衰减速度比一个收敛的几何级数的项更快，因此该级数收敛。如果 ，那么级数的项的增长速度比一个发散的几何级数的项更快，因此该级数发散。如果 ，那么级数的项的衰减速度与一个收敛的几何级数的项相同，因此测试是不确定的。\n4. 根值判别法根值判别法是一种用于判断级数的收敛性或发散性的测试方法。根值判别法规定如下：\n假设  是一个具有正项的级数，令 （这个极限可能存在也可能不存在）。\n\n如果 ，则  绝对收敛。\n如果  或 ，则  发散。\n如果  或极限不存在，则根值测试无法确定收敛性或发散性，我们需要使用其他测试方法。\n\n从直观上讲，根值测试将级数的项与一个收敛的几何级数的项进行比较，该几何级数的公比为 。如果 ，那么级数的项的衰减速度比一个收敛的几何级数的项更快，因此该级数收敛。如果 ，那么级数的项的增长速度比一个发散的几何级数的项更快，因此该级数发散。如果 ，那么级数的项的衰减速度与一个收敛的几何级数的项相同，因此测试是不确定的。\n这章节的内容非常重要，因为我们随后提到的许多概念和扩展都是基于这一章的结论，所以一定要仔细阅读。\n","slug":"正项级数","date":"2023-07-15T09:07:26.000Z","categories_index":"","tags_index":"笔记,Math","author_index":"General_K1ng"},{"id":"8c5051666bb20a88e04fe467e55f2664","title":"无穷级数的性质","content":"欢迎来到无穷级数的奇妙世界！在这一章中，我们将探索无穷级数的性质，包括收敛、发散以及我们可以对级数进行的代数运算。理解这些性质对于数学和科学的许多领域都是至关重要的，它使我们能够做出准确的预测，解决重要的问题，并发展新的计算方法。所以，让我们一起深入探索无穷级数的惊人性质吧。\n几个重要的无穷级数除了探索无穷级数的性质，我们还将介绍和研究一些在数学中最重要的级数。其中包括几何级数，在微积分中有许多重要的应用，以及调和级数，它是一个经典的发散级数的例子。我们还将研究其他重要的级数，如交错级数和泰勒级数，在数学和科学的许多领域都有广泛的应用。所以，准备好一起探索无穷级数的性质，以及数学中一些最重要的级数吧！\n几何级数几何级数是一种特殊类型的无穷级数，其中每一项都是前一项的常数倍（说白了就是等比数列）。几何级数的一般形式为其中  是第一项， 是公比。几何级数在数学中很重要，在科学和工程中也有许多应用。\n推导通项公式为了推导出几何级数的求和公式，我们从考虑级数的部分和开始。设  为级数的前  项和，那么我们可以将方程的两边都乘以  得到将第二个方程从第一个方程中减去，我们得到这可以简化为如果 ，我们可以将两边都除以  得到这个公式给出了几何级数的前  项和。\n要求解无穷几何级数的和，我们取  趋向于无穷的极限：如果 ，那么当  趋向于无穷时， 趋向于零，所以极限简化为这就是当  时无穷几何级数的和的公式。\n几何级数的敛散性几何级数的收敛性取决于公比  的值。我们可以将几何级数分为三类：\n\n如果 ，那么级数绝对收敛。这意味着级数收敛且和是有限的。\n如果 ，那么级数可能收敛，也可能发散。在这种情况下，我们需要观察级数的项的行为来确定收敛性或发散性。\n如果 ，那么级数发散。这意味着级数的和是无穷的。\n\n例如，考虑级数\n这是一个公比为 ， 的几何级数。由于 ，该级数绝对收敛，和为\n\n\n\n\n\n\n\n\n\n这个图像生动地展示了为什么这个几何级数的和是2。当然，为了方便起见，我们让级数的第一项从  开始。每次将图像分成两半并取剩余部分的一半，即四分之一，依此类推，我们发现图像的总面积仍然是1，直到无穷项。\n几何级数的应用几何级数在数学、科学和工程中有许多应用。例如，它们可以用来模拟指数增长或衰减，如人口增长或放射性物质的衰变。它们还可以用于计算某些类型的积分和近似函数。\n结论几何级数是微积分中的一个基本概念，在各个领域中都有许多应用。理解几何级数的收敛和发散对于使用闭合解找到级数的和非常重要。\n调和级数调和级数是数学中一个众所周知的级数，它在许多不同的背景下自然出现，包括微积分、数论和物理学。特别地，它是以下形式的级数：\n调和级数之所以有趣，是因为它是一个发散的级数，也就是说它没有有限的和。这可以通过检查级数的部分和来看出，随着添加更多的项，部分和会无限增长。\n敛散性的证明为了证明调和级数的发散性，我们可以使用积分测试。积分测试表明，如果函数  对于所有  是正的、递减的和连续的，并且对于所有 ，有 ，那么级数  和不定积分  要么都收敛，要么都发散。\n对于调和级数，我们可以选择 ，它满足积分测试的条件。不定积分  可以计算为：由于该积分发散，调和级数也必定发散。\n\n\n可以看到，每个矩形的面积都是 ，所以前  个矩形的总面积是 。随着  的增加，矩形的面积逐渐接近 ，因此阶梯状的图形逐渐趋近于斜率为  的曲线。最终，当  趋向于无穷时，矩形的面积趋向于 ，阶梯状的图形趋向于曲线 。\n这种可视化可以帮助我们更好地理解级数的行为以及它与自然对数的关系。\n当然，如果你无法理解这个图像以及以上所说的证明过程，没关系，你只需要记住调和级数是发散的。\n调和级数的应用调和级数的发散性在数学和科学中有许多重要的应用，例如：\n\n调和级数在数论中被用来研究质数的分布。级数的发散意味着质数是无穷多的，这是数论中的一个基本结果。\n调和级数的发散性在物理学中也有重要的应用，特别是在电场的研究中。点电荷在电场中的电势能与点电荷与电场中所有其他电荷之间距离的倒数之和成正比。这个和等价于调和级数，它的发散性意味着点电荷的电势能是无限大的。\n\n结论总之，调和级数是数学和科学中重要而有趣的级数。它是一个发散的级数，也就是说它没有有限的和。我们可以使用积分测试来证明级数的发散性，而级数的发散性在数论和物理学中有重要的应用。\n无穷级数的一些性质\n如果给定的无穷级数  收敛，那么任何形式为  的级数，其中  是常数，也将收敛。这个性质可以通过序列极限的定义得出。\n\n\n\n\n\n\n\n\n\n\n\n我们可以看到  收敛，并且  也收敛，它们的收敛性与  相同。\n因此，这个定理可以用来证明  收敛，因为它是通过将  乘以常数 0.5 而得到的。\n\n为了证明这个性质，我们可以设  是级数  的部分和序列， 是级数  的部分和序列。那么我们有：和将第一个等式乘以 ，我们得到：现在，设  是序列  的极限，即 。由于级数  收敛，我们知道极限  是有限的。因此，根据极限的代数性质，我们有：类似地，序列  的极限为：因此，级数  也收敛，其和为 。\n综上所述，无穷级数的线性性质表明，如果给定的无穷级数收敛，那么通过将原级数的项乘以一个常数得到的任何级数也将收敛，其和将是该常数与原级数和的乘积。这个性质可以通过序列极限的定义和极限的代数性质得到。\n\n\n\n如果  和  收敛，那么  也收敛。\n\n\n\n\n\n\n\n\n\n\n\n\n\n我们可以看到  和  都收敛，而  也收敛，它们的收敛性与  和  相同。\n因此，这个定理可以用来证明  收敛，因为它是  和  的和。\n\n要证明这个结果，我们可以使用以下步骤：\n\n令 。那么  是由  和  对应的项相加得到的级数。\n\n由于  和  都收敛，它们的部分和序列  和  也收敛。即， 和 。\n\n我们想要证明  收敛。为了做到这一点，我们需要证明  的部分和序列  收敛。也就是说，我们需要证明  存在。\n\n我们可以将  表示为  和  的形式：\n\n根据极限的性质，我们有：\n\n因此，我们已经证明了  的部分和序列  收敛，因此级数  收敛。\n\n由于  被定义为 ，所以这个结果对于  和  两种情况都成立。也就是说，如果  和  收敛，那么  和  也收敛。\n\n\n\n\n\n对于仍然在任意添加括号后保持收敛的无穷级数\n\n​\t\t如果您有Python环境，我强烈建议您运行我提供的”Verifying_Property_3” Python文件，您可以看到在不同括号下的图像的差异。\n\n要了解这个结论为什么成立，考虑一个收敛于极限的无穷级数。也就是说，偏和数列，其中，当趋向于无穷时收敛于。\n现在，假设我们以任意方式给级数的项添加括号，也就是说，我们用括号将某些项分组，但不改变项的顺序。例如，我们可以写成：或者或者任何其他方式的分组。\n让我们用表示新的偏和数列，其中是前个分组的和。例如，在上述第一种分组中，我们有，，，依此类推。\n现在，考虑级数中的任意两个相邻的分组。我们将第一个分组中的项称为，将第二个分组中的项称为。那么这两个分组的和为：根据加法的结合律，我们可以重新排列这个和为：也就是说，我们可以以任何希望的方式将这些项分组，得到的和仍然相同。因此，新的分组的偏和数列与原始的偏和数列相同。换句话说，在收敛级数的项上添加括号不会改变级数的极限。\n因此，我们已经证明了对于收敛的无穷级数，在其项上添加任何括号后，级数仍然收敛，且极限不变。\n\n\n​\t\t需要注意的是，这个性质只适用于收敛的级数。对于发散的级数，重新排列项可能会导致不同的收敛性质。\n\n通过删除、添加或更改有限项，级数的收敛性不会改变，但和可能会改变。\n\n\n要正式证明这个性质，让我们考虑一个无穷级数，其中是级数的第个项。我们想要证明，如果我们通过添加、删除或更改任意有限数量的项来修改这个级数，级数的收敛性或发散性不会改变。\n首先，让我们考虑添加或删除有限数量的项的情况。设为原级数的原和，为修改后级数的新和。我们可以将表示为两个级数的和：第一个级数是原级数删除或添加有限数量的项后得到的，第二个级数是由被删除或添加的项组成的有限级数。形式上，我们可以写成：这里，是正整数，是非负整数，是修改后级数的第个项。\n由于原级数收敛于，我们有：现在，让我们考虑修改后的级数。修改后级数的第一部分收敛于与原级数相同的极限，因为它们之间只有有限数量的项不同。第二部分是一个有限级数，因此它收敛于一个有限和。因此，修改后的级数也收敛于和。\n因此，我们已经证明，如果我们通过添加或删除有限数量的项来修改一个无穷级数，级数的收敛性或发散性不会改变。\n接下来，让我们考虑更改有限数量的项的情况。假设我们通过将第个项更改为来修改级数，其中。设和分别为原和和修改后的和。那么，我们可以写成：由于和之间的差是一个有限数，级数的收敛性或发散性不会改变。然而，级数的实际和是不同的。\n总而言之，”通过删除、添加或更改有限项，级数的收敛性不会改变，但和可能会改变”是无穷级数理论中的一个基本结果。它告诉我们，我们可以通过添加、删除或更改有限数量的项来修改一个无穷级数，而不影响其收敛性或发散性。然而，级数的实际和可能会有所不同。\n\n\n\n级数收敛的必要条件是。换句话说，如果是一个收敛的级数，那么。\n\n\n要证明这个结果，假设是一个收敛的级数。根据定义，这意味着偏和序列收敛到某个有限极限。\n我们可以将级数的第个项表示为两个相邻偏和的差：将两边取极限，当时，我们得到：这里我们利用了序列收敛于的事实，因此和。\n因此，我们已经证明了如果是一个收敛的级数，那么。\n值得注意的是，这个结果的逆命题不一定成立。也就是说，仅仅因为，并不意味着是收敛的。例如，调和级数是发散的，尽管。因此，条件只是收敛的必要条件，而不是充分条件。\n\n\n当然，我们要求你不必记住或完全理解这些性质的推导过程，这些只是为了帮助你理解。在考试中，你只需要记住加粗的文字，这应该不难，对吗？\n","slug":"无穷级数的性质","date":"2023-07-15T07:46:56.000Z","categories_index":"","tags_index":"笔记,Math","author_index":"General_K1ng"},{"id":"fca5d0f1b5b938fde80803f8dc301aa3","title":"我的博客之旅：学习、分享与成长","content":"\n\n\n\n\n\n\n\n\n欢迎来到我的博客！我是金洪来，目前就读于西交利物浦大学，专业是信息与计算科学（ICS）。在我充满好奇心和激情的探索中，我决定搭建这个博客，与大家分享我的学习经历、见解和成果。对我来说，这是一次意义非凡的旅程，我希望能够与你们一起成长、互相学习和建立联系。\n自我介绍我是一个对新兴技术充满热情的学生，同时也热爱广泛阅读。在我信息与计算科学的学习中，我不仅学习了编程语言和算法，还探索了许多有趣的领域，如人工智能、数据科学和网络安全。我迷恋于技术的力量和它所带来的无限可能。通过博客，我希望能够与大家分享我的学习经验、项目经历以及对技术和生活的思考。\n搭建博客的动机我为什么突然决定搭建博客呢？首先，学习新技术时，我发现将所学知识记录下来是一种非常有效的方法，可以帮助我更好地理解和巩固所学内容。通过博客，我可以分享这些知识，并与志同道合的人们交流和互动，从中收获更多的见解和观点。其次，博客可以成为一个平台，让我与专业人士和技术大佬们建立联系。我希望能够从他们的经验中获得启发和指导，进一步提升自己的技术能力和职业发展。最重要的是，我相信博客是一个分享和学习的场所，我希望能够通过博客与读者们一起成长，共同进步。\n目标受众我的博客欢迎所有学生、志同道合的朋友、技术大佬和技术小白们。无论你是正在学习编程的初学者，还是想深入了解某个领域的专业人士，我都希望我的博客能够为你提供有价值的信息和灵感。在我的博客中，你将找到关于技术教程、项目经验、学习心得，以及我对生活和工作的见解和体验分享。我希望能够为你提供有趣且实用的内容，无论你身在何处、经历如何，我都希望我的博客能够成为你学习和成长的伙伴。\n博客内容计划在我的博客中，你将看到各种内容，涵盖了技术教程、项目经验、学习笔记以及我对生活和工作的见解和体验。我计划分享一些简单易懂的技术教程，帮助初学者快速入门。通过清晰的代码示例和详细的解释，我希望能够让你轻松理解复杂的概念和技术。同时，我也会分享一些我在项目中遇到的挑战和解决方法，以及学习过程中的心得体会。我相信通过分享这些经验，我们可以相互帮助和共同成长。此外，我会不定期地分享一些生活感悟和工作经验，希望能够给你带来一些启发和思考。\n学习和成长通过搭建博客，我期望自己能够不断学习和成长。通过与读者的互动和交流，我相信我可以提升自己的学习能力和沟通技巧。我希望能够给你提供有价值的内容和支持，帮助你解决问题、开拓思路。同时，我也希望能够通过博客启发更多的人，鼓励他们追求自己的梦想，勇敢地探索未知的领域。在这个博客的旅程中，我将不断挑战自我，拓宽自己的知识边界，并将这些经验和成长与大家分享。\n结语感谢你花时间阅读我的博客介绍。我希望你能够加入我的博客之旅，与我一起探索技术的奇妙世界，共同成长和学习。如果你对我的博客感兴趣或有任何问题、建议或想法，请随时与我联系。我期待与你在博客中互动，并希望我的博客能够对你有所帮助。谢谢！\n","slug":"我的第一篇博客","date":"2023-07-14T09:16:53.000Z","categories_index":"","tags_index":"随笔","author_index":"General_K1ng"}]